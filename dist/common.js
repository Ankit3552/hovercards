require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/cameron/Desktop/HoverCards/deckard/app/lightbox/both.js":[function(require,module,exports){
var $ = require('jquery');
var _ = require('underscore');

require('../common/mixins');

var EXTENSION_ID = chrome.i18n.getMessage('@@extension_id');

var NameSpace = '.' + EXTENSION_ID;

var Click = 'click' + NameSpace;

$('html').on(Click, '.' + _.prefix('hovercard__box'), function() {
	var hovercard = $(this).parents('.' + _.prefix('hovercard'));
	$.lightbox(hovercard.data(EXTENSION_ID + '-identity'), hovercard);
});

},{"../common/mixins":"/Users/cameron/Desktop/HoverCards/deckard/app/common/mixins.js","jquery":"/Users/cameron/Desktop/HoverCards/deckard/node_modules/jquery/dist/jquery.js","underscore":"/Users/cameron/.nvm/versions/node/v4.1.1/lib/node_modules/underscore/underscore.js"}],"/Users/cameron/Desktop/HoverCards/deckard/app/template_loading/index.js":[function(require,module,exports){
var _              = require('underscore');
var Ractive        = require('ractive');
var authentication = require('../authentication');
var config         = require('../config');
var service        = require('../service');
var urls           = require('hovercardsshared/urls');
require('../common/mixins');

Ractive.DEBUG = "development" !== 'production';

Ractive.prototype.observeUntil = function(keypath, handler, options) {
	if (this.get(keypath)) {
		handler(this.get(keypath));
		return { cancel: _.noop };
	} else {
		return this.observeOnce(keypath, handler, options);
	}
};

Ractive.prototype.service = function(keypath, identity, handler) {
	var ractive = this;
	var val     = ractive.get(keypath);
	if (val && (val.loading || val.loaded)) {
		return;
	}
	ractive.set(keypath + '.loading', true);
	ractive.set(keypath + '.loaded',  false);
	service(identity || val, function try_service(err, data) {
		if (err) {
			ractive.set(keypath + '.err',     err);
			ractive.set(keypath + '.loaded',  true);
			ractive.set(keypath + '.loading', false);
			if (err.status === 401) {
				ractive.set(keypath + '.err.authenticate', function authenticate() {
					ractive.set(keypath + '.err.authenticate', _.noop);
					authentication((identity || val).api, function(err) {
						if (err) {
							ractive.set(keypath + '.err', err);
							return ractive.set(keypath + '.err.authenticate', authenticate);
						}
						ractive.set(keypath + '.loading', true);
						ractive.set(keypath + '.loaded',  false);
						ractive.set(keypath + '.err',     null);
						service(identity || val, try_service);
					});
				});
			}
			return (handler || _.noop)(ractive.get(keypath + '.err'));
		}
		ractive.set(keypath, _.extend(data, { loaded: true, loading: false }));
		(handler || _.noop)(null, ractive.get(keypath));
	});
};

// TODO Put this in shared pkg
var global_data = {
	_: _,
	copy: function(name, api) {
		var rest = _.rest(arguments, 2);
		name = (name || '').replace(/\-/g, '_');
		return (!_.isEmpty(api) && chrome.i18n.getMessage(api + '_' + name, rest)) || chrome.i18n.getMessage(name, rest);
	},
	has_media: function(content) {
		return content && (content.video || content.gif || content.images || content.image);
	},
	prefix: _.prefix,
	timestamp: function(time_in_milli) {
		var time_in_sec = Math.floor(time_in_milli / 1000) % 60 + '';
		var time_in_min = Math.floor(time_in_milli / (60 * 1000)) % 60 + '';
		while (time_in_sec.length < 2) {
			time_in_sec = '0' + time_in_sec;
		}
		return time_in_min + ':' + time_in_sec;
	},
	url: urls.print
};

var HoverCardRactive = Ractive.extend({
	data:       global_data,
	partials:   _.chain({'imgur/account-content': require('../../node_modules/hovercardsshared/imgur/account-content.html'),'imgur/account': require('../../node_modules/hovercardsshared/imgur/account.html'),'imgur/content': require('../../node_modules/hovercardsshared/imgur/content.html'),'imgur/discussion-header': require('../../node_modules/hovercardsshared/imgur/discussion-header.html'),'imgur/discussion': require('../../node_modules/hovercardsshared/imgur/discussion.html'),'instagram/account-content': require('../../node_modules/hovercardsshared/instagram/account-content.html'),'instagram/account': require('../../node_modules/hovercardsshared/instagram/account.html'),'instagram/content': require('../../node_modules/hovercardsshared/instagram/content.html'),'instagram/discussion-header': require('../../node_modules/hovercardsshared/instagram/discussion-header.html'),'instagram/discussion': require('../../node_modules/hovercardsshared/instagram/discussion.html'),'reddit/account-content': require('../../node_modules/hovercardsshared/reddit/account-content.html'),'reddit/account': require('../../node_modules/hovercardsshared/reddit/account.html'),'reddit/content': require('../../node_modules/hovercardsshared/reddit/content.html'),'reddit/discussion-header': require('../../node_modules/hovercardsshared/reddit/discussion-header.html'),'reddit/discussion': require('../../node_modules/hovercardsshared/reddit/discussion.html'),'soundcloud/account-content': require('../../node_modules/hovercardsshared/soundcloud/account-content.html'),'soundcloud/account': require('../../node_modules/hovercardsshared/soundcloud/account.html'),'soundcloud/content': require('../../node_modules/hovercardsshared/soundcloud/content.html'),'soundcloud/discussion-header': require('../../node_modules/hovercardsshared/soundcloud/discussion-header.html'),'soundcloud/discussion': require('../../node_modules/hovercardsshared/soundcloud/discussion.html'),'twitter/account-content': require('../../node_modules/hovercardsshared/twitter/account-content.html'),'twitter/account': require('../../node_modules/hovercardsshared/twitter/account.html'),'twitter/content': require('../../node_modules/hovercardsshared/twitter/content.html'),'twitter/discussion-header': require('../../node_modules/hovercardsshared/twitter/discussion-header.html'),'twitter/discussion': require('../../node_modules/hovercardsshared/twitter/discussion.html'),'youtube/account-content': require('../../node_modules/hovercardsshared/youtube/account-content.html'),'youtube/account': require('../../node_modules/hovercardsshared/youtube/account.html'),'youtube/content': require('../../node_modules/hovercardsshared/youtube/content.html'),'youtube/discussion-header': require('../../node_modules/hovercardsshared/youtube/discussion-header.html'),'youtube/discussion': require('../../node_modules/hovercardsshared/youtube/discussion.html')})
	             .extend({'account/layout': require('../../node_modules/hovercardsshared/account/layout.html'),'content/layout': require('../../node_modules/hovercardsshared/content/layout.html')})
	             .reduce(function(memo, template, key) {
	                 memo[key.replace('/', '-')] = template;
	                 return memo;
	             }, {})
	             .value(),
	components: _.chain({'account-content/catch-errors': require('../../node_modules/hovercardsshared/account-content/catch-errors.ract'),'account/account': require('../../node_modules/hovercardsshared/account/account.ract'),'common/catch-errors': require('../../node_modules/hovercardsshared/common/catch-errors.ract'),'content/header': require('../../node_modules/hovercardsshared/content/header.ract'),'content/media': require('../../node_modules/hovercardsshared/content/media.ract'),'content/text': require('../../node_modules/hovercardsshared/content/text.ract'),'discussion/catch-errors': require('../../node_modules/hovercardsshared/discussion/catch-errors.ract'),'discussion/comment': require('../../node_modules/hovercardsshared/discussion/comment.ract'),'discussion/header': require('../../node_modules/hovercardsshared/discussion/header.ract'),'soundcloud/song': require('../../node_modules/hovercardsshared/soundcloud/song.ract'),'twitter/tweet': require('../../node_modules/hovercardsshared/twitter/tweet.ract'),'youtube/video': require('../../node_modules/hovercardsshared/youtube/video.ract')})
	             .extend({'catch-errors': require('../../node_modules/hovercardsshared/common/catch-errors.ract')})
	             .reduce(function(memo, obj, key) {
	                 obj.data = _.extend(obj.data || {}, global_data);
	                 var key_parts = key.split(/[/-]/g);
	                 while (key_parts[0] && _.isEqual(key_parts[0], key_parts[1])) {
	                     key_parts.shift();
	                 }
	                 memo[key_parts.join('-')] = Ractive.extend(obj);
	                 return memo;
	             }, {})
	             .value(),
	decorators:  _.chain({'date-decorator': require('../../node_modules/hovercardsshared/common/date-decorator.js'),'number-decorator': require('../../node_modules/hovercardsshared/common/number-decorator.js')})
	              .reduce(function(memo, template, key) {
	                  memo[key.replace(/-decorator$/, '')] = template;
	                  return memo;
	              }, {})
	              .value()
});

module.exports = function(obj, identity) {
	var ractive = obj.data('ractive');

	if (!ractive) {
		ractive = new HoverCardRactive({
			template: '{{>type+"-layout"}}',
			data:     _.clone(identity),
			el:       obj
		});
		obj.data('ractive', ractive);
		ractive.set('scrollpos', 0);
		ractive.set('scrollposbottom', 21);

		switch (identity.type) {
			case 'content':
				ractive.service('content', identity, function(err, data) {
					if (err) {
						return;
					}
					var given_discussions = _.each(data.discussions, _.partial(_.extend, _, { loaded: true })) || [];
					delete data.discussions;
					var default_discussions = _.chain(config.apis[data.api])
					                           .result('discussion_apis', [])
					                           .map(function(api) {
					                               return (api === data.api) ? _.defaults({ type: 'discussion', loaded: false }, data) :
					                                                           { api: api, type: 'discussion', for: _.clone(data), loaded: false };
					                           })
					                           .value();
					ractive.set('discussions', _.chain(given_discussions)
					                            .union(default_discussions)
					                            .uniq(_.property('api'))
					                            .value());
					ractive.set('discussion_i', 0);
					ractive.observeUntil('expanded', function() {
						ractive.observe('discussion_i', function(i) {
							ractive.service('discussions.' + i);
						});
					});
				});
				break;
			case 'account':
				ractive.set('accounts', [identity]);
				ractive.set('account_i', 0);
				ractive.observe('account_i', function(i) {
					ractive.service('accounts.' + i, null, function(err, data) {
						if (err) {
							return;
						}
						if (data.content) {
							ractive.set('accounts.' + i + '.content.loaded', true);
						} else {
							ractive.set('accounts.' + i + '.content', _.defaults({ type: 'account_content', loaded: false }, data));
						}
						ractive.observeUntil('expanded', function() {
							ractive.service('accounts.' + i + '.content');
						});
						ractive.set('accounts', _.chain(ractive.get('accounts'))
						                         .union(data.accounts)
						                         .uniq(_.property('api'))
						                         .value());
					});
				});
				break;
		}
	}

	return ractive;
};

},{"../../node_modules/hovercardsshared/account-content/catch-errors.ract":"/Users/cameron/Desktop/HoverCards/hovercardsshared/account-content/catch-errors.ract","../../node_modules/hovercardsshared/account/account.ract":"/Users/cameron/Desktop/HoverCards/hovercardsshared/account/account.ract","../../node_modules/hovercardsshared/account/layout.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/account/layout.html","../../node_modules/hovercardsshared/common/catch-errors.ract":"/Users/cameron/Desktop/HoverCards/hovercardsshared/common/catch-errors.ract","../../node_modules/hovercardsshared/common/date-decorator.js":"/Users/cameron/Desktop/HoverCards/hovercardsshared/common/date-decorator.js","../../node_modules/hovercardsshared/common/number-decorator.js":"/Users/cameron/Desktop/HoverCards/hovercardsshared/common/number-decorator.js","../../node_modules/hovercardsshared/content/header.ract":"/Users/cameron/Desktop/HoverCards/hovercardsshared/content/header.ract","../../node_modules/hovercardsshared/content/layout.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/content/layout.html","../../node_modules/hovercardsshared/content/media.ract":"/Users/cameron/Desktop/HoverCards/hovercardsshared/content/media.ract","../../node_modules/hovercardsshared/content/text.ract":"/Users/cameron/Desktop/HoverCards/hovercardsshared/content/text.ract","../../node_modules/hovercardsshared/discussion/catch-errors.ract":"/Users/cameron/Desktop/HoverCards/hovercardsshared/discussion/catch-errors.ract","../../node_modules/hovercardsshared/discussion/comment.ract":"/Users/cameron/Desktop/HoverCards/hovercardsshared/discussion/comment.ract","../../node_modules/hovercardsshared/discussion/header.ract":"/Users/cameron/Desktop/HoverCards/hovercardsshared/discussion/header.ract","../../node_modules/hovercardsshared/imgur/account-content.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/imgur/account-content.html","../../node_modules/hovercardsshared/imgur/account.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/imgur/account.html","../../node_modules/hovercardsshared/imgur/content.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/imgur/content.html","../../node_modules/hovercardsshared/imgur/discussion-header.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/imgur/discussion-header.html","../../node_modules/hovercardsshared/imgur/discussion.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/imgur/discussion.html","../../node_modules/hovercardsshared/instagram/account-content.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/instagram/account-content.html","../../node_modules/hovercardsshared/instagram/account.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/instagram/account.html","../../node_modules/hovercardsshared/instagram/content.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/instagram/content.html","../../node_modules/hovercardsshared/instagram/discussion-header.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/instagram/discussion-header.html","../../node_modules/hovercardsshared/instagram/discussion.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/instagram/discussion.html","../../node_modules/hovercardsshared/reddit/account-content.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/reddit/account-content.html","../../node_modules/hovercardsshared/reddit/account.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/reddit/account.html","../../node_modules/hovercardsshared/reddit/content.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/reddit/content.html","../../node_modules/hovercardsshared/reddit/discussion-header.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/reddit/discussion-header.html","../../node_modules/hovercardsshared/reddit/discussion.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/reddit/discussion.html","../../node_modules/hovercardsshared/soundcloud/account-content.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/soundcloud/account-content.html","../../node_modules/hovercardsshared/soundcloud/account.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/soundcloud/account.html","../../node_modules/hovercardsshared/soundcloud/content.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/soundcloud/content.html","../../node_modules/hovercardsshared/soundcloud/discussion-header.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/soundcloud/discussion-header.html","../../node_modules/hovercardsshared/soundcloud/discussion.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/soundcloud/discussion.html","../../node_modules/hovercardsshared/soundcloud/song.ract":"/Users/cameron/Desktop/HoverCards/hovercardsshared/soundcloud/song.ract","../../node_modules/hovercardsshared/twitter/account-content.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/twitter/account-content.html","../../node_modules/hovercardsshared/twitter/account.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/twitter/account.html","../../node_modules/hovercardsshared/twitter/content.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/twitter/content.html","../../node_modules/hovercardsshared/twitter/discussion-header.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/twitter/discussion-header.html","../../node_modules/hovercardsshared/twitter/discussion.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/twitter/discussion.html","../../node_modules/hovercardsshared/twitter/tweet.ract":"/Users/cameron/Desktop/HoverCards/hovercardsshared/twitter/tweet.ract","../../node_modules/hovercardsshared/youtube/account-content.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/youtube/account-content.html","../../node_modules/hovercardsshared/youtube/account.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/youtube/account.html","../../node_modules/hovercardsshared/youtube/content.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/youtube/content.html","../../node_modules/hovercardsshared/youtube/discussion-header.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/youtube/discussion-header.html","../../node_modules/hovercardsshared/youtube/discussion.html":"/Users/cameron/Desktop/HoverCards/hovercardsshared/youtube/discussion.html","../../node_modules/hovercardsshared/youtube/video.ract":"/Users/cameron/Desktop/HoverCards/hovercardsshared/youtube/video.ract","../authentication":"/Users/cameron/Desktop/HoverCards/deckard/app/authentication/index.js","../common/mixins":"/Users/cameron/Desktop/HoverCards/deckard/app/common/mixins.js","../config":"/Users/cameron/Desktop/HoverCards/deckard/app/config.js","../service":"/Users/cameron/Desktop/HoverCards/deckard/app/service/index.js","hovercardsshared/urls":"/Users/cameron/Desktop/HoverCards/hovercardsshared/urls/index.js","ractive":"/Users/cameron/Desktop/HoverCards/deckard/node_modules/ractive/ractive.js","underscore":"/Users/cameron/.nvm/versions/node/v4.1.1/lib/node_modules/underscore/underscore.js"}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/youtube/video.ract":[function(require,module,exports){
var component = module;

	// FIXME This is so janky, I love/hate it

	function givescript(src, text) {
		var script  = document.createElement('script');
		script.type = 'text/javascript';
		if (src) {
			script.src = src;
		} else {
			script.text = (text || '') + '; document.currentScript.parentNode.removeChild(document.currentScript);';
		}
		document.body.appendChild(script);
		return script;
	}

	component.exports = {
		oninit: function() {
			var _ = this.get('_');

			this.set('uniqueid', _.uniqueId(_.prefix('youtube-video-')));
			this.observe('expanded', function(expanded) {
				var id = this.get('uniqueid');
				givescript(null, 'window[\'' + id  + '-muted\'] = ' + !this.get('expanded') + ';' +
				'if (window[\'' + id  + '\'] && window[\'' + id  + '\'].mute) {' +
					'window[\'' + id  + '-muted\'] ? window[\'' + id  + '\'].mute() : window[\'' + id  + '\'].unMute();' +
				'}');
			});

			if (document.querySelectorAll('script[src="https://www.youtube.com/iframe_api"]').length) {
				return;
			}
			givescript('https://www.youtube.com/iframe_api');
		},
		oncomplete: function() {
			var id = this.get('uniqueid');
			document.getElementById(id).setAttribute('allowFullScreen', '');
			givescript(null, 'window[\'' + id  + '-timeout\'] = setInterval(function() {' +
				'if (!YT || !YT.Player) {' +
					'return;' +
				'}' +
				'clearInterval(window[\'' + id  + '-timeout\']);' +
				'delete window[\'' + id  + '-timeout\'];' +
				'window[\'' + id  + '\'] = new YT.Player(\'' + id + '\', {' +
					'events: {' +
						'onReady: function(event) {' +
							'window[\'' + id  + '-muted\'] ? event.target.mute() : event.target.unMute();' +
						'}' +
					'}' +
				'});' +
			'}, 500)');
		}
	};

component.exports.template = { v:3,
  t:[ { t:7,
      e:"iframe",
      a:{ "class":[ { t:2,
            r:"class" } ],
        src:[ "https://www.youtube.com/embed/",
          { t:2,
            r:"id" },
          "?enablejsapi=1&autoplay=1&showinfo=0" ],
        id:[ { t:2,
            r:"uniqueid" } ] } },
    " " ] }
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/youtube/discussion.html":[function(require,module,exports){
arguments[4]["/Users/cameron/Desktop/HoverCards/hovercardsshared/instagram/discussion.html"][0].apply(exports,arguments)
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/youtube/discussion-header.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":7,"e":"discussion-header","a":{"content":[{"t":2,"r":"content"}]},"f":[{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"content.stats.views"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"views\",\"youtube\")"}}]}," ",{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"content.stats.likes"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"likes\",\"youtube\")"}}]}," ",{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"content.stats.dislikes"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"dislikes\",\"youtube\")"}}]}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/youtube/content.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":7,"e":"content-header"}," ",{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"content-container\")"}}," ",{"t":2,"x":{"r":["prefix"],"s":"_0(\"flex-row\")"}}]},"f":[{"t":7,"e":"youtube-video","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"content-container-video\")"}}],"id":[{"t":2,"r":"content.id"}]}}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/youtube/account.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"account-cover\")"}}],"style":["background-image:url('",{"t":2,"r":"account.banner"},"')"]}}],"n":50,"r":"account.banner"},{"t":7,"e":"account","a":{"account":[{"t":2,"r":"account"}]},"f":[{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"account.stats.content"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"content\",\"youtube\")"}}]}," ",{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"account.stats.followers"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"followers\",\"youtube\")"}}]}," ",{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"account.stats.views"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"views\",\"youtube\")"}}]}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/youtube/account-content.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"image-container\")"}}]},"f":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"image-item\")"}}]},"f":[{"t":7,"e":"a","a":{"href":[{"t":2,"x":{"r":["url","."],"s":"_0(_1)"}}],"target":"_blank"},"f":[{"t":7,"e":"img","a":{"src":[{"t":2,"x":{"r":["image.medium","image.large","image.small"],"s":"_0||_1||_2"}}]}}," ",{"t":7,"e":"span","f":[{"t":2,"r":"name"}]}]}]}],"r":"account.content.content"}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/twitter/tweet.ract":[function(require,module,exports){
var component = module;



component.exports.template = { v:3,
  t:[ { t:4,
      f:[ { t:7,
          e:"twitter-tweet",
          a:{ tweet:[ { t:2,
                r:"tweet.reposted_content" } ],
            isretweet:"true" } } ],
      n:50,
      r:"tweet.reposted_content" },
    { t:4,
      n:51,
      f:[ { t:4,
          n:50,
          x:{ r:[ "tweet.replied_to_content",
              "inconversation" ],
            s:"_0&&!_1" },
          f:[ { t:7,
              e:"div",
              a:{ "class":[ { t:2,
                    x:{ r:[ "prefix" ],
                      s:"_0(\"tweet-conversation\")" } } ] },
              f:[ { t:7,
                  e:"twitter-tweet",
                  a:{ inconversation:"true" } } ] } ] },
        { t:4,
          n:50,
          x:{ r:[ "tweet.replied_to_content",
              "inconversation" ],
            s:"!(_0&&!_1)" },
          f:[ " ",
            { t:4,
              f:[ { t:7,
                  e:"twitter-tweet",
                  a:{ tweet:[ { t:2,
                        r:"tweet.replied_to_content" } ] } } ],
              n:50,
              r:"tweet.replied_to_content" },
            " ",
            { t:7,
              e:"div",
              a:{ "class":[ { t:2,
                    x:{ r:[ "isretweet",
                        "prefix" ],
                      s:"_0?_1(\"comment-item_retweet\"):\"\"" } } ] },
              f:[ { t:7,
                  e:"discussion-comment",
                  a:{ comment:[ { t:2,
                        x:{ r:[ "_",
                            "tweet" ],
                          s:"_0.defaults({content:_1},_1)" } } ] },
                  f:[ { t:4,
                      f:[ { t:7,
                          e:"div",
                          a:{ "class":[ { t:2,
                                x:{ r:[ "prefix" ],
                                  s:"_0(\"comment-text-image\")" } } ] },
                          f:[ { t:7,
                              e:"content-media",
                              a:{ content:[ { t:2,
                                    r:"tweet" } ],
                                collapsed:"1",
                                dontautoplay:[ { t:2,
                                    x:{ r:[  ],
                                      s:"true" } } ] } } ] } ],
                      n:50,
                      x:{ r:[ "has_media",
                          "tweet" ],
                        s:"_0(_1)" } },
                    " ",
                    { t:4,
                      f:[ { t:7,
                          e:"div",
                          a:{ "class":[ { t:2,
                                x:{ r:[ "prefix" ],
                                  s:"_0(\"comment-text-quote\")" } } ] },
                          f:[ { t:7,
                              e:"twitter-tweet",
                              a:{ tweet:[ { t:2,
                                    r:"tweet.quoted_content" } ],
                                noavatarimages:"true" } } ] } ],
                      n:50,
                      r:"tweet.quoted_content" } ] } ] } ] } ],
      r:"tweet.reposted_content" } ] }
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/twitter/discussion.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":4,"f":[{"t":7,"e":"twitter-tweet","a":{"tweet":[{"t":2,"r":"."}]}}],"r":"discussion.comments"}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/twitter/discussion-header.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":7,"e":"discussion-header","a":{"content":[{"t":2,"r":"content"}]},"f":[{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"content.stats.reposts"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"reposts\",\"twitter\")"}}]}," ",{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"content.stats.likes"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"likes\",\"twitter\")"}}]}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/twitter/content.html":[function(require,module,exports){
arguments[4]["/Users/cameron/Desktop/HoverCards/hovercardsshared/reddit/content.html"][0].apply(exports,arguments)
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/twitter/account.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"account-cover\")"}}],"style":["background-image:url('",{"t":2,"r":"account.banner"},"')"]}}],"n":50,"r":"account.banner"},{"t":7,"e":"account","a":{"account":[{"t":2,"r":"account"}]},"f":[{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"account.stats.content"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"content\",\"twitter\")"}}]}," ",{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"account.stats.followers"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"followers\",\"twitter\")"}}]}," ",{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"account.stats.following"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"following\",\"twitter\")"}}]}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/twitter/account-content.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":4,"f":[{"t":7,"e":"twitter-tweet","a":{"tweet":[{"t":2,"x":{"r":["_","account","."],"s":"_0.defaults({account:_1},_2)"}}]}}],"r":"account.content.content"}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/soundcloud/song.ract":[function(require,module,exports){
var component = module;



component.exports.template = { t:[  ],
  v:3 }
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/soundcloud/discussion.html":[function(require,module,exports){
arguments[4]["/Users/cameron/Desktop/HoverCards/hovercardsshared/instagram/discussion.html"][0].apply(exports,arguments)
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/soundcloud/discussion-header.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":7,"e":"discussion-header","a":{"content":[{"t":2,"r":"content"}]},"f":[{"t":4,"f":[{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"content.stats.content"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"content\",\"soundcloud\")"}}]}],"n":50,"x":{"r":["content.as"],"s":"_0===\"playlist\""}},{"t":4,"n":51,"f":[{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"content.stats.likes"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"likes\",\"soundcloud\")"}}]}," ",{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"content.stats.views"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"views\",\"soundcloud\")"}}]}," ",{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"content.stats.comments"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"comments\",\"soundcloud\")"}}]}],"x":{"r":["content.as"],"s":"_0===\"playlist\""}}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/soundcloud/content.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":7,"e":"content-header"}," ",{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"content-container\")"}}," ",{"t":2,"x":{"r":["prefix"],"s":"_0(\"flex-row\")"}}]},"f":[{"t":4,"f":[{"t":7,"e":"iframe","a":{"src":["https://w.soundcloud.com/player/?url=",{"t":2,"x":{"r":["url","content"],"s":"encodeURI(_0(_1))"}},"&auto_play=true&hide_related=true&show_user=true&show_reposts=false&visual=true"],"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"content-container-image\")"}}],"height":[{"t":2,"x":{"r":["content.as"],"s":"_0===\"playlist\"?420:280"}}],"width":"680","style":["height:",{"t":2,"x":{"r":["content.as"],"s":"_0===\"playlist\"?420:280"}},"px;width:680px;"],"scrolling":"no","frameborder":"no"}}],"n":50,"r":"expanded"},{"t":4,"n":51,"f":[{"t":7,"e":"content-media","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"content-container-image\")"}}]}}],"r":"expanded"}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/soundcloud/account.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"account-cover\")"}}],"style":["background-image:url('",{"t":2,"r":"account.banner"},"')"]}}],"n":50,"r":"account.banner"},{"t":7,"e":"account","a":{"account":[{"t":2,"r":"account"}]},"f":[{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"account.stats.content"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"content\",\"soundcloud\")"}}]}," ",{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"account.stats.followers"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"followers\",\"soundcloud\")"}}]}," ",{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"account.stats.following"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"following\",\"soundcloud\")"}}]}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/soundcloud/account-content.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"image-container\")"}}]},"f":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"image-item\")"}}," ",{"t":2,"x":{"r":["as","prefix"],"s":"(_0===\"playlist\")&&_1(\"playlist-item\")"}}]},"f":[{"t":7,"e":"a","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"image-item-square\")"}}],"href":[{"t":2,"x":{"r":["url","."],"s":"_0(_1)"}}],"target":"_blank"},"f":[{"t":7,"e":"div","a":{"style":["background-image:url('",{"t":2,"x":{"r":["image.medium","image.large","image.small"],"s":"_0||_1||_2"}},"')"]}}," ",{"t":7,"e":"span","f":[{"t":2,"r":".name"}]}]}]}],"r":"account.content.content"}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/reddit/discussion.html":[function(require,module,exports){
arguments[4]["/Users/cameron/Desktop/HoverCards/hovercardsshared/imgur/discussion.html"][0].apply(exports,arguments)
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/reddit/discussion-header.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":7,"e":"discussion-header","a":{"content":[{"t":2,"r":"content"}]},"f":[{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"content.stats.score"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"score\",\"reddit\")"}}]}," ",{"t":7,"e":"span","f":[{"t":7,"e":"em","f":[{"t":2,"x":{"r":["content.stats.score_ratio"],"s":"parseInt(_0*100)"}},"%"]}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"score_ratio\",\"reddit\")"}}]}," ",{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"content.stats.comments"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"comments\",\"reddit\")"}}]}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/reddit/content.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":7,"e":"content-header"}," ",{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"content-container\")"}}," ",{"t":2,"x":{"r":["prefix"],"s":"_0(\"flex-row\")"}}]},"f":[{"t":4,"f":[{"t":7,"e":"content-media","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"content-container-image\")"}}]}}],"n":50,"x":{"r":["has_media","content"],"s":"_0(_1)"}},{"t":4,"n":51,"f":[{"t":7,"e":"content-text"}],"x":{"r":["has_media","content"],"s":"_0(_1)"}}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/reddit/account.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"account-cover\")"}}],"style":["background-image:url('",{"t":2,"r":"account.banner"},"')"]}}],"n":50,"r":"account.banner"},{"t":7,"e":"account","a":{"account":[{"t":2,"r":"account"}]},"f":[{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"account.stats.link_karma"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"link-karma\",\"reddit\")"}}]}," ",{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"account.stats.comment_karma"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"comment-karma\",\"reddit\")"}}]}," ",{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"date","d":[{"t":2,"r":"account.date"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"account-age\",\"reddit\")"}}]}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/reddit/account-content.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":4,"f":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"post-item\")"}}]},"f":[{"t":7,"e":"span","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"post-item-reply-title\")"}}]},"f":["Posted in ",{"t":7,"e":"a","a":{"href":["https://www.reddit.com/r/",{"t":2,"r":"subreddit"}],"target":"_blank"},"f":["/r/",{"t":2,"r":"subreddit"}]}," ",{"t":7,"e":"a","a":{"href":[{"t":2,"x":{"r":["url","."],"s":"_0(_1)"}}],"target":"_blank"},"f":[{"t":7,"e":"span","o":{"n":"date","d":[{"t":2,"r":"date"}]}}]}]}," ",{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"post-item-link\")"}}]},"f":[{"t":7,"e":"a","a":{"href":[{"t":2,"x":{"r":[".url","url","."],"s":"_0||_1(_2)"}}],"target":"_blank"},"f":[{"t":2,"r":"name"}]}]}]}],"n":50,"x":{"r":["type"],"s":"_0===\"content\""}},{"t":4,"n":51,"f":[{"t":4,"n":50,"x":{"r":["type"],"s":"_0===\"comment\""},"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"post-item\")"}}]},"f":[{"t":7,"e":"span","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"post-item-title\")"}}]},"f":["In response to ",{"t":7,"e":"a","a":{"href":[{"t":2,"x":{"r":["content.url","url","content"],"s":"_0||_1(_2)"}}],"target":"_blank"},"f":[{"t":2,"r":"content.name"}]}," in ",{"t":7,"e":"a","a":{"href":["https://www.reddit.com/r/",{"t":2,"r":"content.subreddit"}],"target":"_blank"},"f":["/r/",{"t":2,"r":"content.subreddit"}]}," ",{"t":7,"e":"a","a":{"href":[{"t":2,"x":{"r":["url","content","."],"s":"_0(_1,_2)"}}],"target":"_blank"},"f":[{"t":7,"e":"span","o":{"n":"date","d":[{"t":2,"r":"date"}]}}]}]}," ",{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"post-item-paragraph\")"}}]},"f":[{"t":3,"r":"text"}]}]}]}],"x":{"r":["type"],"s":"_0===\"content\""}}],"r":"account.content.content"}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/instagram/discussion.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":4,"f":[{"t":7,"e":"discussion-comment","a":{"comment":[{"t":2,"r":"."}]}}],"r":"discussion.comments"}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/instagram/discussion-header.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":7,"e":"discussion-header","a":{"content":[{"t":2,"r":"content"}]},"f":[{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"content.stats.likes"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"likes\",\"instagram\")"}}]}," ",{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"content.stats.comments"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"comments\",\"instagram\")"}}]}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/instagram/content.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":7,"e":"content-header"}," ",{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"content-container\")"}}," ",{"t":2,"x":{"r":["prefix"],"s":"_0(\"flex-row\")"}}]},"f":[{"t":7,"e":"content-media","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"content-container-image\")"}}]}}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/instagram/account.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"account-cover\")"}}," ",{"t":2,"x":{"r":["prefix"],"s":"_0(\"flex-row\")"}}]},"f":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"instagram-cover-images\")"}}],"style":["background-image: url('",{"t":2,"x":{"r":["image.medium","image.large","image.small"],"s":"_0||_1||_2"}},"')"]}}],"x":{"r":["_","account.content.content"],"s":"_0.first(_1,3)"}}]}],"n":50,"x":{"r":["expanded","account.content.content"],"s":"!_0&&_1"}},{"t":7,"e":"account","a":{"account":[{"t":2,"r":"account"}]},"f":[{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"account.stats.content"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"content\",\"instagram\")"}}]}," ",{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"account.stats.followers"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"followers\",\"instagram\")"}}]}," ",{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"account.stats.following"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"following\",\"instagram\")"}}]}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/instagram/account-content.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"image-container\")"}}]},"f":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"image-item\")"}}," ",{"t":2,"x":{"r":["prefix"],"s":"_0(\"flex-row\")"}}]},"f":[{"t":7,"e":"a","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"image-item-square\")"}}],"href":[{"t":2,"x":{"r":["url","."],"s":"_0(_1)"}}],"target":"_blank"},"f":[{"t":7,"e":"div","a":{"style":["background-image:url('",{"t":2,"x":{"r":["image.medium","image.large","image.small"],"s":"_0||_1||_2"}},"')"]}}]}]}],"r":"account.content.content"}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/imgur/discussion.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":4,"f":[{"t":7,"e":"discussion-comment","a":{"comment":[{"t":2,"r":"."}],"noavatarimages":"true"}}],"r":"discussion.comments"}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/imgur/discussion-header.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":7,"e":"discussion-header","a":{"content":[{"t":2,"r":"content"}]},"f":[{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"content.stats.views"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"views\",\"imgur\")"}}]}," ",{"t":4,"f":[{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"content.stats.score"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"score\",\"imgur\")"}}]}],"n":50,"x":{"r":["_","content.stats.score"],"s":"!_0.isUndefined(_1)"}}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/imgur/content.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":4,"f":[{"t":7,"e":"content-header"}],"n":50,"r":"expanded"},{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"content-container\")"}}," ",{"t":2,"x":{"r":["prefix"],"s":"_0(\"flex-row\")"}}]},"f":[{"t":4,"f":[{"t":4,"f":[{"t":7,"e":"img","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"content-container-image\")"}}],"src":[{"t":2,"x":{"r":[".image.large",".image.medium",".image.small"],"s":"_0||_1||_2"}}]}}," ",{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"content-container-text\")"}}]},"f":[{"t":7,"e":"b","f":[{"t":2,"r":".name"}]}," ",{"t":7,"e":"p","f":[{"t":3,"r":".text"}]}]}],"n":50,"x":{"r":[".name",".text"],"s":"_0||_1"}}],"r":"content.content"}],"n":50,"x":{"r":["expanded","content.content"],"s":"_0&&_1"}},{"t":4,"n":51,"f":[{"t":7,"e":"content-media","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"content-container-image\")"}}]}}],"x":{"r":["expanded","content.content"],"s":"_0&&_1"}}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/imgur/account.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"account-cover\")"}}," ",{"t":2,"x":{"r":["prefix"],"s":"_0(\"flex-row\")"}}]},"f":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"instagram-cover-images\")"}}],"style":["background-image: url('",{"t":2,"x":{"r":["image.medium","image.large","image.small"],"s":"_0||_1||_2"}},"')"]}}],"x":{"r":["_","account.content.content"],"s":"_0.first(_1,3)"}}]}],"n":50,"x":{"r":["expanded","account.content.content"],"s":"!_0&&_1"}},{"t":7,"e":"account","a":{"account":[{"t":2,"r":"account"}]},"f":[{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"number","d":[{"t":2,"r":"account.stats.score"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"score\",\"imgur\")"}}]}," ",{"t":7,"e":"span","f":[{"t":7,"e":"em","o":{"n":"date","d":[{"t":2,"r":"account.date"}]}}," ",{"t":2,"x":{"r":["copy"],"s":"_0(\"account-age\",\"imgur\")"}}]}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/imgur/account-content.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"image-container\")"}}]},"f":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"image-item\")"}}]},"f":[{"t":7,"e":"a","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"image-item-square\")"}}],"href":[{"t":2,"x":{"r":["url","."],"s":"_0(_1)"}}],"target":"_blank"},"f":[{"t":7,"e":"div","a":{"style":["background-image:url('",{"t":2,"x":{"r":["image.medium","image.large","image.small"],"s":"_0||_1||_2"}},"')"]}}," ",{"t":7,"e":"span","f":[{"t":2,"r":".name"}]}]}]}],"r":"account.content.content"}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/discussion/header.ract":[function(require,module,exports){
var component = module;



component.exports.template = { v:3,
  t:[ { t:4,
      f:[ { t:7,
          e:"content-text" } ],
      n:50,
      x:{ r:[ "has_media",
          "content",
          "content.api",
          "content_api" ],
        s:"_0(_1)||_2!==_3" } },
    { t:7,
      e:"div",
      a:{ "class":[ { t:2,
            x:{ r:[ "prefix" ],
              s:"_0(\"meta\")" } },
          " ",
          { t:2,
            x:{ r:[ "prefix" ],
              s:"_0(\"flex-row\")" } } ] },
      f:[ { t:7,
          e:"div",
          a:{ "class":[ { t:2,
                x:{ r:[ "prefix" ],
                  s:"_0(\"meta-main\")" } } ] },
          f:[ { t:7,
              e:"div",
              a:{ "class":[ { t:2,
                    x:{ r:[ "prefix" ],
                      s:"_0(\"meta-main-stats\")" } } ] },
              f:[ { t:8,
                  r:"content" } ] },
            " ",
            { t:4,
              f:[ { t:7,
                  e:"div",
                  a:{ "class":[ { t:2,
                        x:{ r:[ "prefix" ],
                          s:"_0(\"meta-main-value\")" } } ] },
                  f:[ { t:7,
                      e:"span",
                      a:{ "class":[ { t:2,
                            x:{ r:[ "prefix" ],
                              s:"_0(\"click-to-view\")" } } ] },
                      f:[ "Click to view full size" ] },
                    " ",
                    { t:4,
                      f:[ { t:7,
                          e:"span",
                          f:[ "+ ",
                            { t:7,
                              e:"i",
                              a:{ "class":[ { t:2,
                                    x:{ r:[ "prefix" ],
                                      s:"_0(\"network\")" } },
                                  " ",
                                  { t:2,
                                    x:{ r:[ "prefix",
                                        "content.account.accounts.0.api" ],
                                      s:"_0(_1)" } } ] } },
                            " account." ] } ],
                      n:50,
                      r:"content.accounts.0" } ] } ],
              n:50,
              x:{ r:[ "expanded" ],
                s:"!_0" } } ] },
        " ",
        { t:4,
          f:[ { t:7,
              e:"div",
              a:{ "class":[ { t:2,
                    x:{ r:[ "prefix" ],
                      s:"_0(\"meta-side\")" } } ] },
              f:[ { t:7,
                  e:"i",
                  a:{ "class":[ { t:2,
                        x:{ r:[ "prefix" ],
                          s:"_0(\"network\")" } },
                      " ",
                      { t:2,
                        x:{ r:[ "prefix",
                            "content.api" ],
                          s:"_0(_1)" } } ] } } ] } ],
          n:50,
          x:{ r:[ "expanded" ],
            s:"!_0" } } ] } ] }
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/discussion/comment.ract":[function(require,module,exports){
var component = module;



component.exports.template = { v:3,
  t:[ { t:7,
      e:"div",
      a:{ "class":[ { t:2,
            x:{ r:[ "prefix" ],
              s:"_0(\"comment-item\")" } } ] },
      f:[ { t:4,
          f:[ { t:7,
              e:"div",
              a:{ "class":[ { t:2,
                    x:{ r:[ "prefix" ],
                      s:"_0(\"comment-image\")" } } ] },
              f:[ { t:4,
                  f:[ { t:7,
                      e:"a",
                      a:{ href:[ { t:2,
                            x:{ r:[ "url",
                                "comment.account" ],
                              s:"_0(_1)" } } ],
                        target:"_blank",
                        style:[ "background-image:url('",
                          { t:2,
                            x:{ r:[ ".medium",
                                ".large",
                                ".small" ],
                              s:"_0||_1||_2" } },
                          "')" ] } } ],
                  r:"comment.account.image" },
                { t:4,
                  n:51,
                  f:[ { t:7,
                      e:"a",
                      a:{ href:[ { t:2,
                            x:{ r:[ "url",
                                "comment.account" ],
                              s:"_0(_1)" } } ],
                        target:"_blank",
                        "class":[ { t:2,
                            x:{ r:[ "prefix" ],
                              s:"_0(\"comment-image-empty\")" } } ] } } ],
                  r:"comment.account.image" } ] } ],
          n:50,
          x:{ r:[ "noavatarimages" ],
            s:"!_0" } },
        " ",
        { t:7,
          e:"div",
          a:{ "class":[ { t:2,
                x:{ r:[ "prefix" ],
                  s:"_0(\"comment-text\")" } } ] },
          f:[ { t:7,
              e:"a",
              a:{ href:[ { t:2,
                    x:{ r:[ "url",
                        "comment.account" ],
                      s:"_0(_1)" } } ],
                target:"_blank" },
              f:[ { t:2,
                  x:{ r:[ "comment.account.name",
                      "comment.account.id",
                      "copy",
                      "comment.api" ],
                    s:"_0||(_1&&_2(\"account-id-as-name\",_3,_1))||_2(\"account-empty\",_3)" } } ] },
            " ",
            { t:7,
              e:"a",
              a:{ href:[ { t:2,
                    x:{ r:[ "url",
                        "comment.content",
                        "discussion.content",
                        "content",
                        "comment" ],
                      s:"_0(_1||_2||_3,_4)" } } ],
                target:"_blank",
                "class":"no-hovercard" },
              f:[ { t:4,
                  f:[ { t:7,
                      e:"span",
                      f:[ { t:2,
                          x:{ r:[ "timestamp",
                              "comment.time_offset" ],
                            s:"_0(_1)" } } ] } ],
                  n:50,
                  x:{ r:[ "_",
                      "comment.time_offset" ],
                    s:"_0.isNumber(_1)" } },
                { t:4,
                  n:51,
                  f:[ { t:7,
                      e:"span",
                      o:{ n:"date",
                        d:[ { t:2,
                            r:"comment.date" } ] } } ],
                  x:{ r:[ "_",
                      "comment.time_offset" ],
                    s:"_0.isNumber(_1)" } } ] },
            " ",
            { t:7,
              e:"p",
              f:[ { t:3,
                  r:"comment.text" } ] },
            " ",
            { t:8,
              r:"content" },
            " ",
            { t:4,
              f:[ { t:7,
                  e:"div",
                  a:{ "class":[ { t:2,
                        x:{ r:[ "prefix" ],
                          s:"_0(\"meta-stats\")" } } ] },
                  f:[ { t:4,
                      f:[ { t:7,
                          e:"span",
                          f:[ { t:7,
                              e:"em",
                              o:{ n:"number",
                                d:[ { t:2,
                                    r:"." } ] } },
                            " ",
                            { t:2,
                              x:{ r:[ "copy",
                                  "stat",
                                  "comment.api" ],
                                s:"_0(_1,_2)" } } ] } ],
                      n:52,
                      i:"stat",
                      r:"comment.stats" } ] } ],
              n:50,
              r:"comment.stats" } ] } ] },
    " ",
    { t:4,
      f:[ { t:7,
          e:"div",
          a:{ "class":[ { t:2,
                x:{ r:[ "prefix" ],
                  s:"_0(\"comment-replies\")" } } ] },
          f:[ { t:4,
              f:[ { t:7,
                  e:"discussion-comment",
                  a:{ comment:[ { t:2,
                        r:"." } ] } } ],
              r:"comment.replies" } ] } ],
      n:50,
      r:"comment.replies" } ] }
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/discussion/catch-errors.ract":[function(require,module,exports){
var component = module;



component.exports.template = { v:3,
  t:[ { t:7,
      e:"catch-errors",
      f:[ { t:4,
          f:[ "You can't comment on this so go away" ],
          n:50,
          r:"object.uncommentable" },
        { t:4,
          n:51,
          f:[ { t:4,
              n:50,
              x:{ r:[ "_",
                  "object.comments" ],
                s:"_0.isEmpty(_1)" },
              f:[ "This bitch ain't got no comments!" ] },
            { t:4,
              n:50,
              x:{ r:[ "_",
                  "object.comments" ],
                s:"!(_0.isEmpty(_1))" },
              f:[ " ",
                { t:16 } ] } ],
          r:"object.uncommentable" } ] } ] }
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/content/text.ract":[function(require,module,exports){
var component = module;



component.exports.template = { v:3,
  t:[ { t:4,
      f:[ { t:4,
          f:[ { t:7,
              e:"div",
              a:{ "class":[ { t:2,
                    x:{ r:[ "prefix" ],
                      s:"_0(\"description\")" } },
                  " ",
                  { t:2,
                    x:{ r:[ "descriptionexpand",
                        "_" ],
                      s:"_0?_1.prefix(\"expand-description\"):\"\"" } } ] },
              v:{ click:{ m:"set",
                  a:{ r:[ "expanded" ],
                    s:"[\"descriptionexpand\",_0]" } } },
              f:[ { t:4,
                  f:[ { t:7,
                      e:"a",
                      a:{ "class":[ "no-hovercard ",
                          { t:2,
                            x:{ r:[ "prefix" ],
                              s:"_0(\"description-title\")" } } ],
                        href:[ { t:2,
                            x:{ r:[ "url",
                                "." ],
                              s:"_0(_1)" } } ],
                        target:"_blank" },
                      f:[ { t:2,
                          r:".name" } ] } ],
                  n:50,
                  r:".name" },
                " ",
                { t:4,
                  f:[ { t:7,
                      e:"p",
                      f:[ { t:3,
                          r:".text" } ] } ],
                  n:50,
                  r:".text" } ] } ],
          n:50,
          x:{ r:[ ".text",
              ".name" ],
            s:"_0||_1" } } ],
      r:"content" } ] }
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/content/media.ract":[function(require,module,exports){
var component = module;

	component.exports = {
		oncomplete: function() {
			var ractive = this;
			if (ractive.get('content.video') || ractive.get('content.gif')) {
				var _ = ractive.get('_');

				var id = _.uniqueId(_.prefix('video-'));
				ractive.set('uniqueid', id);
				var element = document.getElementById(id);
				if (!this.get('dontautoplay')) {
					element.play();
				}
				element.onclick = function() {
					if (!ractive.get('expanded')) {
						return;
					}
					if (element.paused) {
						element.play();
					} else {
						element.pause();
					}
				};
			}
		}
	};

component.exports.template = { v:3,
  t:[ { t:4,
      f:[ { t:4,
          f:[ { t:7,
              e:"video",
              a:{ "class":[ { t:2,
                    r:"class" } ],
                src:[ { t:2,
                    r:".video" } ],
                poster:[ { t:2,
                    x:{ r:[ "expanded",
                        ".image.medium",
                        ".image.large",
                        ".image.small" ],
                      s:"(_0?(_2||_1):(_1||_2))||_3" } } ],
                muted:[ { t:2,
                    x:{ r:[ "expanded" ],
                      s:"_0?\"\":\"muted\"" } } ],
                controls:[ { t:2,
                    x:{ r:[ "expanded" ],
                      s:"_0?\"controls\":\"\"" } } ],
                loop:"loop",
                id:[ { t:2,
                    r:"uniqueid" } ] } } ],
          n:50,
          r:".video" },
        { t:4,
          n:51,
          f:[ { t:4,
              n:50,
              x:{ r:[ ".gif" ],
                s:"_0" },
              f:[ { t:7,
                  e:"video",
                  a:{ "class":[ { t:2,
                        r:"class" } ],
                    src:[ { t:2,
                        r:".gif" } ],
                    poster:[ { t:2,
                        x:{ r:[ "expanded",
                            ".image.medium",
                            ".image.large",
                            ".image.small" ],
                          s:"(_0?(_2||_1):(_1||_2))||_3" } } ],
                    muted:"muted",
                    loop:"loop",
                    id:[ { t:2,
                        r:"uniqueid" } ] } } ] },
            { t:4,
              n:50,
              x:{ r:[ ".gif",
                  ".images" ],
                s:"(!(_0))&&(_1)" },
              f:[ " ",
                { t:4,
                  f:[ { t:4,
                      f:[ { t:4,
                          f:[ { t:7,
                              e:"img",
                              a:{ "class":[ { t:2,
                                    r:"class" } ],
                                src:[ { t:2,
                                    x:{ r:[ ".large",
                                        ".medium",
                                        ".small" ],
                                      s:"_0||_1||_2" } } ] } } ],
                          n:50,
                          x:{ r:[ "i",
                              "collapsed",
                              "../../images.length" ],
                            s:"!_0||!_1||_2<=2" } } ],
                      n:52,
                      i:"i",
                      r:".images" },
                    " ",
                    { t:4,
                      f:[ { t:7,
                          e:"a",
                          v:{ click:{ m:"toggle",
                              a:{ r:[  ],
                                s:"[\"collapsed\"]" } } },
                          f:[ "Click to view ",
                            { t:2,
                              x:{ r:[ ".images.length" ],
                                s:"_0-1" } },
                            " more image",
                            { t:2,
                              x:{ r:[ ".images.length" ],
                                s:"_0>2?\"s\":\"\"" } },
                            " in album" ] } ],
                      n:50,
                      x:{ r:[ "collapsed",
                          ".images.length" ],
                        s:"_0&&_1>2" } } ],
                  n:50,
                  r:"expanded" },
                { t:4,
                  n:51,
                  f:[ { t:4,
                      f:[ { t:7,
                          e:"img",
                          a:{ "class":[ { t:2,
                                r:"class" } ],
                            src:[ { t:2,
                                x:{ r:[ ".medium",
                                    ".large",
                                    ".small" ],
                                  s:"_0||_1||_2" } } ] } } ],
                      x:{ r:[ ".image",
                          ".images.0" ],
                        s:"_0||_1" } } ],
                  r:"expanded" } ] },
            { t:4,
              n:50,
              x:{ r:[ ".gif",
                  ".images",
                  ".image" ],
                s:"(!(_0))&&((!(_1))&&(_2))" },
              f:[ " ",
                { t:7,
                  e:"img",
                  a:{ "class":[ { t:2,
                        r:"class" } ],
                    src:[ { t:2,
                        x:{ r:[ "expanded",
                            ".image.medium",
                            ".image.large",
                            ".image.small" ],
                          s:"(_0?(_2||_1):(_1||_2))||_3" } } ] } } ] } ],
          r:".video" } ],
      r:"content" } ] }
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/content/layout.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":[{"t":4,"f":[{"t":2,"x":{"r":["_"],"s":"_0.prefix(\"content-video\")"}}],"n":50,"r":"content.video"},{"t":4,"n":51,"f":[{"t":4,"n":50,"x":{"r":["content.gif"],"s":"_0"},"f":[{"t":2,"x":{"r":["_"],"s":"_0.prefix(\"content-gif\")"}}]},{"t":4,"n":50,"x":{"r":["content.gif","content.images","content.content"],"s":"(!(_0))&&(_1||_2)"},"f":[" ",{"t":2,"x":{"r":["_"],"s":"_0.prefix(\"content-images\")"}}]},{"t":4,"n":50,"x":{"r":["content.gif","content.images","content.content","content.image"],"s":"(!(_0))&&((!(_1||_2))&&(_3))"},"f":[" ",{"t":2,"x":{"r":["_"],"s":"_0.prefix(\"content-image\")"}}]},{"t":4,"n":50,"x":{"r":["content.gif","content.images","content.content","content.image"],"s":"(!(_0))&&((!(_1||_2))&&(!(_3)))"},"f":[" ",{"t":2,"x":{"r":["_"],"s":"_0.prefix(\"content-text\")"}}]}],"r":"content.video"}," ",{"t":2,"x":{"r":["_","content.api"],"s":"_0.prefix(\"content-\"+_1)"}}]},"f":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["_"],"s":"_0.prefix(\"content\")"}}]},"f":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["_"],"s":"_0.prefix(\"loading\")"}}]}}],"n":50,"r":"content.loading"},{"t":4,"n":51,"f":[{"t":4,"n":50,"x":{"r":["content.loaded"],"s":"_0"},"f":[{"t":7,"e":"catch-errors","a":{"object":[{"t":2,"r":"content"}]},"f":[{"t":8,"x":{"r":["content"],"s":"_0.api+\"-content\""}}]}]}],"r":"content.loading"}]}," ",{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["_"],"s":"_0.prefix(\"discussion\")"}}," ",{"t":2,"x":{"r":["scrollpos","scrollposbottom","_"],"s":"_0>20&&_1>20?_2.prefix(\"discussion_fixed\"):\"\""}}," ",{"t":2,"x":{"r":["scrollposbottom","_"],"s":"_0<=20?_1.prefix(\"discussion_at-bottom\"):\"\""}}],"style":[{"t":2,"x":{"r":["scrollpos","scrollposbottom","boxmargin"],"s":"_0>20&&_1>20?\"right: \"+_2+\"px !important;\":\"\""}}]},"f":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["_"],"s":"_0.prefix(\"flex-spread\")"}}," ",{"t":2,"x":{"r":["_"],"s":"_0.prefix(\"account-switcher\")"}}]},"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["_"],"s":"_0.prefix(\"tabs\")"}}]},"f":[{"t":4,"f":[{"t":7,"e":"span","v":{"click":{"m":"set","a":{"r":["i"],"s":"[\"discussion_i\",_0]"}}},"a":{"class":[{"t":2,"x":{"r":["_"],"s":"_0.prefix(\"tabs__tab\")"}}," ",{"t":2,"x":{"r":["i","discussion_i","_"],"s":"_0===_1?_2.prefix(\"tabs__tab_selected\"):\"\""}}]},"f":[{"t":2,"x":{"r":["copy",".api"],"s":"_0(_1)"}}]}],"n":52,"i":"i","r":"discussions"}]}]}],"n":50,"x":{"r":["discussions","expanded"],"s":"_0&&_1"}}," ",{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["_"],"s":"_0.prefix(\"testing\")"}}]},"f":[{"t":4,"f":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["_"],"s":"_0.prefix(\"discussion__header\")"}}]},"f":[{"t":4,"n":53,"f":[{"t":8,"x":{"r":["api"],"s":"_0+\"-discussion-header\""}}],"x":{"r":[".","../api"],"s":"{content:_0,content_api:_1}"}}]}],"n":50,"r":"."}],"n":53,"x":{"r":["expanded","content.api","discussion_i","discussions","content.loaded","content.err","content"],"s":"_0?(_3[_2].loaded&&!_3[_2].err&&_3[_2].content)||(_1===_3[_2].api&&_6):(_4&&!_5&&_6)"}}," ",{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["_"],"s":"_0.prefix(\"discussion__body\")"}}]},"f":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["_"],"s":"_0.prefix(\"loading\")"}}]}}],"n":50,"rx":{"r":"discussions","m":[{"t":30,"n":"discussion_i"},"loading"]}},{"t":4,"n":51,"f":[{"t":4,"n":50,"x":{"r":["discussion_i","discussions"],"s":"_1[_0].loaded"},"f":[{"t":7,"e":"discussion-catch-errors","a":{"object":[{"t":2,"rx":{"r":"discussions","m":[{"t":30,"n":"discussion_i"}]}}]},"f":[{"t":4,"n":53,"f":[{"t":8,"x":{"r":["discussion_i","discussions"],"s":"_1[_0].api+\"-discussion\""}}],"x":{"r":["discussion_i","discussions"],"s":"{discussion:_1[_0]}"}}]}]}],"rx":{"r":"discussions","m":[{"t":30,"n":"discussion_i"},"loading"]}}]}],"n":50,"x":{"r":["discussion_i","discussions","expanded"],"s":"_1&&_1[_0]&&_2"}}]}]}],"n":50,"r":"content"}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/content/header.ract":[function(require,module,exports){
var component = module;



component.exports.template = { v:3,
  t:[ { t:4,
      f:[ { t:7,
          e:"div",
          a:{ "class":[ { t:2,
                x:{ r:[ "prefix" ],
                  s:"_0(\"content-account\")" } },
              " ",
              { t:2,
                x:{ r:[ "prefix" ],
                  s:"_0(\"flex-spread\")" } } ] },
          f:[ { t:7,
              e:"div",
              a:{ "class":[ { t:2,
                    x:{ r:[ "prefix" ],
                      s:"_0(\"flex-center\")" } } ] },
              f:[ { t:4,
                  f:[ { t:4,
                      f:[ { t:7,
                          e:"a",
                          a:{ "class":[ { t:2,
                                x:{ r:[ "prefix" ],
                                  s:"_0(\"content-account-image\")" } } ],
                            href:[ { t:2,
                                x:{ r:[ "url",
                                    ".account" ],
                                  s:"_0(_1)" } } ],
                            target:"_blank",
                            style:[ "background-image:url('",
                              { t:2,
                                x:{ r:[ ".account.image.small",
                                    ".account.image.medium",
                                    ".account.image.large" ],
                                  s:"_0||_1||_2" } },
                              "')" ] } } ],
                      n:50,
                      r:".account.image" },
                    " ",
                    { t:7,
                      e:"div",
                      f:[ { t:7,
                          e:"a",
                          a:{ "class":[ { t:2,
                                x:{ r:[ "prefix" ],
                                  s:"_0(\"content-account-name\")" } } ],
                            href:[ { t:2,
                                x:{ r:[ "url",
                                    ".account" ],
                                  s:"_0(_1)" } } ],
                            target:"_blank" },
                          f:[ { t:2,
                              x:{ r:[ ".account.name",
                                  ".account.id",
                                  "copy",
                                  ".account.api" ],
                                s:"_0||_2(\"account-id-as-name\",_3,_1)||_2(\"account-empty\",_3)" } } ] },
                        " ",
                        { t:4,
                          f:[ { t:7,
                              e:"a",
                              a:{ href:[ { t:2,
                                    x:{ r:[ "url",
                                        "." ],
                                      s:"_0(_1)" } } ],
                                target:"_blank",
                                "class":"no-hovercard" },
                              f:[ { t:7,
                                  e:"br" },
                                { t:7,
                                  e:"span",
                                  o:{ n:"date",
                                    d:[ { t:2,
                                        r:".date" } ] } } ] } ],
                          n:50,
                          r:"expanded" } ] } ],
                  n:50,
                  r:".account" } ] },
            " ",
            { t:7,
              e:"div",
              f:[ { t:4,
                  f:[ { t:7,
                      e:"a",
                      a:{ "class":[ { t:2,
                            x:{ r:[ "prefix" ],
                              s:"_0(\"share-button\")" } },
                          " ",
                          { t:2,
                            x:{ r:[ "prefix" ],
                              s:"_0(\"share-facebook\")" } } ],
                        href:[ "https://www.facebook.com/sharer/sharer.php?u=",
                          { t:2,
                            x:{ r:[ "url",
                                "." ],
                              s:"_0(_1)" } } ],
                        target:"_blank" },
                      f:[ "Share" ] },
                    " ",
                    { t:7,
                      e:"a",
                      a:{ "class":[ { t:2,
                            x:{ r:[ "prefix" ],
                              s:"_0(\"share-button\")" } },
                          " ",
                          { t:2,
                            x:{ r:[ "prefix" ],
                              s:"_0(\"share-twitter\")" } } ],
                        href:[ "https://twitter.com/intent/tweet?url=",
                          { t:2,
                            x:{ r:[ "url",
                                "." ],
                              s:"_0(_1)" } },
                          "&via=hovercards&source=https://hovercards.com" ],
                        target:"_blank" },
                      f:[ "Tweet" ] } ],
                  n:50,
                  r:"expanded" },
                { t:4,
                  n:51,
                  f:[ { t:7,
                      e:"a",
                      a:{ href:[ { t:2,
                            x:{ r:[ "url",
                                "." ],
                              s:"_0(_1)" } } ],
                        target:"_blank",
                        "class":"no-hovercard" },
                      f:[ { t:7,
                          e:"span",
                          o:{ n:"date",
                            d:[ { t:2,
                                r:".date" } ] } } ] } ],
                  r:"expanded" } ] } ] } ],
      r:"content" } ] }
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/common/number-decorator.js":[function(require,module,exports){
var _ = require('underscore');

var units = ['', 'x-thousand', 'x-million', 'x-billion', 'x-trillion'];

// If the number is already going to be 4 digits or less, leave it alone
// Otherwise, make it 3 digits, and with the proper units
module.exports = function(node, number) {
	var copy = this.get('copy') || _.identity;
	if (!_.isNumber(number) || _.isNaN(number)) {
		node.textContent = number;
	} else if (number < 10000) {
		node.textContent = number.toLocaleString();
	} else {
		var log1000      = Math.floor(Math.log10(number) / 3);
		var multiple1000 = number / Math.pow(1000, log1000);
		var roundto      = Math.pow(10, 2 - Math.floor(Math.log10(multiple1000)));
		multiple1000     = Math.round(multiple1000 * roundto) / roundto;

		if (log1000) {
			node.textContent = copy(units[log1000], null, multiple1000.toLocaleString());
			node.title       = number.toLocaleString();
		} else {
			// Shouldn't happen
			node.textContent = multiple1000.toLocaleString();
		}
	}
	return { teardown: _.noop };
};

},{"underscore":"/Users/cameron/.nvm/versions/node/v4.1.1/lib/node_modules/underscore/underscore.js"}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/common/date-decorator.js":[function(require,module,exports){
var _ = require('underscore');

var units = [
	{ copy: 'x-seconds', value: -1 },
	{ copy: 'x-seconds', value: 1000 },
	{ copy: 'x-minutes', value: 1000 * 60 },
	{ copy: 'x-hours',   value: 1000 * 60 * 60 },
	{ copy: 'x-days',    value: 1000 * 60 * 60 * 24 },
	{ copy: 'x-months',  value: 1000 * 60 * 60 * 24 * 31 },
	{ copy: 'x-years',   value: 1000 * 60 * 60 * 24 * 31 * 12 }
];

// Display with the proper units, then update when we're going to
// change
module.exports = function(node, date) {
	var copy = this.get('copy') || _.identity;
	if (!_.isNumber(date) || _.isNaN(date)) {
		node.textContent = date;
		return { teardown: _.noop };
	}

	date       = new Date(date);
	node.title = date.toString();

	var timeout;
	function display_date_and_set_timeout() {
		var now                = new Date();
		var now_with_date_time = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(),
		                                           date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()));
		// This difference pretends that months are exactly 31 days.
		var difference = now - now_with_date_time +
		                 1000 * 60 * 60 * 24 * (now.getUTCDate() - date.getUTCDate() +
		                                        31 * (now.getUTCMonth() - date.getUTCMonth() +
		                                              12 * (now.getUTCFullYear() - date.getUTCFullYear())));
		var unit  = units[_.sortedIndex(units, { value: difference }, 'value') - 1];
		var value = Math.floor(difference / unit.value);

		node.textContent = copy(unit.copy, null, value);
		setTimeout(display_date_and_set_timeout, date + (value + 1) * unit.value - now);
	}
	display_date_and_set_timeout();

	return { teardown: function() { clearTimeout(timeout); } };
};

},{"underscore":"/Users/cameron/.nvm/versions/node/v4.1.1/lib/node_modules/underscore/underscore.js"}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/common/catch-errors.ract":[function(require,module,exports){
var component = module;

	component.exports = {
		oninit: function() {
			this.on('authenticate', function() {
				this.get('object.err.authenticate')();
			});
		}
	};

component.exports.template = { v:3,
  t:[ { t:4,
      f:[ { t:4,
          f:[ { t:7,
              e:"div",
              a:{ "class":[ { t:2,
                    x:{ r:[ "_" ],
                      s:"_0.prefix(\"error\")" } },
                  " ",
                  { t:2,
                    x:{ r:[ "_" ],
                      s:"_0.prefix(\"flex-center\")" } } ] },
              f:[ { t:7,
                  e:"div",
                  a:{ "class":[ { t:2,
                        x:{ r:[ "_" ],
                          s:"_0.prefix(\"error-image\")" } } ] } },
                " ",
                { t:7,
                  e:"div",
                  f:[ { t:7,
                      e:"b",
                      f:[ { t:2,
                          x:{ r:[ ".err.status",
                              "copy",
                              ".api" ],
                            s:"_1(\"err-\"+_0+\"-name\",_2,_1(_2))" } } ] },
                    " ",
                    { t:7,
                      e:"p",
                      f:[ { t:2,
                          x:{ r:[ ".err.status",
                              "copy",
                              ".api" ],
                            s:"_1(\"err-\"+_0+\"-text\",_2,_1(_2))" } } ] },
                    " ",
                    { t:4,
                      f:[ { t:7,
                          e:"a",
                          v:{ click:"authenticate" },
                          a:{ "class":[ { t:2,
                                x:{ r:[ "_",
                                    ".api" ],
                                  s:"_0.prefix(_1)" } },
                              " ",
                              { t:2,
                                x:{ r:[ "_" ],
                                  s:"_0.prefix(\"signin-cta\")" } } ] },
                          f:[ { t:2,
                              x:{ r:[ "copy",
                                  ".api" ],
                                s:"_0(\"err-401-cta\",_1,_0(_1))" } } ] } ],
                      n:50,
                      x:{ r:[ ".err.status" ],
                        s:"_0===401" } } ] } ] } ],
          r:"object" } ],
      n:50,
      r:"object.err" },
    { t:4,
      n:51,
      f:[ { t:16 } ],
      r:"object.err" } ] }
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/account/layout.html":[function(require,module,exports){
module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["_"],"s":"_0.prefix(\"account-container\")"}}]},"f":[{"t":4,"f":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"flex-spread\")"}}," ",{"t":2,"x":{"r":["prefix"],"s":"_0(\"account-switcher\")"}}]},"f":[{"t":7,"e":"div","f":[{"t":7,"e":"span","f":[{"t":2,"x":{"r":["accounts.0.name","accounts.0.id","copy","accounts.0.api"],"s":"_0||_2(\"account-id-as-name\",_3,_1)||_2(\"account-empty\",_3)"}},"'s accounts:"]}]}," ",{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"tabs\")"}}]},"f":[{"t":4,"f":[{"t":7,"e":"span","v":{"click":{"m":"set","a":{"r":["i"],"s":"[\"account_i\",_0]"}}},"a":{"class":[{"t":2,"x":{"r":["prefix"],"s":"_0(\"tabs__tab\")"}}," ",{"t":2,"x":{"r":["i","account_i","_"],"s":"_0===_1?_2.prefix(\"tabs__tab_selected\"):\"\""}}]},"f":[{"t":2,"x":{"r":["copy",".api"],"s":"_0(_1)"}}]}],"n":52,"i":"i","r":"accounts"}]}]}],"n":50,"x":{"r":["expanded","accounts.length"],"s":"_0&&_1>1"}}," ",{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["_"],"s":"_0.prefix(\"account\")"}}]},"f":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["_"],"s":"_0.prefix(\"loading\")"}}]}}],"n":50,"rx":{"r":"accounts","m":[{"t":30,"n":"account_i"},"loading"]}},{"t":4,"n":51,"f":[{"t":4,"n":50,"x":{"r":["account_i","accounts"],"s":"_1[_0].loaded"},"f":[{"t":7,"e":"catch-errors","a":{"object":[{"t":2,"rx":{"r":"accounts","m":[{"t":30,"n":"account_i"}]}}]},"f":[{"t":4,"n":53,"f":[{"t":8,"x":{"r":["account_i","accounts"],"s":"_1[_0].api+\"-account\""}}],"x":{"r":["account_i","accounts"],"s":"{account:_1[_0]}"}}]}]}],"rx":{"r":"accounts","m":[{"t":30,"n":"account_i"},"loading"]}}]}],"n":50,"rx":{"r":"accounts","m":[{"t":30,"n":"account_i"}]}}," ",{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["_"],"s":"_0.prefix(\"account-content\")"}}]},"f":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":[{"t":2,"x":{"r":["_"],"s":"_0.prefix(\"loading\")"}}]}}],"n":50,"rx":{"r":"accounts","m":[{"t":30,"n":"account_i"},"content","loading"]}},{"t":4,"n":51,"f":[{"t":4,"n":50,"x":{"r":["account_i","accounts"],"s":"_1[_0].content.loaded"},"f":[{"t":7,"e":"account-content-catch-errors","a":{"object":[{"t":2,"rx":{"r":"accounts","m":[{"t":30,"n":"account_i"},"content"]}}]},"f":[{"t":4,"n":53,"f":[{"t":8,"x":{"r":["account_i","accounts"],"s":"_1[_0].content.api+\"-account-content\""}}],"x":{"r":["account_i","accounts"],"s":"{account:_1[_0]}"}}]}]}],"rx":{"r":"accounts","m":[{"t":30,"n":"account_i"},"content","loading"]}}]}],"n":50,"x":{"r":["expanded","account_i","accounts"],"s":"_0&&_2[_1].content"}}],"n":50,"x":{"r":["accounts","_","account_i"],"s":"_0&&_1.isNumber(_2)"}}]}]}
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/account/account.ract":[function(require,module,exports){
var component = module;



component.exports.template = { v:3,
  t:[ { t:4,
      f:[ { t:7,
          e:"a",
          a:{ "class":[ { t:2,
                x:{ r:[ "prefix" ],
                  s:"_0(\"account-image\")" } },
              " no-hovercard" ],
            href:[ { t:2,
                x:{ r:[ "url",
                    "account" ],
                  s:"_0(_1)" } } ],
            target:"_blank",
            style:[ "background-image:url('",
              { t:2,
                x:{ r:[ "medium",
                    "large",
                    "small" ],
                  s:"_0||_1||_2" } },
              "')" ] } } ],
      r:"account.image" },
    { t:7,
      e:"div",
      a:{ "class":[ { t:2,
            x:{ r:[ "prefix" ],
              s:"_0(\"account-name\")" } },
          " ",
          { t:2,
            x:{ r:[ "prefix" ],
              s:"_0(\"flex-row\")" } } ] },
      f:[ { t:7,
          e:"a",
          a:{ href:[ { t:2,
                x:{ r:[ "url",
                    "account" ],
                  s:"_0(_1)" } } ],
            target:"_blank",
            "class":"no-hovercard" },
          f:[ { t:2,
              x:{ r:[ "account.name",
                  "account.id",
                  "copy",
                  "account.api" ],
                s:"_0||_2(\"account-id-as-name\",_3,_1)||_2(\"account-empty\",_3)" } } ] },
        " ",
        { t:7,
          e:"span",
          a:{ "class":[ { t:2,
                x:{ r:[ "account.verified",
                    "prefix" ],
                  s:"_0?_1(\"verified\"):\"\"" } } ] } } ] },
    " ",
    { t:4,
      f:[ { t:7,
          e:"div",
          a:{ "class":[ { t:2,
                x:{ r:[ "prefix" ],
                  s:"_0(\"description\")" } },
              " ",
              { t:2,
                x:{ r:[ "descriptionexpand",
                    "_" ],
                  s:"_0?_1.prefix(\"expand-description\"):\"\"" } } ] },
          v:{ click:{ m:"set",
              a:{ r:[ "expanded" ],
                s:"[\"descriptionexpand\",_0]" } } },
          f:[ { t:7,
              e:"p",
              a:{ "class":[ { t:2,
                    x:{ r:[ "prefix" ],
                      s:"_0(\"text-center\")" } } ] },
              f:[ { t:3,
                  r:"account.text" } ] } ] } ],
      n:50,
      r:"account.text" },
    { t:7,
      e:"div",
      a:{ "class":[ { t:2,
            x:{ r:[ "prefix" ],
              s:"_0(\"meta\")" } },
          " ",
          { t:2,
            x:{ r:[ "prefix" ],
              s:"_0(\"flex-row\")" } } ] },
      f:[ { t:7,
          e:"div",
          a:{ "class":[ { t:2,
                x:{ r:[ "prefix" ],
                  s:"_0(\"meta-main\")" } } ] },
          f:[ { t:7,
              e:"div",
              a:{ "class":[ { t:2,
                    x:{ r:[ "prefix" ],
                      s:"_0(\"meta-main-stats\")" } } ] },
              f:[ { t:8,
                  r:"content" } ] },
            " ",
            { t:4,
              f:[ { t:7,
                  e:"div",
                  a:{ "class":[ { t:2,
                        x:{ r:[ "prefix" ],
                          s:"_0(\"meta-main-value\")" } } ] },
                  f:[ { t:7,
                      e:"span",
                      a:{ "class":[ { t:2,
                            x:{ r:[ "prefix" ],
                              s:"_0(\"click-to-view\")" } } ] },
                      f:[ "Click to view full profile" ] },
                    " ",
                    { t:4,
                      f:[ { t:7,
                          e:"span",
                          f:[ "+ ",
                            { t:7,
                              e:"i",
                              a:{ "class":[ { t:2,
                                    x:{ r:[ "prefix" ],
                                      s:"_0(\"network\")" } },
                                  " ",
                                  { t:2,
                                    x:{ r:[ "prefix",
                                        "accounts.1.api" ],
                                      s:"_0(_1)" } } ] } },
                            " account." ] } ],
                      n:50,
                      x:{ r:[ "accounts.length" ],
                        s:"_0>1" } } ] } ],
              n:50,
              x:{ r:[ "expanded" ],
                s:"!_0" } } ] },
        " ",
        { t:7,
          e:"div",
          a:{ "class":[ { t:2,
                x:{ r:[ "prefix" ],
                  s:"_0(\"meta-side\")" } } ] },
          f:[ { t:7,
              e:"i",
              a:{ "class":[ { t:2,
                    x:{ r:[ "prefix" ],
                      s:"_0(\"network\")" } },
                  " ",
                  { t:2,
                    x:{ r:[ "prefix",
                        "account.api" ],
                      s:"_0(_1)" } } ] } } ] } ] } ] }
},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/account-content/catch-errors.ract":[function(require,module,exports){
var component = module;



component.exports.template = { v:3,
  t:[ { t:7,
      e:"catch-errors",
      f:[ { t:4,
          f:[ "This bitch ain't got no content!" ],
          n:50,
          x:{ r:[ "_",
              "object.content" ],
            s:"_0.isEmpty(_1)" } },
        { t:4,
          n:51,
          f:[ { t:16 } ],
          x:{ r:[ "_",
              "object.content" ],
            s:"_0.isEmpty(_1)" } } ] } ] }
},{}],"/Users/cameron/Desktop/HoverCards/deckard/node_modules/ractive/ractive.js":[function(require,module,exports){
/*
	Ractive.js v0.7.3
	Sat Apr 25 2015 13:52:38 GMT-0400 (EDT) - commit da40f81c660ba2f09c45a09a9c20fdd34ee36d80

	http://ractivejs.org
	http://twitter.com/RactiveJS

	Released under the MIT License.
*/

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  global.Ractive = factory()
}(this, function () { 'use strict';

  var TEMPLATE_VERSION = 3;

  var defaultOptions = {

  	// render placement:
  	el: void 0,
  	append: false,

  	// template:
  	template: { v: TEMPLATE_VERSION, t: [] },

  	// parse:     // TODO static delimiters?
  	preserveWhitespace: false,
  	sanitize: false,
  	stripComments: true,
  	delimiters: ["{{", "}}"],
  	tripleDelimiters: ["{{{", "}}}"],
  	interpolate: false,

  	// data & binding:
  	data: {},
  	computed: {},
  	magic: false,
  	modifyArrays: true,
  	adapt: [],
  	isolated: false,
  	twoway: true,
  	lazy: false,

  	// transitions:
  	noIntro: false,
  	transitionsEnabled: true,
  	complete: void 0,

  	// css:
  	css: null,
  	noCssTransform: false
  };

  var config_defaults = defaultOptions;

  // These are a subset of the easing equations found at
  // https://raw.github.com/danro/easing-js - license info
  // follows:

  // --------------------------------------------------
  // easing.js v0.5.4
  // Generic set of easing functions with AMD support
  // https://github.com/danro/easing-js
  // This code may be freely distributed under the MIT license
  // http://danro.mit-license.org/
  // --------------------------------------------------
  // All functions adapted from Thomas Fuchs & Jeremy Kahn
  // Easing Equations (c) 2003 Robert Penner, BSD license
  // https://raw.github.com/danro/easing-js/master/LICENSE
  // --------------------------------------------------

  // In that library, the functions named easeIn, easeOut, and
  // easeInOut below are named easeInCubic, easeOutCubic, and
  // (you guessed it) easeInOutCubic.
  //
  // You can add additional easing functions to this list, and they
  // will be globally available.

  var static_easing = {
  	linear: function (pos) {
  		return pos;
  	},
  	easeIn: function (pos) {
  		return Math.pow(pos, 3);
  	},
  	easeOut: function (pos) {
  		return Math.pow(pos - 1, 3) + 1;
  	},
  	easeInOut: function (pos) {
  		if ((pos /= 0.5) < 1) {
  			return 0.5 * Math.pow(pos, 3);
  		}
  		return 0.5 * (Math.pow(pos - 2, 3) + 2);
  	}
  };

  /*global console, navigator */
  var isClient, isJsdom, hasConsole, environment__magic, namespaces, svg, vendors;

  isClient = typeof document === "object";

  isJsdom = typeof navigator !== "undefined" && /jsDom/.test(navigator.appName);

  hasConsole = typeof console !== "undefined" && typeof console.warn === "function" && typeof console.warn.apply === "function";

  try {
  	Object.defineProperty({}, "test", { value: 0 });
  	environment__magic = true;
  } catch (e) {
  	environment__magic = false;
  }

  namespaces = {
  	html: "http://www.w3.org/1999/xhtml",
  	mathml: "http://www.w3.org/1998/Math/MathML",
  	svg: "http://www.w3.org/2000/svg",
  	xlink: "http://www.w3.org/1999/xlink",
  	xml: "http://www.w3.org/XML/1998/namespace",
  	xmlns: "http://www.w3.org/2000/xmlns/"
  };

  if (typeof document === "undefined") {
  	svg = false;
  } else {
  	svg = document && document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
  }

  vendors = ["o", "ms", "moz", "webkit"];

  var createElement, matches, dom__div, methodNames, unprefixed, prefixed, dom__i, j, makeFunction;

  // Test for SVG support
  if (!svg) {
  	createElement = function (type, ns) {
  		if (ns && ns !== namespaces.html) {
  			throw "This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you're trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information";
  		}

  		return document.createElement(type);
  	};
  } else {
  	createElement = function (type, ns) {
  		if (!ns || ns === namespaces.html) {
  			return document.createElement(type);
  		}

  		return document.createElementNS(ns, type);
  	};
  }

  function getElement(input) {
  	var output;

  	if (!input || typeof input === "boolean") {
  		return;
  	}

  	if (typeof window === "undefined" || !document || !input) {
  		return null;
  	}

  	// We already have a DOM node - no work to do. (Duck typing alert!)
  	if (input.nodeType) {
  		return input;
  	}

  	// Get node from string
  	if (typeof input === "string") {
  		// try ID first
  		output = document.getElementById(input);

  		// then as selector, if possible
  		if (!output && document.querySelector) {
  			output = document.querySelector(input);
  		}

  		// did it work?
  		if (output && output.nodeType) {
  			return output;
  		}
  	}

  	// If we've been given a collection (jQuery, Zepto etc), extract the first item
  	if (input[0] && input[0].nodeType) {
  		return input[0];
  	}

  	return null;
  }

  if (!isClient) {
  	matches = null;
  } else {
  	dom__div = createElement("div");
  	methodNames = ["matches", "matchesSelector"];

  	makeFunction = function (methodName) {
  		return function (node, selector) {
  			return node[methodName](selector);
  		};
  	};

  	dom__i = methodNames.length;

  	while (dom__i-- && !matches) {
  		unprefixed = methodNames[dom__i];

  		if (dom__div[unprefixed]) {
  			matches = makeFunction(unprefixed);
  		} else {
  			j = vendors.length;
  			while (j--) {
  				prefixed = vendors[dom__i] + unprefixed.substr(0, 1).toUpperCase() + unprefixed.substring(1);

  				if (dom__div[prefixed]) {
  					matches = makeFunction(prefixed);
  					break;
  				}
  			}
  		}
  	}

  	// IE8...
  	if (!matches) {
  		matches = function (node, selector) {
  			var nodes, parentNode, i;

  			parentNode = node.parentNode;

  			if (!parentNode) {
  				// empty dummy <div>
  				dom__div.innerHTML = "";

  				parentNode = dom__div;
  				node = node.cloneNode();

  				dom__div.appendChild(node);
  			}

  			nodes = parentNode.querySelectorAll(selector);

  			i = nodes.length;
  			while (i--) {
  				if (nodes[i] === node) {
  					return true;
  				}
  			}

  			return false;
  		};
  	}
  }

  function detachNode(node) {
  	if (node && typeof node.parentNode !== "unknown" && node.parentNode) {
  		node.parentNode.removeChild(node);
  	}

  	return node;
  }

  function safeToStringValue(value) {
  	return value == null || !value.toString ? "" : value;
  }

  var legacy = null;

  var create, defineProperty, defineProperties;

  try {
  	Object.defineProperty({}, "test", { value: 0 });

  	if (isClient) {
  		Object.defineProperty(document.createElement("div"), "test", { value: 0 });
  	}

  	defineProperty = Object.defineProperty;
  } catch (err) {
  	// Object.defineProperty doesn't exist, or we're in IE8 where you can
  	// only use it with DOM objects (what were you smoking, MSFT?)
  	defineProperty = function (obj, prop, desc) {
  		obj[prop] = desc.value;
  	};
  }

  try {
  	try {
  		Object.defineProperties({}, { test: { value: 0 } });
  	} catch (err) {
  		// TODO how do we account for this? noMagic = true;
  		throw err;
  	}

  	if (isClient) {
  		Object.defineProperties(createElement("div"), { test: { value: 0 } });
  	}

  	defineProperties = Object.defineProperties;
  } catch (err) {
  	defineProperties = function (obj, props) {
  		var prop;

  		for (prop in props) {
  			if (props.hasOwnProperty(prop)) {
  				defineProperty(obj, prop, props[prop]);
  			}
  		}
  	};
  }

  try {
  	Object.create(null);

  	create = Object.create;
  } catch (err) {
  	// sigh
  	create = (function () {
  		var F = function () {};

  		return function (proto, props) {
  			var obj;

  			if (proto === null) {
  				return {};
  			}

  			F.prototype = proto;
  			obj = new F();

  			if (props) {
  				Object.defineProperties(obj, props);
  			}

  			return obj;
  		};
  	})();
  }

  function utils_object__extend(target) {
  	for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		sources[_key - 1] = arguments[_key];
  	}

  	var prop, source;

  	while (source = sources.shift()) {
  		for (prop in source) {
  			if (hasOwn.call(source, prop)) {
  				target[prop] = source[prop];
  			}
  		}
  	}

  	return target;
  }

  function fillGaps(target) {
  	for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		sources[_key - 1] = arguments[_key];
  	}

  	sources.forEach(function (s) {
  		for (var key in s) {
  			if (s.hasOwnProperty(key) && !(key in target)) {
  				target[key] = s[key];
  			}
  		}
  	});

  	return target;
  }

  var hasOwn = Object.prototype.hasOwnProperty;

  // thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
  var is__toString = Object.prototype.toString,
      arrayLikePattern = /^\[object (?:Array|FileList)\]$/;
  function isArray(thing) {
  	return is__toString.call(thing) === "[object Array]";
  }

  function isArrayLike(obj) {
  	return arrayLikePattern.test(is__toString.call(obj));
  }

  function isEqual(a, b) {
  	if (a === null && b === null) {
  		return true;
  	}

  	if (typeof a === "object" || typeof b === "object") {
  		return false;
  	}

  	return a === b;
  }

  function is__isNumeric(thing) {
  	return !isNaN(parseFloat(thing)) && isFinite(thing);
  }

  function isObject(thing) {
  	return thing && is__toString.call(thing) === "[object Object]";
  }

  var noop = function () {};

  /* global console */
  var alreadyWarned = {},
      log,
      printWarning,
      welcome;

  if (hasConsole) {
  	(function () {
  		var welcomeIntro = ["%cRactive.js %c0.7.3 %cin debug mode, %cmore...", "color: rgb(114, 157, 52); font-weight: normal;", "color: rgb(85, 85, 85); font-weight: normal;", "color: rgb(85, 85, 85); font-weight: normal;", "color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;"];
  		var welcomeMessage = "You're running Ractive 0.7.3 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\n\nTo disable debug mode, add this line at the start of your app:\n  Ractive.DEBUG = false;\n\nTo disable debug mode when your app is minified, add this snippet:\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\n\nGet help and support:\n  http://docs.ractivejs.org\n  http://stackoverflow.com/questions/tagged/ractivejs\n  http://groups.google.com/forum/#!forum/ractive-js\n  http://twitter.com/ractivejs\n\nFound a bug? Raise an issue:\n  https://github.com/ractivejs/ractive/issues\n\n";

  		welcome = function () {
  			var hasGroup = !!console.groupCollapsed;
  			console[hasGroup ? "groupCollapsed" : "log"].apply(console, welcomeIntro);
  			console.log(welcomeMessage);
  			if (hasGroup) {
  				console.groupEnd(welcomeIntro);
  			}

  			welcome = noop;
  		};

  		printWarning = function (message, args) {
  			welcome();

  			// extract information about the instance this message pertains to, if applicable
  			if (typeof args[args.length - 1] === "object") {
  				var options = args.pop();
  				var ractive = options ? options.ractive : null;

  				if (ractive) {
  					// if this is an instance of a component that we know the name of, add
  					// it to the message
  					var _name = undefined;
  					if (ractive.component && (_name = ractive.component.name)) {
  						message = "<" + _name + "> " + message;
  					}

  					var node = undefined;
  					if (node = options.node || ractive.fragment && ractive.fragment.rendered && ractive.find("*")) {
  						args.push(node);
  					}
  				}
  			}

  			console.warn.apply(console, ["%cRactive.js: %c" + message, "color: rgb(114, 157, 52);", "color: rgb(85, 85, 85);"].concat(args));
  		};

  		log = function () {
  			console.log.apply(console, arguments);
  		};
  	})();
  } else {
  	printWarning = log = welcome = noop;
  }

  function format(message, args) {
  	return message.replace(/%s/g, function () {
  		return args.shift();
  	});
  }

  function fatal(message) {
  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		args[_key - 1] = arguments[_key];
  	}

  	message = format(message, args);
  	throw new Error(message);
  }

  function logIfDebug() {
  	if (_Ractive.DEBUG) {
  		log.apply(null, arguments);
  	}
  }

  function warn(message) {
  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		args[_key - 1] = arguments[_key];
  	}

  	message = format(message, args);
  	printWarning(message, args);
  }

  function warnOnce(message) {
  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		args[_key - 1] = arguments[_key];
  	}

  	message = format(message, args);

  	if (alreadyWarned[message]) {
  		return;
  	}

  	alreadyWarned[message] = true;
  	printWarning(message, args);
  }

  function warnIfDebug() {
  	if (_Ractive.DEBUG) {
  		warn.apply(null, arguments);
  	}
  }

  function warnOnceIfDebug() {
  	if (_Ractive.DEBUG) {
  		warnOnce.apply(null, arguments);
  	}
  }

  // Error messages that are used (or could be) in multiple places
  var badArguments = "Bad arguments";
  var noRegistryFunctionReturn = "A function was specified for \"%s\" %s, but no %s was returned";
  var missingPlugin = function (name, type) {
    return "Missing \"" + name + "\" " + type + " plugin. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#" + type + "s";
  };

  function findInViewHierarchy(registryName, ractive, name) {
  	var instance = findInstance(registryName, ractive, name);
  	return instance ? instance[registryName][name] : null;
  }

  function findInstance(registryName, ractive, name) {
  	while (ractive) {
  		if (name in ractive[registryName]) {
  			return ractive;
  		}

  		if (ractive.isolated) {
  			return null;
  		}

  		ractive = ractive.parent;
  	}
  }

  var interpolate = function (from, to, ractive, type) {
  	if (from === to) {
  		return snap(to);
  	}

  	if (type) {

  		var interpol = findInViewHierarchy("interpolators", ractive, type);
  		if (interpol) {
  			return interpol(from, to) || snap(to);
  		}

  		fatal(missingPlugin(type, "interpolator"));
  	}

  	return static_interpolators.number(from, to) || static_interpolators.array(from, to) || static_interpolators.object(from, to) || snap(to);
  };

  var shared_interpolate = interpolate;

  function snap(to) {
  	return function () {
  		return to;
  	};
  }

  var interpolators = {
  	number: function (from, to) {
  		var delta;

  		if (!is__isNumeric(from) || !is__isNumeric(to)) {
  			return null;
  		}

  		from = +from;
  		to = +to;

  		delta = to - from;

  		if (!delta) {
  			return function () {
  				return from;
  			};
  		}

  		return function (t) {
  			return from + t * delta;
  		};
  	},

  	array: function (from, to) {
  		var intermediate, interpolators, len, i;

  		if (!isArray(from) || !isArray(to)) {
  			return null;
  		}

  		intermediate = [];
  		interpolators = [];

  		i = len = Math.min(from.length, to.length);
  		while (i--) {
  			interpolators[i] = shared_interpolate(from[i], to[i]);
  		}

  		// surplus values - don't interpolate, but don't exclude them either
  		for (i = len; i < from.length; i += 1) {
  			intermediate[i] = from[i];
  		}

  		for (i = len; i < to.length; i += 1) {
  			intermediate[i] = to[i];
  		}

  		return function (t) {
  			var i = len;

  			while (i--) {
  				intermediate[i] = interpolators[i](t);
  			}

  			return intermediate;
  		};
  	},

  	object: function (from, to) {
  		var properties, len, interpolators, intermediate, prop;

  		if (!isObject(from) || !isObject(to)) {
  			return null;
  		}

  		properties = [];
  		intermediate = {};
  		interpolators = {};

  		for (prop in from) {
  			if (hasOwn.call(from, prop)) {
  				if (hasOwn.call(to, prop)) {
  					properties.push(prop);
  					interpolators[prop] = shared_interpolate(from[prop], to[prop]);
  				} else {
  					intermediate[prop] = from[prop];
  				}
  			}
  		}

  		for (prop in to) {
  			if (hasOwn.call(to, prop) && !hasOwn.call(from, prop)) {
  				intermediate[prop] = to[prop];
  			}
  		}

  		len = properties.length;

  		return function (t) {
  			var i = len,
  			    prop;

  			while (i--) {
  				prop = properties[i];

  				intermediate[prop] = interpolators[prop](t);
  			}

  			return intermediate;
  		};
  	}
  };

  var static_interpolators = interpolators;

  // This function takes a keypath such as 'foo.bar.baz', and returns
  // all the variants of that keypath that include a wildcard in place
  // of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
  // These are then checked against the dependants map (ractive.viewmodel.depsMap)
  // to see if any pattern observers are downstream of one or more of
  // these wildcard keypaths (e.g. 'foo.bar.*.status')
  var utils_getPotentialWildcardMatches = getPotentialWildcardMatches;

  var starMaps = {};
  function getPotentialWildcardMatches(keypath) {
  	var keys, starMap, mapper, i, result, wildcardKeypath;

  	keys = keypath.split(".");
  	if (!(starMap = starMaps[keys.length])) {
  		starMap = getStarMap(keys.length);
  	}

  	result = [];

  	mapper = function (star, i) {
  		return star ? "*" : keys[i];
  	};

  	i = starMap.length;
  	while (i--) {
  		wildcardKeypath = starMap[i].map(mapper).join(".");

  		if (!result.hasOwnProperty(wildcardKeypath)) {
  			result.push(wildcardKeypath);
  			result[wildcardKeypath] = true;
  		}
  	}

  	return result;
  }

  // This function returns all the possible true/false combinations for
  // a given number - e.g. for two, the possible combinations are
  // [ true, true ], [ true, false ], [ false, true ], [ false, false ].
  // It does so by getting all the binary values between 0 and e.g. 11
  function getStarMap(num) {
  	var ones = "",
  	    max,
  	    binary,
  	    starMap,
  	    mapper,
  	    i,
  	    j,
  	    l,
  	    map;

  	if (!starMaps[num]) {
  		starMap = [];

  		while (ones.length < num) {
  			ones += 1;
  		}

  		max = parseInt(ones, 2);

  		mapper = function (digit) {
  			return digit === "1";
  		};

  		for (i = 0; i <= max; i += 1) {
  			binary = i.toString(2);
  			while (binary.length < num) {
  				binary = "0" + binary;
  			}

  			map = [];
  			l = binary.length;
  			for (j = 0; j < l; j++) {
  				map.push(mapper(binary[j]));
  			}
  			starMap[i] = map;
  		}

  		starMaps[num] = starMap;
  	}

  	return starMaps[num];
  }

  var refPattern = /\[\s*(\*|[0-9]|[1-9][0-9]+)\s*\]/g;
  var patternPattern = /\*/;
  var keypathCache = {};

  var Keypath = function (str) {
  	var keys = str.split(".");

  	this.str = str;

  	if (str[0] === "@") {
  		this.isSpecial = true;
  		this.value = decodeKeypath(str);
  	}

  	this.firstKey = keys[0];
  	this.lastKey = keys.pop();

  	this.isPattern = patternPattern.test(str);

  	this.parent = str === "" ? null : getKeypath(keys.join("."));
  	this.isRoot = !str;
  };

  Keypath.prototype = {
  	equalsOrStartsWith: function (keypath) {
  		return keypath === this || this.startsWith(keypath);
  	},

  	join: function (str) {
  		return getKeypath(this.isRoot ? String(str) : this.str + "." + str);
  	},

  	replace: function (oldKeypath, newKeypath) {
  		if (this === oldKeypath) {
  			return newKeypath;
  		}

  		if (this.startsWith(oldKeypath)) {
  			return newKeypath === null ? newKeypath : getKeypath(this.str.replace(oldKeypath.str + ".", newKeypath.str + "."));
  		}
  	},

  	startsWith: function (keypath) {
  		if (!keypath) {
  			// TODO under what circumstances does this happen?
  			return false;
  		}

  		return keypath && this.str.substr(0, keypath.str.length + 1) === keypath.str + ".";
  	},

  	toString: function () {
  		throw new Error("Bad coercion");
  	},

  	valueOf: function () {
  		throw new Error("Bad coercion");
  	},

  	wildcardMatches: function () {
  		return this._wildcardMatches || (this._wildcardMatches = utils_getPotentialWildcardMatches(this.str));
  	}
  };
  function assignNewKeypath(target, property, oldKeypath, newKeypath) {
  	var existingKeypath = target[property];

  	if (existingKeypath && (existingKeypath.equalsOrStartsWith(newKeypath) || !existingKeypath.equalsOrStartsWith(oldKeypath))) {
  		return;
  	}

  	target[property] = existingKeypath ? existingKeypath.replace(oldKeypath, newKeypath) : newKeypath;
  	return true;
  }

  function decodeKeypath(keypath) {
  	var value = keypath.slice(2);

  	if (keypath[1] === "i") {
  		return is__isNumeric(value) ? +value : value;
  	} else {
  		return value;
  	}
  }

  function getKeypath(str) {
  	if (str == null) {
  		return str;
  	}

  	// TODO it *may* be worth having two versions of this function - one where
  	// keypathCache inherits from null, and one for IE8. Depends on how
  	// much of an overhead hasOwnProperty is - probably negligible
  	if (!keypathCache.hasOwnProperty(str)) {
  		keypathCache[str] = new Keypath(str);
  	}

  	return keypathCache[str];
  }

  function getMatchingKeypaths(ractive, keypath) {
  	var keys, key, matchingKeypaths;

  	keys = keypath.str.split(".");
  	matchingKeypaths = [rootKeypath];

  	while (key = keys.shift()) {
  		if (key === "*") {
  			// expand to find all valid child keypaths
  			matchingKeypaths = matchingKeypaths.reduce(expand, []);
  		} else {
  			if (matchingKeypaths[0] === rootKeypath) {
  				// first key
  				matchingKeypaths[0] = getKeypath(key);
  			} else {
  				matchingKeypaths = matchingKeypaths.map(concatenate(key));
  			}
  		}
  	}

  	return matchingKeypaths;

  	function expand(matchingKeypaths, keypath) {
  		var wrapper, value, keys;

  		if (keypath.isRoot) {
  			keys = [].concat(Object.keys(ractive.viewmodel.data), Object.keys(ractive.viewmodel.mappings), Object.keys(ractive.viewmodel.computations));
  		} else {
  			wrapper = ractive.viewmodel.wrapped[keypath.str];
  			value = wrapper ? wrapper.get() : ractive.viewmodel.get(keypath);

  			keys = value ? Object.keys(value) : null;
  		}

  		if (keys) {
  			keys.forEach(function (key) {
  				if (key !== "_ractive" || !isArray(value)) {
  					matchingKeypaths.push(keypath.join(key));
  				}
  			});
  		}

  		return matchingKeypaths;
  	}
  }

  function concatenate(key) {
  	return function (keypath) {
  		return keypath.join(key);
  	};
  }
  function normalise(ref) {
  	return ref ? ref.replace(refPattern, ".$1") : "";
  }

  var rootKeypath = getKeypath("");

  var shared_add = add;
  var shared_add__errorMessage = "Cannot add to a non-numeric value";
  function add(root, keypath, d) {
  	if (typeof keypath !== "string" || !is__isNumeric(d)) {
  		throw new Error("Bad arguments");
  	}

  	var value = undefined,
  	    changes = undefined;

  	if (/\*/.test(keypath)) {
  		changes = {};

  		getMatchingKeypaths(root, getKeypath(normalise(keypath))).forEach(function (keypath) {
  			var value = root.viewmodel.get(keypath);

  			if (!is__isNumeric(value)) {
  				throw new Error(shared_add__errorMessage);
  			}

  			changes[keypath.str] = value + d;
  		});

  		return root.set(changes);
  	}

  	value = root.get(keypath);

  	if (!is__isNumeric(value)) {
  		throw new Error(shared_add__errorMessage);
  	}

  	return root.set(keypath, +value + d);
  }

  var prototype_add = Ractive$add;
  function Ractive$add(keypath, d) {
  	return shared_add(this, keypath, d === undefined ? 1 : +d);
  }

  var requestAnimationFrame;

  // If window doesn't exist, we don't need requestAnimationFrame
  if (typeof window === "undefined") {
  	requestAnimationFrame = null;
  } else {
  	// https://gist.github.com/paulirish/1579671
  	(function (vendors, lastTime, window) {

  		var x, setTimeout;

  		if (window.requestAnimationFrame) {
  			return;
  		}

  		for (x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
  			window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
  		}

  		if (!window.requestAnimationFrame) {
  			setTimeout = window.setTimeout;

  			window.requestAnimationFrame = function (callback) {
  				var currTime, timeToCall, id;

  				currTime = Date.now();
  				timeToCall = Math.max(0, 16 - (currTime - lastTime));
  				id = setTimeout(function () {
  					callback(currTime + timeToCall);
  				}, timeToCall);

  				lastTime = currTime + timeToCall;
  				return id;
  			};
  		}
  	})(vendors, 0, window);

  	requestAnimationFrame = window.requestAnimationFrame;
  }

  var rAF = requestAnimationFrame;

  var getTime;

  if (typeof window !== "undefined" && window.performance && typeof window.performance.now === "function") {
  	getTime = function () {
  		return window.performance.now();
  	};
  } else {
  	getTime = function () {
  		return Date.now();
  	};
  }

  var utils_getTime = getTime;

  var deprecations = {
  	construct: {
  		deprecated: "beforeInit",
  		replacement: "onconstruct"
  	},
  	render: {
  		deprecated: "init",
  		message: "The \"init\" method has been deprecated " + "and will likely be removed in a future release. " + "You can either use the \"oninit\" method which will fire " + "only once prior to, and regardless of, any eventual ractive " + "instance being rendered, or if you need to access the " + "rendered DOM, use \"onrender\" instead. " + "See http://docs.ractivejs.org/latest/migrating for more information."
  	},
  	complete: {
  		deprecated: "complete",
  		replacement: "oncomplete"
  	}
  };

  function Hook(event) {
  	this.event = event;
  	this.method = "on" + event;
  	this.deprecate = deprecations[event];
  }

  Hook.prototype.fire = function (ractive, arg) {
  	function call(method) {
  		if (ractive[method]) {
  			arg ? ractive[method](arg) : ractive[method]();
  			return true;
  		}
  	}

  	call(this.method);

  	if (!ractive[this.method] && this.deprecate && call(this.deprecate.deprecated)) {
  		if (this.deprecate.message) {
  			warnIfDebug(this.deprecate.message);
  		} else {
  			warnIfDebug("The method \"%s\" has been deprecated in favor of \"%s\" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.", this.deprecate.deprecated, this.deprecate.replacement);
  		}
  	}

  	arg ? ractive.fire(this.event, arg) : ractive.fire(this.event);
  };

  var hooks_Hook = Hook;

  function addToArray(array, value) {
  	var index = array.indexOf(value);

  	if (index === -1) {
  		array.push(value);
  	}
  }

  function arrayContains(array, value) {
  	for (var i = 0, c = array.length; i < c; i++) {
  		if (array[i] == value) {
  			return true;
  		}
  	}

  	return false;
  }

  function arrayContentsMatch(a, b) {
  	var i;

  	if (!isArray(a) || !isArray(b)) {
  		return false;
  	}

  	if (a.length !== b.length) {
  		return false;
  	}

  	i = a.length;
  	while (i--) {
  		if (a[i] !== b[i]) {
  			return false;
  		}
  	}

  	return true;
  }

  function ensureArray(x) {
  	if (typeof x === "string") {
  		return [x];
  	}

  	if (x === undefined) {
  		return [];
  	}

  	return x;
  }

  function lastItem(array) {
  	return array[array.length - 1];
  }

  function removeFromArray(array, member) {
  	var index = array.indexOf(member);

  	if (index !== -1) {
  		array.splice(index, 1);
  	}
  }

  function toArray(arrayLike) {
  	var array = [],
  	    i = arrayLike.length;
  	while (i--) {
  		array[i] = arrayLike[i];
  	}

  	return array;
  }

  var _Promise,
      PENDING = {},
      FULFILLED = {},
      REJECTED = {};

  if (typeof Promise === "function") {
  	// use native Promise
  	_Promise = Promise;
  } else {
  	_Promise = function (callback) {
  		var fulfilledHandlers = [],
  		    rejectedHandlers = [],
  		    state = PENDING,
  		    result,
  		    dispatchHandlers,
  		    makeResolver,
  		    fulfil,
  		    reject,
  		    promise;

  		makeResolver = function (newState) {
  			return function (value) {
  				if (state !== PENDING) {
  					return;
  				}

  				result = value;
  				state = newState;

  				dispatchHandlers = makeDispatcher(state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result);

  				// dispatch onFulfilled and onRejected handlers asynchronously
  				wait(dispatchHandlers);
  			};
  		};

  		fulfil = makeResolver(FULFILLED);
  		reject = makeResolver(REJECTED);

  		try {
  			callback(fulfil, reject);
  		} catch (err) {
  			reject(err);
  		}

  		promise = {
  			// `then()` returns a Promise - 2.2.7
  			then: function (onFulfilled, onRejected) {
  				var promise2 = new _Promise(function (fulfil, reject) {

  					var processResolutionHandler = function (handler, handlers, forward) {

  						// 2.2.1.1
  						if (typeof handler === "function") {
  							handlers.push(function (p1result) {
  								var x;

  								try {
  									x = handler(p1result);
  									utils_Promise__resolve(promise2, x, fulfil, reject);
  								} catch (err) {
  									reject(err);
  								}
  							});
  						} else {
  							// Forward the result of promise1 to promise2, if resolution handlers
  							// are not given
  							handlers.push(forward);
  						}
  					};

  					// 2.2
  					processResolutionHandler(onFulfilled, fulfilledHandlers, fulfil);
  					processResolutionHandler(onRejected, rejectedHandlers, reject);

  					if (state !== PENDING) {
  						// If the promise has resolved already, dispatch the appropriate handlers asynchronously
  						wait(dispatchHandlers);
  					}
  				});

  				return promise2;
  			}
  		};

  		promise["catch"] = function (onRejected) {
  			return this.then(null, onRejected);
  		};

  		return promise;
  	};

  	_Promise.all = function (promises) {
  		return new _Promise(function (fulfil, reject) {
  			var result = [],
  			    pending,
  			    i,
  			    processPromise;

  			if (!promises.length) {
  				fulfil(result);
  				return;
  			}

  			processPromise = function (promise, i) {
  				if (promise && typeof promise.then === "function") {
  					promise.then(function (value) {
  						result[i] = value;
  						--pending || fulfil(result);
  					}, reject);
  				} else {
  					result[i] = promise;
  					--pending || fulfil(result);
  				}
  			};

  			pending = i = promises.length;
  			while (i--) {
  				processPromise(promises[i], i);
  			}
  		});
  	};

  	_Promise.resolve = function (value) {
  		return new _Promise(function (fulfil) {
  			fulfil(value);
  		});
  	};

  	_Promise.reject = function (reason) {
  		return new _Promise(function (fulfil, reject) {
  			reject(reason);
  		});
  	};
  }

  var utils_Promise = _Promise;

  // TODO use MutationObservers or something to simulate setImmediate
  function wait(callback) {
  	setTimeout(callback, 0);
  }

  function makeDispatcher(handlers, result) {
  	return function () {
  		var handler;

  		while (handler = handlers.shift()) {
  			handler(result);
  		}
  	};
  }

  function utils_Promise__resolve(promise, x, fulfil, reject) {
  	// Promise Resolution Procedure
  	var then;

  	// 2.3.1
  	if (x === promise) {
  		throw new TypeError("A promise's fulfillment handler cannot return the same promise");
  	}

  	// 2.3.2
  	if (x instanceof _Promise) {
  		x.then(fulfil, reject);
  	}

  	// 2.3.3
  	else if (x && (typeof x === "object" || typeof x === "function")) {
  		try {
  			then = x.then; // 2.3.3.1
  		} catch (e) {
  			reject(e); // 2.3.3.2
  			return;
  		}

  		// 2.3.3.3
  		if (typeof then === "function") {
  			var called, resolvePromise, rejectPromise;

  			resolvePromise = function (y) {
  				if (called) {
  					return;
  				}
  				called = true;
  				utils_Promise__resolve(promise, y, fulfil, reject);
  			};

  			rejectPromise = function (r) {
  				if (called) {
  					return;
  				}
  				called = true;
  				reject(r);
  			};

  			try {
  				then.call(x, resolvePromise, rejectPromise);
  			} catch (e) {
  				if (!called) {
  					// 2.3.3.3.4.1
  					reject(e); // 2.3.3.3.4.2
  					called = true;
  					return;
  				}
  			}
  		} else {
  			fulfil(x);
  		}
  	} else {
  		fulfil(x);
  	}
  }

  var getInnerContext = function (fragment) {
  	do {
  		if (fragment.context !== undefined) {
  			return fragment.context;
  		}
  	} while (fragment = fragment.parent);

  	return rootKeypath;
  };

  var shared_resolveRef = resolveRef;

  function resolveRef(ractive, ref, fragment) {
  	var keypath;

  	ref = normalise(ref);

  	// If a reference begins '~/', it's a top-level reference
  	if (ref.substr(0, 2) === "~/") {
  		keypath = getKeypath(ref.substring(2));
  		createMappingIfNecessary(ractive, keypath.firstKey, fragment);
  	}

  	// If a reference begins with '.', it's either a restricted reference or
  	// an ancestor reference...
  	else if (ref[0] === ".") {
  		keypath = resolveAncestorRef(getInnerContext(fragment), ref);

  		if (keypath) {
  			createMappingIfNecessary(ractive, keypath.firstKey, fragment);
  		}
  	}

  	// ...otherwise we need to figure out the keypath based on context
  	else {
  		keypath = resolveAmbiguousReference(ractive, getKeypath(ref), fragment);
  	}

  	return keypath;
  }

  function resolveAncestorRef(baseContext, ref) {
  	var contextKeys;

  	// TODO...
  	if (baseContext != undefined && typeof baseContext !== "string") {
  		baseContext = baseContext.str;
  	}

  	// {{.}} means 'current context'
  	if (ref === ".") return getKeypath(baseContext);

  	contextKeys = baseContext ? baseContext.split(".") : [];

  	// ancestor references (starting "../") go up the tree
  	if (ref.substr(0, 3) === "../") {
  		while (ref.substr(0, 3) === "../") {
  			if (!contextKeys.length) {
  				throw new Error("Could not resolve reference - too many \"../\" prefixes");
  			}

  			contextKeys.pop();
  			ref = ref.substring(3);
  		}

  		contextKeys.push(ref);
  		return getKeypath(contextKeys.join("."));
  	}

  	// not an ancestor reference - must be a restricted reference (prepended with "." or "./")
  	if (!baseContext) {
  		return getKeypath(ref.replace(/^\.\/?/, ""));
  	}

  	return getKeypath(baseContext + ref.replace(/^\.\//, "."));
  }

  function resolveAmbiguousReference(ractive, ref, fragment, isParentLookup) {
  	var context, key, parentValue, hasContextChain, parentKeypath;

  	if (ref.isRoot) {
  		return ref;
  	}

  	key = ref.firstKey;

  	while (fragment) {
  		context = fragment.context;
  		fragment = fragment.parent;

  		if (!context) {
  			continue;
  		}

  		hasContextChain = true;
  		parentValue = ractive.viewmodel.get(context);

  		if (parentValue && (typeof parentValue === "object" || typeof parentValue === "function") && key in parentValue) {
  			return context.join(ref.str);
  		}
  	}

  	// Root/computed/mapped property?
  	if (isRootProperty(ractive.viewmodel, key)) {
  		return ref;
  	}

  	// If this is an inline component, and it's not isolated, we
  	// can try going up the scope chain
  	if (ractive.parent && !ractive.isolated) {
  		hasContextChain = true;
  		fragment = ractive.component.parentFragment;

  		key = getKeypath(key);

  		if (parentKeypath = resolveAmbiguousReference(ractive.parent, key, fragment, true)) {
  			// We need to create an inter-component binding
  			ractive.viewmodel.map(key, {
  				origin: ractive.parent.viewmodel,
  				keypath: parentKeypath
  			});

  			return ref;
  		}
  	}

  	// If there's no context chain, and the instance is either a) isolated or
  	// b) an orphan, then we know that the keypath is identical to the reference
  	if (!isParentLookup && !hasContextChain) {
  		// the data object needs to have a property by this name,
  		// to prevent future failed lookups
  		ractive.viewmodel.set(ref, undefined);
  		return ref;
  	}
  }

  function createMappingIfNecessary(ractive, key) {
  	var parentKeypath;

  	if (!ractive.parent || ractive.isolated || isRootProperty(ractive.viewmodel, key)) {
  		return;
  	}

  	key = getKeypath(key);

  	if (parentKeypath = resolveAmbiguousReference(ractive.parent, key, ractive.component.parentFragment, true)) {
  		ractive.viewmodel.map(key, {
  			origin: ractive.parent.viewmodel,
  			keypath: parentKeypath
  		});
  	}
  }

  function isRootProperty(viewmodel, key) {
  	// special case for reference to root
  	return key === "" || key in viewmodel.data || key in viewmodel.computations || key in viewmodel.mappings;
  }

  function teardown(x) {
    x.teardown();
  }

  function methodCallers__unbind(x) {
    x.unbind();
  }

  function methodCallers__unrender(x) {
    x.unrender();
  }

  function cancel(x) {
    x.cancel();
  }

  var TransitionManager = function (callback, parent) {
  	this.callback = callback;
  	this.parent = parent;

  	this.intros = [];
  	this.outros = [];

  	this.children = [];
  	this.totalChildren = this.outroChildren = 0;

  	this.detachQueue = [];
  	this.decoratorQueue = [];
  	this.outrosComplete = false;

  	if (parent) {
  		parent.addChild(this);
  	}
  };

  TransitionManager.prototype = {
  	addChild: function (child) {
  		this.children.push(child);

  		this.totalChildren += 1;
  		this.outroChildren += 1;
  	},

  	decrementOutros: function () {
  		this.outroChildren -= 1;
  		check(this);
  	},

  	decrementTotal: function () {
  		this.totalChildren -= 1;
  		check(this);
  	},

  	add: function (transition) {
  		var list = transition.isIntro ? this.intros : this.outros;
  		list.push(transition);
  	},

  	addDecorator: function (decorator) {
  		this.decoratorQueue.push(decorator);
  	},

  	remove: function (transition) {
  		var list = transition.isIntro ? this.intros : this.outros;
  		removeFromArray(list, transition);
  		check(this);
  	},

  	init: function () {
  		this.ready = true;
  		check(this);
  	},

  	detachNodes: function () {
  		this.decoratorQueue.forEach(teardown);
  		this.detachQueue.forEach(detach);
  		this.children.forEach(detachNodes);
  	}
  };

  function detach(element) {
  	element.detach();
  }

  function detachNodes(tm) {
  	tm.detachNodes();
  }

  function check(tm) {
  	if (!tm.ready || tm.outros.length || tm.outroChildren) return;

  	// If all outros are complete, and we haven't already done this,
  	// we notify the parent if there is one, otherwise
  	// start detaching nodes
  	if (!tm.outrosComplete) {
  		if (tm.parent) {
  			tm.parent.decrementOutros(tm);
  		} else {
  			tm.detachNodes();
  		}

  		tm.outrosComplete = true;
  	}

  	// Once everything is done, we can notify parent transition
  	// manager and call the callback
  	if (!tm.intros.length && !tm.totalChildren) {
  		if (typeof tm.callback === "function") {
  			tm.callback();
  		}

  		if (tm.parent) {
  			tm.parent.decrementTotal();
  		}
  	}
  }

  var global_TransitionManager = TransitionManager;

  var batch,
      runloop,
      unresolved = [],
      changeHook = new hooks_Hook("change");

  runloop = {
  	start: function (instance, returnPromise) {
  		var promise, fulfilPromise;

  		if (returnPromise) {
  			promise = new utils_Promise(function (f) {
  				return fulfilPromise = f;
  			});
  		}

  		batch = {
  			previousBatch: batch,
  			transitionManager: new global_TransitionManager(fulfilPromise, batch && batch.transitionManager),
  			views: [],
  			tasks: [],
  			ractives: [],
  			instance: instance
  		};

  		if (instance) {
  			batch.ractives.push(instance);
  		}

  		return promise;
  	},

  	end: function () {
  		flushChanges();

  		batch.transitionManager.init();
  		if (!batch.previousBatch && !!batch.instance) batch.instance.viewmodel.changes = [];
  		batch = batch.previousBatch;
  	},

  	addRactive: function (ractive) {
  		if (batch) {
  			addToArray(batch.ractives, ractive);
  		}
  	},

  	registerTransition: function (transition) {
  		transition._manager = batch.transitionManager;
  		batch.transitionManager.add(transition);
  	},

  	registerDecorator: function (decorator) {
  		batch.transitionManager.addDecorator(decorator);
  	},

  	addView: function (view) {
  		batch.views.push(view);
  	},

  	addUnresolved: function (thing) {
  		unresolved.push(thing);
  	},

  	removeUnresolved: function (thing) {
  		removeFromArray(unresolved, thing);
  	},

  	// synchronise node detachments with transition ends
  	detachWhenReady: function (thing) {
  		batch.transitionManager.detachQueue.push(thing);
  	},

  	scheduleTask: function (task, postRender) {
  		var _batch;

  		if (!batch) {
  			task();
  		} else {
  			_batch = batch;
  			while (postRender && _batch.previousBatch) {
  				// this can't happen until the DOM has been fully updated
  				// otherwise in some situations (with components inside elements)
  				// transitions and decorators will initialise prematurely
  				_batch = _batch.previousBatch;
  			}

  			_batch.tasks.push(task);
  		}
  	}
  };

  var global_runloop = runloop;

  function flushChanges() {
  	var i, thing, changeHash;

  	while (batch.ractives.length) {
  		thing = batch.ractives.pop();
  		changeHash = thing.viewmodel.applyChanges();

  		if (changeHash) {
  			changeHook.fire(thing, changeHash);
  		}
  	}

  	attemptKeypathResolution();

  	// Now that changes have been fully propagated, we can update the DOM
  	// and complete other tasks
  	for (i = 0; i < batch.views.length; i += 1) {
  		batch.views[i].update();
  	}
  	batch.views.length = 0;

  	for (i = 0; i < batch.tasks.length; i += 1) {
  		batch.tasks[i]();
  	}
  	batch.tasks.length = 0;

  	// If updating the view caused some model blowback - e.g. a triple
  	// containing <option> elements caused the binding on the <select>
  	// to update - then we start over
  	if (batch.ractives.length) return flushChanges();
  }

  function attemptKeypathResolution() {
  	var i, item, keypath, resolved;

  	i = unresolved.length;

  	// see if we can resolve any unresolved references
  	while (i--) {
  		item = unresolved[i];

  		if (item.keypath) {
  			// it resolved some other way. TODO how? two-way binding? Seems
  			// weird that we'd still end up here
  			unresolved.splice(i, 1);
  			continue; // avoid removing the wrong thing should the next condition be true
  		}

  		if (keypath = shared_resolveRef(item.root, item.ref, item.parentFragment)) {
  			(resolved || (resolved = [])).push({
  				item: item,
  				keypath: keypath
  			});

  			unresolved.splice(i, 1);
  		}
  	}

  	if (resolved) {
  		resolved.forEach(global_runloop__resolve);
  	}
  }

  function global_runloop__resolve(resolved) {
  	resolved.item.resolve(resolved.keypath);
  }

  var queue = [];

  var animations = {
  	tick: function () {
  		var i, animation, now;

  		now = utils_getTime();

  		global_runloop.start();

  		for (i = 0; i < queue.length; i += 1) {
  			animation = queue[i];

  			if (!animation.tick(now)) {
  				// animation is complete, remove it from the stack, and decrement i so we don't miss one
  				queue.splice(i--, 1);
  			}
  		}

  		global_runloop.end();

  		if (queue.length) {
  			rAF(animations.tick);
  		} else {
  			animations.running = false;
  		}
  	},

  	add: function (animation) {
  		queue.push(animation);

  		if (!animations.running) {
  			animations.running = true;
  			rAF(animations.tick);
  		}
  	},

  	// TODO optimise this
  	abort: function (keypath, root) {
  		var i = queue.length,
  		    animation;

  		while (i--) {
  			animation = queue[i];

  			if (animation.root === root && animation.keypath === keypath) {
  				animation.stop();
  			}
  		}
  	}
  };

  var shared_animations = animations;

  var Animation = function (options) {
  	var key;

  	this.startTime = Date.now();

  	// from and to
  	for (key in options) {
  		if (options.hasOwnProperty(key)) {
  			this[key] = options[key];
  		}
  	}

  	this.interpolator = shared_interpolate(this.from, this.to, this.root, this.interpolator);
  	this.running = true;

  	this.tick();
  };

  Animation.prototype = {
  	tick: function () {
  		var elapsed, t, value, timeNow, index, keypath;

  		keypath = this.keypath;

  		if (this.running) {
  			timeNow = Date.now();
  			elapsed = timeNow - this.startTime;

  			if (elapsed >= this.duration) {
  				if (keypath !== null) {
  					global_runloop.start(this.root);
  					this.root.viewmodel.set(keypath, this.to);
  					global_runloop.end();
  				}

  				if (this.step) {
  					this.step(1, this.to);
  				}

  				this.complete(this.to);

  				index = this.root._animations.indexOf(this);

  				// TODO investigate why this happens
  				if (index === -1) {
  					warnIfDebug("Animation was not found");
  				}

  				this.root._animations.splice(index, 1);

  				this.running = false;
  				return false; // remove from the stack
  			}

  			t = this.easing ? this.easing(elapsed / this.duration) : elapsed / this.duration;

  			if (keypath !== null) {
  				value = this.interpolator(t);
  				global_runloop.start(this.root);
  				this.root.viewmodel.set(keypath, value);
  				global_runloop.end();
  			}

  			if (this.step) {
  				this.step(t, value);
  			}

  			return true; // keep in the stack
  		}

  		return false; // remove from the stack
  	},

  	stop: function () {
  		var index;

  		this.running = false;

  		index = this.root._animations.indexOf(this);

  		// TODO investigate why this happens
  		if (index === -1) {
  			warnIfDebug("Animation was not found");
  		}

  		this.root._animations.splice(index, 1);
  	}
  };

  var animate_Animation = Animation;

  var prototype_animate = Ractive$animate;

  var noAnimation = { stop: noop };
  function Ractive$animate(keypath, to, options) {
  	var promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;

  	promise = new utils_Promise(function (fulfil) {
  		return fulfilPromise = fulfil;
  	});

  	// animate multiple keypaths
  	if (typeof keypath === "object") {
  		options = to || {};
  		easing = options.easing;
  		duration = options.duration;

  		animations = [];

  		// we don't want to pass the `step` and `complete` handlers, as they will
  		// run for each animation! So instead we'll store the handlers and create
  		// our own...
  		step = options.step;
  		complete = options.complete;

  		if (step || complete) {
  			currentValues = {};

  			options.step = null;
  			options.complete = null;

  			makeValueCollector = function (keypath) {
  				return function (t, value) {
  					currentValues[keypath] = value;
  				};
  			};
  		}

  		for (k in keypath) {
  			if (keypath.hasOwnProperty(k)) {
  				if (step || complete) {
  					collectValue = makeValueCollector(k);
  					options = { easing: easing, duration: duration };

  					if (step) {
  						options.step = collectValue;
  					}
  				}

  				options.complete = complete ? collectValue : noop;
  				animations.push(animate(this, k, keypath[k], options));
  			}
  		}

  		// Create a dummy animation, to facilitate step/complete
  		// callbacks, and Promise fulfilment
  		dummyOptions = { easing: easing, duration: duration };

  		if (step) {
  			dummyOptions.step = function (t) {
  				return step(t, currentValues);
  			};
  		}

  		if (complete) {
  			promise.then(function (t) {
  				return complete(t, currentValues);
  			});
  		}

  		dummyOptions.complete = fulfilPromise;

  		dummy = animate(this, null, null, dummyOptions);
  		animations.push(dummy);

  		promise.stop = function () {
  			var animation;

  			while (animation = animations.pop()) {
  				animation.stop();
  			}

  			if (dummy) {
  				dummy.stop();
  			}
  		};

  		return promise;
  	}

  	// animate a single keypath
  	options = options || {};

  	if (options.complete) {
  		promise.then(options.complete);
  	}

  	options.complete = fulfilPromise;
  	animation = animate(this, keypath, to, options);

  	promise.stop = function () {
  		return animation.stop();
  	};
  	return promise;
  }

  function animate(root, keypath, to, options) {
  	var easing, duration, animation, from;

  	if (keypath) {
  		keypath = getKeypath(normalise(keypath));
  	}

  	if (keypath !== null) {
  		from = root.viewmodel.get(keypath);
  	}

  	// cancel any existing animation
  	// TODO what about upstream/downstream keypaths?
  	shared_animations.abort(keypath, root);

  	// don't bother animating values that stay the same
  	if (isEqual(from, to)) {
  		if (options.complete) {
  			options.complete(options.to);
  		}

  		return noAnimation;
  	}

  	// easing function
  	if (options.easing) {
  		if (typeof options.easing === "function") {
  			easing = options.easing;
  		} else {
  			easing = root.easing[options.easing];
  		}

  		if (typeof easing !== "function") {
  			easing = null;
  		}
  	}

  	// duration
  	duration = options.duration === undefined ? 400 : options.duration;

  	// TODO store keys, use an internal set method
  	animation = new animate_Animation({
  		keypath: keypath,
  		from: from,
  		to: to,
  		root: root,
  		duration: duration,
  		easing: easing,
  		interpolator: options.interpolator,

  		// TODO wrap callbacks if necessary, to use instance as context
  		step: options.step,
  		complete: options.complete
  	});

  	shared_animations.add(animation);
  	root._animations.push(animation);

  	return animation;
  }

  var prototype_detach = Ractive$detach;
  var prototype_detach__detachHook = new hooks_Hook("detach");
  function Ractive$detach() {
  	if (this.detached) {
  		return this.detached;
  	}

  	if (this.el) {
  		removeFromArray(this.el.__ractive_instances__, this);
  	}
  	this.detached = this.fragment.detach();
  	prototype_detach__detachHook.fire(this);
  	return this.detached;
  }

  var prototype_find = Ractive$find;

  function Ractive$find(selector) {
  	if (!this.el) {
  		return null;
  	}

  	return this.fragment.find(selector);
  }

  var test = Query$test;
  function Query$test(item, noDirty) {
  	var itemMatches;

  	if (this._isComponentQuery) {
  		itemMatches = !this.selector || item.name === this.selector;
  	} else {
  		itemMatches = item.node ? matches(item.node, this.selector) : null;
  	}

  	if (itemMatches) {
  		this.push(item.node || item.instance);

  		if (!noDirty) {
  			this._makeDirty();
  		}

  		return true;
  	}
  }

  var makeQuery_cancel = function () {
  	var liveQueries, selector, index;

  	liveQueries = this._root[this._isComponentQuery ? "liveComponentQueries" : "liveQueries"];
  	selector = this.selector;

  	index = liveQueries.indexOf(selector);

  	if (index !== -1) {
  		liveQueries.splice(index, 1);
  		liveQueries[selector] = null;
  	}
  };

  var sortByItemPosition = function (a, b) {
  	var ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;

  	ancestryA = getAncestry(a.component || a._ractive.proxy);
  	ancestryB = getAncestry(b.component || b._ractive.proxy);

  	oldestA = lastItem(ancestryA);
  	oldestB = lastItem(ancestryB);

  	// remove items from the end of both ancestries as long as they are identical
  	// - the final one removed is the closest mutual ancestor
  	while (oldestA && oldestA === oldestB) {
  		ancestryA.pop();
  		ancestryB.pop();

  		mutualAncestor = oldestA;

  		oldestA = lastItem(ancestryA);
  		oldestB = lastItem(ancestryB);
  	}

  	// now that we have the mutual ancestor, we can find which is earliest
  	oldestA = oldestA.component || oldestA;
  	oldestB = oldestB.component || oldestB;

  	fragmentA = oldestA.parentFragment;
  	fragmentB = oldestB.parentFragment;

  	// if both items share a parent fragment, our job is easy
  	if (fragmentA === fragmentB) {
  		indexA = fragmentA.items.indexOf(oldestA);
  		indexB = fragmentB.items.indexOf(oldestB);

  		// if it's the same index, it means one contains the other,
  		// so we see which has the longest ancestry
  		return indexA - indexB || ancestryA.length - ancestryB.length;
  	}

  	// if mutual ancestor is a section, we first test to see which section
  	// fragment comes first
  	if (fragments = mutualAncestor.fragments) {
  		indexA = fragments.indexOf(fragmentA);
  		indexB = fragments.indexOf(fragmentB);

  		return indexA - indexB || ancestryA.length - ancestryB.length;
  	}

  	throw new Error("An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!");
  };

  function getParent(item) {
  	var parentFragment;

  	if (parentFragment = item.parentFragment) {
  		return parentFragment.owner;
  	}

  	if (item.component && (parentFragment = item.component.parentFragment)) {
  		return parentFragment.owner;
  	}
  }

  function getAncestry(item) {
  	var ancestry, ancestor;

  	ancestry = [item];

  	ancestor = getParent(item);

  	while (ancestor) {
  		ancestry.push(ancestor);
  		ancestor = getParent(ancestor);
  	}

  	return ancestry;
  }

  var sortByDocumentPosition = function (node, otherNode) {
  	var bitmask;

  	if (node.compareDocumentPosition) {
  		bitmask = node.compareDocumentPosition(otherNode);
  		return bitmask & 2 ? 1 : -1;
  	}

  	// In old IE, we can piggy back on the mechanism for
  	// comparing component positions
  	return sortByItemPosition(node, otherNode);
  };

  var sort = function () {
  	this.sort(this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition);
  	this._dirty = false;
  };

  var makeQuery_dirty = function () {
  	var _this = this;

  	if (!this._dirty) {
  		this._dirty = true;

  		// Once the DOM has been updated, ensure the query
  		// is correctly ordered
  		global_runloop.scheduleTask(function () {
  			_this._sort();
  		});
  	}
  };

  var remove = function (nodeOrComponent) {
  	var index = this.indexOf(this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent);

  	if (index !== -1) {
  		this.splice(index, 1);
  	}
  };

  var _makeQuery = makeQuery;
  function makeQuery(ractive, selector, live, isComponentQuery) {
  	var query = [];

  	defineProperties(query, {
  		selector: { value: selector },
  		live: { value: live },

  		_isComponentQuery: { value: isComponentQuery },
  		_test: { value: test }
  	});

  	if (!live) {
  		return query;
  	}

  	defineProperties(query, {
  		cancel: { value: makeQuery_cancel },

  		_root: { value: ractive },
  		_sort: { value: sort },
  		_makeDirty: { value: makeQuery_dirty },
  		_remove: { value: remove },

  		_dirty: { value: false, writable: true }
  	});

  	return query;
  }

  var prototype_findAll = Ractive$findAll;
  function Ractive$findAll(selector, options) {
  	var liveQueries, query;

  	if (!this.el) {
  		return [];
  	}

  	options = options || {};
  	liveQueries = this._liveQueries;

  	// Shortcut: if we're maintaining a live query with this
  	// selector, we don't need to traverse the parallel DOM
  	if (query = liveQueries[selector]) {

  		// Either return the exact same query, or (if not live) a snapshot
  		return options && options.live ? query : query.slice();
  	}

  	query = _makeQuery(this, selector, !!options.live, false);

  	// Add this to the list of live queries Ractive needs to maintain,
  	// if applicable
  	if (query.live) {
  		liveQueries.push(selector);
  		liveQueries["_" + selector] = query;
  	}

  	this.fragment.findAll(selector, query);
  	return query;
  }

  var prototype_findAllComponents = Ractive$findAllComponents;
  function Ractive$findAllComponents(selector, options) {
  	var liveQueries, query;

  	options = options || {};
  	liveQueries = this._liveComponentQueries;

  	// Shortcut: if we're maintaining a live query with this
  	// selector, we don't need to traverse the parallel DOM
  	if (query = liveQueries[selector]) {

  		// Either return the exact same query, or (if not live) a snapshot
  		return options && options.live ? query : query.slice();
  	}

  	query = _makeQuery(this, selector, !!options.live, true);

  	// Add this to the list of live queries Ractive needs to maintain,
  	// if applicable
  	if (query.live) {
  		liveQueries.push(selector);
  		liveQueries["_" + selector] = query;
  	}

  	this.fragment.findAllComponents(selector, query);
  	return query;
  }

  var prototype_findComponent = Ractive$findComponent;

  function Ractive$findComponent(selector) {
  	return this.fragment.findComponent(selector);
  }

  var findContainer = Ractive$findContainer;

  function Ractive$findContainer(selector) {
  	if (this.container) {
  		if (this.container.component && this.container.component.name === selector) {
  			return this.container;
  		} else {
  			return this.container.findContainer(selector);
  		}
  	}

  	return null;
  }

  var findParent = Ractive$findParent;

  function Ractive$findParent(selector) {

  	if (this.parent) {
  		if (this.parent.component && this.parent.component.name === selector) {
  			return this.parent;
  		} else {
  			return this.parent.findParent(selector);
  		}
  	}

  	return null;
  }

  var eventStack = {
  	enqueue: function (ractive, event) {
  		if (ractive.event) {
  			ractive._eventQueue = ractive._eventQueue || [];
  			ractive._eventQueue.push(ractive.event);
  		}
  		ractive.event = event;
  	},
  	dequeue: function (ractive) {
  		if (ractive._eventQueue && ractive._eventQueue.length) {
  			ractive.event = ractive._eventQueue.pop();
  		} else {
  			delete ractive.event;
  		}
  	}
  };

  var shared_eventStack = eventStack;

  var shared_fireEvent = fireEvent;

  function fireEvent(ractive, eventName) {
  	var options = arguments[2] === undefined ? {} : arguments[2];

  	if (!eventName) {
  		return;
  	}

  	if (!options.event) {
  		options.event = {
  			name: eventName,
  			// until event not included as argument default
  			_noArg: true
  		};
  	} else {
  		options.event.name = eventName;
  	}

  	var eventNames = getKeypath(eventName).wildcardMatches();
  	fireEventAs(ractive, eventNames, options.event, options.args, true);
  }

  function fireEventAs(ractive, eventNames, event, args) {
  	var initialFire = arguments[4] === undefined ? false : arguments[4];

  	var subscribers,
  	    i,
  	    bubble = true;

  	shared_eventStack.enqueue(ractive, event);

  	for (i = eventNames.length; i >= 0; i--) {
  		subscribers = ractive._subs[eventNames[i]];

  		if (subscribers) {
  			bubble = notifySubscribers(ractive, subscribers, event, args) && bubble;
  		}
  	}

  	shared_eventStack.dequeue(ractive);

  	if (ractive.parent && bubble) {

  		if (initialFire && ractive.component) {
  			var fullName = ractive.component.name + "." + eventNames[eventNames.length - 1];
  			eventNames = getKeypath(fullName).wildcardMatches();

  			if (event) {
  				event.component = ractive;
  			}
  		}

  		fireEventAs(ractive.parent, eventNames, event, args);
  	}
  }

  function notifySubscribers(ractive, subscribers, event, args) {
  	var originalEvent = null,
  	    stopEvent = false;

  	if (event && !event._noArg) {
  		args = [event].concat(args);
  	}

  	// subscribers can be modified inflight, e.g. "once" functionality
  	// so we need to copy to make sure everyone gets called
  	subscribers = subscribers.slice();

  	for (var i = 0, len = subscribers.length; i < len; i += 1) {
  		if (subscribers[i].apply(ractive, args) === false) {
  			stopEvent = true;
  		}
  	}

  	if (event && !event._noArg && stopEvent && (originalEvent = event.original)) {
  		originalEvent.preventDefault && originalEvent.preventDefault();
  		originalEvent.stopPropagation && originalEvent.stopPropagation();
  	}

  	return !stopEvent;
  }

  var prototype_fire = Ractive$fire;
  function Ractive$fire(eventName) {

  	var options = {
  		args: Array.prototype.slice.call(arguments, 1)
  	};

  	shared_fireEvent(this, eventName, options);
  }

  var prototype_get = Ractive$get;
  var options = {
  	capture: true, // top-level calls should be intercepted
  	noUnwrap: true, // wrapped values should NOT be unwrapped
  	fullRootGet: true // root get should return mappings
  };
  function Ractive$get(keypath) {
  	var value;

  	keypath = getKeypath(normalise(keypath));
  	value = this.viewmodel.get(keypath, options);

  	// Create inter-component binding, if necessary
  	if (value === undefined && this.parent && !this.isolated) {
  		if (shared_resolveRef(this, keypath.str, this.component.parentFragment)) {
  			// creates binding as side-effect, if appropriate
  			value = this.viewmodel.get(keypath);
  		}
  	}

  	return value;
  }

  var insert = Ractive$insert;

  var insertHook = new hooks_Hook("insert");
  function Ractive$insert(target, anchor) {
  	if (!this.fragment.rendered) {
  		// TODO create, and link to, documentation explaining this
  		throw new Error("The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.");
  	}

  	target = getElement(target);
  	anchor = getElement(anchor) || null;

  	if (!target) {
  		throw new Error("You must specify a valid target to insert into");
  	}

  	target.insertBefore(this.detach(), anchor);
  	this.el = target;

  	(target.__ractive_instances__ || (target.__ractive_instances__ = [])).push(this);
  	this.detached = null;

  	fireInsertHook(this);
  }

  function fireInsertHook(ractive) {
  	insertHook.fire(ractive);

  	ractive.findAllComponents("*").forEach(function (child) {
  		fireInsertHook(child.instance);
  	});
  }

  var prototype_merge = Ractive$merge;
  function Ractive$merge(keypath, array, options) {
  	var currentArray, promise;

  	keypath = getKeypath(normalise(keypath));
  	currentArray = this.viewmodel.get(keypath);

  	// If either the existing value or the new value isn't an
  	// array, just do a regular set
  	if (!isArray(currentArray) || !isArray(array)) {
  		return this.set(keypath, array, options && options.complete);
  	}

  	// Manage transitions
  	promise = global_runloop.start(this, true);
  	this.viewmodel.merge(keypath, currentArray, array, options);
  	global_runloop.end();

  	return promise;
  }

  var Observer = function (ractive, keypath, callback, options) {
  	this.root = ractive;
  	this.keypath = keypath;
  	this.callback = callback;
  	this.defer = options.defer;

  	// default to root as context, but allow it to be overridden
  	this.context = options && options.context ? options.context : ractive;
  };

  Observer.prototype = {
  	init: function (immediate) {
  		this.value = this.root.get(this.keypath.str);

  		if (immediate !== false) {
  			this.update();
  		} else {
  			this.oldValue = this.value;
  		}
  	},

  	setValue: function (value) {
  		var _this = this;

  		if (!isEqual(value, this.value)) {
  			this.value = value;

  			if (this.defer && this.ready) {
  				global_runloop.scheduleTask(function () {
  					return _this.update();
  				});
  			} else {
  				this.update();
  			}
  		}
  	},

  	update: function () {
  		// Prevent infinite loops
  		if (this.updating) {
  			return;
  		}

  		this.updating = true;

  		this.callback.call(this.context, this.value, this.oldValue, this.keypath.str);
  		this.oldValue = this.value;

  		this.updating = false;
  	}
  };

  var observe_Observer = Observer;

  var observe_getPattern = getPattern;
  function getPattern(ractive, pattern) {
  	var matchingKeypaths, values;

  	matchingKeypaths = getMatchingKeypaths(ractive, pattern);

  	values = {};
  	matchingKeypaths.forEach(function (keypath) {
  		values[keypath.str] = ractive.get(keypath.str);
  	});

  	return values;
  }

  var PatternObserver,
      slice = Array.prototype.slice;

  PatternObserver = function (ractive, keypath, callback, options) {
  	this.root = ractive;

  	this.callback = callback;
  	this.defer = options.defer;

  	this.keypath = keypath;
  	this.regex = new RegExp("^" + keypath.str.replace(/\./g, "\\.").replace(/\*/g, "([^\\.]+)") + "$");
  	this.values = {};

  	if (this.defer) {
  		this.proxies = [];
  	}

  	// default to root as context, but allow it to be overridden
  	this.context = options && options.context ? options.context : ractive;
  };

  PatternObserver.prototype = {
  	init: function (immediate) {
  		var values, keypath;

  		values = observe_getPattern(this.root, this.keypath);

  		if (immediate !== false) {
  			for (keypath in values) {
  				if (values.hasOwnProperty(keypath)) {
  					this.update(getKeypath(keypath));
  				}
  			}
  		} else {
  			this.values = values;
  		}
  	},

  	update: function (keypath) {
  		var _this = this;

  		var values;

  		if (keypath.isPattern) {
  			values = observe_getPattern(this.root, keypath);

  			for (keypath in values) {
  				if (values.hasOwnProperty(keypath)) {
  					this.update(getKeypath(keypath));
  				}
  			}

  			return;
  		}

  		// special case - array mutation should not trigger `array.*`
  		// pattern observer with `array.length`
  		if (this.root.viewmodel.implicitChanges[keypath.str]) {
  			return;
  		}

  		if (this.defer && this.ready) {
  			global_runloop.scheduleTask(function () {
  				return _this.getProxy(keypath).update();
  			});
  			return;
  		}

  		this.reallyUpdate(keypath);
  	},

  	reallyUpdate: function (keypath) {
  		var keypathStr, value, keys, args;

  		keypathStr = keypath.str;
  		value = this.root.viewmodel.get(keypath);

  		// Prevent infinite loops
  		if (this.updating) {
  			this.values[keypathStr] = value;
  			return;
  		}

  		this.updating = true;

  		if (!isEqual(value, this.values[keypathStr]) || !this.ready) {
  			keys = slice.call(this.regex.exec(keypathStr), 1);
  			args = [value, this.values[keypathStr], keypathStr].concat(keys);

  			this.values[keypathStr] = value;
  			this.callback.apply(this.context, args);
  		}

  		this.updating = false;
  	},

  	getProxy: function (keypath) {
  		var _this = this;

  		if (!this.proxies[keypath.str]) {
  			this.proxies[keypath.str] = {
  				update: function () {
  					return _this.reallyUpdate(keypath);
  				}
  			};
  		}

  		return this.proxies[keypath.str];
  	}
  };

  var observe_PatternObserver = PatternObserver;

  var observe_getObserverFacade = getObserverFacade;
  var emptyObject = {};
  function getObserverFacade(ractive, keypath, callback, options) {
  	var observer, isPatternObserver, cancelled;

  	keypath = getKeypath(normalise(keypath));
  	options = options || emptyObject;

  	// pattern observers are treated differently
  	if (keypath.isPattern) {
  		observer = new observe_PatternObserver(ractive, keypath, callback, options);
  		ractive.viewmodel.patternObservers.push(observer);
  		isPatternObserver = true;
  	} else {
  		observer = new observe_Observer(ractive, keypath, callback, options);
  	}

  	observer.init(options.init);
  	ractive.viewmodel.register(keypath, observer, isPatternObserver ? "patternObservers" : "observers");

  	// This flag allows observers to initialise even with undefined values
  	observer.ready = true;

  	var facade = {
  		cancel: function () {
  			var index;

  			if (cancelled) {
  				return;
  			}

  			if (isPatternObserver) {
  				index = ractive.viewmodel.patternObservers.indexOf(observer);

  				ractive.viewmodel.patternObservers.splice(index, 1);
  				ractive.viewmodel.unregister(keypath, observer, "patternObservers");
  			} else {
  				ractive.viewmodel.unregister(keypath, observer, "observers");
  			}
  			cancelled = true;
  		}
  	};

  	ractive._observers.push(facade);
  	return facade;
  }

  var observe = Ractive$observe;
  function Ractive$observe(keypath, callback, options) {

  	var observers, map, keypaths, i;

  	// Allow a map of keypaths to handlers
  	if (isObject(keypath)) {
  		options = callback;
  		map = keypath;

  		observers = [];

  		for (keypath in map) {
  			if (map.hasOwnProperty(keypath)) {
  				callback = map[keypath];
  				observers.push(this.observe(keypath, callback, options));
  			}
  		}

  		return {
  			cancel: function () {
  				while (observers.length) {
  					observers.pop().cancel();
  				}
  			}
  		};
  	}

  	// Allow `ractive.observe( callback )` - i.e. observe entire model
  	if (typeof keypath === "function") {
  		options = callback;
  		callback = keypath;
  		keypath = "";

  		return observe_getObserverFacade(this, keypath, callback, options);
  	}

  	keypaths = keypath.split(" ");

  	// Single keypath
  	if (keypaths.length === 1) {
  		return observe_getObserverFacade(this, keypath, callback, options);
  	}

  	// Multiple space-separated keypaths
  	observers = [];

  	i = keypaths.length;
  	while (i--) {
  		keypath = keypaths[i];

  		if (keypath) {
  			observers.push(observe_getObserverFacade(this, keypath, callback, options));
  		}
  	}

  	return {
  		cancel: function () {
  			while (observers.length) {
  				observers.pop().cancel();
  			}
  		}
  	};
  }

  var observeOnce = Ractive$observeOnce;

  function Ractive$observeOnce(property, callback, options) {

  	var observer = this.observe(property, function () {
  		callback.apply(this, arguments);
  		observer.cancel();
  	}, { init: false, defer: options && options.defer });

  	return observer;
  }

  var shared_trim = function (str) {
    return str.trim();
  };

  var notEmptyString = function (str) {
    return str !== "";
  };

  var off = Ractive$off;
  function Ractive$off(eventName, callback) {
  	var _this = this;

  	var eventNames;

  	// if no arguments specified, remove all callbacks
  	if (!eventName) {
  		// TODO use this code instead, once the following issue has been resolved
  		// in PhantomJS (tests are unpassable otherwise!)
  		// https://github.com/ariya/phantomjs/issues/11856
  		// defineProperty( this, '_subs', { value: create( null ), configurable: true });
  		for (eventName in this._subs) {
  			delete this._subs[eventName];
  		}
  	} else {
  		// Handle multiple space-separated event names
  		eventNames = eventName.split(" ").map(shared_trim).filter(notEmptyString);

  		eventNames.forEach(function (eventName) {
  			var subscribers, index;

  			// If we have subscribers for this event...
  			if (subscribers = _this._subs[eventName]) {
  				// ...if a callback was specified, only remove that
  				if (callback) {
  					index = subscribers.indexOf(callback);
  					if (index !== -1) {
  						subscribers.splice(index, 1);
  					}
  				}

  				// ...otherwise remove all callbacks
  				else {
  					_this._subs[eventName] = [];
  				}
  			}
  		});
  	}

  	return this;
  }

  var on = Ractive$on;
  function Ractive$on(eventName, callback) {
  	var _this = this;

  	var listeners, n, eventNames;

  	// allow mutliple listeners to be bound in one go
  	if (typeof eventName === "object") {
  		listeners = [];

  		for (n in eventName) {
  			if (eventName.hasOwnProperty(n)) {
  				listeners.push(this.on(n, eventName[n]));
  			}
  		}

  		return {
  			cancel: function () {
  				var listener;

  				while (listener = listeners.pop()) {
  					listener.cancel();
  				}
  			}
  		};
  	}

  	// Handle multiple space-separated event names
  	eventNames = eventName.split(" ").map(shared_trim).filter(notEmptyString);

  	eventNames.forEach(function (eventName) {
  		(_this._subs[eventName] || (_this._subs[eventName] = [])).push(callback);
  	});

  	return {
  		cancel: function () {
  			return _this.off(eventName, callback);
  		}
  	};
  }

  var once = Ractive$once;

  function Ractive$once(eventName, handler) {

  	var listener = this.on(eventName, function () {
  		handler.apply(this, arguments);
  		listener.cancel();
  	});

  	// so we can still do listener.cancel() manually
  	return listener;
  }

  // This function takes an array, the name of a mutator method, and the
  // arguments to call that mutator method with, and returns an array that
  // maps the old indices to their new indices.

  // So if you had something like this...
  //
  //     array = [ 'a', 'b', 'c', 'd' ];
  //     array.push( 'e' );
  //
  // ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices
  // have changed. If you then did this...
  //
  //     array.unshift( 'z' );
  //
  // ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved
  // one higher to make room for the 'z'. If you removed an item, the new index
  // would be -1...
  //
  //     array.splice( 2, 2 );
  //
  // ...this would result in [ 0, 1, -1, -1, 2, 3 ].
  //
  // This information is used to enable fast, non-destructive shuffling of list
  // sections when you do e.g. `ractive.splice( 'items', 2, 2 );

  var shared_getNewIndices = getNewIndices;

  function getNewIndices(array, methodName, args) {
  	var spliceArguments,
  	    len,
  	    newIndices = [],
  	    removeStart,
  	    removeEnd,
  	    balance,
  	    i;

  	spliceArguments = getSpliceEquivalent(array, methodName, args);

  	if (!spliceArguments) {
  		return null; // TODO support reverse and sort?
  	}

  	len = array.length;
  	balance = spliceArguments.length - 2 - spliceArguments[1];

  	removeStart = Math.min(len, spliceArguments[0]);
  	removeEnd = removeStart + spliceArguments[1];

  	for (i = 0; i < removeStart; i += 1) {
  		newIndices.push(i);
  	}

  	for (; i < removeEnd; i += 1) {
  		newIndices.push(-1);
  	}

  	for (; i < len; i += 1) {
  		newIndices.push(i + balance);
  	}

  	// there is a net shift for the rest of the array starting with index + balance
  	if (balance !== 0) {
  		newIndices.touchedFrom = spliceArguments[0];
  	} else {
  		newIndices.touchedFrom = array.length;
  	}

  	return newIndices;
  }

  // The pop, push, shift an unshift methods can all be represented
  // as an equivalent splice
  function getSpliceEquivalent(array, methodName, args) {
  	switch (methodName) {
  		case "splice":
  			if (args[0] !== undefined && args[0] < 0) {
  				args[0] = array.length + Math.max(args[0], -array.length);
  			}

  			while (args.length < 2) {
  				args.push(0);
  			}

  			// ensure we only remove elements that exist
  			args[1] = Math.min(args[1], array.length - args[0]);

  			return args;

  		case "sort":
  		case "reverse":
  			return null;

  		case "pop":
  			if (array.length) {
  				return [array.length - 1, 1];
  			}
  			return [0, 0];

  		case "push":
  			return [array.length, 0].concat(args);

  		case "shift":
  			return [0, array.length ? 1 : 0];

  		case "unshift":
  			return [0, 0].concat(args);
  	}
  }

  var arrayProto = Array.prototype;

  var makeArrayMethod = function (methodName) {
  	return function (keypath) {
  		for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  			args[_key - 1] = arguments[_key];
  		}

  		var array,
  		    newIndices = [],
  		    len,
  		    promise,
  		    result;

  		keypath = getKeypath(normalise(keypath));

  		array = this.viewmodel.get(keypath);
  		len = array.length;

  		if (!isArray(array)) {
  			throw new Error("Called ractive." + methodName + "('" + keypath.str + "'), but '" + keypath.str + "' does not refer to an array");
  		}

  		newIndices = shared_getNewIndices(array, methodName, args);

  		result = arrayProto[methodName].apply(array, args);
  		promise = global_runloop.start(this, true).then(function () {
  			return result;
  		});

  		if (!!newIndices) {
  			this.viewmodel.smartUpdate(keypath, array, newIndices);
  		} else {
  			this.viewmodel.mark(keypath);
  		}

  		global_runloop.end();

  		return promise;
  	};
  };

  var pop = makeArrayMethod("pop");

  var push = makeArrayMethod("push");

  var css,
      update,
      styleElement,
      head,
      styleSheet,
      inDom,
      global_css__prefix = "/* Ractive.js component styles */\n",
      styles = [],
      dirty = false;

  if (!isClient) {
  	// TODO handle encapsulated CSS in server-rendered HTML!
  	css = {
  		add: noop,
  		apply: noop
  	};
  } else {
  	styleElement = document.createElement("style");
  	styleElement.type = "text/css";

  	head = document.getElementsByTagName("head")[0];

  	inDom = false;

  	// Internet Exploder won't let you use styleSheet.innerHTML - we have to
  	// use styleSheet.cssText instead
  	styleSheet = styleElement.styleSheet;

  	update = function () {
  		var css = global_css__prefix + styles.map(function (s) {
  			return "\n/* {" + s.id + "} */\n" + s.styles;
  		}).join("\n");

  		if (styleSheet) {
  			styleSheet.cssText = css;
  		} else {
  			styleElement.innerHTML = css;
  		}

  		if (!inDom) {
  			head.appendChild(styleElement);
  			inDom = true;
  		}
  	};

  	css = {
  		add: function (s) {
  			styles.push(s);
  			dirty = true;
  		},

  		apply: function () {
  			if (dirty) {
  				update();
  				dirty = false;
  			}
  		}
  	};
  }

  var global_css = css;

  var prototype_render = Ractive$render;

  var renderHook = new hooks_Hook("render"),
      completeHook = new hooks_Hook("complete");
  function Ractive$render(target, anchor) {
  	var _this = this;

  	var promise, instances, transitionsEnabled;

  	// if `noIntro` is `true`, temporarily disable transitions
  	transitionsEnabled = this.transitionsEnabled;
  	if (this.noIntro) {
  		this.transitionsEnabled = false;
  	}

  	promise = global_runloop.start(this, true);
  	global_runloop.scheduleTask(function () {
  		return renderHook.fire(_this);
  	}, true);

  	if (this.fragment.rendered) {
  		throw new Error("You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first");
  	}

  	target = getElement(target) || this.el;
  	anchor = getElement(anchor) || this.anchor;

  	this.el = target;
  	this.anchor = anchor;

  	if (!this.append && target) {
  		// Teardown any existing instances *before* trying to set up the new one -
  		// avoids certain weird bugs
  		var others = target.__ractive_instances__;
  		if (others && others.length) {
  			removeOtherInstances(others);
  		}

  		// make sure we are the only occupants
  		target.innerHTML = ""; // TODO is this quicker than removeChild? Initial research inconclusive
  	}

  	if (this.cssId) {
  		// ensure encapsulated CSS is up-to-date
  		global_css.apply();
  	}

  	if (target) {
  		if (!(instances = target.__ractive_instances__)) {
  			target.__ractive_instances__ = [this];
  		} else {
  			instances.push(this);
  		}

  		if (anchor) {
  			target.insertBefore(this.fragment.render(), anchor);
  		} else {
  			target.appendChild(this.fragment.render());
  		}
  	}

  	global_runloop.end();

  	this.transitionsEnabled = transitionsEnabled;

  	return promise.then(function () {
  		return completeHook.fire(_this);
  	});
  }

  function removeOtherInstances(others) {
  	others.splice(0, others.length).forEach(teardown);
  }

  var adaptConfigurator = {
  	extend: function (Parent, proto, options) {
  		proto.adapt = custom_adapt__combine(proto.adapt, ensureArray(options.adapt));
  	},

  	init: function () {}
  };

  var custom_adapt = adaptConfigurator;

  function custom_adapt__combine(a, b) {
  	var c = a.slice(),
  	    i = b.length;

  	while (i--) {
  		if (! ~c.indexOf(b[i])) {
  			c.push(b[i]);
  		}
  	}

  	return c;
  }

  var transform = transformCss;

  var selectorsPattern = /(?:^|\})?\s*([^\{\}]+)\s*\{/g,
      commentsPattern = /\/\*.*?\*\//g,
      selectorUnitPattern = /((?:(?:\[[^\]+]\])|(?:[^\s\+\>\~:]))+)((?::[^\s\+\>\~\(]+(?:\([^\)]+\))?)?\s*[\s\+\>\~]?)\s*/g,
      mediaQueryPattern = /^@media/,
      dataRvcGuidPattern = /\[data-ractive-css~="\{[a-z0-9-]+\}"]/g;
  function transformCss(css, id) {
  	var transformed, dataAttr, addGuid;

  	dataAttr = "[data-ractive-css~=\"{" + id + "}\"]";

  	addGuid = function (selector) {
  		var selectorUnits,
  		    match,
  		    unit,
  		    base,
  		    prepended,
  		    appended,
  		    i,
  		    transformed = [];

  		selectorUnits = [];

  		while (match = selectorUnitPattern.exec(selector)) {
  			selectorUnits.push({
  				str: match[0],
  				base: match[1],
  				modifiers: match[2]
  			});
  		}

  		// For each simple selector within the selector, we need to create a version
  		// that a) combines with the id, and b) is inside the id
  		base = selectorUnits.map(extractString);

  		i = selectorUnits.length;
  		while (i--) {
  			appended = base.slice();

  			// Pseudo-selectors should go after the attribute selector
  			unit = selectorUnits[i];
  			appended[i] = unit.base + dataAttr + unit.modifiers || "";

  			prepended = base.slice();
  			prepended[i] = dataAttr + " " + prepended[i];

  			transformed.push(appended.join(" "), prepended.join(" "));
  		}

  		return transformed.join(", ");
  	};

  	if (dataRvcGuidPattern.test(css)) {
  		transformed = css.replace(dataRvcGuidPattern, dataAttr);
  	} else {
  		transformed = css.replace(commentsPattern, "").replace(selectorsPattern, function (match, $1) {
  			var selectors, transformed;

  			// don't transform media queries!
  			if (mediaQueryPattern.test($1)) return match;

  			selectors = $1.split(",").map(trim);
  			transformed = selectors.map(addGuid).join(", ") + " ";

  			return match.replace($1, transformed);
  		});
  	}

  	return transformed;
  }

  function trim(str) {
  	if (str.trim) {
  		return str.trim();
  	}

  	return str.replace(/^\s+/, "").replace(/\s+$/, "");
  }

  function extractString(unit) {
  	return unit.str;
  }

  var css_css__uid = 1;

  var cssConfigurator = {
  	name: "css",

  	extend: function (Parent, proto, options) {
  		if (options.css) {
  			var id = css_css__uid++;
  			var styles = options.noCssTransform ? options.css : transform(options.css, id);

  			proto.cssId = id;
  			global_css.add({ id: id, styles: styles });
  		}
  	},

  	init: function () {}
  };

  var css_css = cssConfigurator;

  function validate(data) {
  	// Warn if userOptions.data is a non-POJO
  	if (data && data.constructor !== Object) {
  		if (typeof data === "function") {} else if (typeof data !== "object") {
  			fatal("data option must be an object or a function, `" + data + "` is not valid");
  		} else {
  			warnIfDebug("If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged");
  		}
  	}
  }

  var dataConfigurator = {
  	name: "data",

  	extend: function (Parent, proto, options) {
  		var key = undefined,
  		    value = undefined;

  		// check for non-primitives, which could cause mutation-related bugs
  		if (options.data && isObject(options.data)) {
  			for (key in options.data) {
  				value = options.data[key];

  				if (value && typeof value === "object") {
  					if (isObject(value) || isArray(value)) {
  						warnIfDebug("Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\n\n  // this...\n  data: function () {\n    return {\n      myObject: {}\n    };\n  })\n\n  // instead of this:\n  data: {\n    myObject: {}\n  }");
  					}
  				}
  			}
  		}

  		proto.data = custom_data__combine(proto.data, options.data);
  	},

  	init: function (Parent, ractive, options) {
  		var result = custom_data__combine(Parent.prototype.data, options.data);

  		if (typeof result === "function") {
  			result = result.call(ractive);
  		}

  		return result || {};
  	},

  	reset: function (ractive) {
  		var result = this.init(ractive.constructor, ractive, ractive.viewmodel);

  		ractive.viewmodel.reset(result);
  		return true;
  	}
  };

  var custom_data = dataConfigurator;

  function custom_data__combine(parentValue, childValue) {
  	validate(childValue);

  	var parentIsFn = typeof parentValue === "function";
  	var childIsFn = typeof childValue === "function";

  	// Very important, otherwise child instance can become
  	// the default data object on Ractive or a component.
  	// then ractive.set() ends up setting on the prototype!
  	if (!childValue && !parentIsFn) {
  		childValue = {};
  	}

  	// Fast path, where we just need to copy properties from
  	// parent to child
  	if (!parentIsFn && !childIsFn) {
  		return fromProperties(childValue, parentValue);
  	}

  	return function () {
  		var child = childIsFn ? callDataFunction(childValue, this) : childValue;
  		var parent = parentIsFn ? callDataFunction(parentValue, this) : parentValue;

  		return fromProperties(child, parent);
  	};
  }

  function callDataFunction(fn, context) {
  	var data = fn.call(context);

  	if (!data) return;

  	if (typeof data !== "object") {
  		fatal("Data function must return an object");
  	}

  	if (data.constructor !== Object) {
  		warnOnceIfDebug("Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged");
  	}

  	return data;
  }

  function fromProperties(primary, secondary) {
  	if (primary && secondary) {
  		for (var key in secondary) {
  			if (!(key in primary)) {
  				primary[key] = secondary[key];
  			}
  		}

  		return primary;
  	}

  	return primary || secondary;
  }

  // TODO do we need to support this in the new Ractive() case?

  var Parser,
      ParseError,
      parse_Parser__leadingWhitespace = /^\s+/;

  ParseError = function (message) {
  	this.name = "ParseError";
  	this.message = message;
  	try {
  		throw new Error(message);
  	} catch (e) {
  		this.stack = e.stack;
  	}
  };

  ParseError.prototype = Error.prototype;

  Parser = function (str, options) {
  	var items,
  	    item,
  	    lineStart = 0;

  	this.str = str;
  	this.options = options || {};
  	this.pos = 0;

  	this.lines = this.str.split("\n");
  	this.lineEnds = this.lines.map(function (line) {
  		var lineEnd = lineStart + line.length + 1; // +1 for the newline

  		lineStart = lineEnd;
  		return lineEnd;
  	}, 0);

  	// Custom init logic
  	if (this.init) this.init(str, options);

  	items = [];

  	while (this.pos < this.str.length && (item = this.read())) {
  		items.push(item);
  	}

  	this.leftover = this.remaining();
  	this.result = this.postProcess ? this.postProcess(items, options) : items;
  };

  Parser.prototype = {
  	read: function (converters) {
  		var pos, i, len, item;

  		if (!converters) converters = this.converters;

  		pos = this.pos;

  		len = converters.length;
  		for (i = 0; i < len; i += 1) {
  			this.pos = pos; // reset for each attempt

  			if (item = converters[i](this)) {
  				return item;
  			}
  		}

  		return null;
  	},

  	getLinePos: function (char) {
  		var lineNum = 0,
  		    lineStart = 0,
  		    columnNum;

  		while (char >= this.lineEnds[lineNum]) {
  			lineStart = this.lineEnds[lineNum];
  			lineNum += 1;
  		}

  		columnNum = char - lineStart;
  		return [lineNum + 1, columnNum + 1, char]; // line/col should be one-based, not zero-based!
  	},

  	error: function (message) {
  		var pos = this.getLinePos(this.pos);
  		var lineNum = pos[0];
  		var columnNum = pos[1];

  		var line = this.lines[pos[0] - 1];
  		var numTabs = 0;
  		var annotation = line.replace(/\t/g, function (match, char) {
  			if (char < pos[1]) {
  				numTabs += 1;
  			}

  			return "  ";
  		}) + "\n" + new Array(pos[1] + numTabs).join(" ") + "^----";

  		var error = new ParseError("" + message + " at line " + lineNum + " character " + columnNum + ":\n" + annotation);

  		error.line = pos[0];
  		error.character = pos[1];
  		error.shortMessage = message;

  		throw error;
  	},

  	matchString: function (string) {
  		if (this.str.substr(this.pos, string.length) === string) {
  			this.pos += string.length;
  			return string;
  		}
  	},

  	matchPattern: function (pattern) {
  		var match;

  		if (match = pattern.exec(this.remaining())) {
  			this.pos += match[0].length;
  			return match[1] || match[0];
  		}
  	},

  	allowWhitespace: function () {
  		this.matchPattern(parse_Parser__leadingWhitespace);
  	},

  	remaining: function () {
  		return this.str.substring(this.pos);
  	},

  	nextChar: function () {
  		return this.str.charAt(this.pos);
  	}
  };

  Parser.extend = function (proto) {
  	var Parent = this,
  	    Child,
  	    key;

  	Child = function (str, options) {
  		Parser.call(this, str, options);
  	};

  	Child.prototype = create(Parent.prototype);

  	for (key in proto) {
  		if (hasOwn.call(proto, key)) {
  			Child.prototype[key] = proto[key];
  		}
  	}

  	Child.extend = Parser.extend;
  	return Child;
  };

  var parse_Parser = Parser;

  var TEXT = 1;
  var INTERPOLATOR = 2;
  var TRIPLE = 3;
  var SECTION = 4;
  var INVERTED = 5;
  var CLOSING = 6;
  var ELEMENT = 7;
  var PARTIAL = 8;
  var COMMENT = 9;
  var DELIMCHANGE = 10;
  var ATTRIBUTE = 13;
  var CLOSING_TAG = 14;
  var COMPONENT = 15;
  var YIELDER = 16;
  var INLINE_PARTIAL = 17;
  var DOCTYPE = 18;

  var NUMBER_LITERAL = 20;
  var STRING_LITERAL = 21;
  var ARRAY_LITERAL = 22;
  var OBJECT_LITERAL = 23;
  var BOOLEAN_LITERAL = 24;
  var REGEXP_LITERAL = 25;

  var GLOBAL = 26;
  var KEY_VALUE_PAIR = 27;

  var REFERENCE = 30;
  var REFINEMENT = 31;
  var MEMBER = 32;
  var PREFIX_OPERATOR = 33;
  var BRACKETED = 34;
  var CONDITIONAL = 35;
  var INFIX_OPERATOR = 36;

  var INVOCATION = 40;

  var SECTION_IF = 50;
  var SECTION_UNLESS = 51;
  var SECTION_EACH = 52;
  var SECTION_WITH = 53;
  var SECTION_IF_WITH = 54;

  var ELSE = 60;
  var ELSEIF = 61;

  var mustache_readDelimiterChange = readDelimiterChange;
  var delimiterChangePattern = /^[^\s=]+/,
      whitespacePattern = /^\s+/;
  function readDelimiterChange(parser) {
  	var start, opening, closing;

  	if (!parser.matchString("=")) {
  		return null;
  	}

  	start = parser.pos;

  	// allow whitespace before new opening delimiter
  	parser.allowWhitespace();

  	opening = parser.matchPattern(delimiterChangePattern);
  	if (!opening) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace (in fact, it's necessary...)
  	if (!parser.matchPattern(whitespacePattern)) {
  		return null;
  	}

  	closing = parser.matchPattern(delimiterChangePattern);
  	if (!closing) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace before closing '='
  	parser.allowWhitespace();

  	if (!parser.matchString("=")) {
  		parser.pos = start;
  		return null;
  	}

  	return [opening, closing];
  }

  var readRegexpLiteral = readRegexpLiteral__readNumberLiteral;
  var regexpPattern = /^(\/(?:[^\n\r\u2028\u2029/\\[]|\\.|\[(?:[^\n\r\u2028\u2029\]\\]|\\.)*])+\/(?:([gimuy])(?![a-z]*\2))*(?![a-zA-Z_$0-9]))/;
  function readRegexpLiteral__readNumberLiteral(parser) {
  	var result;

  	if (result = parser.matchPattern(regexpPattern)) {
  		return {
  			t: REGEXP_LITERAL,
  			v: result
  		};
  	}

  	return null;
  }

  var converters_readMustache = readMustache;

  var delimiterChangeToken = { t: DELIMCHANGE, exclude: true };
  function readMustache(parser) {
  	var mustache, i;

  	// If we're inside a <script> or <style> tag, and we're not
  	// interpolating, bug out
  	if (parser.interpolate[parser.inside] === false) {
  		return null;
  	}

  	for (i = 0; i < parser.tags.length; i += 1) {
  		if (mustache = readMustacheOfType(parser, parser.tags[i])) {
  			return mustache;
  		}
  	}
  }

  function readMustacheOfType(parser, tag) {
  	var start, mustache, reader, i;

  	start = parser.pos;

  	if (parser.matchString("\\" + tag.open)) {
  		if (start === 0 || parser.str[start - 1] !== "\\") {
  			return tag.open;
  		}
  	} else if (!parser.matchString(tag.open)) {
  		return null;
  	}

  	// delimiter change?
  	if (mustache = mustache_readDelimiterChange(parser)) {
  		// find closing delimiter or abort...
  		if (!parser.matchString(tag.close)) {
  			return null;
  		}

  		// ...then make the switch
  		tag.open = mustache[0];
  		tag.close = mustache[1];
  		parser.sortMustacheTags();

  		return delimiterChangeToken;
  	}

  	parser.allowWhitespace();

  	// illegal section closer
  	if (parser.matchString("/")) {
  		parser.pos -= 1;
  		var rewind = parser.pos;
  		if (!readRegexpLiteral(parser)) {
  			parser.pos = rewind - tag.close.length;
  			parser.error("Attempted to close a section that wasn't open");
  		} else {
  			parser.pos = rewind;
  		}
  	}

  	for (i = 0; i < tag.readers.length; i += 1) {
  		reader = tag.readers[i];

  		if (mustache = reader(parser, tag)) {
  			if (tag.isStatic) {
  				mustache.s = true; // TODO make this `1` instead - more compact
  			}

  			if (parser.includeLinePositions) {
  				mustache.p = parser.getLinePos(start);
  			}

  			return mustache;
  		}
  	}

  	parser.pos = start;
  	return null;
  }

  var expectedExpression = "Expected a JavaScript expression";
  var expectedParen = "Expected closing paren";

  var literal_readNumberLiteral = literal_readNumberLiteral__readNumberLiteral;
  var literal_readNumberLiteral__numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
  function literal_readNumberLiteral__readNumberLiteral(parser) {
  	var result;

  	if (result = parser.matchPattern(literal_readNumberLiteral__numberPattern)) {
  		return {
  			t: NUMBER_LITERAL,
  			v: result
  		};
  	}

  	return null;
  }

  var literal_readBooleanLiteral = readBooleanLiteral;
  function readBooleanLiteral(parser) {
  	var remaining = parser.remaining();

  	if (remaining.substr(0, 4) === "true") {
  		parser.pos += 4;
  		return {
  			t: BOOLEAN_LITERAL,
  			v: "true"
  		};
  	}

  	if (remaining.substr(0, 5) === "false") {
  		parser.pos += 5;
  		return {
  			t: BOOLEAN_LITERAL,
  			v: "false"
  		};
  	}

  	return null;
  }

  var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;

  // Match one or more characters until: ", ', \, or EOL/EOF.
  // EOL/EOF is written as (?!.) (meaning there's no non-newline char next).
  stringMiddlePattern = /^(?=.)[^"'\\]+?(?:(?!.)|(?=["'\\]))/;

  // Match one escape sequence, including the backslash.
  escapeSequencePattern = /^\\(?:['"\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;

  // Match one ES5 line continuation (backslash + line terminator).
  lineContinuationPattern = /^\\(?:\r\n|[\u000A\u000D\u2028\u2029])/;

  // Helper for defining getDoubleQuotedString and getSingleQuotedString.
  var makeQuotedStringMatcher = function (okQuote) {
  	return function (parser) {
  		var start, literal, done, next;

  		start = parser.pos;
  		literal = "\"";
  		done = false;

  		while (!done) {
  			next = parser.matchPattern(stringMiddlePattern) || parser.matchPattern(escapeSequencePattern) || parser.matchString(okQuote);
  			if (next) {
  				if (next === "\"") {
  					literal += "\\\"";
  				} else if (next === "\\'") {
  					literal += "'";
  				} else {
  					literal += next;
  				}
  			} else {
  				next = parser.matchPattern(lineContinuationPattern);
  				if (next) {
  					// convert \(newline-like) into a \u escape, which is allowed in JSON
  					literal += "\\u" + ("000" + next.charCodeAt(1).toString(16)).slice(-4);
  				} else {
  					done = true;
  				}
  			}
  		}

  		literal += "\"";

  		// use JSON.parse to interpret escapes
  		return JSON.parse(literal);
  	};
  };

  var getSingleQuotedString = makeQuotedStringMatcher("\"");
  var getDoubleQuotedString = makeQuotedStringMatcher("'");

  var readStringLiteral = function (parser) {
  	var start, string;

  	start = parser.pos;

  	if (parser.matchString("\"")) {
  		string = getDoubleQuotedString(parser);

  		if (!parser.matchString("\"")) {
  			parser.pos = start;
  			return null;
  		}

  		return {
  			t: STRING_LITERAL,
  			v: string
  		};
  	}

  	if (parser.matchString("'")) {
  		string = getSingleQuotedString(parser);

  		if (!parser.matchString("'")) {
  			parser.pos = start;
  			return null;
  		}

  		return {
  			t: STRING_LITERAL,
  			v: string
  		};
  	}

  	return null;
  };

  var patterns__name = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;

  // http://mathiasbynens.be/notes/javascript-properties
  // can be any name, string literal, or number literal
  var shared_readKey = readKey;
  var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
  function readKey(parser) {
  	var token;

  	if (token = readStringLiteral(parser)) {
  		return identifier.test(token.v) ? token.v : "\"" + token.v.replace(/"/g, "\\\"") + "\"";
  	}

  	if (token = literal_readNumberLiteral(parser)) {
  		return token.v;
  	}

  	if (token = parser.matchPattern(patterns__name)) {
  		return token;
  	}
  }

  var keyValuePair = readKeyValuePair;
  function readKeyValuePair(parser) {
  	var start, key, value;

  	start = parser.pos;

  	// allow whitespace between '{' and key
  	parser.allowWhitespace();

  	key = shared_readKey(parser);
  	if (key === null) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace between key and ':'
  	parser.allowWhitespace();

  	// next character must be ':'
  	if (!parser.matchString(":")) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace between ':' and value
  	parser.allowWhitespace();

  	// next expression must be a, well... expression
  	value = converters_readExpression(parser);
  	if (value === null) {
  		parser.pos = start;
  		return null;
  	}

  	return {
  		t: KEY_VALUE_PAIR,
  		k: key,
  		v: value
  	};
  }

  var objectLiteral_keyValuePairs = readKeyValuePairs;
  function readKeyValuePairs(parser) {
  	var start, pairs, pair, keyValuePairs;

  	start = parser.pos;

  	pair = keyValuePair(parser);
  	if (pair === null) {
  		return null;
  	}

  	pairs = [pair];

  	if (parser.matchString(",")) {
  		keyValuePairs = readKeyValuePairs(parser);

  		if (!keyValuePairs) {
  			parser.pos = start;
  			return null;
  		}

  		return pairs.concat(keyValuePairs);
  	}

  	return pairs;
  }

  var readObjectLiteral = function (parser) {
  	var start, keyValuePairs;

  	start = parser.pos;

  	// allow whitespace
  	parser.allowWhitespace();

  	if (!parser.matchString("{")) {
  		parser.pos = start;
  		return null;
  	}

  	keyValuePairs = objectLiteral_keyValuePairs(parser);

  	// allow whitespace between final value and '}'
  	parser.allowWhitespace();

  	if (!parser.matchString("}")) {
  		parser.pos = start;
  		return null;
  	}

  	return {
  		t: OBJECT_LITERAL,
  		m: keyValuePairs
  	};
  };

  var shared_readExpressionList = readExpressionList;
  function readExpressionList(parser) {
  	var start, expressions, expr, next;

  	start = parser.pos;

  	parser.allowWhitespace();

  	expr = converters_readExpression(parser);

  	if (expr === null) {
  		return null;
  	}

  	expressions = [expr];

  	// allow whitespace between expression and ','
  	parser.allowWhitespace();

  	if (parser.matchString(",")) {
  		next = readExpressionList(parser);
  		if (next === null) {
  			parser.error(expectedExpression);
  		}

  		next.forEach(append);
  	}

  	function append(expression) {
  		expressions.push(expression);
  	}

  	return expressions;
  }

  var readArrayLiteral = function (parser) {
  	var start, expressionList;

  	start = parser.pos;

  	// allow whitespace before '['
  	parser.allowWhitespace();

  	if (!parser.matchString("[")) {
  		parser.pos = start;
  		return null;
  	}

  	expressionList = shared_readExpressionList(parser);

  	if (!parser.matchString("]")) {
  		parser.pos = start;
  		return null;
  	}

  	return {
  		t: ARRAY_LITERAL,
  		m: expressionList
  	};
  };

  var primary_readLiteral = readLiteral;
  function readLiteral(parser) {
  	return literal_readNumberLiteral(parser) || literal_readBooleanLiteral(parser) || readStringLiteral(parser) || readObjectLiteral(parser) || readArrayLiteral(parser) || readRegexpLiteral(parser);
  }

  var primary_readReference = readReference;
  var prefixPattern = /^(?:~\/|(?:\.\.\/)+|\.\/(?:\.\.\/)*|\.)/,
      globals,
      keywords;

  // if a reference is a browser global, we don't deference it later, so it needs special treatment
  globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)\b/;

  // keywords are not valid references, with the exception of `this`
  keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;

  var legalReference = /^[a-zA-Z$_0-9]+(?:(?:\.[a-zA-Z$_0-9]+)|(?:\[[0-9]+\]))*/;
  var relaxedName = /^[a-zA-Z_$][-a-zA-Z_$0-9]*/;
  function readReference(parser) {
  	var startPos, prefix, name, global, reference, lastDotIndex;

  	startPos = parser.pos;

  	name = parser.matchPattern(/^@(?:keypath|index|key)/);

  	if (!name) {
  		prefix = parser.matchPattern(prefixPattern) || "";
  		name = !prefix && parser.relaxedNames && parser.matchPattern(relaxedName) || parser.matchPattern(legalReference);

  		if (!name && prefix === ".") {
  			prefix = "";
  			name = ".";
  		}
  	}

  	if (!name) {
  		return null;
  	}

  	// bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)
  	if (!prefix && !parser.relaxedNames && keywords.test(name)) {
  		parser.pos = startPos;
  		return null;
  	}

  	// if this is a browser global, stop here
  	if (!prefix && globals.test(name)) {
  		global = globals.exec(name)[0];
  		parser.pos = startPos + global.length;

  		return {
  			t: GLOBAL,
  			v: global
  		};
  	}

  	reference = (prefix || "") + normalise(name);

  	if (parser.matchString("(")) {
  		// if this is a method invocation (as opposed to a function) we need
  		// to strip the method name from the reference combo, else the context
  		// will be wrong
  		lastDotIndex = reference.lastIndexOf(".");
  		if (lastDotIndex !== -1) {
  			reference = reference.substr(0, lastDotIndex);
  			parser.pos = startPos + reference.length;
  		} else {
  			parser.pos -= 1;
  		}
  	}

  	return {
  		t: REFERENCE,
  		n: reference.replace(/^this\./, "./").replace(/^this$/, ".")
  	};
  }

  var primary_readBracketedExpression = readBracketedExpression;
  function readBracketedExpression(parser) {
  	var start, expr;

  	start = parser.pos;

  	if (!parser.matchString("(")) {
  		return null;
  	}

  	parser.allowWhitespace();

  	expr = converters_readExpression(parser);
  	if (!expr) {
  		parser.error(expectedExpression);
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString(")")) {
  		parser.error(expectedParen);
  	}

  	return {
  		t: BRACKETED,
  		x: expr
  	};
  }

  var readPrimary = function (parser) {
  	return primary_readLiteral(parser) || primary_readReference(parser) || primary_readBracketedExpression(parser);
  };

  var shared_readRefinement = readRefinement;
  function readRefinement(parser) {
  	var start, name, expr;

  	start = parser.pos;

  	parser.allowWhitespace();

  	// "." name
  	if (parser.matchString(".")) {
  		parser.allowWhitespace();

  		if (name = parser.matchPattern(patterns__name)) {
  			return {
  				t: REFINEMENT,
  				n: name
  			};
  		}

  		parser.error("Expected a property name");
  	}

  	// "[" expression "]"
  	if (parser.matchString("[")) {
  		parser.allowWhitespace();

  		expr = converters_readExpression(parser);
  		if (!expr) {
  			parser.error(expectedExpression);
  		}

  		parser.allowWhitespace();

  		if (!parser.matchString("]")) {
  			parser.error("Expected ']'");
  		}

  		return {
  			t: REFINEMENT,
  			x: expr
  		};
  	}

  	return null;
  }

  var readMemberOrInvocation = function (parser) {
  	var current, expression, refinement, expressionList;

  	expression = readPrimary(parser);

  	if (!expression) {
  		return null;
  	}

  	while (expression) {
  		current = parser.pos;

  		if (refinement = shared_readRefinement(parser)) {
  			expression = {
  				t: MEMBER,
  				x: expression,
  				r: refinement
  			};
  		} else if (parser.matchString("(")) {
  			parser.allowWhitespace();
  			expressionList = shared_readExpressionList(parser);

  			parser.allowWhitespace();

  			if (!parser.matchString(")")) {
  				parser.error(expectedParen);
  			}

  			expression = {
  				t: INVOCATION,
  				x: expression
  			};

  			if (expressionList) {
  				expression.o = expressionList;
  			}
  		} else {
  			break;
  		}
  	}

  	return expression;
  };

  var readTypeOf, makePrefixSequenceMatcher;

  makePrefixSequenceMatcher = function (symbol, fallthrough) {
  	return function (parser) {
  		var expression;

  		if (expression = fallthrough(parser)) {
  			return expression;
  		}

  		if (!parser.matchString(symbol)) {
  			return null;
  		}

  		parser.allowWhitespace();

  		expression = converters_readExpression(parser);
  		if (!expression) {
  			parser.error(expectedExpression);
  		}

  		return {
  			s: symbol,
  			o: expression,
  			t: PREFIX_OPERATOR
  		};
  	};
  };

  // create all prefix sequence matchers, return readTypeOf
  (function () {
  	var i, len, matcher, prefixOperators, fallthrough;

  	prefixOperators = "! ~ + - typeof".split(" ");

  	fallthrough = readMemberOrInvocation;
  	for (i = 0, len = prefixOperators.length; i < len; i += 1) {
  		matcher = makePrefixSequenceMatcher(prefixOperators[i], fallthrough);
  		fallthrough = matcher;
  	}

  	// typeof operator is higher precedence than multiplication, so provides the
  	// fallthrough for the multiplication sequence matcher we're about to create
  	// (we're skipping void and delete)
  	readTypeOf = fallthrough;
  })();

  var readTypeof = readTypeOf;

  var readLogicalOr, makeInfixSequenceMatcher;

  makeInfixSequenceMatcher = function (symbol, fallthrough) {
  	return function (parser) {
  		var start, left, right;

  		left = fallthrough(parser);
  		if (!left) {
  			return null;
  		}

  		// Loop to handle left-recursion in a case like `a * b * c` and produce
  		// left association, i.e. `(a * b) * c`.  The matcher can't call itself
  		// to parse `left` because that would be infinite regress.
  		while (true) {
  			start = parser.pos;

  			parser.allowWhitespace();

  			if (!parser.matchString(symbol)) {
  				parser.pos = start;
  				return left;
  			}

  			// special case - in operator must not be followed by [a-zA-Z_$0-9]
  			if (symbol === "in" && /[a-zA-Z_$0-9]/.test(parser.remaining().charAt(0))) {
  				parser.pos = start;
  				return left;
  			}

  			parser.allowWhitespace();

  			// right operand must also consist of only higher-precedence operators
  			right = fallthrough(parser);
  			if (!right) {
  				parser.pos = start;
  				return left;
  			}

  			left = {
  				t: INFIX_OPERATOR,
  				s: symbol,
  				o: [left, right]
  			};

  			// Loop back around.  If we don't see another occurrence of the symbol,
  			// we'll return left.
  		}
  	};
  };

  // create all infix sequence matchers, and return readLogicalOr
  (function () {
  	var i, len, matcher, infixOperators, fallthrough;

  	// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)
  	// Each sequence matcher will initially fall through to its higher precedence
  	// neighbour, and only attempt to match if one of the higher precedence operators
  	// (or, ultimately, a literal, reference, or bracketed expression) already matched
  	infixOperators = "* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||".split(" ");

  	// A typeof operator is higher precedence than multiplication
  	fallthrough = readTypeof;
  	for (i = 0, len = infixOperators.length; i < len; i += 1) {
  		matcher = makeInfixSequenceMatcher(infixOperators[i], fallthrough);
  		fallthrough = matcher;
  	}

  	// Logical OR is the fallthrough for the conditional matcher
  	readLogicalOr = fallthrough;
  })();

  var expressions_readLogicalOr = readLogicalOr;

  // The conditional operator is the lowest precedence operator, so we start here
  var readConditional = getConditional;
  function getConditional(parser) {
  	var start, expression, ifTrue, ifFalse;

  	expression = expressions_readLogicalOr(parser);
  	if (!expression) {
  		return null;
  	}

  	start = parser.pos;

  	parser.allowWhitespace();

  	if (!parser.matchString("?")) {
  		parser.pos = start;
  		return expression;
  	}

  	parser.allowWhitespace();

  	ifTrue = converters_readExpression(parser);
  	if (!ifTrue) {
  		parser.error(expectedExpression);
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString(":")) {
  		parser.error("Expected \":\"");
  	}

  	parser.allowWhitespace();

  	ifFalse = converters_readExpression(parser);
  	if (!ifFalse) {
  		parser.error(expectedExpression);
  	}

  	return {
  		t: CONDITIONAL,
  		o: [expression, ifTrue, ifFalse]
  	};
  }

  var converters_readExpression = readExpression;
  function readExpression(parser) {
  	// The conditional operator is the lowest precedence operator (except yield,
  	// assignment operators, and commas, none of which are supported), so we
  	// start there. If it doesn't match, it 'falls through' to progressively
  	// higher precedence operators, until it eventually matches (or fails to
  	// match) a 'primary' - a literal or a reference. This way, the abstract syntax
  	// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.
  	return readConditional(parser);
  }

  var utils_flattenExpression = flattenExpression;

  function flattenExpression(expression) {
  	var refs;

  	extractRefs(expression, refs = []);

  	return {
  		r: refs,
  		s: stringify(expression)
  	};

  	function stringify(node) {
  		switch (node.t) {
  			case BOOLEAN_LITERAL:
  			case GLOBAL:
  			case NUMBER_LITERAL:
  			case REGEXP_LITERAL:
  				return node.v;

  			case STRING_LITERAL:
  				return JSON.stringify(String(node.v));

  			case ARRAY_LITERAL:
  				return "[" + (node.m ? node.m.map(stringify).join(",") : "") + "]";

  			case OBJECT_LITERAL:
  				return "{" + (node.m ? node.m.map(stringify).join(",") : "") + "}";

  			case KEY_VALUE_PAIR:
  				return node.k + ":" + stringify(node.v);

  			case PREFIX_OPERATOR:
  				return (node.s === "typeof" ? "typeof " : node.s) + stringify(node.o);

  			case INFIX_OPERATOR:
  				return stringify(node.o[0]) + (node.s.substr(0, 2) === "in" ? " " + node.s + " " : node.s) + stringify(node.o[1]);

  			case INVOCATION:
  				return stringify(node.x) + "(" + (node.o ? node.o.map(stringify).join(",") : "") + ")";

  			case BRACKETED:
  				return "(" + stringify(node.x) + ")";

  			case MEMBER:
  				return stringify(node.x) + stringify(node.r);

  			case REFINEMENT:
  				return node.n ? "." + node.n : "[" + stringify(node.x) + "]";

  			case CONDITIONAL:
  				return stringify(node.o[0]) + "?" + stringify(node.o[1]) + ":" + stringify(node.o[2]);

  			case REFERENCE:
  				return "_" + refs.indexOf(node.n);

  			default:
  				throw new Error("Expected legal JavaScript");
  		}
  	}
  }

  // TODO maybe refactor this?
  function extractRefs(node, refs) {
  	var i, list;

  	if (node.t === REFERENCE) {
  		if (refs.indexOf(node.n) === -1) {
  			refs.unshift(node.n);
  		}
  	}

  	list = node.o || node.m;
  	if (list) {
  		if (isObject(list)) {
  			extractRefs(list, refs);
  		} else {
  			i = list.length;
  			while (i--) {
  				extractRefs(list[i], refs);
  			}
  		}
  	}

  	if (node.x) {
  		extractRefs(node.x, refs);
  	}

  	if (node.r) {
  		extractRefs(node.r, refs);
  	}

  	if (node.v) {
  		extractRefs(node.v, refs);
  	}
  }

  var utils_refineExpression = refineExpression;

  var arrayMemberPattern = /^[0-9][1-9]*$/;
  function refineExpression(expression, mustache) {
  	var referenceExpression;

  	if (expression) {
  		while (expression.t === BRACKETED && expression.x) {
  			expression = expression.x;
  		}

  		// special case - integers should be treated as array members references,
  		// rather than as expressions in their own right
  		if (expression.t === REFERENCE) {
  			mustache.r = expression.n;
  		} else {
  			if (expression.t === NUMBER_LITERAL && arrayMemberPattern.test(expression.v)) {
  				mustache.r = expression.v;
  			} else if (referenceExpression = getReferenceExpression(expression)) {
  				mustache.rx = referenceExpression;
  			} else {
  				mustache.x = utils_flattenExpression(expression);
  			}
  		}

  		return mustache;
  	}
  }

  // TODO refactor this! it's bewildering
  function getReferenceExpression(expression) {
  	var members = [],
  	    refinement;

  	while (expression.t === MEMBER && expression.r.t === REFINEMENT) {
  		refinement = expression.r;

  		if (refinement.x) {
  			if (refinement.x.t === REFERENCE) {
  				members.unshift(refinement.x);
  			} else {
  				members.unshift(utils_flattenExpression(refinement.x));
  			}
  		} else {
  			members.unshift(refinement.n);
  		}

  		expression = expression.x;
  	}

  	if (expression.t !== REFERENCE) {
  		return null;
  	}

  	return {
  		r: expression.n,
  		m: members
  	};
  }

  var mustache_readTriple = readTriple;
  function readTriple(parser, tag) {
  	var expression = converters_readExpression(parser),
  	    triple;

  	if (!expression) {
  		return null;
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	triple = { t: TRIPLE };
  	utils_refineExpression(expression, triple); // TODO handle this differently - it's mysterious

  	return triple;
  }

  var mustache_readUnescaped = readUnescaped;
  function readUnescaped(parser, tag) {
  	var expression, triple;

  	if (!parser.matchString("&")) {
  		return null;
  	}

  	parser.allowWhitespace();

  	expression = converters_readExpression(parser);

  	if (!expression) {
  		return null;
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	triple = { t: TRIPLE };
  	utils_refineExpression(expression, triple); // TODO handle this differently - it's mysterious

  	return triple;
  }

  var mustache_readPartial = readPartial;
  function readPartial(parser, tag) {
  	var start, nameStart, expression, context, partial;

  	start = parser.pos;

  	if (!parser.matchString(">")) {
  		return null;
  	}

  	parser.allowWhitespace();
  	nameStart = parser.pos;

  	// Partial names can include hyphens, so we can't use readExpression
  	// blindly. Instead, we use the `relaxedNames` flag to indicate that
  	// `foo-bar` should be read as a single name, rather than 'subtract
  	// bar from foo'
  	parser.relaxedNames = true;
  	expression = converters_readExpression(parser);
  	parser.relaxedNames = false;

  	parser.allowWhitespace();
  	context = converters_readExpression(parser);
  	parser.allowWhitespace();

  	if (!expression) {
  		return null;
  	}

  	partial = { t: PARTIAL };
  	utils_refineExpression(expression, partial); // TODO...

  	parser.allowWhitespace();

  	// if we have another expression - e.g. `{{>foo bar}}` - then
  	// we turn it into `{{#with bar}}{{>foo}}{{/with}}`
  	if (context) {
  		partial = {
  			t: SECTION,
  			n: SECTION_WITH,
  			f: [partial]
  		};

  		utils_refineExpression(context, partial);
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	return partial;
  }

  var readMustacheComment = readComment;
  function readComment(parser, tag) {
  	var index;

  	if (!parser.matchString("!")) {
  		return null;
  	}

  	index = parser.remaining().indexOf(tag.close);

  	if (index !== -1) {
  		parser.pos += index + tag.close.length;
  		return { t: COMMENT };
  	}
  }

  var converters_readExpressionOrReference = readExpressionOrReference;
  function readExpressionOrReference(parser, expectedFollowers) {
  	var start, expression, i;

  	start = parser.pos;
  	expression = converters_readExpression(parser);

  	if (!expression) {
  		return null;
  	}

  	for (i = 0; i < expectedFollowers.length; i += 1) {
  		if (parser.remaining().substr(0, expectedFollowers[i].length) === expectedFollowers[i]) {
  			return expression;
  		}
  	}

  	parser.pos = start;
  	return primary_readReference(parser);
  }

  var mustache_readInterpolator = readInterpolator;
  function readInterpolator(parser, tag) {
  	var start, expression, interpolator, err;

  	start = parser.pos;

  	// TODO would be good for perf if we could do away with the try-catch
  	try {
  		expression = converters_readExpressionOrReference(parser, [tag.close]);
  	} catch (e) {
  		err = e;
  	}

  	if (!expression) {
  		if (parser.str.charAt(start) === "!") {
  			// special case - comment
  			parser.pos = start;
  			return null;
  		}

  		if (err) {
  			throw err;
  		}
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "' after reference");

  		if (!expression) {
  			// special case - comment
  			if (parser.nextChar() === "!") {
  				return null;
  			}

  			parser.error("Expected expression or legal reference");
  		}
  	}

  	interpolator = { t: INTERPOLATOR };
  	utils_refineExpression(expression, interpolator); // TODO handle this differently - it's mysterious

  	return interpolator;
  }

  var mustache_readYielder = readYielder;
  var yieldPattern = /^yield\s*/;
  function readYielder(parser, tag) {
  	var start, name, yielder;

  	if (!parser.matchPattern(yieldPattern)) {
  		return null;
  	}

  	start = parser.pos;
  	name = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\-]*/);

  	parser.allowWhitespace();

  	if (!parser.matchString(tag.close)) {
  		parser.error("expected legal partial name");
  	}

  	yielder = { t: YIELDER };

  	if (name) {
  		yielder.n = name;
  	}

  	return yielder;
  }

  var section_readClosing = readClosing;
  function readClosing(parser, tag) {
  	var start, remaining, index, closing;

  	start = parser.pos;

  	if (!parser.matchString(tag.open)) {
  		return null;
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString("/")) {
  		parser.pos = start;
  		return null;
  	}

  	parser.allowWhitespace();

  	remaining = parser.remaining();
  	index = remaining.indexOf(tag.close);

  	if (index !== -1) {
  		closing = {
  			t: CLOSING,
  			r: remaining.substr(0, index).split(" ")[0]
  		};

  		parser.pos += index;

  		if (!parser.matchString(tag.close)) {
  			parser.error("Expected closing delimiter '" + tag.close + "'");
  		}

  		return closing;
  	}

  	parser.pos = start;
  	return null;
  }

  var section_readElse = section_readElse__readElse;
  var section_readElse__elsePattern = /^\s*else\s*/;
  function section_readElse__readElse(parser, tag) {
  	var start = parser.pos;

  	if (!parser.matchString(tag.open)) {
  		return null;
  	}

  	if (!parser.matchPattern(section_readElse__elsePattern)) {
  		parser.pos = start;
  		return null;
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	return {
  		t: ELSE
  	};
  }

  var readElseIf = readElseIf__readElse;
  var readElseIf__elsePattern = /^\s*elseif\s+/;
  function readElseIf__readElse(parser, tag) {
  	var start = parser.pos,
  	    expression;

  	if (!parser.matchString(tag.open)) {
  		return null;
  	}

  	if (!parser.matchPattern(readElseIf__elsePattern)) {
  		parser.pos = start;
  		return null;
  	}

  	expression = converters_readExpression(parser);

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	return {
  		t: ELSEIF,
  		x: expression
  	};
  }

  var handlebarsBlockCodes = {
  	each: SECTION_EACH,
  	"if": SECTION_IF,
  	"if-with": SECTION_IF_WITH,
  	"with": SECTION_WITH,
  	unless: SECTION_UNLESS
  };

  var mustache_readSection = readSection;

  var indexRefPattern = /^\s*:\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,
      keyIndexRefPattern = /^\s*,\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,
      handlebarsBlockPattern = new RegExp("^(" + Object.keys(handlebarsBlockCodes).join("|") + ")\\b");
  function readSection(parser, tag) {
  	var start, expression, section, child, children, hasElse, block, unlessBlock, conditions, closed, i, expectedClose;

  	start = parser.pos;

  	if (parser.matchString("^")) {
  		section = { t: SECTION, f: [], n: SECTION_UNLESS };
  	} else if (parser.matchString("#")) {
  		section = { t: SECTION, f: [] };

  		if (parser.matchString("partial")) {
  			parser.pos = start - parser.standardDelimiters[0].length;
  			parser.error("Partial definitions can only be at the top level of the template, or immediately inside components");
  		}

  		if (block = parser.matchPattern(handlebarsBlockPattern)) {
  			expectedClose = block;
  			section.n = handlebarsBlockCodes[block];
  		}
  	} else {
  		return null;
  	}

  	parser.allowWhitespace();

  	expression = converters_readExpression(parser);

  	if (!expression) {
  		parser.error("Expected expression");
  	}

  	// optional index and key references
  	if (i = parser.matchPattern(indexRefPattern)) {
  		var extra = undefined;

  		if (extra = parser.matchPattern(keyIndexRefPattern)) {
  			section.i = i + "," + extra;
  		} else {
  			section.i = i;
  		}
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	parser.sectionDepth += 1;
  	children = section.f;

  	conditions = [];

  	do {
  		if (child = section_readClosing(parser, tag)) {
  			if (expectedClose && child.r !== expectedClose) {
  				parser.error("Expected " + tag.open + "/" + expectedClose + "" + tag.close);
  			}

  			parser.sectionDepth -= 1;
  			closed = true;
  		} else if (child = readElseIf(parser, tag)) {
  			if (section.n === SECTION_UNLESS) {
  				parser.error("{{else}} not allowed in {{#unless}}");
  			}

  			if (hasElse) {
  				parser.error("illegal {{elseif...}} after {{else}}");
  			}

  			if (!unlessBlock) {
  				unlessBlock = createUnlessBlock(expression, section.n);
  			}

  			unlessBlock.f.push({
  				t: SECTION,
  				n: SECTION_IF,
  				x: utils_flattenExpression(mustache_readSection__combine(conditions.concat(child.x))),
  				f: children = []
  			});

  			conditions.push(invert(child.x));
  		} else if (child = section_readElse(parser, tag)) {
  			if (section.n === SECTION_UNLESS) {
  				parser.error("{{else}} not allowed in {{#unless}}");
  			}

  			if (hasElse) {
  				parser.error("there can only be one {{else}} block, at the end of a section");
  			}

  			hasElse = true;

  			// use an unless block if there's no elseif
  			if (!unlessBlock) {
  				unlessBlock = createUnlessBlock(expression, section.n);
  				children = unlessBlock.f;
  			} else {
  				unlessBlock.f.push({
  					t: SECTION,
  					n: SECTION_IF,
  					x: utils_flattenExpression(mustache_readSection__combine(conditions)),
  					f: children = []
  				});
  			}
  		} else {
  			child = parser.read(READERS);

  			if (!child) {
  				break;
  			}

  			children.push(child);
  		}
  	} while (!closed);

  	if (unlessBlock) {
  		// special case - `with` should become `if-with` (TODO is this right?
  		// seems to me that `with` ought to behave consistently, regardless
  		// of the presence/absence of `else`. In other words should always
  		// be `if-with`
  		if (section.n === SECTION_WITH) {
  			section.n = SECTION_IF_WITH;
  		}

  		section.l = unlessBlock;
  	}

  	utils_refineExpression(expression, section);

  	// TODO if a section is empty it should be discarded. Don't do
  	// that here though - we need to clean everything up first, as
  	// it may contain removeable whitespace. As a temporary measure,
  	// to pass the existing tests, remove empty `f` arrays
  	if (!section.f.length) {
  		delete section.f;
  	}

  	return section;
  }

  function createUnlessBlock(expression, sectionType) {
  	var unlessBlock;

  	if (sectionType === SECTION_WITH) {
  		// special case - a `{{#with foo}}` section will render if `foo` is
  		// truthy, so the `{{else}}` section needs to render if `foo` is falsy,
  		// rather than adhering to the normal `{{#unless foo}}` logic (which
  		// treats empty arrays/objects as falsy)
  		unlessBlock = {
  			t: SECTION,
  			n: SECTION_IF,
  			f: []
  		};

  		utils_refineExpression(invert(expression), unlessBlock);
  	} else {
  		unlessBlock = {
  			t: SECTION,
  			n: SECTION_UNLESS,
  			f: []
  		};

  		utils_refineExpression(expression, unlessBlock);
  	}

  	return unlessBlock;
  }

  function invert(expression) {
  	if (expression.t === PREFIX_OPERATOR && expression.s === "!") {
  		return expression.o;
  	}

  	return {
  		t: PREFIX_OPERATOR,
  		s: "!",
  		o: parensIfNecessary(expression)
  	};
  }

  function mustache_readSection__combine(expressions) {
  	if (expressions.length === 1) {
  		return expressions[0];
  	}

  	return {
  		t: INFIX_OPERATOR,
  		s: "&&",
  		o: [parensIfNecessary(expressions[0]), parensIfNecessary(mustache_readSection__combine(expressions.slice(1)))]
  	};
  }

  function parensIfNecessary(expression) {
  	// TODO only wrap if necessary
  	return {
  		t: BRACKETED,
  		x: expression
  	};
  }

  var converters_readHtmlComment = readHtmlComment;
  var OPEN_COMMENT = "<!--",
      CLOSE_COMMENT = "-->";
  function readHtmlComment(parser) {
  	var start, content, remaining, endIndex, comment;

  	start = parser.pos;

  	if (!parser.matchString(OPEN_COMMENT)) {
  		return null;
  	}

  	remaining = parser.remaining();
  	endIndex = remaining.indexOf(CLOSE_COMMENT);

  	if (endIndex === -1) {
  		parser.error("Illegal HTML - expected closing comment sequence ('-->')");
  	}

  	content = remaining.substr(0, endIndex);
  	parser.pos += endIndex + 3;

  	comment = {
  		t: COMMENT,
  		c: content
  	};

  	if (parser.includeLinePositions) {
  		comment.p = parser.getLinePos(start);
  	}

  	return comment;
  }

  var booleanAttributes, voidElementNames, htmlEntities, controlCharacters, entityPattern, lessThan, greaterThan, amp;

  // https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316
  booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;
  voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;

  htmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, int: 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830 };
  controlCharacters = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376];
  entityPattern = new RegExp("&(#?(?:x[\\w\\d]+|\\d+|" + Object.keys(htmlEntities).join("|") + "));?", "g");

  function decodeCharacterReferences(html) {
  	return html.replace(entityPattern, function (match, entity) {
  		var code;

  		// Handle named entities
  		if (entity[0] !== "#") {
  			code = htmlEntities[entity];
  		} else if (entity[1] === "x") {
  			code = parseInt(entity.substring(2), 16);
  		} else {
  			code = parseInt(entity.substring(1), 10);
  		}

  		if (!code) {
  			return match;
  		}

  		return String.fromCharCode(validateCode(code));
  	});
  }

  // some code points are verboten. If we were inserting HTML, the browser would replace the illegal
  // code points with alternatives in some cases - since we're bypassing that mechanism, we need
  // to replace them ourselves
  //
  // Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
  function validateCode(code) {
  	if (!code) {
  		return 65533;
  	}

  	// line feed becomes generic whitespace
  	if (code === 10) {
  		return 32;
  	}

  	// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
  	if (code < 128) {
  		return code;
  	}

  	// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
  	// to correct the mistake or we'll end up with missing € signs and so on
  	if (code <= 159) {
  		return controlCharacters[code - 128];
  	}

  	// basic multilingual plane
  	if (code < 55296) {
  		return code;
  	}

  	// UTF-16 surrogate halves
  	if (code <= 57343) {
  		return 65533;
  	}

  	// rest of the basic multilingual plane
  	if (code <= 65535) {
  		return code;
  	}

  	return 65533;
  }

  lessThan = /</g;
  greaterThan = />/g;
  amp = /&/g;

  function escapeHtml(str) {
  	return str.replace(amp, "&amp;").replace(lessThan, "&lt;").replace(greaterThan, "&gt;");
  }

  var leadingLinebreak = /^\s*\r?\n/,
      trailingLinebreak = /\r?\n\s*$/;

  var stripStandalones = function (items) {
  	var i, current, backOne, backTwo, lastSectionItem;

  	for (i = 1; i < items.length; i += 1) {
  		current = items[i];
  		backOne = items[i - 1];
  		backTwo = items[i - 2];

  		// if we're at the end of a [text][comment][text] sequence...
  		if (isString(current) && isComment(backOne) && isString(backTwo)) {

  			// ... and the comment is a standalone (i.e. line breaks either side)...
  			if (trailingLinebreak.test(backTwo) && leadingLinebreak.test(current)) {

  				// ... then we want to remove the whitespace after the first line break
  				items[i - 2] = backTwo.replace(trailingLinebreak, "\n");

  				// and the leading line break of the second text token
  				items[i] = current.replace(leadingLinebreak, "");
  			}
  		}

  		// if the current item is a section, and it is preceded by a linebreak, and
  		// its first item is a linebreak...
  		if (isSection(current) && isString(backOne)) {
  			if (trailingLinebreak.test(backOne) && isString(current.f[0]) && leadingLinebreak.test(current.f[0])) {
  				items[i - 1] = backOne.replace(trailingLinebreak, "\n");
  				current.f[0] = current.f[0].replace(leadingLinebreak, "");
  			}
  		}

  		// if the last item was a section, and it is followed by a linebreak, and
  		// its last item is a linebreak...
  		if (isString(current) && isSection(backOne)) {
  			lastSectionItem = lastItem(backOne.f);

  			if (isString(lastSectionItem) && trailingLinebreak.test(lastSectionItem) && leadingLinebreak.test(current)) {
  				backOne.f[backOne.f.length - 1] = lastSectionItem.replace(trailingLinebreak, "\n");
  				items[i] = current.replace(leadingLinebreak, "");
  			}
  		}
  	}

  	return items;
  };

  function isString(item) {
  	return typeof item === "string";
  }

  function isComment(item) {
  	return item.t === COMMENT || item.t === DELIMCHANGE;
  }

  function isSection(item) {
  	return (item.t === SECTION || item.t === INVERTED) && item.f;
  }

  var trimWhitespace = function (items, leadingPattern, trailingPattern) {
  	var item;

  	if (leadingPattern) {
  		item = items[0];
  		if (typeof item === "string") {
  			item = item.replace(leadingPattern, "");

  			if (!item) {
  				items.shift();
  			} else {
  				items[0] = item;
  			}
  		}
  	}

  	if (trailingPattern) {
  		item = lastItem(items);
  		if (typeof item === "string") {
  			item = item.replace(trailingPattern, "");

  			if (!item) {
  				items.pop();
  			} else {
  				items[items.length - 1] = item;
  			}
  		}
  	}
  };

  var utils_cleanup = cleanup;
  var contiguousWhitespace = /[ \t\f\r\n]+/g;
  var preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i;
  var utils_cleanup__leadingWhitespace = /^[ \t\f\r\n]+/;
  var trailingWhitespace = /[ \t\f\r\n]+$/;
  var leadingNewLine = /^(?:\r\n|\r|\n)/;
  var trailingNewLine = /(?:\r\n|\r|\n)$/;
  function cleanup(items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace) {
  	var i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, key;

  	// First pass - remove standalones and comments etc
  	stripStandalones(items);

  	i = items.length;
  	while (i--) {
  		item = items[i];

  		// Remove delimiter changes, unsafe elements etc
  		if (item.exclude) {
  			items.splice(i, 1);
  		}

  		// Remove comments, unless we want to keep them
  		else if (stripComments && item.t === COMMENT) {
  			items.splice(i, 1);
  		}
  	}

  	// If necessary, remove leading and trailing whitespace
  	trimWhitespace(items, removeLeadingWhitespace ? utils_cleanup__leadingWhitespace : null, removeTrailingWhitespace ? trailingWhitespace : null);

  	i = items.length;
  	while (i--) {
  		item = items[i];

  		// Recurse
  		if (item.f) {
  			var isPreserveWhitespaceElement = item.t === ELEMENT && preserveWhitespaceElements.test(item.e);
  			preserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;

  			if (!preserveWhitespace && isPreserveWhitespaceElement) {
  				trimWhitespace(item.f, leadingNewLine, trailingNewLine);
  			}

  			if (!preserveWhitespaceInsideFragment) {
  				previousItem = items[i - 1];
  				nextItem = items[i + 1];

  				// if the previous item was a text item with trailing whitespace,
  				// remove leading whitespace inside the fragment
  				if (!previousItem || typeof previousItem === "string" && trailingWhitespace.test(previousItem)) {
  					removeLeadingWhitespaceInsideFragment = true;
  				}

  				// and vice versa
  				if (!nextItem || typeof nextItem === "string" && utils_cleanup__leadingWhitespace.test(nextItem)) {
  					removeTrailingWhitespaceInsideFragment = true;
  				}
  			}

  			cleanup(item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  		}

  		// Split if-else blocks into two (an if, and an unless)
  		if (item.l) {
  			cleanup(item.l.f, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);

  			items.splice(i + 1, 0, item.l);
  			delete item.l; // TODO would be nice if there was a way around this
  		}

  		// Clean up element attributes
  		if (item.a) {
  			for (key in item.a) {
  				if (item.a.hasOwnProperty(key) && typeof item.a[key] !== "string") {
  					cleanup(item.a[key], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  				}
  			}
  		}

  		// Clean up conditional attributes
  		if (item.m) {
  			cleanup(item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  		}

  		// Clean up event handlers
  		if (item.v) {
  			for (key in item.v) {
  				if (item.v.hasOwnProperty(key)) {
  					// clean up names
  					if (isArray(item.v[key].n)) {
  						cleanup(item.v[key].n, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  					}

  					// clean up params
  					if (isArray(item.v[key].d)) {
  						cleanup(item.v[key].d, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  					}
  				}
  			}
  		}
  	}

  	// final pass - fuse text nodes together
  	i = items.length;
  	while (i--) {
  		if (typeof items[i] === "string") {
  			if (typeof items[i + 1] === "string") {
  				items[i] = items[i] + items[i + 1];
  				items.splice(i + 1, 1);
  			}

  			if (!preserveWhitespace) {
  				items[i] = items[i].replace(contiguousWhitespace, " ");
  			}

  			if (items[i] === "") {
  				items.splice(i, 1);
  			}
  		}
  	}
  }

  var element_readClosingTag = readClosingTag;
  var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\-]*)\s*\>/;
  function readClosingTag(parser) {
  	var start, tag;

  	start = parser.pos;

  	// are we looking at a closing tag?
  	if (!parser.matchString("</")) {
  		return null;
  	}

  	if (tag = parser.matchPattern(closingTagPattern)) {
  		if (parser.inside && tag !== parser.inside) {
  			parser.pos = start;
  			return null;
  		}

  		return {
  			t: CLOSING_TAG,
  			e: tag
  		};
  	}

  	// We have an illegal closing tag, report it
  	parser.pos -= 2;
  	parser.error("Illegal closing tag");
  }

  var getLowestIndex = function (haystack, needles) {
  	var i, index, lowest;

  	i = needles.length;
  	while (i--) {
  		index = haystack.indexOf(needles[i]);

  		// short circuit
  		if (!index) {
  			return 0;
  		}

  		if (index === -1) {
  			continue;
  		}

  		if (!lowest || index < lowest) {
  			lowest = index;
  		}
  	}

  	return lowest || -1;
  };

  var element_readAttribute = readAttribute;

  var attributeNamePattern = /^[^\s"'>\/=]+/,
      unquotedAttributeValueTextPattern = /^[^\s"'=<>`]+/;
  function readAttribute(parser) {
  	var attr, name, value;

  	parser.allowWhitespace();

  	name = parser.matchPattern(attributeNamePattern);
  	if (!name) {
  		return null;
  	}

  	attr = { name: name };

  	value = readAttributeValue(parser);
  	if (value != null) {
  		// not null/undefined
  		attr.value = value;
  	}

  	return attr;
  }

  function readAttributeValue(parser) {
  	var start, valueStart, startDepth, value;

  	start = parser.pos;

  	// next character must be `=`, `/`, `>` or whitespace
  	if (!/[=\/>\s]/.test(parser.nextChar())) {
  		parser.error("Expected `=`, `/`, `>` or whitespace");
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString("=")) {
  		parser.pos = start;
  		return null;
  	}

  	parser.allowWhitespace();

  	valueStart = parser.pos;
  	startDepth = parser.sectionDepth;

  	value = readQuotedAttributeValue(parser, "'") || readQuotedAttributeValue(parser, "\"") || readUnquotedAttributeValue(parser);

  	if (value === null) {
  		parser.error("Expected valid attribute value");
  	}

  	if (parser.sectionDepth !== startDepth) {
  		parser.pos = valueStart;
  		parser.error("An attribute value must contain as many opening section tags as closing section tags");
  	}

  	if (!value.length) {
  		return "";
  	}

  	if (value.length === 1 && typeof value[0] === "string") {
  		return decodeCharacterReferences(value[0]);
  	}

  	return value;
  }

  function readUnquotedAttributeValueToken(parser) {
  	var start, text, haystack, needles, index;

  	start = parser.pos;

  	text = parser.matchPattern(unquotedAttributeValueTextPattern);

  	if (!text) {
  		return null;
  	}

  	haystack = text;
  	needles = parser.tags.map(function (t) {
  		return t.open;
  	}); // TODO refactor... we do this in readText.js as well

  	if ((index = getLowestIndex(haystack, needles)) !== -1) {
  		text = text.substr(0, index);
  		parser.pos = start + text.length;
  	}

  	return text;
  }

  function readUnquotedAttributeValue(parser) {
  	var tokens, token;

  	parser.inAttribute = true;

  	tokens = [];

  	token = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);
  	while (token !== null) {
  		tokens.push(token);
  		token = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);
  	}

  	if (!tokens.length) {
  		return null;
  	}

  	parser.inAttribute = false;
  	return tokens;
  }

  function readQuotedAttributeValue(parser, quoteMark) {
  	var start, tokens, token;

  	start = parser.pos;

  	if (!parser.matchString(quoteMark)) {
  		return null;
  	}

  	parser.inAttribute = quoteMark;

  	tokens = [];

  	token = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);
  	while (token !== null) {
  		tokens.push(token);
  		token = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);
  	}

  	if (!parser.matchString(quoteMark)) {
  		parser.pos = start;
  		return null;
  	}

  	parser.inAttribute = false;

  	return tokens;
  }

  function readQuotedStringToken(parser, quoteMark) {
  	var start, index, haystack, needles;

  	start = parser.pos;
  	haystack = parser.remaining();

  	needles = parser.tags.map(function (t) {
  		return t.open;
  	}); // TODO refactor... we do this in readText.js as well
  	needles.push(quoteMark);

  	index = getLowestIndex(haystack, needles);

  	if (index === -1) {
  		parser.error("Quoted attribute value must have a closing quote");
  	}

  	if (!index) {
  		return null;
  	}

  	parser.pos += index;
  	return haystack.substr(0, index);
  }

  var JsonParser, specials, specialsPattern, parseJSON__numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;

  specials = {
  	"true": true,
  	"false": false,
  	undefined: undefined,
  	"null": null
  };

  specialsPattern = new RegExp("^(?:" + Object.keys(specials).join("|") + ")");
  parseJSON__numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
  placeholderPattern = /\$\{([^\}]+)\}/g;
  placeholderAtStartPattern = /^\$\{([^\}]+)\}/;
  onlyWhitespace = /^\s*$/;

  JsonParser = parse_Parser.extend({
  	init: function (str, options) {
  		this.values = options.values;
  		this.allowWhitespace();
  	},

  	postProcess: function (result) {
  		if (result.length !== 1 || !onlyWhitespace.test(this.leftover)) {
  			return null;
  		}

  		return { value: result[0].v };
  	},

  	converters: [function getPlaceholder(parser) {
  		var placeholder;

  		if (!parser.values) {
  			return null;
  		}

  		placeholder = parser.matchPattern(placeholderAtStartPattern);

  		if (placeholder && parser.values.hasOwnProperty(placeholder)) {
  			return { v: parser.values[placeholder] };
  		}
  	}, function getSpecial(parser) {
  		var special;

  		if (special = parser.matchPattern(specialsPattern)) {
  			return { v: specials[special] };
  		}
  	}, function getNumber(parser) {
  		var number;

  		if (number = parser.matchPattern(parseJSON__numberPattern)) {
  			return { v: +number };
  		}
  	}, function getString(parser) {
  		var stringLiteral = readStringLiteral(parser),
  		    values;

  		if (stringLiteral && (values = parser.values)) {
  			return {
  				v: stringLiteral.v.replace(placeholderPattern, function (match, $1) {
  					return $1 in values ? values[$1] : $1;
  				})
  			};
  		}

  		return stringLiteral;
  	}, function getObject(parser) {
  		var result, pair;

  		if (!parser.matchString("{")) {
  			return null;
  		}

  		result = {};

  		parser.allowWhitespace();

  		if (parser.matchString("}")) {
  			return { v: result };
  		}

  		while (pair = getKeyValuePair(parser)) {
  			result[pair.key] = pair.value;

  			parser.allowWhitespace();

  			if (parser.matchString("}")) {
  				return { v: result };
  			}

  			if (!parser.matchString(",")) {
  				return null;
  			}
  		}

  		return null;
  	}, function getArray(parser) {
  		var result, valueToken;

  		if (!parser.matchString("[")) {
  			return null;
  		}

  		result = [];

  		parser.allowWhitespace();

  		if (parser.matchString("]")) {
  			return { v: result };
  		}

  		while (valueToken = parser.read()) {
  			result.push(valueToken.v);

  			parser.allowWhitespace();

  			if (parser.matchString("]")) {
  				return { v: result };
  			}

  			if (!parser.matchString(",")) {
  				return null;
  			}

  			parser.allowWhitespace();
  		}

  		return null;
  	}]
  });

  function getKeyValuePair(parser) {
  	var key, valueToken, pair;

  	parser.allowWhitespace();

  	key = shared_readKey(parser);

  	if (!key) {
  		return null;
  	}

  	pair = { key: key };

  	parser.allowWhitespace();
  	if (!parser.matchString(":")) {
  		return null;
  	}
  	parser.allowWhitespace();

  	valueToken = parser.read();
  	if (!valueToken) {
  		return null;
  	}

  	pair.value = valueToken.v;

  	return pair;
  }

  var parseJSON = function (str, values) {
  	var parser = new JsonParser(str, {
  		values: values
  	});

  	return parser.result;
  };

  // TODO clean this up, it's shocking
  var element_processDirective = processDirective;
  var methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\(/,
      methodCallExcessPattern = /\)\s*$/,
      ExpressionParser;

  ExpressionParser = parse_Parser.extend({
  	converters: [converters_readExpression]
  });
  function processDirective(tokens, parentParser) {
  	var result, match, parser, args, token, colonIndex, directiveName, directiveArgs, parsed;

  	if (typeof tokens === "string") {
  		if (match = methodCallPattern.exec(tokens)) {
  			var end = tokens.lastIndexOf(")");

  			// check for invalid method calls
  			if (!methodCallExcessPattern.test(tokens)) {
  				parentParser.error("Invalid input after method call expression '" + tokens.slice(end + 1) + "'");
  			}

  			result = { m: match[1] };
  			args = "[" + tokens.slice(result.m.length + 1, end) + "]";

  			parser = new ExpressionParser(args);
  			result.a = utils_flattenExpression(parser.result[0]);

  			return result;
  		}

  		if (tokens.indexOf(":") === -1) {
  			return tokens.trim();
  		}

  		tokens = [tokens];
  	}

  	result = {};

  	directiveName = [];
  	directiveArgs = [];

  	if (tokens) {
  		while (tokens.length) {
  			token = tokens.shift();

  			if (typeof token === "string") {
  				colonIndex = token.indexOf(":");

  				if (colonIndex === -1) {
  					directiveName.push(token);
  				} else {

  					// is the colon the first character?
  					if (colonIndex) {
  						// no
  						directiveName.push(token.substr(0, colonIndex));
  					}

  					// if there is anything after the colon in this token, treat
  					// it as the first token of the directiveArgs fragment
  					if (token.length > colonIndex + 1) {
  						directiveArgs[0] = token.substring(colonIndex + 1);
  					}

  					break;
  				}
  			} else {
  				directiveName.push(token);
  			}
  		}

  		directiveArgs = directiveArgs.concat(tokens);
  	}

  	if (!directiveName.length) {
  		result = "";
  	} else if (directiveArgs.length || typeof directiveName !== "string") {
  		result = {
  			// TODO is this really necessary? just use the array
  			n: directiveName.length === 1 && typeof directiveName[0] === "string" ? directiveName[0] : directiveName
  		};

  		if (directiveArgs.length === 1 && typeof directiveArgs[0] === "string") {
  			parsed = parseJSON("[" + directiveArgs[0] + "]");
  			result.a = parsed ? parsed.value : directiveArgs[0].trim();
  		} else {
  			result.d = directiveArgs;
  		}
  	} else {
  		result = directiveName;
  	}

  	return result;
  }

  var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/,
      validTagNameFollower = /^[\s\n\/>]/,
      onPattern = /^on/,
      proxyEventPattern = /^on-([a-zA-Z\\*\\.$_][a-zA-Z\\*\\.$_0-9\-]+)$/,
      reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,
      directives = { "intro-outro": "t0", intro: "t1", outro: "t2", decorator: "o" },
      exclude = { exclude: true },
      disallowedContents;

  // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
  disallowedContents = {
  	li: ["li"],
  	dt: ["dt", "dd"],
  	dd: ["dt", "dd"],
  	p: "address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul".split(" "),
  	rt: ["rt", "rp"],
  	rp: ["rt", "rp"],
  	optgroup: ["optgroup"],
  	option: ["option", "optgroup"],
  	thead: ["tbody", "tfoot"],
  	tbody: ["tbody", "tfoot"],
  	tfoot: ["tbody"],
  	tr: ["tr", "tbody"],
  	td: ["td", "th", "tr"],
  	th: ["td", "th", "tr"]
  };

  var converters_readElement = readElement;

  function readElement(parser) {
  	var start, element, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, partials, hasPartials, child, closed, pos, remaining, closingTag;

  	start = parser.pos;

  	if (parser.inside || parser.inAttribute) {
  		return null;
  	}

  	if (!parser.matchString("<")) {
  		return null;
  	}

  	// if this is a closing tag, abort straight away
  	if (parser.nextChar() === "/") {
  		return null;
  	}

  	element = {};
  	if (parser.includeLinePositions) {
  		element.p = parser.getLinePos(start);
  	}

  	if (parser.matchString("!")) {
  		element.t = DOCTYPE;
  		if (!parser.matchPattern(/^doctype/i)) {
  			parser.error("Expected DOCTYPE declaration");
  		}

  		element.a = parser.matchPattern(/^(.+?)>/);
  		return element;
  	}

  	element.t = ELEMENT;

  	// element name
  	element.e = parser.matchPattern(tagNamePattern);
  	if (!element.e) {
  		return null;
  	}

  	// next character must be whitespace, closing solidus or '>'
  	if (!validTagNameFollower.test(parser.nextChar())) {
  		parser.error("Illegal tag name");
  	}

  	addProxyEvent = function (name, directive) {
  		var directiveName = directive.n || directive;

  		if (reservedEventNames.test(directiveName)) {
  			parser.pos -= directiveName.length;
  			parser.error("Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)");
  		}

  		element.v[name] = directive;
  	};

  	parser.allowWhitespace();

  	// directives and attributes
  	while (attribute = converters_readMustache(parser) || element_readAttribute(parser)) {
  		// regular attributes
  		if (attribute.name) {
  			// intro, outro, decorator
  			if (directiveName = directives[attribute.name]) {
  				element[directiveName] = element_processDirective(attribute.value, parser);
  			}

  			// on-click etc
  			else if (match = proxyEventPattern.exec(attribute.name)) {
  				if (!element.v) element.v = {};
  				directive = element_processDirective(attribute.value, parser);
  				addProxyEvent(match[1], directive);
  			} else {
  				if (!parser.sanitizeEventAttributes || !onPattern.test(attribute.name)) {
  					if (!element.a) element.a = {};
  					element.a[attribute.name] = attribute.value || (attribute.value === "" ? "" : 0);
  				}
  			}
  		}

  		// {{#if foo}}class='foo'{{/if}}
  		else {
  			if (!element.m) element.m = [];
  			element.m.push(attribute);
  		}

  		parser.allowWhitespace();
  	}

  	// allow whitespace before closing solidus
  	parser.allowWhitespace();

  	// self-closing solidus?
  	if (parser.matchString("/")) {
  		selfClosing = true;
  	}

  	// closing angle bracket
  	if (!parser.matchString(">")) {
  		return null;
  	}

  	var lowerCaseName = element.e.toLowerCase();
  	var preserveWhitespace = parser.preserveWhitespace;

  	if (!selfClosing && !voidElementNames.test(element.e)) {
  		parser.elementStack.push(lowerCaseName);

  		// Special case - if we open a script element, further tags should
  		// be ignored unless they're a closing script element
  		if (lowerCaseName === "script" || lowerCaseName === "style") {
  			parser.inside = lowerCaseName;
  		}

  		children = [];
  		partials = create(null);

  		do {
  			pos = parser.pos;
  			remaining = parser.remaining();

  			// if for example we're in an <li> element, and we see another
  			// <li> tag, close the first so they become siblings
  			if (!canContain(lowerCaseName, remaining)) {
  				closed = true;
  			}

  			// closing tag
  			else if (closingTag = element_readClosingTag(parser)) {
  				closed = true;

  				var closingTagName = closingTag.e.toLowerCase();

  				// if this *isn't* the closing tag for the current element...
  				if (closingTagName !== lowerCaseName) {
  					// rewind parser
  					parser.pos = pos;

  					// if it doesn't close a parent tag, error
  					if (! ~parser.elementStack.indexOf(closingTagName)) {
  						var errorMessage = "Unexpected closing tag";

  						// add additional help for void elements, since component names
  						// might clash with them
  						if (voidElementNames.test(closingTagName)) {
  							errorMessage += " (<" + closingTagName + "> is a void element - it cannot contain children)";
  						}

  						parser.error(errorMessage);
  					}
  				}
  			}

  			// implicit close by closing section tag. TODO clean this up
  			else if (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {
  				closed = true;
  				parser.pos = pos;
  			} else {
  				if (child = parser.read(PARTIAL_READERS)) {
  					if (partials[child.n]) {
  						parser.pos = pos;
  						parser.error("Duplicate partial definition");
  					}

  					utils_cleanup(child.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);

  					partials[child.n] = child.f;
  					hasPartials = true;
  				} else {
  					if (child = parser.read(READERS)) {
  						children.push(child);
  					} else {
  						closed = true;
  					}
  				}
  			}
  		} while (!closed);

  		if (children.length) {
  			element.f = children;
  		}

  		if (hasPartials) {
  			element.p = partials;
  		}

  		parser.elementStack.pop();
  	}

  	parser.inside = null;

  	if (parser.sanitizeElements && parser.sanitizeElements.indexOf(lowerCaseName) !== -1) {
  		return exclude;
  	}

  	return element;
  }

  function canContain(name, remaining) {
  	var match, disallowed;

  	match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec(remaining);
  	disallowed = disallowedContents[name];

  	if (!match || !disallowed) {
  		return true;
  	}

  	return ! ~disallowed.indexOf(match[1].toLowerCase());
  }

  var converters_readText = readText;
  function readText(parser) {
  	var index, remaining, disallowed, barrier;

  	remaining = parser.remaining();

  	barrier = parser.inside ? "</" + parser.inside : "<";

  	if (parser.inside && !parser.interpolate[parser.inside]) {
  		index = remaining.indexOf(barrier);
  	} else {
  		disallowed = parser.tags.map(function (t) {
  			return t.open;
  		});
  		disallowed = disallowed.concat(parser.tags.map(function (t) {
  			return "\\" + t.open;
  		}));

  		// http://developers.whatwg.org/syntax.html#syntax-attributes
  		if (parser.inAttribute === true) {
  			// we're inside an unquoted attribute value
  			disallowed.push("\"", "'", "=", "<", ">", "`");
  		} else if (parser.inAttribute) {
  			// quoted attribute value
  			disallowed.push(parser.inAttribute);
  		} else {
  			disallowed.push(barrier);
  		}

  		index = getLowestIndex(remaining, disallowed);
  	}

  	if (!index) {
  		return null;
  	}

  	if (index === -1) {
  		index = remaining.length;
  	}

  	parser.pos += index;

  	return parser.inside ? remaining.substr(0, index) : decodeCharacterReferences(remaining.substr(0, index));
  }

  var utils_escapeRegExp = escapeRegExp;
  var utils_escapeRegExp__pattern = /[-/\\^$*+?.()|[\]{}]/g;
  function escapeRegExp(str) {
  	return str.replace(utils_escapeRegExp__pattern, "\\$&");
  }

  var converters_readPartialDefinitionComment = readPartialDefinitionComment;

  var startPattern = /^<!--\s*/,
      namePattern = /s*>\s*([a-zA-Z_$][-a-zA-Z_$0-9]*)\s*/,
      finishPattern = /\s*-->/,
      child;

  function readPartialDefinitionComment(parser) {
  	var firstPos = parser.pos,
  	    open = parser.standardDelimiters[0],
  	    close = parser.standardDelimiters[1],
  	    content = undefined,
  	    closed = undefined;

  	if (!parser.matchPattern(startPattern) || !parser.matchString(open)) {
  		parser.pos = firstPos;
  		return null;
  	}

  	var name = parser.matchPattern(namePattern);

  	warnOnceIfDebug("Inline partial comments are deprecated.\nUse this...\n  {{#partial " + name + "}} ... {{/partial}}\n\n...instead of this:\n  <!-- {{>" + name + "}} --> ... <!-- {{/" + name + "}} -->'");

  	// make sure the rest of the comment is in the correct place
  	if (!parser.matchString(close) || !parser.matchPattern(finishPattern)) {
  		parser.pos = firstPos;
  		return null;
  	}

  	content = [];

  	var endPattern = new RegExp("^<!--\\s*" + utils_escapeRegExp(open) + "\\s*\\/\\s*" + name + "\\s*" + utils_escapeRegExp(close) + "\\s*-->");

  	do {
  		if (parser.matchPattern(endPattern)) {
  			closed = true;
  		} else {
  			child = parser.read(READERS);
  			if (!child) {
  				parser.error("expected closing comment ('<!-- " + open + "/" + name + "" + close + " -->')");
  			}

  			content.push(child);
  		}
  	} while (!closed);

  	return {
  		t: INLINE_PARTIAL,
  		f: content,
  		n: name
  	};
  }

  var converters_readPartialDefinitionSection = readPartialDefinitionSection;
  var partialDefinitionSectionPattern = /^#\s*partial\s+/;
  function readPartialDefinitionSection(parser) {
  	var start, name, content, child, closed;

  	start = parser.pos;

  	var delimiters = parser.standardDelimiters;

  	if (!parser.matchString(delimiters[0])) {
  		return null;
  	}

  	if (!parser.matchPattern(partialDefinitionSectionPattern)) {
  		parser.pos = start;
  		return null;
  	}

  	name = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\-]*/);

  	if (!name) {
  		parser.error("expected legal partial name");
  	}

  	if (!parser.matchString(delimiters[1])) {
  		parser.error("Expected closing delimiter '" + delimiters[1] + "'");
  	}

  	content = [];

  	do {
  		// TODO clean this up
  		if (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {
  			if (!child.r === "partial") {
  				parser.error("Expected " + delimiters[0] + "/partial" + delimiters[1]);
  			}

  			closed = true;
  		} else {
  			child = parser.read(READERS);

  			if (!child) {
  				parser.error("Expected " + delimiters[0] + "/partial" + delimiters[1]);
  			}

  			content.push(child);
  		}
  	} while (!closed);

  	return {
  		t: INLINE_PARTIAL,
  		n: name,
  		f: content
  	};
  }

  var converters_readTemplate = readTemplate;
  function readTemplate(parser) {
  	var fragment = [];
  	var partials = create(null);
  	var hasPartials = false;

  	var preserveWhitespace = parser.preserveWhitespace;

  	while (parser.pos < parser.str.length) {
  		var pos = parser.pos,
  		    item = undefined,
  		    partial = undefined;

  		if (partial = parser.read(PARTIAL_READERS)) {
  			if (partials[partial.n]) {
  				parser.pos = pos;
  				parser.error("Duplicated partial definition");
  			}

  			utils_cleanup(partial.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);

  			partials[partial.n] = partial.f;
  			hasPartials = true;
  		} else if (item = parser.read(READERS)) {
  			fragment.push(item);
  		} else {
  			parser.error("Unexpected template content");
  		}
  	}

  	var result = {
  		v: TEMPLATE_VERSION,
  		t: fragment
  	};

  	if (hasPartials) {
  		result.p = partials;
  	}

  	return result;
  }

  var _parse = parse;

  var STANDARD_READERS = [mustache_readPartial, mustache_readUnescaped, mustache_readSection, mustache_readYielder, mustache_readInterpolator, readMustacheComment];
  var TRIPLE_READERS = [mustache_readTriple];
  var STATIC_READERS = [mustache_readUnescaped, mustache_readSection, mustache_readInterpolator]; // TODO does it make sense to have a static section?

  var StandardParser = undefined;
  function parse(template, options) {
  	return new StandardParser(template, options || {}).result;
  }

  var READERS = [converters_readMustache, converters_readHtmlComment, converters_readElement, converters_readText];
  var PARTIAL_READERS = [converters_readPartialDefinitionComment, converters_readPartialDefinitionSection];

  StandardParser = parse_Parser.extend({
  	init: function (str, options) {
  		var tripleDelimiters = options.tripleDelimiters || ["{{{", "}}}"],
  		    staticDelimiters = options.staticDelimiters || ["[[", "]]"],
  		    staticTripleDelimiters = options.staticTripleDelimiters || ["[[[", "]]]"];

  		this.standardDelimiters = options.delimiters || ["{{", "}}"];

  		this.tags = [{ isStatic: false, isTriple: false, open: this.standardDelimiters[0], close: this.standardDelimiters[1], readers: STANDARD_READERS }, { isStatic: false, isTriple: true, open: tripleDelimiters[0], close: tripleDelimiters[1], readers: TRIPLE_READERS }, { isStatic: true, isTriple: false, open: staticDelimiters[0], close: staticDelimiters[1], readers: STATIC_READERS }, { isStatic: true, isTriple: true, open: staticTripleDelimiters[0], close: staticTripleDelimiters[1], readers: TRIPLE_READERS }];

  		this.sortMustacheTags();

  		this.sectionDepth = 0;
  		this.elementStack = [];

  		this.interpolate = {
  			script: !options.interpolate || options.interpolate.script !== false,
  			style: !options.interpolate || options.interpolate.style !== false
  		};

  		if (options.sanitize === true) {
  			options.sanitize = {
  				// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json
  				elements: "applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title".split(" "),
  				eventAttributes: true
  			};
  		}

  		this.stripComments = options.stripComments !== false;
  		this.preserveWhitespace = options.preserveWhitespace;
  		this.sanitizeElements = options.sanitize && options.sanitize.elements;
  		this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;
  		this.includeLinePositions = options.includeLinePositions;
  	},

  	postProcess: function (result) {
  		// special case - empty string
  		if (!result.length) {
  			return { t: [], v: TEMPLATE_VERSION };
  		}

  		if (this.sectionDepth > 0) {
  			this.error("A section was left open");
  		}

  		utils_cleanup(result[0].t, this.stripComments, this.preserveWhitespace, !this.preserveWhitespace, !this.preserveWhitespace);

  		return result[0];
  	},

  	converters: [converters_readTemplate],

  	sortMustacheTags: function () {
  		// Sort in order of descending opening delimiter length (longer first),
  		// to protect against opening delimiters being substrings of each other
  		this.tags.sort(function (a, b) {
  			return b.open.length - a.open.length;
  		});
  	}
  });

  var parseOptions = ["preserveWhitespace", "sanitize", "stripComments", "delimiters", "tripleDelimiters", "interpolate"];

  var parser = {
  	fromId: fromId, isHashedId: isHashedId, isParsed: isParsed, getParseOptions: getParseOptions, createHelper: template_parser__createHelper,
  	parse: doParse
  };

  function template_parser__createHelper(parseOptions) {
  	var helper = create(parser);
  	helper.parse = function (template, options) {
  		return doParse(template, options || parseOptions);
  	};
  	return helper;
  }

  function doParse(template, parseOptions) {
  	if (!_parse) {
  		throw new Error("Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser");
  	}

  	return _parse(template, parseOptions || this.options);
  }

  function fromId(id, options) {
  	var template;

  	if (!isClient) {
  		if (options && options.noThrow) {
  			return;
  		}
  		throw new Error("Cannot retrieve template #" + id + " as Ractive is not running in a browser.");
  	}

  	if (isHashedId(id)) {
  		id = id.substring(1);
  	}

  	if (!(template = document.getElementById(id))) {
  		if (options && options.noThrow) {
  			return;
  		}
  		throw new Error("Could not find template element with id #" + id);
  	}

  	if (template.tagName.toUpperCase() !== "SCRIPT") {
  		if (options && options.noThrow) {
  			return;
  		}
  		throw new Error("Template element with id #" + id + ", must be a <script> element");
  	}

  	return "textContent" in template ? template.textContent : template.innerHTML;
  }

  function isHashedId(id) {
  	return id && id[0] === "#";
  }

  function isParsed(template) {
  	return !(typeof template === "string");
  }

  function getParseOptions(ractive) {
  	// Could be Ractive or a Component
  	if (ractive.defaults) {
  		ractive = ractive.defaults;
  	}

  	return parseOptions.reduce(function (val, key) {
  		val[key] = ractive[key];
  		return val;
  	}, {});
  }

  var template_parser = parser;

  var templateConfigurator = {
  	name: "template",

  	extend: function extend(Parent, proto, options) {
  		var template;

  		// only assign if exists
  		if ("template" in options) {
  			template = options.template;

  			if (typeof template === "function") {
  				proto.template = template;
  			} else {
  				proto.template = parseIfString(template, proto);
  			}
  		}
  	},

  	init: function init(Parent, ractive, options) {
  		var template, fn;

  		// TODO because of prototypal inheritance, we might just be able to use
  		// ractive.template, and not bother passing through the Parent object.
  		// At present that breaks the test mocks' expectations
  		template = "template" in options ? options.template : Parent.prototype.template;

  		if (typeof template === "function") {
  			fn = template;
  			template = getDynamicTemplate(ractive, fn);

  			ractive._config.template = {
  				fn: fn,
  				result: template
  			};
  		}

  		template = parseIfString(template, ractive);

  		// TODO the naming of this is confusing - ractive.template refers to [...],
  		// but Component.prototype.template refers to {v:1,t:[],p:[]}...
  		// it's unnecessary, because the developer never needs to access
  		// ractive.template
  		ractive.template = template.t;

  		if (template.p) {
  			extendPartials(ractive.partials, template.p);
  		}
  	},

  	reset: function (ractive) {
  		var result = resetValue(ractive),
  		    parsed;

  		if (result) {
  			parsed = parseIfString(result, ractive);

  			ractive.template = parsed.t;
  			extendPartials(ractive.partials, parsed.p, true);

  			return true;
  		}
  	}
  };

  function resetValue(ractive) {
  	var initial = ractive._config.template,
  	    result;

  	// If this isn't a dynamic template, there's nothing to do
  	if (!initial || !initial.fn) {
  		return;
  	}

  	result = getDynamicTemplate(ractive, initial.fn);

  	// TODO deep equality check to prevent unnecessary re-rendering
  	// in the case of already-parsed templates
  	if (result !== initial.result) {
  		initial.result = result;
  		result = parseIfString(result, ractive);
  		return result;
  	}
  }

  function getDynamicTemplate(ractive, fn) {
  	var helper = template_template__createHelper(template_parser.getParseOptions(ractive));
  	return fn.call(ractive, helper);
  }

  function template_template__createHelper(parseOptions) {
  	var helper = create(template_parser);
  	helper.parse = function (template, options) {
  		return template_parser.parse(template, options || parseOptions);
  	};
  	return helper;
  }

  function parseIfString(template, ractive) {
  	if (typeof template === "string") {
  		// ID of an element containing the template?
  		if (template[0] === "#") {
  			template = template_parser.fromId(template);
  		}

  		template = _parse(template, template_parser.getParseOptions(ractive));
  	}

  	// Check that the template even exists
  	else if (template == undefined) {
  		throw new Error("The template cannot be " + template + ".");
  	}

  	// Check the parsed template has a version at all
  	else if (typeof template.v !== "number") {
  		throw new Error("The template parser was passed a non-string template, but the template doesn't have a version.  Make sure you're passing in the template you think you are.");
  	}

  	// Check we're using the correct version
  	else if (template.v !== TEMPLATE_VERSION) {
  		throw new Error("Mismatched template version (expected " + TEMPLATE_VERSION + ", got " + template.v + ") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app");
  	}

  	return template;
  }

  function extendPartials(existingPartials, newPartials, overwrite) {
  	if (!newPartials) return;

  	// TODO there's an ambiguity here - we need to overwrite in the `reset()`
  	// case, but not initially...

  	for (var key in newPartials) {
  		if (overwrite || !existingPartials.hasOwnProperty(key)) {
  			existingPartials[key] = newPartials[key];
  		}
  	}
  }

  var template_template = templateConfigurator;

  var config_registries__registryNames, Registry, registries;

  config_registries__registryNames = ["adaptors", "components", "computed", "decorators", "easing", "events", "interpolators", "partials", "transitions"];

  Registry = function (name, useDefaults) {
  	this.name = name;
  	this.useDefaults = useDefaults;
  };

  Registry.prototype = {
  	constructor: Registry,

  	extend: function (Parent, proto, options) {
  		this.configure(this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options);
  	},

  	init: function () {},

  	configure: function (Parent, target, options) {
  		var name = this.name,
  		    option = options[name],
  		    registry;

  		registry = create(Parent[name]);

  		for (var key in option) {
  			registry[key] = option[key];
  		}

  		target[name] = registry;
  	},

  	reset: function (ractive) {
  		var registry = ractive[this.name];
  		var changed = false;
  		Object.keys(registry).forEach(function (key) {
  			var item = registry[key];
  			if (item._fn) {
  				if (item._fn.isOwner) {
  					registry[key] = item._fn;
  				} else {
  					delete registry[key];
  				}
  				changed = true;
  			}
  		});
  		return changed;
  	}
  };

  registries = config_registries__registryNames.map(function (name) {
  	return new Registry(name, name === "computed");
  });

  var config_registries = registries;

  /*this.configure(
  	this.useDefaults ? Parent.defaults : Parent,
  	ractive,
  	options );*/

  var wrapPrototype = wrap;

  function wrap(parent, name, method) {
  	if (!/_super/.test(method)) {
  		return method;
  	}

  	var wrapper = function wrapSuper() {
  		var superMethod = getSuperMethod(wrapper._parent, name),
  		    hasSuper = ("_super" in this),
  		    oldSuper = this._super,
  		    result;

  		this._super = superMethod;

  		result = method.apply(this, arguments);

  		if (hasSuper) {
  			this._super = oldSuper;
  		} else {
  			delete this._super;
  		}

  		return result;
  	};

  	wrapper._parent = parent;
  	wrapper._method = method;

  	return wrapper;
  }

  function getSuperMethod(parent, name) {
  	var value, method;

  	if (name in parent) {
  		value = parent[name];

  		if (typeof value === "function") {
  			method = value;
  		} else {
  			method = function returnValue() {
  				return value;
  			};
  		}
  	} else {
  		method = noop;
  	}

  	return method;
  }

  var config_deprecate = deprecate;
  function getMessage(deprecated, correct, isError) {
  	return "options." + deprecated + " has been deprecated in favour of options." + correct + "." + (isError ? " You cannot specify both options, please use options." + correct + "." : "");
  }

  function deprecateOption(options, deprecatedOption, correct) {
  	if (deprecatedOption in options) {
  		if (!(correct in options)) {
  			warnIfDebug(getMessage(deprecatedOption, correct));
  			options[correct] = options[deprecatedOption];
  		} else {
  			throw new Error(getMessage(deprecatedOption, correct, true));
  		}
  	}
  }
  function deprecate(options) {
  	deprecateOption(options, "beforeInit", "onconstruct");
  	deprecateOption(options, "init", "onrender");
  	deprecateOption(options, "complete", "oncomplete");
  	deprecateOption(options, "eventDefinitions", "events");

  	// Using extend with Component instead of options,
  	// like Human.extend( Spider ) means adaptors as a registry
  	// gets copied to options. So we have to check if actually an array
  	if (isArray(options.adaptors)) {
  		deprecateOption(options, "adaptors", "adapt");
  	}
  }

  var config, order, defaultKeys, custom, isBlacklisted, isStandardKey;

  custom = {
  	adapt: custom_adapt,
  	css: css_css,
  	data: custom_data,
  	template: template_template
  };

  defaultKeys = Object.keys(config_defaults);

  isStandardKey = makeObj(defaultKeys.filter(function (key) {
  	return !custom[key];
  }));

  // blacklisted keys that we don't double extend
  isBlacklisted = makeObj(defaultKeys.concat(config_registries.map(function (r) {
  	return r.name;
  })));

  order = [].concat(defaultKeys.filter(function (key) {
  	return !config_registries[key] && !custom[key];
  }), config_registries, custom.data, custom.template, custom.css);

  config = {
  	extend: function (Parent, proto, options) {
  		return configure("extend", Parent, proto, options);
  	},

  	init: function (Parent, ractive, options) {
  		return configure("init", Parent, ractive, options);
  	},

  	reset: function (ractive) {
  		return order.filter(function (c) {
  			return c.reset && c.reset(ractive);
  		}).map(function (c) {
  			return c.name;
  		});
  	},

  	// this defines the order. TODO this isn't used anywhere in the codebase,
  	// only in the test suite - should get rid of it
  	order: order };

  function configure(method, Parent, target, options) {
  	config_deprecate(options);

  	for (var key in options) {
  		if (isStandardKey.hasOwnProperty(key)) {
  			var value = options[key];

  			// warn the developer if they passed a function and ignore its value

  			// NOTE: we allow some functions on "el" because we duck type element lists
  			// and some libraries or ef'ed-up virtual browsers (phantomJS) return a
  			// function object as the result of querySelector methods
  			if (key !== "el" && typeof value === "function") {
  				warnIfDebug("" + key + " is a Ractive option that does not expect a function and will be ignored", method === "init" ? target : null);
  			} else {
  				target[key] = value;
  			}
  		}
  	}

  	config_registries.forEach(function (registry) {
  		registry[method](Parent, target, options);
  	});

  	custom_adapt[method](Parent, target, options);
  	template_template[method](Parent, target, options);
  	css_css[method](Parent, target, options);

  	extendOtherMethods(Parent.prototype, target, options);
  }

  function extendOtherMethods(parent, target, options) {
  	for (var key in options) {
  		if (!isBlacklisted[key] && options.hasOwnProperty(key)) {
  			var member = options[key];

  			// if this is a method that overwrites a method, wrap it:
  			if (typeof member === "function") {
  				member = wrapPrototype(parent, key, member);
  			}

  			target[key] = member;
  		}
  	}
  }

  function makeObj(array) {
  	var obj = {};
  	array.forEach(function (x) {
  		return obj[x] = true;
  	});
  	return obj;
  }

  var config_config = config;

  var prototype_bubble = Fragment$bubble;

  function Fragment$bubble() {
  	this.dirtyValue = this.dirtyArgs = true;

  	if (this.bound && typeof this.owner.bubble === "function") {
  		this.owner.bubble();
  	}
  }

  var Fragment_prototype_detach = Fragment$detach;

  function Fragment$detach() {
  	var docFrag;

  	if (this.items.length === 1) {
  		return this.items[0].detach();
  	}

  	docFrag = document.createDocumentFragment();

  	this.items.forEach(function (item) {
  		var node = item.detach();

  		// TODO The if {...} wasn't previously required - it is now, because we're
  		// forcibly detaching everything to reorder sections after an update. That's
  		// a non-ideal brute force approach, implemented to get all the tests to pass
  		// - as soon as it's replaced with something more elegant, this should
  		// revert to `docFrag.appendChild( item.detach() )`
  		if (node) {
  			docFrag.appendChild(node);
  		}
  	});

  	return docFrag;
  }

  var Fragment_prototype_find = Fragment$find;

  function Fragment$find(selector) {
  	var i, len, item, queryResult;

  	if (this.items) {
  		len = this.items.length;
  		for (i = 0; i < len; i += 1) {
  			item = this.items[i];

  			if (item.find && (queryResult = item.find(selector))) {
  				return queryResult;
  			}
  		}

  		return null;
  	}
  }

  var Fragment_prototype_findAll = Fragment$findAll;

  function Fragment$findAll(selector, query) {
  	var i, len, item;

  	if (this.items) {
  		len = this.items.length;
  		for (i = 0; i < len; i += 1) {
  			item = this.items[i];

  			if (item.findAll) {
  				item.findAll(selector, query);
  			}
  		}
  	}

  	return query;
  }

  var Fragment_prototype_findAllComponents = Fragment$findAllComponents;

  function Fragment$findAllComponents(selector, query) {
  	var i, len, item;

  	if (this.items) {
  		len = this.items.length;
  		for (i = 0; i < len; i += 1) {
  			item = this.items[i];

  			if (item.findAllComponents) {
  				item.findAllComponents(selector, query);
  			}
  		}
  	}

  	return query;
  }

  var Fragment_prototype_findComponent = Fragment$findComponent;

  function Fragment$findComponent(selector) {
  	var len, i, item, queryResult;

  	if (this.items) {
  		len = this.items.length;
  		for (i = 0; i < len; i += 1) {
  			item = this.items[i];

  			if (item.findComponent && (queryResult = item.findComponent(selector))) {
  				return queryResult;
  			}
  		}

  		return null;
  	}
  }

  var prototype_findNextNode = Fragment$findNextNode;

  function Fragment$findNextNode(item) {
  	var index = item.index,
  	    node;

  	if (this.items[index + 1]) {
  		node = this.items[index + 1].firstNode();
  	}

  	// if this is the root fragment, and there are no more items,
  	// it means we're at the end...
  	else if (this.owner === this.root) {
  		if (!this.owner.component) {
  			// TODO but something else could have been appended to
  			// this.root.el, no?
  			node = null;
  		}

  		// ...unless this is a component
  		else {
  			node = this.owner.component.findNextNode();
  		}
  	} else {
  		node = this.owner.findNextNode(this);
  	}

  	return node;
  }

  var prototype_firstNode = Fragment$firstNode;

  function Fragment$firstNode() {
  	if (this.items && this.items[0]) {
  		return this.items[0].firstNode();
  	}

  	return null;
  }

  var shared_processItems = processItems;

  function processItems(items, values, guid, counter) {
  	counter = counter || 0;

  	return items.map(function (item) {
  		var placeholderId, wrapped, value;

  		if (item.text) {
  			return item.text;
  		}

  		if (item.fragments) {
  			return item.fragments.map(function (fragment) {
  				return processItems(fragment.items, values, guid, counter);
  			}).join("");
  		}

  		placeholderId = guid + "-" + counter++;

  		if (item.keypath && (wrapped = item.root.viewmodel.wrapped[item.keypath.str])) {
  			value = wrapped.value;
  		} else {
  			value = item.getValue();
  		}

  		values[placeholderId] = value;

  		return "${" + placeholderId + "}";
  	}).join("");
  }

  var getArgsList = Fragment$getArgsList;
  function Fragment$getArgsList() {
  	var values, source, parsed, result;

  	if (this.dirtyArgs) {
  		source = shared_processItems(this.items, values = {}, this.root._guid);
  		parsed = parseJSON("[" + source + "]", values);

  		if (!parsed) {
  			result = [this.toString()];
  		} else {
  			result = parsed.value;
  		}

  		this.argsList = result;
  		this.dirtyArgs = false;
  	}

  	return this.argsList;
  }

  var getNode = Fragment$getNode;

  function Fragment$getNode() {
  	var fragment = this;

  	do {
  		if (fragment.pElement) {
  			return fragment.pElement.node;
  		}
  	} while (fragment = fragment.parent);

  	return this.root.detached || this.root.el;
  }

  var prototype_getValue = Fragment$getValue;
  function Fragment$getValue() {
  	var values, source, parsed, result;

  	if (this.dirtyValue) {
  		source = shared_processItems(this.items, values = {}, this.root._guid);
  		parsed = parseJSON(source, values);

  		if (!parsed) {
  			result = this.toString();
  		} else {
  			result = parsed.value;
  		}

  		this.value = result;
  		this.dirtyValue = false;
  	}

  	return this.value;
  }

  var shared_detach = function () {
  	return detachNode(this.node);
  };

  var Text = function (options) {
  	this.type = TEXT;
  	this.text = options.template;
  };

  Text.prototype = {
  	detach: shared_detach,

  	firstNode: function () {
  		return this.node;
  	},

  	render: function () {
  		if (!this.node) {
  			this.node = document.createTextNode(this.text);
  		}

  		return this.node;
  	},

  	toString: function (escape) {
  		return escape ? escapeHtml(this.text) : this.text;
  	},

  	unrender: function (shouldDestroy) {
  		if (shouldDestroy) {
  			return this.detach();
  		}
  	}
  };

  var items_Text = Text;

  var shared_unbind = shared_unbind__unbind;

  function shared_unbind__unbind() {
  	if (this.registered) {
  		// this was registered as a dependant
  		this.root.viewmodel.unregister(this.keypath, this);
  	}

  	if (this.resolver) {
  		this.resolver.unbind();
  	}
  }

  var Mustache_getValue = Mustache$getValue;

  function Mustache$getValue() {
  	return this.value;
  }

  var ReferenceResolver = function (owner, ref, callback) {
  	var keypath;

  	this.ref = ref;
  	this.resolved = false;

  	this.root = owner.root;
  	this.parentFragment = owner.parentFragment;
  	this.callback = callback;

  	keypath = shared_resolveRef(owner.root, ref, owner.parentFragment);
  	if (keypath != undefined) {
  		this.resolve(keypath);
  	} else {
  		global_runloop.addUnresolved(this);
  	}
  };

  ReferenceResolver.prototype = {
  	resolve: function (keypath) {
  		if (this.keypath && !keypath) {
  			// it was resolved, and now it's not. Can happen if e.g. `bar` in
  			// `{{foo[bar]}}` becomes undefined
  			global_runloop.addUnresolved(this);
  		}

  		this.resolved = true;

  		this.keypath = keypath;
  		this.callback(keypath);
  	},

  	forceResolution: function () {
  		this.resolve(getKeypath(this.ref));
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		var keypath;

  		if (this.keypath != undefined) {
  			keypath = this.keypath.replace(oldKeypath, newKeypath);
  			// was a new keypath created?
  			if (keypath !== undefined) {
  				// resolve it
  				this.resolve(keypath);
  			}
  		}
  	},

  	unbind: function () {
  		if (!this.resolved) {
  			global_runloop.removeUnresolved(this);
  		}
  	}
  };

  var Resolvers_ReferenceResolver = ReferenceResolver;

  var SpecialResolver = function (owner, ref, callback) {
  	this.parentFragment = owner.parentFragment;
  	this.ref = ref;
  	this.callback = callback;

  	this.rebind();
  };

  var props = {
  	"@keypath": { prefix: "c", prop: ["context"] },
  	"@index": { prefix: "i", prop: ["index"] },
  	"@key": { prefix: "k", prop: ["key", "index"] }
  };

  function getProp(target, prop) {
  	var value;
  	for (var i = 0; i < prop.prop.length; i++) {
  		if ((value = target[prop.prop[i]]) !== undefined) {
  			return value;
  		}
  	}
  }

  SpecialResolver.prototype = {
  	rebind: function () {
  		var ref = this.ref,
  		    fragment = this.parentFragment,
  		    prop = props[ref],
  		    value;

  		if (!prop) {
  			throw new Error("Unknown special reference \"" + ref + "\" - valid references are @index, @key and @keypath");
  		}

  		// have we already found the nearest parent?
  		if (this.cached) {
  			return this.callback(getKeypath("@" + prop.prefix + getProp(this.cached, prop)));
  		}

  		// special case for indices, which may cross component boundaries
  		if (prop.prop.indexOf("index") !== -1 || prop.prop.indexOf("key") !== -1) {
  			while (fragment) {
  				if (fragment.owner.currentSubtype === SECTION_EACH && (value = getProp(fragment, prop)) !== undefined) {
  					this.cached = fragment;

  					fragment.registerIndexRef(this);

  					return this.callback(getKeypath("@" + prop.prefix + value));
  				}

  				// watch for component boundaries
  				if (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {
  					fragment = fragment.owner.component.parentFragment;
  				} else {
  					fragment = fragment.parent;
  				}
  			}
  		} else {
  			while (fragment) {
  				if ((value = getProp(fragment, prop)) !== undefined) {
  					return this.callback(getKeypath("@" + prop.prefix + value.str));
  				}

  				fragment = fragment.parent;
  			}
  		}
  	},

  	unbind: function () {
  		if (this.cached) {
  			this.cached.unregisterIndexRef(this);
  		}
  	}
  };

  var Resolvers_SpecialResolver = SpecialResolver;

  var IndexResolver = function (owner, ref, callback) {
  	this.parentFragment = owner.parentFragment;
  	this.ref = ref;
  	this.callback = callback;

  	ref.ref.fragment.registerIndexRef(this);

  	this.rebind();
  };

  IndexResolver.prototype = {
  	rebind: function () {
  		var index,
  		    ref = this.ref.ref;

  		if (ref.ref.t === "k") {
  			index = "k" + ref.fragment.key;
  		} else {
  			index = "i" + ref.fragment.index;
  		}

  		if (index !== undefined) {
  			this.callback(getKeypath("@" + index));
  		}
  	},

  	unbind: function () {
  		this.ref.ref.fragment.unregisterIndexRef(this);
  	}
  };

  var Resolvers_IndexResolver = IndexResolver;

  var Resolvers_findIndexRefs = findIndexRefs;

  function findIndexRefs(fragment, refName) {
  	var result = {},
  	    refs,
  	    fragRefs,
  	    ref,
  	    i,
  	    owner,
  	    hit = false;

  	if (!refName) {
  		result.refs = refs = {};
  	}

  	while (fragment) {
  		if ((owner = fragment.owner) && (fragRefs = owner.indexRefs)) {

  			// we're looking for a particular ref, and it's here
  			if (refName && (ref = owner.getIndexRef(refName))) {
  				result.ref = {
  					fragment: fragment,
  					ref: ref
  				};
  				return result;
  			}

  			// we're collecting refs up-tree
  			else if (!refName) {
  				for (i in fragRefs) {
  					ref = fragRefs[i];

  					// don't overwrite existing refs - they should shadow parents
  					if (!refs[ref.n]) {
  						hit = true;
  						refs[ref.n] = {
  							fragment: fragment,
  							ref: ref
  						};
  					}
  				}
  			}
  		}

  		// watch for component boundaries
  		if (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {
  			result.componentBoundary = true;
  			fragment = fragment.owner.component.parentFragment;
  		} else {
  			fragment = fragment.parent;
  		}
  	}

  	if (!hit) {
  		return undefined;
  	} else {
  		return result;
  	}
  }

  findIndexRefs.resolve = function resolve(indices) {
  	var refs = {},
  	    k,
  	    ref;

  	for (k in indices.refs) {
  		ref = indices.refs[k];
  		refs[ref.ref.n] = ref.ref.t === "k" ? ref.fragment.key : ref.fragment.index;
  	}

  	return refs;
  };

  var Resolvers_createReferenceResolver = createReferenceResolver;
  function createReferenceResolver(owner, ref, callback) {
  	var indexRef;

  	if (ref.charAt(0) === "@") {
  		return new Resolvers_SpecialResolver(owner, ref, callback);
  	}

  	if (indexRef = Resolvers_findIndexRefs(owner.parentFragment, ref)) {
  		return new Resolvers_IndexResolver(owner, indexRef, callback);
  	}

  	return new Resolvers_ReferenceResolver(owner, ref, callback);
  }

  var shared_getFunctionFromString = getFunctionFromString;
  var cache = {};
  function getFunctionFromString(str, i) {
  	var fn, args;

  	if (cache[str]) {
  		return cache[str];
  	}

  	args = [];
  	while (i--) {
  		args[i] = "_" + i;
  	}

  	fn = new Function(args.join(","), "return(" + str + ")");

  	cache[str] = fn;
  	return fn;
  }

  var ExpressionResolver,
      Resolvers_ExpressionResolver__bind = Function.prototype.bind;

  ExpressionResolver = function (owner, parentFragment, expression, callback) {
  	var _this = this;

  	var ractive;

  	ractive = owner.root;

  	this.root = ractive;
  	this.parentFragment = parentFragment;
  	this.callback = callback;
  	this.owner = owner;
  	this.str = expression.s;
  	this.keypaths = [];

  	// Create resolvers for each reference
  	this.pending = expression.r.length;
  	this.refResolvers = expression.r.map(function (ref, i) {
  		return Resolvers_createReferenceResolver(_this, ref, function (keypath) {
  			_this.resolve(i, keypath);
  		});
  	});

  	this.ready = true;
  	this.bubble();
  };

  ExpressionResolver.prototype = {
  	bubble: function () {
  		if (!this.ready) {
  			return;
  		}

  		this.uniqueString = getUniqueString(this.str, this.keypaths);
  		this.keypath = createExpressionKeypath(this.uniqueString);

  		this.createEvaluator();
  		this.callback(this.keypath);
  	},

  	unbind: function () {
  		var resolver;

  		while (resolver = this.refResolvers.pop()) {
  			resolver.unbind();
  		}
  	},

  	resolve: function (index, keypath) {
  		this.keypaths[index] = keypath;
  		this.bubble();
  	},

  	createEvaluator: function () {
  		var _this = this;

  		var computation, valueGetters, signature, keypath, fn;

  		keypath = this.keypath;
  		computation = this.root.viewmodel.computations[keypath.str];

  		// only if it doesn't exist yet!
  		if (!computation) {
  			fn = shared_getFunctionFromString(this.str, this.refResolvers.length);

  			valueGetters = this.keypaths.map(function (keypath) {
  				var value;

  				if (keypath === "undefined") {
  					return function () {
  						return undefined;
  					};
  				}

  				// 'special' keypaths encode a value
  				if (keypath.isSpecial) {
  					value = keypath.value;
  					return function () {
  						return value;
  					};
  				}

  				return function () {
  					var value = _this.root.viewmodel.get(keypath, { noUnwrap: true, fullRootGet: true });
  					if (typeof value === "function") {
  						value = wrapFunction(value, _this.root);
  					}
  					return value;
  				};
  			});

  			signature = {
  				deps: this.keypaths.filter(isValidDependency),
  				getter: function () {
  					var args = valueGetters.map(call);
  					return fn.apply(null, args);
  				}
  			};

  			computation = this.root.viewmodel.compute(keypath, signature);
  		} else {
  			this.root.viewmodel.mark(keypath);
  		}
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		// TODO only bubble once, no matter how many references are affected by the rebind
  		this.refResolvers.forEach(function (r) {
  			return r.rebind(oldKeypath, newKeypath);
  		});
  	}
  };

  var Resolvers_ExpressionResolver = ExpressionResolver;

  function call(value) {
  	return value.call();
  }

  function getUniqueString(str, keypaths) {
  	// get string that is unique to this expression
  	return str.replace(/_([0-9]+)/g, function (match, $1) {
  		var keypath, value;

  		// make sure we're not replacing a non-keypath _[0-9]
  		if (+$1 >= keypaths.length) {
  			return "_" + $1;
  		}

  		keypath = keypaths[$1];

  		if (keypath === undefined) {
  			return "undefined";
  		}

  		if (keypath.isSpecial) {
  			value = keypath.value;
  			return typeof value === "number" ? value : "\"" + value + "\"";
  		}

  		return keypath.str;
  	});
  }

  function createExpressionKeypath(uniqueString) {
  	// Sanitize by removing any periods or square brackets. Otherwise
  	// we can't split the keypath into keys!
  	// Remove asterisks too, since they mess with pattern observers
  	return getKeypath("${" + uniqueString.replace(/[\.\[\]]/g, "-").replace(/\*/, "#MUL#") + "}");
  }

  function isValidDependency(keypath) {
  	return keypath !== undefined && keypath[0] !== "@";
  }

  function wrapFunction(fn, ractive) {
  	var wrapped, prop, key;

  	if (fn.__ractive_nowrap) {
  		return fn;
  	}

  	prop = "__ractive_" + ractive._guid;
  	wrapped = fn[prop];

  	if (wrapped) {
  		return wrapped;
  	} else if (/this/.test(fn.toString())) {
  		defineProperty(fn, prop, {
  			value: Resolvers_ExpressionResolver__bind.call(fn, ractive),
  			configurable: true
  		});

  		// Add properties/methods to wrapped function
  		for (key in fn) {
  			if (fn.hasOwnProperty(key)) {
  				fn[prop][key] = fn[key];
  			}
  		}

  		ractive._boundFunctions.push({
  			fn: fn,
  			prop: prop
  		});

  		return fn[prop];
  	}

  	defineProperty(fn, "__ractive_nowrap", {
  		value: fn
  	});

  	return fn.__ractive_nowrap;
  }

  var MemberResolver = function (template, resolver, parentFragment) {
  	var _this = this;

  	this.resolver = resolver;
  	this.root = resolver.root;
  	this.parentFragment = parentFragment;
  	this.viewmodel = resolver.root.viewmodel;

  	if (typeof template === "string") {
  		this.value = template;
  	}

  	// Simple reference?
  	else if (template.t === REFERENCE) {
  		this.refResolver = Resolvers_createReferenceResolver(this, template.n, function (keypath) {
  			_this.resolve(keypath);
  		});
  	}

  	// Otherwise we have an expression in its own right
  	else {
  		new Resolvers_ExpressionResolver(resolver, parentFragment, template, function (keypath) {
  			_this.resolve(keypath);
  		});
  	}
  };

  MemberResolver.prototype = {
  	resolve: function (keypath) {
  		if (this.keypath) {
  			this.viewmodel.unregister(this.keypath, this);
  		}

  		this.keypath = keypath;
  		this.value = this.viewmodel.get(keypath);

  		this.bind();

  		this.resolver.bubble();
  	},

  	bind: function () {
  		this.viewmodel.register(this.keypath, this);
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		if (this.refResolver) {
  			this.refResolver.rebind(oldKeypath, newKeypath);
  		}
  	},

  	setValue: function (value) {
  		this.value = value;
  		this.resolver.bubble();
  	},

  	unbind: function () {
  		if (this.keypath) {
  			this.viewmodel.unregister(this.keypath, this);
  		}

  		if (this.refResolver) {
  			this.refResolver.unbind();
  		}
  	},

  	forceResolution: function () {
  		if (this.refResolver) {
  			this.refResolver.forceResolution();
  		}
  	}
  };

  var ReferenceExpressionResolver_MemberResolver = MemberResolver;

  var ReferenceExpressionResolver = function (mustache, template, callback) {
  	var _this = this;

  	var ractive, ref, keypath, parentFragment;

  	this.parentFragment = parentFragment = mustache.parentFragment;
  	this.root = ractive = mustache.root;
  	this.mustache = mustache;

  	this.ref = ref = template.r;
  	this.callback = callback;

  	this.unresolved = [];

  	// Find base keypath
  	if (keypath = shared_resolveRef(ractive, ref, parentFragment)) {
  		this.base = keypath;
  	} else {
  		this.baseResolver = new Resolvers_ReferenceResolver(this, ref, function (keypath) {
  			_this.base = keypath;
  			_this.baseResolver = null;
  			_this.bubble();
  		});
  	}

  	// Find values for members, or mark them as unresolved
  	this.members = template.m.map(function (template) {
  		return new ReferenceExpressionResolver_MemberResolver(template, _this, parentFragment);
  	});

  	this.ready = true;
  	this.bubble(); // trigger initial resolution if possible
  };

  ReferenceExpressionResolver.prototype = {
  	getKeypath: function () {
  		var values = this.members.map(ReferenceExpressionResolver_ReferenceExpressionResolver__getValue);

  		if (!values.every(isDefined) || this.baseResolver) {
  			return null;
  		}

  		return this.base.join(values.join("."));
  	},

  	bubble: function () {
  		if (!this.ready || this.baseResolver) {
  			return;
  		}

  		this.callback(this.getKeypath());
  	},

  	unbind: function () {
  		this.members.forEach(methodCallers__unbind);
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		var changed;

  		if (this.base) {
  			var newBase = this.base.replace(oldKeypath, newKeypath);
  			if (newBase && newBase !== this.base) {
  				this.base = newBase;
  				changed = true;
  			}
  		}

  		this.members.forEach(function (members) {
  			if (members.rebind(oldKeypath, newKeypath)) {
  				changed = true;
  			}
  		});

  		if (changed) {
  			this.bubble();
  		}
  	},

  	forceResolution: function () {
  		if (this.baseResolver) {
  			this.base = getKeypath(this.ref);

  			this.baseResolver.unbind();
  			this.baseResolver = null;
  		}

  		this.members.forEach(forceResolution);
  		this.bubble();
  	}
  };

  function ReferenceExpressionResolver_ReferenceExpressionResolver__getValue(member) {
  	return member.value;
  }

  function isDefined(value) {
  	return value != undefined;
  }

  function forceResolution(member) {
  	member.forceResolution();
  }

  var ReferenceExpressionResolver_ReferenceExpressionResolver = ReferenceExpressionResolver;

  var Mustache_initialise = Mustache$init;
  function Mustache$init(mustache, options) {

  	var ref, parentFragment, template;

  	parentFragment = options.parentFragment;
  	template = options.template;

  	mustache.root = parentFragment.root;
  	mustache.parentFragment = parentFragment;
  	mustache.pElement = parentFragment.pElement;

  	mustache.template = options.template;
  	mustache.index = options.index || 0;
  	mustache.isStatic = options.template.s;

  	mustache.type = options.template.t;

  	mustache.registered = false;

  	// if this is a simple mustache, with a reference, we just need to resolve
  	// the reference to a keypath
  	if (ref = template.r) {
  		mustache.resolver = Resolvers_createReferenceResolver(mustache, ref, resolve);
  	}

  	// if it's an expression, we have a bit more work to do
  	if (options.template.x) {
  		mustache.resolver = new Resolvers_ExpressionResolver(mustache, parentFragment, options.template.x, resolveAndRebindChildren);
  	}

  	if (options.template.rx) {
  		mustache.resolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(mustache, options.template.rx, resolveAndRebindChildren);
  	}

  	// Special case - inverted sections
  	if (mustache.template.n === SECTION_UNLESS && !mustache.hasOwnProperty("value")) {
  		mustache.setValue(undefined);
  	}

  	function resolve(keypath) {
  		mustache.resolve(keypath);
  	}

  	function resolveAndRebindChildren(newKeypath) {
  		var oldKeypath = mustache.keypath;

  		if (newKeypath != oldKeypath) {
  			mustache.resolve(newKeypath);

  			if (oldKeypath !== undefined) {
  				mustache.fragments && mustache.fragments.forEach(function (f) {
  					f.rebind(oldKeypath, newKeypath);
  				});
  			}
  		}
  	}
  }

  var Mustache_resolve = Mustache$resolve;

  function Mustache$resolve(keypath) {
  	var wasResolved, value, twowayBinding;

  	// 'Special' keypaths, e.g. @foo or @7, encode a value
  	if (keypath && keypath.isSpecial) {
  		this.keypath = keypath;
  		this.setValue(keypath.value);
  		return;
  	}

  	// If we resolved previously, we need to unregister
  	if (this.registered) {
  		// undefined or null
  		this.root.viewmodel.unregister(this.keypath, this);
  		this.registered = false;

  		wasResolved = true;
  	}

  	this.keypath = keypath;

  	// If the new keypath exists, we need to register
  	// with the viewmodel
  	if (keypath != undefined) {
  		// undefined or null
  		value = this.root.viewmodel.get(keypath);
  		this.root.viewmodel.register(keypath, this);

  		this.registered = true;
  	}

  	// Either way we need to queue up a render (`value`
  	// will be `undefined` if there's no keypath)
  	this.setValue(value);

  	// Two-way bindings need to point to their new target keypath
  	if (wasResolved && (twowayBinding = this.twowayBinding)) {
  		twowayBinding.rebound();
  	}
  }

  var Mustache_rebind = Mustache$rebind;

  function Mustache$rebind(oldKeypath, newKeypath) {
  	// Children first
  	if (this.fragments) {
  		this.fragments.forEach(function (f) {
  			return f.rebind(oldKeypath, newKeypath);
  		});
  	}

  	// Expression mustache?
  	if (this.resolver) {
  		this.resolver.rebind(oldKeypath, newKeypath);
  	}
  }

  var Mustache = {
  	getValue: Mustache_getValue,
  	init: Mustache_initialise,
  	resolve: Mustache_resolve,
  	rebind: Mustache_rebind
  };

  var Interpolator = function (options) {
  	this.type = INTERPOLATOR;
  	Mustache.init(this, options);
  };

  Interpolator.prototype = {
  	update: function () {
  		this.node.data = this.value == undefined ? "" : this.value;
  	},
  	resolve: Mustache.resolve,
  	rebind: Mustache.rebind,
  	detach: shared_detach,

  	unbind: shared_unbind,

  	render: function () {
  		if (!this.node) {
  			this.node = document.createTextNode(safeToStringValue(this.value));
  		}

  		return this.node;
  	},

  	unrender: function (shouldDestroy) {
  		if (shouldDestroy) {
  			detachNode(this.node);
  		}
  	},

  	getValue: Mustache.getValue,

  	// TEMP
  	setValue: function (value) {
  		var wrapper;

  		// TODO is there a better way to approach this?
  		if (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {
  			value = wrapper.get();
  		}

  		if (!isEqual(value, this.value)) {
  			this.value = value;
  			this.parentFragment.bubble();

  			if (this.node) {
  				global_runloop.addView(this);
  			}
  		}
  	},

  	firstNode: function () {
  		return this.node;
  	},

  	toString: function (escape) {
  		var string = "" + safeToStringValue(this.value);
  		return escape ? escapeHtml(string) : string;
  	}
  };

  var items_Interpolator = Interpolator;

  var Section_prototype_bubble = Section$bubble;

  function Section$bubble() {
  	this.parentFragment.bubble();
  }

  var Section_prototype_detach = Section$detach;

  function Section$detach() {
  	var docFrag;

  	if (this.fragments.length === 1) {
  		return this.fragments[0].detach();
  	}

  	docFrag = document.createDocumentFragment();

  	this.fragments.forEach(function (item) {
  		docFrag.appendChild(item.detach());
  	});

  	return docFrag;
  }

  var find = Section$find;

  function Section$find(selector) {
  	var i, len, queryResult;

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		if (queryResult = this.fragments[i].find(selector)) {
  			return queryResult;
  		}
  	}

  	return null;
  }

  var findAll = Section$findAll;

  function Section$findAll(selector, query) {
  	var i, len;

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		this.fragments[i].findAll(selector, query);
  	}
  }

  var findAllComponents = Section$findAllComponents;

  function Section$findAllComponents(selector, query) {
  	var i, len;

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		this.fragments[i].findAllComponents(selector, query);
  	}
  }

  var findComponent = Section$findComponent;

  function Section$findComponent(selector) {
  	var i, len, queryResult;

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		if (queryResult = this.fragments[i].findComponent(selector)) {
  			return queryResult;
  		}
  	}

  	return null;
  }

  var findNextNode = Section$findNextNode;

  function Section$findNextNode(fragment) {
  	if (this.fragments[fragment.index + 1]) {
  		return this.fragments[fragment.index + 1].firstNode();
  	}

  	return this.parentFragment.findNextNode(this);
  }

  var firstNode = Section$firstNode;

  function Section$firstNode() {
  	var len, i, node;

  	if (len = this.fragments.length) {
  		for (i = 0; i < len; i += 1) {
  			if (node = this.fragments[i].firstNode()) {
  				return node;
  			}
  		}
  	}

  	return this.parentFragment.findNextNode(this);
  }

  var shuffle = Section$shuffle;

  function Section$shuffle(newIndices) {
  	var _this = this;

  	var parentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment;

  	// short circuit any double-updates, and ensure that this isn't applied to
  	// non-list sections
  	if (this.shuffling || this.unbound || this.currentSubtype !== SECTION_EACH) {
  		return;
  	}

  	this.shuffling = true;
  	global_runloop.scheduleTask(function () {
  		return _this.shuffling = false;
  	});

  	parentFragment = this.parentFragment;

  	reboundFragments = [];

  	// TODO: need to update this
  	// first, rebind existing fragments
  	newIndices.forEach(function (newIndex, oldIndex) {
  		var fragment, by, oldKeypath, newKeypath, deps;

  		if (newIndex === oldIndex) {
  			reboundFragments[newIndex] = _this.fragments[oldIndex];
  			return;
  		}

  		fragment = _this.fragments[oldIndex];

  		if (firstChange === undefined) {
  			firstChange = oldIndex;
  		}

  		// does this fragment need to be torn down?
  		if (newIndex === -1) {
  			_this.fragmentsToUnrender.push(fragment);
  			fragment.unbind();
  			return;
  		}

  		// Otherwise, it needs to be rebound to a new index
  		by = newIndex - oldIndex;
  		oldKeypath = _this.keypath.join(oldIndex);
  		newKeypath = _this.keypath.join(newIndex);

  		fragment.index = newIndex;

  		// notify any registered index refs directly
  		if (deps = fragment.registeredIndexRefs) {
  			deps.forEach(shuffle__blindRebind);
  		}

  		fragment.rebind(oldKeypath, newKeypath);
  		reboundFragments[newIndex] = fragment;
  	});

  	newLength = this.root.viewmodel.get(this.keypath).length;

  	// If nothing changed with the existing fragments, then we start adding
  	// new fragments at the end...
  	if (firstChange === undefined) {
  		// ...unless there are no new fragments to add
  		if (this.length === newLength) {
  			return;
  		}

  		firstChange = this.length;
  	}

  	this.length = this.fragments.length = newLength;

  	if (this.rendered) {
  		global_runloop.addView(this);
  	}

  	// Prepare new fragment options
  	fragmentOptions = {
  		template: this.template.f,
  		root: this.root,
  		owner: this
  	};

  	// Add as many new fragments as we need to, or add back existing
  	// (detached) fragments
  	for (i = firstChange; i < newLength; i += 1) {
  		fragment = reboundFragments[i];

  		if (!fragment) {
  			this.fragmentsToCreate.push(i);
  		}

  		this.fragments[i] = fragment;
  	}
  }

  function shuffle__blindRebind(dep) {
  	// the keypath doesn't actually matter here as it won't have changed
  	dep.rebind("", "");
  }

  var prototype_rebind = function (oldKeypath, newKeypath) {
  	Mustache.rebind.call(this, oldKeypath, newKeypath);
  };

  var Section_prototype_render = Section$render;

  function Section$render() {
  	var _this = this;

  	this.docFrag = document.createDocumentFragment();

  	this.fragments.forEach(function (f) {
  		return _this.docFrag.appendChild(f.render());
  	});

  	this.renderedFragments = this.fragments.slice();
  	this.fragmentsToRender = [];

  	this.rendered = true;
  	return this.docFrag;
  }

  var setValue = Section$setValue;

  function Section$setValue(value) {
  	var _this = this;

  	var wrapper, fragmentOptions;

  	if (this.updating) {
  		// If a child of this section causes a re-evaluation - for example, an
  		// expression refers to a function that mutates the array that this
  		// section depends on - we'll end up with a double rendering bug (see
  		// https://github.com/ractivejs/ractive/issues/748). This prevents it.
  		return;
  	}

  	this.updating = true;

  	// with sections, we need to get the fake value if we have a wrapped object
  	if (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {
  		value = wrapper.get();
  	}

  	// If any fragments are awaiting creation after a splice,
  	// this is the place to do it
  	if (this.fragmentsToCreate.length) {
  		fragmentOptions = {
  			template: this.template.f || [],
  			root: this.root,
  			pElement: this.pElement,
  			owner: this
  		};

  		this.fragmentsToCreate.forEach(function (index) {
  			var fragment;

  			fragmentOptions.context = _this.keypath.join(index);
  			fragmentOptions.index = index;

  			fragment = new virtualdom_Fragment(fragmentOptions);
  			_this.fragmentsToRender.push(_this.fragments[index] = fragment);
  		});

  		this.fragmentsToCreate.length = 0;
  	} else if (reevaluateSection(this, value)) {
  		this.bubble();

  		if (this.rendered) {
  			global_runloop.addView(this);
  		}
  	}

  	this.value = value;
  	this.updating = false;
  }

  function changeCurrentSubtype(section, value, obj) {
  	if (value === SECTION_EACH) {
  		// make sure ref type is up to date for key or value indices
  		if (section.indexRefs && section.indexRefs[0]) {
  			var ref = section.indexRefs[0];

  			// when switching flavors, make sure the section gets updated
  			if (obj && ref.t === "i" || !obj && ref.t === "k") {
  				// if switching from object to list, unbind all of the old fragments
  				if (!obj) {
  					section.length = 0;
  					section.fragmentsToUnrender = section.fragments.slice(0);
  					section.fragmentsToUnrender.forEach(function (f) {
  						return f.unbind();
  					});
  				}
  			}

  			ref.t = obj ? "k" : "i";
  		}
  	}

  	section.currentSubtype = value;
  }

  function reevaluateSection(section, value) {
  	var fragmentOptions = {
  		template: section.template.f || [],
  		root: section.root,
  		pElement: section.parentFragment.pElement,
  		owner: section
  	};

  	section.hasContext = true;

  	// If we already know the section type, great
  	// TODO can this be optimised? i.e. pick an reevaluateSection function during init
  	// and avoid doing this each time?
  	if (section.subtype) {
  		switch (section.subtype) {
  			case SECTION_IF:
  				section.hasContext = false;
  				return reevaluateConditionalSection(section, value, false, fragmentOptions);

  			case SECTION_UNLESS:
  				section.hasContext = false;
  				return reevaluateConditionalSection(section, value, true, fragmentOptions);

  			case SECTION_WITH:
  				return reevaluateContextSection(section, fragmentOptions);

  			case SECTION_IF_WITH:
  				return reevaluateConditionalContextSection(section, value, fragmentOptions);

  			case SECTION_EACH:
  				if (isObject(value)) {
  					changeCurrentSubtype(section, section.subtype, true);
  					return reevaluateListObjectSection(section, value, fragmentOptions);
  				}

  				// Fallthrough - if it's a conditional or an array we need to continue
  		}
  	}

  	// Otherwise we need to work out what sort of section we're dealing with
  	section.ordered = !!isArrayLike(value);

  	// Ordered list section
  	if (section.ordered) {
  		changeCurrentSubtype(section, SECTION_EACH, false);
  		return reevaluateListSection(section, value, fragmentOptions);
  	}

  	// Unordered list, or context
  	if (isObject(value) || typeof value === "function") {
  		// Index reference indicates section should be treated as a list
  		if (section.template.i) {
  			changeCurrentSubtype(section, SECTION_EACH, true);
  			return reevaluateListObjectSection(section, value, fragmentOptions);
  		}

  		// Otherwise, object provides context for contents
  		changeCurrentSubtype(section, SECTION_WITH, false);
  		return reevaluateContextSection(section, fragmentOptions);
  	}

  	// Conditional section
  	changeCurrentSubtype(section, SECTION_IF, false);
  	section.hasContext = false;
  	return reevaluateConditionalSection(section, value, false, fragmentOptions);
  }

  function reevaluateListSection(section, value, fragmentOptions) {
  	var i, length, fragment;

  	length = value.length;

  	if (length === section.length) {
  		// Nothing to do
  		return false;
  	}

  	// if the array is shorter than it was previously, remove items
  	if (length < section.length) {
  		section.fragmentsToUnrender = section.fragments.splice(length, section.length - length);
  		section.fragmentsToUnrender.forEach(methodCallers__unbind);
  	}

  	// otherwise...
  	else {
  		if (length > section.length) {
  			// add any new ones
  			for (i = section.length; i < length; i += 1) {
  				// append list item to context stack
  				fragmentOptions.context = section.keypath.join(i);
  				fragmentOptions.index = i;

  				fragment = new virtualdom_Fragment(fragmentOptions);
  				section.fragmentsToRender.push(section.fragments[i] = fragment);
  			}
  		}
  	}

  	section.length = length;
  	return true;
  }

  function reevaluateListObjectSection(section, value, fragmentOptions) {
  	var id, i, hasKey, fragment, changed, deps;

  	hasKey = section.hasKey || (section.hasKey = {});

  	// remove any fragments that should no longer exist
  	i = section.fragments.length;
  	while (i--) {
  		fragment = section.fragments[i];

  		if (!(fragment.key in value)) {
  			changed = true;

  			fragment.unbind();
  			section.fragmentsToUnrender.push(fragment);
  			section.fragments.splice(i, 1);

  			hasKey[fragment.key] = false;
  		}
  	}

  	// notify any dependents about changed indices
  	i = section.fragments.length;
  	while (i--) {
  		fragment = section.fragments[i];

  		if (fragment.index !== i) {
  			fragment.index = i;
  			if (deps = fragment.registeredIndexRefs) {
  				deps.forEach(setValue__blindRebind);
  			}
  		}
  	}

  	// add any that haven't been created yet
  	i = section.fragments.length;
  	for (id in value) {
  		if (!hasKey[id]) {
  			changed = true;

  			fragmentOptions.context = section.keypath.join(id);
  			fragmentOptions.key = id;
  			fragmentOptions.index = i++;

  			fragment = new virtualdom_Fragment(fragmentOptions);

  			section.fragmentsToRender.push(fragment);
  			section.fragments.push(fragment);
  			hasKey[id] = true;
  		}
  	}

  	section.length = section.fragments.length;
  	return changed;
  }

  function reevaluateConditionalContextSection(section, value, fragmentOptions) {
  	if (value) {
  		return reevaluateContextSection(section, fragmentOptions);
  	} else {
  		return removeSectionFragments(section);
  	}
  }

  function reevaluateContextSection(section, fragmentOptions) {
  	var fragment;

  	// ...then if it isn't rendered, render it, adding section.keypath to the context stack
  	// (if it is already rendered, then any children dependent on the context stack
  	// will update themselves without any prompting)
  	if (!section.length) {
  		// append this section to the context stack
  		fragmentOptions.context = section.keypath;
  		fragmentOptions.index = 0;

  		fragment = new virtualdom_Fragment(fragmentOptions);

  		section.fragmentsToRender.push(section.fragments[0] = fragment);
  		section.length = 1;

  		return true;
  	}
  }

  function reevaluateConditionalSection(section, value, inverted, fragmentOptions) {
  	var doRender, emptyArray, emptyObject, fragment, name;

  	emptyArray = isArrayLike(value) && value.length === 0;
  	emptyObject = false;
  	if (!isArrayLike(value) && isObject(value)) {
  		emptyObject = true;
  		for (name in value) {
  			emptyObject = false;
  			break;
  		}
  	}

  	if (inverted) {
  		doRender = emptyArray || emptyObject || !value;
  	} else {
  		doRender = value && !emptyArray && !emptyObject;
  	}

  	if (doRender) {
  		if (!section.length) {
  			// no change to context stack
  			fragmentOptions.index = 0;

  			fragment = new virtualdom_Fragment(fragmentOptions);
  			section.fragmentsToRender.push(section.fragments[0] = fragment);
  			section.length = 1;

  			return true;
  		}

  		if (section.length > 1) {
  			section.fragmentsToUnrender = section.fragments.splice(1);
  			section.fragmentsToUnrender.forEach(methodCallers__unbind);

  			return true;
  		}
  	} else {
  		return removeSectionFragments(section);
  	}
  }

  function removeSectionFragments(section) {
  	if (section.length) {
  		section.fragmentsToUnrender = section.fragments.splice(0, section.fragments.length).filter(isRendered);
  		section.fragmentsToUnrender.forEach(methodCallers__unbind);
  		section.length = section.fragmentsToRender.length = 0;
  		return true;
  	}
  }

  function isRendered(fragment) {
  	return fragment.rendered;
  }

  function setValue__blindRebind(dep) {
  	// the keypath doesn't actually matter here as it won't have changed
  	dep.rebind("", "");
  }

  var prototype_toString = Section$toString;

  function Section$toString(escape) {
  	var str, i, len;

  	str = "";

  	i = 0;
  	len = this.length;

  	for (i = 0; i < len; i += 1) {
  		str += this.fragments[i].toString(escape);
  	}

  	return str;
  }

  var prototype_unbind = Section$unbind;
  function Section$unbind() {
  	var _this = this;

  	this.fragments.forEach(methodCallers__unbind);
  	this.fragmentsToRender.forEach(function (f) {
  		return removeFromArray(_this.fragments, f);
  	});
  	this.fragmentsToRender = [];
  	shared_unbind.call(this);

  	this.length = 0;
  	this.unbound = true;
  }

  var prototype_unrender = Section$unrender;

  function Section$unrender(shouldDestroy) {
  	this.fragments.forEach(shouldDestroy ? unrenderAndDestroy : prototype_unrender__unrender);
  	this.renderedFragments = [];
  	this.rendered = false;
  }

  function unrenderAndDestroy(fragment) {
  	fragment.unrender(true);
  }

  function prototype_unrender__unrender(fragment) {
  	fragment.unrender(false);
  }

  var prototype_update = Section$update;

  function Section$update() {
  	var fragment, renderIndex, renderedFragments, anchor, target, i, len;

  	// `this.renderedFragments` is in the order of the previous render.
  	// If fragments have shuffled about, this allows us to quickly
  	// reinsert them in the correct place
  	renderedFragments = this.renderedFragments;

  	// Remove fragments that have been marked for destruction
  	while (fragment = this.fragmentsToUnrender.pop()) {
  		fragment.unrender(true);
  		renderedFragments.splice(renderedFragments.indexOf(fragment), 1);
  	}

  	// Render new fragments (but don't insert them yet)
  	while (fragment = this.fragmentsToRender.shift()) {
  		fragment.render();
  	}

  	if (this.rendered) {
  		target = this.parentFragment.getNode();
  	}

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		fragment = this.fragments[i];
  		renderIndex = renderedFragments.indexOf(fragment, i); // search from current index - it's guaranteed to be the same or higher

  		if (renderIndex === i) {
  			// already in the right place. insert accumulated nodes (if any) and carry on
  			if (this.docFrag.childNodes.length) {
  				anchor = fragment.firstNode();
  				target.insertBefore(this.docFrag, anchor);
  			}

  			continue;
  		}

  		this.docFrag.appendChild(fragment.detach());

  		// update renderedFragments
  		if (renderIndex !== -1) {
  			renderedFragments.splice(renderIndex, 1);
  		}
  		renderedFragments.splice(i, 0, fragment);
  	}

  	if (this.rendered && this.docFrag.childNodes.length) {
  		anchor = this.parentFragment.findNextNode(this);
  		target.insertBefore(this.docFrag, anchor);
  	}

  	// Save the rendering order for next time
  	this.renderedFragments = this.fragments.slice();
  }

  var Section = function (options) {
  	this.type = SECTION;
  	this.subtype = this.currentSubtype = options.template.n;
  	this.inverted = this.subtype === SECTION_UNLESS;

  	this.pElement = options.pElement;

  	this.fragments = [];
  	this.fragmentsToCreate = [];
  	this.fragmentsToRender = [];
  	this.fragmentsToUnrender = [];

  	if (options.template.i) {
  		this.indexRefs = options.template.i.split(",").map(function (k, i) {
  			return { n: k, t: i === 0 ? "k" : "i" };
  		});
  	}

  	this.renderedFragments = [];

  	this.length = 0; // number of times this section is rendered

  	Mustache.init(this, options);
  };

  Section.prototype = {
  	bubble: Section_prototype_bubble,
  	detach: Section_prototype_detach,
  	find: find,
  	findAll: findAll,
  	findAllComponents: findAllComponents,
  	findComponent: findComponent,
  	findNextNode: findNextNode,
  	firstNode: firstNode,
  	getIndexRef: function (name) {
  		if (this.indexRefs) {
  			var i = this.indexRefs.length;
  			while (i--) {
  				var ref = this.indexRefs[i];
  				if (ref.n === name) {
  					return ref;
  				}
  			}
  		}
  	},
  	getValue: Mustache.getValue,
  	shuffle: shuffle,
  	rebind: prototype_rebind,
  	render: Section_prototype_render,
  	resolve: Mustache.resolve,
  	setValue: setValue,
  	toString: prototype_toString,
  	unbind: prototype_unbind,
  	unrender: prototype_unrender,
  	update: prototype_update
  };

  var _Section = Section;

  var Triple_prototype_detach = Triple$detach;

  function Triple$detach() {
  	var len, i;

  	if (this.docFrag) {
  		len = this.nodes.length;
  		for (i = 0; i < len; i += 1) {
  			this.docFrag.appendChild(this.nodes[i]);
  		}

  		return this.docFrag;
  	}
  }

  var Triple_prototype_find = Triple$find;
  function Triple$find(selector) {
  	var i, len, node, queryResult;

  	len = this.nodes.length;
  	for (i = 0; i < len; i += 1) {
  		node = this.nodes[i];

  		if (node.nodeType !== 1) {
  			continue;
  		}

  		if (matches(node, selector)) {
  			return node;
  		}

  		if (queryResult = node.querySelector(selector)) {
  			return queryResult;
  		}
  	}

  	return null;
  }

  var Triple_prototype_findAll = Triple$findAll;
  function Triple$findAll(selector, queryResult) {
  	var i, len, node, queryAllResult, numNodes, j;

  	len = this.nodes.length;
  	for (i = 0; i < len; i += 1) {
  		node = this.nodes[i];

  		if (node.nodeType !== 1) {
  			continue;
  		}

  		if (matches(node, selector)) {
  			queryResult.push(node);
  		}

  		if (queryAllResult = node.querySelectorAll(selector)) {
  			numNodes = queryAllResult.length;
  			for (j = 0; j < numNodes; j += 1) {
  				queryResult.push(queryAllResult[j]);
  			}
  		}
  	}
  }

  var Triple_prototype_firstNode = Triple$firstNode;

  function Triple$firstNode() {
  	if (this.rendered && this.nodes[0]) {
  		return this.nodes[0];
  	}

  	return this.parentFragment.findNextNode(this);
  }

  var elementCache = {},
      ieBug,
      ieBlacklist;

  try {
  	createElement("table").innerHTML = "foo";
  } catch (err) {
  	ieBug = true;

  	ieBlacklist = {
  		TABLE: ["<table class=\"x\">", "</table>"],
  		THEAD: ["<table><thead class=\"x\">", "</thead></table>"],
  		TBODY: ["<table><tbody class=\"x\">", "</tbody></table>"],
  		TR: ["<table><tr class=\"x\">", "</tr></table>"],
  		SELECT: ["<select class=\"x\">", "</select>"]
  	};
  }

  var insertHtml = function (html, node, docFrag) {
  	var container,
  	    nodes = [],
  	    wrapper,
  	    selectedOption,
  	    child,
  	    i;

  	// render 0 and false
  	if (html != null && html !== "") {
  		if (ieBug && (wrapper = ieBlacklist[node.tagName])) {
  			container = element("DIV");
  			container.innerHTML = wrapper[0] + html + wrapper[1];
  			container = container.querySelector(".x");

  			if (container.tagName === "SELECT") {
  				selectedOption = container.options[container.selectedIndex];
  			}
  		} else if (node.namespaceURI === namespaces.svg) {
  			container = element("DIV");
  			container.innerHTML = "<svg class=\"x\">" + html + "</svg>";
  			container = container.querySelector(".x");
  		} else {
  			container = element(node.tagName);
  			container.innerHTML = html;

  			if (container.tagName === "SELECT") {
  				selectedOption = container.options[container.selectedIndex];
  			}
  		}

  		while (child = container.firstChild) {
  			nodes.push(child);
  			docFrag.appendChild(child);
  		}

  		// This is really annoying. Extracting <option> nodes from the
  		// temporary container <select> causes the remaining ones to
  		// become selected. So now we have to deselect them. IE8, you
  		// amaze me. You really do
  		// ...and now Chrome too
  		if (node.tagName === "SELECT") {
  			i = nodes.length;
  			while (i--) {
  				if (nodes[i] !== selectedOption) {
  					nodes[i].selected = false;
  				}
  			}
  		}
  	}

  	return nodes;
  };

  function element(tagName) {
  	return elementCache[tagName] || (elementCache[tagName] = createElement(tagName));
  }

  var helpers_updateSelect = updateSelect;

  function updateSelect(parentElement) {
  	var selectedOptions, option, value;

  	if (!parentElement || parentElement.name !== "select" || !parentElement.binding) {
  		return;
  	}

  	selectedOptions = toArray(parentElement.node.options).filter(isSelected);

  	// If one of them had a `selected` attribute, we need to sync
  	// the model to the view
  	if (parentElement.getAttribute("multiple")) {
  		value = selectedOptions.map(function (o) {
  			return o.value;
  		});
  	} else if (option = selectedOptions[0]) {
  		value = option.value;
  	}

  	if (value !== undefined) {
  		parentElement.binding.setValue(value);
  	}

  	parentElement.bubble();
  }

  function isSelected(option) {
  	return option.selected;
  }

  var Triple_prototype_render = Triple$render;
  function Triple$render() {
  	if (this.rendered) {
  		throw new Error("Attempted to render an item that was already rendered");
  	}

  	this.docFrag = document.createDocumentFragment();
  	this.nodes = insertHtml(this.value, this.parentFragment.getNode(), this.docFrag);

  	// Special case - we're inserting the contents of a <select>
  	helpers_updateSelect(this.pElement);

  	this.rendered = true;
  	return this.docFrag;
  }

  var prototype_setValue = Triple$setValue;
  function Triple$setValue(value) {
  	var wrapper;

  	// TODO is there a better way to approach this?
  	if (wrapper = this.root.viewmodel.wrapped[this.keypath.str]) {
  		value = wrapper.get();
  	}

  	if (value !== this.value) {
  		this.value = value;
  		this.parentFragment.bubble();

  		if (this.rendered) {
  			global_runloop.addView(this);
  		}
  	}
  }

  var Triple_prototype_toString = Triple$toString;
  function Triple$toString() {
  	return this.value != undefined ? decodeCharacterReferences("" + this.value) : "";
  }

  var Triple_prototype_unrender = Triple$unrender;
  function Triple$unrender(shouldDestroy) {
  	if (this.rendered && shouldDestroy) {
  		this.nodes.forEach(detachNode);
  		this.rendered = false;
  	}

  	// TODO update live queries
  }

  var Triple_prototype_update = Triple$update;
  function Triple$update() {
  	var node, parentNode;

  	if (!this.rendered) {
  		return;
  	}

  	// Remove existing nodes
  	while (this.nodes && this.nodes.length) {
  		node = this.nodes.pop();
  		node.parentNode.removeChild(node);
  	}

  	// Insert new nodes
  	parentNode = this.parentFragment.getNode();

  	this.nodes = insertHtml(this.value, parentNode, this.docFrag);
  	parentNode.insertBefore(this.docFrag, this.parentFragment.findNextNode(this));

  	// Special case - we're inserting the contents of a <select>
  	helpers_updateSelect(this.pElement);
  }

  var Triple = function (options) {
  	this.type = TRIPLE;
  	Mustache.init(this, options);
  };

  Triple.prototype = {
  	detach: Triple_prototype_detach,
  	find: Triple_prototype_find,
  	findAll: Triple_prototype_findAll,
  	firstNode: Triple_prototype_firstNode,
  	getValue: Mustache.getValue,
  	rebind: Mustache.rebind,
  	render: Triple_prototype_render,
  	resolve: Mustache.resolve,
  	setValue: prototype_setValue,
  	toString: Triple_prototype_toString,
  	unbind: shared_unbind,
  	unrender: Triple_prototype_unrender,
  	update: Triple_prototype_update
  };

  var _Triple = Triple;

  var Element_prototype_bubble = function () {
  	this.parentFragment.bubble();
  };

  var Element_prototype_detach = Element$detach;

  function Element$detach() {
  	var node = this.node,
  	    parentNode;

  	if (node) {
  		// need to check for parent node - DOM may have been altered
  		// by something other than Ractive! e.g. jQuery UI...
  		if (parentNode = node.parentNode) {
  			parentNode.removeChild(node);
  		}

  		return node;
  	}
  }

  var Element_prototype_find = function (selector) {
  	if (!this.node) {
  		// this element hasn't been rendered yet
  		return null;
  	}

  	if (matches(this.node, selector)) {
  		return this.node;
  	}

  	if (this.fragment && this.fragment.find) {
  		return this.fragment.find(selector);
  	}
  };

  var Element_prototype_findAll = function (selector, query) {
  	// Add this node to the query, if applicable, and register the
  	// query on this element
  	if (query._test(this, true) && query.live) {
  		(this.liveQueries || (this.liveQueries = [])).push(query);
  	}

  	if (this.fragment) {
  		this.fragment.findAll(selector, query);
  	}
  };

  var Element_prototype_findAllComponents = function (selector, query) {
  	if (this.fragment) {
  		this.fragment.findAllComponents(selector, query);
  	}
  };

  var Element_prototype_findComponent = function (selector) {
  	if (this.fragment) {
  		return this.fragment.findComponent(selector);
  	}
  };

  var Element_prototype_findNextNode = Element$findNextNode;

  function Element$findNextNode() {
  	return null;
  }

  var Element_prototype_firstNode = Element$firstNode;

  function Element$firstNode() {
  	return this.node;
  }

  var getAttribute = Element$getAttribute;

  function Element$getAttribute(name) {
  	if (!this.attributes || !this.attributes[name]) {
  		return;
  	}

  	return this.attributes[name].value;
  }

  var truthy = /^true|on|yes|1$/i;
  var processBindingAttributes__isNumeric = /^[0-9]+$/;

  var processBindingAttributes = function (element, template) {
  	var val, attrs, attributes;

  	attributes = template.a || {};
  	attrs = {};

  	// attributes that are present but don't have a value (=)
  	// will be set to the number 0, which we condider to be true
  	// the string '0', however is false

  	val = attributes.twoway;
  	if (val !== undefined) {
  		attrs.twoway = val === 0 || truthy.test(val);
  	}

  	val = attributes.lazy;
  	if (val !== undefined) {
  		// check for timeout value
  		if (val !== 0 && processBindingAttributes__isNumeric.test(val)) {
  			attrs.lazy = parseInt(val);
  		} else {
  			attrs.lazy = val === 0 || truthy.test(val);
  		}
  	}

  	return attrs;
  };

  var Attribute_prototype_bubble = Attribute$bubble;
  function Attribute$bubble() {
  	var value = this.useProperty || !this.rendered ? this.fragment.getValue() : this.fragment.toString();

  	// TODO this can register the attribute multiple times (see render test
  	// 'Attribute with nested mustaches')
  	if (!isEqual(value, this.value)) {

  		// Need to clear old id from ractive.nodes
  		if (this.name === "id" && this.value) {
  			delete this.root.nodes[this.value];
  		}

  		this.value = value;

  		if (this.name === "value" && this.node) {
  			// We need to store the value on the DOM like this so we
  			// can retrieve it later without it being coerced to a string
  			this.node._ractive.value = value;
  		}

  		if (this.rendered) {
  			global_runloop.addView(this);
  		}
  	}
  }

  var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;
  svgCamelCaseElements = "altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern".split(" ");
  svgCamelCaseAttributes = "attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan".split(" ");

  createMap = function (items) {
  	var map = {},
  	    i = items.length;
  	while (i--) {
  		map[items[i].toLowerCase()] = items[i];
  	}
  	return map;
  };

  map = createMap(svgCamelCaseElements.concat(svgCamelCaseAttributes));

  var enforceCase = function (elementName) {
  	var lowerCaseElementName = elementName.toLowerCase();
  	return map[lowerCaseElementName] || lowerCaseElementName;
  };

  var determineNameAndNamespace = function (attribute, name) {
  	var colonIndex, namespacePrefix;

  	// are we dealing with a namespaced attribute, e.g. xlink:href?
  	colonIndex = name.indexOf(":");
  	if (colonIndex !== -1) {

  		// looks like we are, yes...
  		namespacePrefix = name.substr(0, colonIndex);

  		// ...unless it's a namespace *declaration*, which we ignore (on the assumption
  		// that only valid namespaces will be used)
  		if (namespacePrefix !== "xmlns") {
  			name = name.substring(colonIndex + 1);

  			attribute.name = enforceCase(name);
  			attribute.namespace = namespaces[namespacePrefix.toLowerCase()];
  			attribute.namespacePrefix = namespacePrefix;

  			if (!attribute.namespace) {
  				throw "Unknown namespace (\"" + namespacePrefix + "\")";
  			}

  			return;
  		}
  	}

  	// SVG attribute names are case sensitive
  	attribute.name = attribute.element.namespace !== namespaces.html ? enforceCase(name) : name;
  };

  var helpers_getInterpolator = getInterpolator;
  function getInterpolator(attribute) {
  	var items = attribute.fragment.items;

  	if (items.length !== 1) {
  		return;
  	}

  	if (items[0].type === INTERPOLATOR) {
  		return items[0];
  	}
  }

  var prototype_init = Attribute$init;
  function Attribute$init(options) {
  	this.type = ATTRIBUTE;
  	this.element = options.element;
  	this.root = options.root;

  	determineNameAndNamespace(this, options.name);
  	this.isBoolean = booleanAttributes.test(this.name);

  	// if it's an empty attribute, or just a straight key-value pair, with no
  	// mustache shenanigans, set the attribute accordingly and go home
  	if (!options.value || typeof options.value === "string") {
  		this.value = this.isBoolean ? true : options.value || "";
  		return;
  	}

  	// otherwise we need to do some work

  	// share parentFragment with parent element
  	this.parentFragment = this.element.parentFragment;

  	this.fragment = new virtualdom_Fragment({
  		template: options.value,
  		root: this.root,
  		owner: this
  	});

  	// TODO can we use this.fragment.toString() in some cases? It's quicker
  	this.value = this.fragment.getValue();

  	// Store a reference to this attribute's interpolator, if its fragment
  	// takes the form `{{foo}}`. This is necessary for two-way binding and
  	// for correctly rendering HTML later
  	this.interpolator = helpers_getInterpolator(this);
  	this.isBindable = !!this.interpolator && !this.interpolator.isStatic;

  	// mark as ready
  	this.ready = true;
  }

  var Attribute_prototype_rebind = Attribute$rebind;

  function Attribute$rebind(oldKeypath, newKeypath) {
  	if (this.fragment) {
  		this.fragment.rebind(oldKeypath, newKeypath);
  	}
  }

  var Attribute_prototype_render = Attribute$render;
  var propertyNames = {
  	"accept-charset": "acceptCharset",
  	accesskey: "accessKey",
  	bgcolor: "bgColor",
  	"class": "className",
  	codebase: "codeBase",
  	colspan: "colSpan",
  	contenteditable: "contentEditable",
  	datetime: "dateTime",
  	dirname: "dirName",
  	"for": "htmlFor",
  	"http-equiv": "httpEquiv",
  	ismap: "isMap",
  	maxlength: "maxLength",
  	novalidate: "noValidate",
  	pubdate: "pubDate",
  	readonly: "readOnly",
  	rowspan: "rowSpan",
  	tabindex: "tabIndex",
  	usemap: "useMap"
  };
  function Attribute$render(node) {
  	var propertyName;

  	this.node = node;

  	// should we use direct property access, or setAttribute?
  	if (!node.namespaceURI || node.namespaceURI === namespaces.html) {
  		propertyName = propertyNames[this.name] || this.name;

  		if (node[propertyName] !== undefined) {
  			this.propertyName = propertyName;
  		}

  		// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
  		// node.selected = true rather than node.setAttribute( 'selected', '' )
  		if (this.isBoolean || this.isTwoway) {
  			this.useProperty = true;
  		}

  		if (propertyName === "value") {
  			node._ractive.value = this.value;
  		}
  	}

  	this.rendered = true;
  	this.update();
  }

  var Attribute_prototype_toString = Attribute$toString;

  function Attribute$toString() {
  	var _ref = this;

  	var name = _ref.name;
  	var namespacePrefix = _ref.namespacePrefix;
  	var value = _ref.value;
  	var interpolator = _ref.interpolator;
  	var fragment = _ref.fragment;

  	// Special case - select and textarea values (should not be stringified)
  	if (name === "value" && (this.element.name === "select" || this.element.name === "textarea")) {
  		return;
  	}

  	// Special case - content editable
  	if (name === "value" && this.element.getAttribute("contenteditable") !== undefined) {
  		return;
  	}

  	// Special case - radio names
  	if (name === "name" && this.element.name === "input" && interpolator) {
  		return "name={{" + (interpolator.keypath.str || interpolator.ref) + "}}";
  	}

  	// Boolean attributes
  	if (this.isBoolean) {
  		return value ? name : "";
  	}

  	if (fragment) {
  		// special case - this catches undefined/null values (#1211)
  		if (fragment.items.length === 1 && fragment.items[0].value == null) {
  			return "";
  		}

  		value = fragment.toString();
  	}

  	if (namespacePrefix) {
  		name = namespacePrefix + ":" + name;
  	}

  	return value ? name + "=\"" + Attribute_prototype_toString__escape(value) + "\"" : name;
  }

  function Attribute_prototype_toString__escape(value) {
  	return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  }

  var Attribute_prototype_unbind = Attribute$unbind;

  function Attribute$unbind() {
  	// ignore non-dynamic attributes
  	if (this.fragment) {
  		this.fragment.unbind();
  	}

  	if (this.name === "id") {
  		delete this.root.nodes[this.value];
  	}
  }

  var updateSelectValue = Attribute$updateSelect;

  function Attribute$updateSelect() {
  	var value = this.value,
  	    options,
  	    option,
  	    optionValue,
  	    i;

  	if (!this.locked) {
  		this.node._ractive.value = value;

  		options = this.node.options;
  		i = options.length;

  		while (i--) {
  			option = options[i];
  			optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive

  			if (optionValue == value) {
  				// double equals as we may be comparing numbers with strings
  				option.selected = true;
  				break;
  			}
  		}
  	}

  	// if we're still here, it means the new value didn't match any of the options...
  	// TODO figure out what to do in this situation
  }

  var updateMultipleSelectValue = Attribute$updateMultipleSelect;
  function Attribute$updateMultipleSelect() {
  	var value = this.value,
  	    options,
  	    i,
  	    option,
  	    optionValue;

  	if (!isArray(value)) {
  		value = [value];
  	}

  	options = this.node.options;
  	i = options.length;

  	while (i--) {
  		option = options[i];
  		optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive
  		option.selected = arrayContains(value, optionValue);
  	}
  }

  var updateRadioName = Attribute$updateRadioName;

  function Attribute$updateRadioName() {
  	var _ref = this;

  	var node = _ref.node;
  	var value = _ref.value;

  	node.checked = value == node._ractive.value;
  }

  var updateRadioValue = Attribute$updateRadioValue;
  function Attribute$updateRadioValue() {
  	var wasChecked,
  	    node = this.node,
  	    binding,
  	    bindings,
  	    i;

  	wasChecked = node.checked;

  	node.value = this.element.getAttribute("value");
  	node.checked = this.element.getAttribute("value") === this.element.getAttribute("name");

  	// This is a special case - if the input was checked, and the value
  	// changed so that it's no longer checked, the twoway binding is
  	// most likely out of date. To fix it we have to jump through some
  	// hoops... this is a little kludgy but it works
  	if (wasChecked && !node.checked && this.element.binding) {
  		bindings = this.element.binding.siblings;

  		if (i = bindings.length) {
  			while (i--) {
  				binding = bindings[i];

  				if (!binding.element.node) {
  					// this is the initial render, siblings are still rendering!
  					// we'll come back later...
  					return;
  				}

  				if (binding.element.node.checked) {
  					global_runloop.addRactive(binding.root);
  					return binding.handleChange();
  				}
  			}

  			this.root.viewmodel.set(binding.keypath, undefined);
  		}
  	}
  }

  var updateCheckboxName = Attribute$updateCheckboxName;
  function Attribute$updateCheckboxName() {
  	var _ref = this;

  	var element = _ref.element;
  	var node = _ref.node;
  	var value = _ref.value;var binding = element.binding;var valueAttribute;var i;

  	valueAttribute = element.getAttribute("value");

  	if (!isArray(value)) {
  		binding.isChecked = node.checked = value == valueAttribute;
  	} else {
  		i = value.length;
  		while (i--) {
  			if (valueAttribute == value[i]) {
  				binding.isChecked = node.checked = true;
  				return;
  			}
  		}
  		binding.isChecked = node.checked = false;
  	}
  }

  var updateClassName = Attribute$updateClassName;
  function Attribute$updateClassName() {
  	this.node.className = safeToStringValue(this.value);
  }

  var updateIdAttribute = Attribute$updateIdAttribute;

  function Attribute$updateIdAttribute() {
  	var _ref = this;

  	var node = _ref.node;
  	var value = _ref.value;

  	this.root.nodes[value] = node;
  	node.id = value;
  }

  var updateIEStyleAttribute = Attribute$updateIEStyleAttribute;

  function Attribute$updateIEStyleAttribute() {
  	var node, value;

  	node = this.node;
  	value = this.value;

  	if (value === undefined) {
  		value = "";
  	}

  	node.style.setAttribute("cssText", value);
  }

  var updateContentEditableValue = Attribute$updateContentEditableValue;

  function Attribute$updateContentEditableValue() {
  	var value = this.value;

  	if (value === undefined) {
  		value = "";
  	}

  	if (!this.locked) {
  		this.node.innerHTML = value;
  	}
  }

  var updateValue = Attribute$updateValue;

  function Attribute$updateValue() {
  	var _ref = this;

  	var node = _ref.node;
  	var value = _ref.value;

  	// store actual value, so it doesn't get coerced to a string
  	node._ractive.value = value;

  	// with two-way binding, only update if the change wasn't initiated by the user
  	// otherwise the cursor will often be sent to the wrong place
  	if (!this.locked) {
  		node.value = value == undefined ? "" : value;
  	}
  }

  var updateBoolean = Attribute$updateBooleanAttribute;

  function Attribute$updateBooleanAttribute() {
  	// with two-way binding, only update if the change wasn't initiated by the user
  	// otherwise the cursor will often be sent to the wrong place
  	if (!this.locked) {
  		this.node[this.propertyName] = this.value;
  	}
  }

  var updateEverythingElse = Attribute$updateEverythingElse;

  function Attribute$updateEverythingElse() {
  	var _ref = this;

  	var node = _ref.node;
  	var namespace = _ref.namespace;
  	var name = _ref.name;
  	var value = _ref.value;
  	var fragment = _ref.fragment;

  	if (namespace) {
  		node.setAttributeNS(namespace, name, (fragment || value).toString());
  	} else if (!this.isBoolean) {
  		if (value == null) {
  			node.removeAttribute(name);
  		} else {
  			node.setAttribute(name, (fragment || value).toString());
  		}
  	}

  	// Boolean attributes - truthy becomes '', falsy means 'remove attribute'
  	else {
  		if (value) {
  			node.setAttribute(name, "");
  		} else {
  			node.removeAttribute(name);
  		}
  	}
  }

  // There are a few special cases when it comes to updating attributes. For this reason,
  // the prototype .update() method points to this method, which waits until the
  // attribute has finished initialising, then replaces the prototype method with a more
  // suitable one. That way, we save ourselves doing a bunch of tests on each call
  var Attribute_prototype_update = Attribute$update;
  function Attribute$update() {
  	var _ref = this;

  	var name = _ref.name;
  	var element = _ref.element;
  	var node = _ref.node;var type;var updateMethod;

  	if (name === "id") {
  		updateMethod = updateIdAttribute;
  	} else if (name === "value") {
  		// special case - selects
  		if (element.name === "select" && name === "value") {
  			updateMethod = element.getAttribute("multiple") ? updateMultipleSelectValue : updateSelectValue;
  		} else if (element.name === "textarea") {
  			updateMethod = updateValue;
  		}

  		// special case - contenteditable
  		else if (element.getAttribute("contenteditable") != null) {
  			updateMethod = updateContentEditableValue;
  		}

  		// special case - <input>
  		else if (element.name === "input") {
  			type = element.getAttribute("type");

  			// type='file' value='{{fileList}}'>
  			if (type === "file") {
  				updateMethod = noop; // read-only
  			}

  			// type='radio' name='{{twoway}}'
  			else if (type === "radio" && element.binding && element.binding.name === "name") {
  				updateMethod = updateRadioValue;
  			} else {
  				updateMethod = updateValue;
  			}
  		}
  	}

  	// special case - <input type='radio' name='{{twoway}}' value='foo'>
  	else if (this.isTwoway && name === "name") {
  		if (node.type === "radio") {
  			updateMethod = updateRadioName;
  		} else if (node.type === "checkbox") {
  			updateMethod = updateCheckboxName;
  		}
  	}

  	// special case - style attributes in Internet Exploder
  	else if (name === "style" && node.style.setAttribute) {
  		updateMethod = updateIEStyleAttribute;
  	}

  	// special case - class names. IE fucks things up, again
  	else if (name === "class" && (!node.namespaceURI || node.namespaceURI === namespaces.html)) {
  		updateMethod = updateClassName;
  	} else if (this.useProperty) {
  		updateMethod = updateBoolean;
  	}

  	if (!updateMethod) {
  		updateMethod = updateEverythingElse;
  	}

  	this.update = updateMethod;
  	this.update();
  }

  var Attribute = function (options) {
  	this.init(options);
  };

  Attribute.prototype = {
  	bubble: Attribute_prototype_bubble,
  	init: prototype_init,
  	rebind: Attribute_prototype_rebind,
  	render: Attribute_prototype_render,
  	toString: Attribute_prototype_toString,
  	unbind: Attribute_prototype_unbind,
  	update: Attribute_prototype_update
  };

  var _Attribute = Attribute;

  var createAttributes = function (element, attributes) {
  	var name,
  	    attribute,
  	    result = [];

  	for (name in attributes) {
  		// skip binding attributes
  		if (name === "twoway" || name === "lazy") {
  			continue;
  		}

  		if (attributes.hasOwnProperty(name)) {
  			attribute = new _Attribute({
  				element: element,
  				name: name,
  				value: attributes[name],
  				root: element.root
  			});

  			result[name] = attribute;

  			if (name !== "value") {
  				result.push(attribute);
  			}
  		}
  	}

  	// value attribute goes last. This is because it
  	// may get clamped on render otherwise, e.g. in
  	// `<input type='range' value='999' min='0' max='1000'>`
  	// since default max is 100
  	if (attribute = result.value) {
  		result.push(attribute);
  	}

  	return result;
  };

  var _ConditionalAttribute__div;

  if (typeof document !== "undefined") {
  	_ConditionalAttribute__div = createElement("div");
  }

  var ConditionalAttribute = function (element, template) {
  	this.element = element;
  	this.root = element.root;
  	this.parentFragment = element.parentFragment;

  	this.attributes = [];

  	this.fragment = new virtualdom_Fragment({
  		root: element.root,
  		owner: this,
  		template: [template]
  	});
  };

  ConditionalAttribute.prototype = {
  	bubble: function () {
  		if (this.node) {
  			this.update();
  		}

  		this.element.bubble();
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		this.fragment.rebind(oldKeypath, newKeypath);
  	},

  	render: function (node) {
  		this.node = node;
  		this.isSvg = node.namespaceURI === namespaces.svg;

  		this.update();
  	},

  	unbind: function () {
  		this.fragment.unbind();
  	},

  	update: function () {
  		var _this = this;

  		var str, attrs;

  		str = this.fragment.toString();
  		attrs = parseAttributes(str, this.isSvg);

  		// any attributes that previously existed but no longer do
  		// must be removed
  		this.attributes.filter(function (a) {
  			return notIn(attrs, a);
  		}).forEach(function (a) {
  			_this.node.removeAttribute(a.name);
  		});

  		attrs.forEach(function (a) {
  			_this.node.setAttribute(a.name, a.value);
  		});

  		this.attributes = attrs;
  	},

  	toString: function () {
  		return this.fragment.toString();
  	}
  };

  var _ConditionalAttribute = ConditionalAttribute;

  function parseAttributes(str, isSvg) {
  	var tag = isSvg ? "svg" : "div";
  	_ConditionalAttribute__div.innerHTML = "<" + tag + " " + str + "></" + tag + ">";

  	return toArray(_ConditionalAttribute__div.childNodes[0].attributes);
  }

  function notIn(haystack, needle) {
  	var i = haystack.length;

  	while (i--) {
  		if (haystack[i].name === needle.name) {
  			return false;
  		}
  	}

  	return true;
  }

  var createConditionalAttributes = function (element, attributes) {
  	if (!attributes) {
  		return [];
  	}

  	return attributes.map(function (a) {
  		return new _ConditionalAttribute(element, a);
  	});
  };

  var Binding = function (element) {
  	var interpolator, keypath, value, parentForm;

  	this.element = element;
  	this.root = element.root;
  	this.attribute = element.attributes[this.name || "value"];

  	interpolator = this.attribute.interpolator;
  	interpolator.twowayBinding = this;

  	if (keypath = interpolator.keypath) {
  		if (keypath.str.slice(-1) === "}") {
  			warnOnceIfDebug("Two-way binding does not work with expressions (`%s` on <%s>)", interpolator.resolver.uniqueString, element.name, { ractive: this.root });
  			return false;
  		}

  		if (keypath.isSpecial) {
  			warnOnceIfDebug("Two-way binding does not work with %s", interpolator.resolver.ref, { ractive: this.root });
  			return false;
  		}
  	} else {
  		// A mustache may be *ambiguous*. Let's say we were given
  		// `value="{{bar}}"`. If the context was `foo`, and `foo.bar`
  		// *wasn't* `undefined`, the keypath would be `foo.bar`.
  		// Then, any user input would result in `foo.bar` being updated.
  		//
  		// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be
  		// left with an unresolved partial keypath - so we are forced to make an
  		// assumption. That assumption is that the input in question should
  		// be forced to resolve to `bar`, and any user input would affect `bar`
  		// and not `foo.bar`.
  		//
  		// Did that make any sense? No? Oh. Sorry. Well the moral of the story is
  		// be explicit when using two-way data-binding about what keypath you're
  		// updating. Using it in lists is probably a recipe for confusion...
  		var ref = interpolator.template.r ? "'" + interpolator.template.r + "' reference" : "expression";
  		warnIfDebug("The %s being used for two-way binding is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity", ref, { ractive: this.root });
  		interpolator.resolver.forceResolution();
  		keypath = interpolator.keypath;
  	}

  	this.attribute.isTwoway = true;
  	this.keypath = keypath;

  	// initialise value, if it's undefined
  	value = this.root.viewmodel.get(keypath);

  	if (value === undefined && this.getInitialValue) {
  		value = this.getInitialValue();

  		if (value !== undefined) {
  			this.root.viewmodel.set(keypath, value);
  		}
  	}

  	if (parentForm = findParentForm(element)) {
  		this.resetValue = value;
  		parentForm.formBindings.push(this);
  	}
  };

  Binding.prototype = {
  	handleChange: function () {
  		var _this = this;

  		global_runloop.start(this.root);
  		this.attribute.locked = true;
  		this.root.viewmodel.set(this.keypath, this.getValue());
  		global_runloop.scheduleTask(function () {
  			return _this.attribute.locked = false;
  		});
  		global_runloop.end();
  	},

  	rebound: function () {
  		var bindings, oldKeypath, newKeypath;

  		oldKeypath = this.keypath;
  		newKeypath = this.attribute.interpolator.keypath;

  		// The attribute this binding is linked to has already done the work
  		if (oldKeypath === newKeypath) {
  			return;
  		}

  		removeFromArray(this.root._twowayBindings[oldKeypath.str], this);

  		this.keypath = newKeypath;

  		bindings = this.root._twowayBindings[newKeypath.str] || (this.root._twowayBindings[newKeypath.str] = []);
  		bindings.push(this);
  	},

  	unbind: function () {}
  };

  Binding.extend = function (properties) {
  	var Parent = this,
  	    SpecialisedBinding;

  	SpecialisedBinding = function (element) {
  		Binding.call(this, element);

  		if (this.init) {
  			this.init();
  		}
  	};

  	SpecialisedBinding.prototype = create(Parent.prototype);
  	utils_object__extend(SpecialisedBinding.prototype, properties);

  	SpecialisedBinding.extend = Binding.extend;

  	return SpecialisedBinding;
  };

  var Binding_Binding = Binding;

  function findParentForm(element) {
  	while (element = element.parent) {
  		if (element.name === "form") {
  			return element;
  		}
  	}
  }

  // this is called when the element is unbound.
  // Specialised bindings can override it

  // This is the handler for DOM events that would lead to a change in the model
  // (i.e. change, sometimes, input, and occasionally click and keyup)
  var handleDomEvent = handleChange;

  function handleChange() {
  	this._ractive.binding.handleChange();
  }

  var GenericBinding;

  GenericBinding = Binding_Binding.extend({
  	getInitialValue: function () {
  		return "";
  	},

  	getValue: function () {
  		return this.element.node.value;
  	},

  	render: function () {
  		var node = this.element.node,
  		    lazy,
  		    timeout = false;
  		this.rendered = true;

  		// any lazy setting for this element overrides the root
  		// if the value is a number, it's a timeout
  		lazy = this.root.lazy;
  		if (this.element.lazy === true) {
  			lazy = true;
  		} else if (this.element.lazy === false) {
  			lazy = false;
  		} else if (is__isNumeric(this.element.lazy)) {
  			lazy = false;
  			timeout = +this.element.lazy;
  		} else if (is__isNumeric(lazy || "")) {
  			timeout = +lazy;
  			lazy = false;

  			// make sure the timeout is available to the handler
  			this.element.lazy = timeout;
  		}

  		this.handler = timeout ? handleDelay : handleDomEvent;

  		node.addEventListener("change", handleDomEvent, false);

  		if (!lazy) {
  			node.addEventListener("input", this.handler, false);

  			if (node.attachEvent) {
  				node.addEventListener("keyup", this.handler, false);
  			}
  		}

  		node.addEventListener("blur", handleBlur, false);
  	},

  	unrender: function () {
  		var node = this.element.node;
  		this.rendered = false;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("input", this.handler, false);
  		node.removeEventListener("keyup", this.handler, false);
  		node.removeEventListener("blur", handleBlur, false);
  	}
  });

  var Binding_GenericBinding = GenericBinding;

  function handleBlur() {
  	var value;

  	handleDomEvent.call(this);

  	value = this._ractive.root.viewmodel.get(this._ractive.binding.keypath);
  	this.value = value == undefined ? "" : value;
  }

  function handleDelay() {
  	var binding = this._ractive.binding,
  	    el = this;

  	if (!!binding._timeout) clearTimeout(binding._timeout);

  	binding._timeout = setTimeout(function () {
  		if (binding.rendered) handleDomEvent.call(el);
  		binding._timeout = undefined;
  	}, binding.element.lazy);
  }

  var ContentEditableBinding = Binding_GenericBinding.extend({
  	getInitialValue: function () {
  		return this.element.fragment ? this.element.fragment.toString() : "";
  	},

  	getValue: function () {
  		return this.element.node.innerHTML;
  	}
  });

  var Binding_ContentEditableBinding = ContentEditableBinding;

  var shared_getSiblings = getSiblings;
  var sets = {};
  function getSiblings(id, group, keypath) {
  	var hash = id + group + keypath;
  	return sets[hash] || (sets[hash] = []);
  }

  var RadioBinding = Binding_Binding.extend({
  	name: "checked",

  	init: function () {
  		this.siblings = shared_getSiblings(this.root._guid, "radio", this.element.getAttribute("name"));
  		this.siblings.push(this);
  	},

  	render: function () {
  		var node = this.element.node;

  		node.addEventListener("change", handleDomEvent, false);

  		if (node.attachEvent) {
  			node.addEventListener("click", handleDomEvent, false);
  		}
  	},

  	unrender: function () {
  		var node = this.element.node;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("click", handleDomEvent, false);
  	},

  	handleChange: function () {
  		global_runloop.start(this.root);

  		this.siblings.forEach(function (binding) {
  			binding.root.viewmodel.set(binding.keypath, binding.getValue());
  		});

  		global_runloop.end();
  	},

  	getValue: function () {
  		return this.element.node.checked;
  	},

  	unbind: function () {
  		removeFromArray(this.siblings, this);
  	}
  });

  var Binding_RadioBinding = RadioBinding;

  var RadioNameBinding = Binding_Binding.extend({
  	name: "name",

  	init: function () {
  		this.siblings = shared_getSiblings(this.root._guid, "radioname", this.keypath.str);
  		this.siblings.push(this);

  		this.radioName = true; // so that ractive.updateModel() knows what to do with this
  	},

  	getInitialValue: function () {
  		if (this.element.getAttribute("checked")) {
  			return this.element.getAttribute("value");
  		}
  	},

  	render: function () {
  		var node = this.element.node;

  		node.name = "{{" + this.keypath.str + "}}";
  		node.checked = this.root.viewmodel.get(this.keypath) == this.element.getAttribute("value");

  		node.addEventListener("change", handleDomEvent, false);

  		if (node.attachEvent) {
  			node.addEventListener("click", handleDomEvent, false);
  		}
  	},

  	unrender: function () {
  		var node = this.element.node;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("click", handleDomEvent, false);
  	},

  	getValue: function () {
  		var node = this.element.node;
  		return node._ractive ? node._ractive.value : node.value;
  	},

  	handleChange: function () {
  		// If this <input> is the one that's checked, then the value of its
  		// `name` keypath gets set to its value
  		if (this.element.node.checked) {
  			Binding_Binding.prototype.handleChange.call(this);
  		}
  	},

  	rebound: function (oldKeypath, newKeypath) {
  		var node;

  		Binding_Binding.prototype.rebound.call(this, oldKeypath, newKeypath);

  		if (node = this.element.node) {
  			node.name = "{{" + this.keypath.str + "}}";
  		}
  	},

  	unbind: function () {
  		removeFromArray(this.siblings, this);
  	}
  });

  var Binding_RadioNameBinding = RadioNameBinding;

  var CheckboxNameBinding = Binding_Binding.extend({
  	name: "name",

  	getInitialValue: function () {
  		// This only gets called once per group (of inputs that
  		// share a name), because it only gets called if there
  		// isn't an initial value. By the same token, we can make
  		// a note of that fact that there was no initial value,
  		// and populate it using any `checked` attributes that
  		// exist (which users should avoid, but which we should
  		// support anyway to avoid breaking expectations)
  		this.noInitialValue = true;
  		return [];
  	},

  	init: function () {
  		var existingValue, bindingValue;

  		this.checkboxName = true; // so that ractive.updateModel() knows what to do with this

  		// Each input has a reference to an array containing it and its
  		// siblings, as two-way binding depends on being able to ascertain
  		// the status of all inputs within the group
  		this.siblings = shared_getSiblings(this.root._guid, "checkboxes", this.keypath.str);
  		this.siblings.push(this);

  		if (this.noInitialValue) {
  			this.siblings.noInitialValue = true;
  		}

  		// If no initial value was set, and this input is checked, we
  		// update the model
  		if (this.siblings.noInitialValue && this.element.getAttribute("checked")) {
  			existingValue = this.root.viewmodel.get(this.keypath);
  			bindingValue = this.element.getAttribute("value");

  			existingValue.push(bindingValue);
  		}
  	},

  	unbind: function () {
  		removeFromArray(this.siblings, this);
  	},

  	render: function () {
  		var node = this.element.node,
  		    existingValue,
  		    bindingValue;

  		existingValue = this.root.viewmodel.get(this.keypath);
  		bindingValue = this.element.getAttribute("value");

  		if (isArray(existingValue)) {
  			this.isChecked = arrayContains(existingValue, bindingValue);
  		} else {
  			this.isChecked = existingValue == bindingValue;
  		}

  		node.name = "{{" + this.keypath.str + "}}";
  		node.checked = this.isChecked;

  		node.addEventListener("change", handleDomEvent, false);

  		// in case of IE emergency, bind to click event as well
  		if (node.attachEvent) {
  			node.addEventListener("click", handleDomEvent, false);
  		}
  	},

  	unrender: function () {
  		var node = this.element.node;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("click", handleDomEvent, false);
  	},

  	changed: function () {
  		var wasChecked = !!this.isChecked;
  		this.isChecked = this.element.node.checked;
  		return this.isChecked === wasChecked;
  	},

  	handleChange: function () {
  		this.isChecked = this.element.node.checked;
  		Binding_Binding.prototype.handleChange.call(this);
  	},

  	getValue: function () {
  		return this.siblings.filter(isChecked).map(Binding_CheckboxNameBinding__getValue);
  	}
  });

  function isChecked(binding) {
  	return binding.isChecked;
  }

  function Binding_CheckboxNameBinding__getValue(binding) {
  	return binding.element.getAttribute("value");
  }

  var Binding_CheckboxNameBinding = CheckboxNameBinding;

  var CheckboxBinding = Binding_Binding.extend({
  	name: "checked",

  	render: function () {
  		var node = this.element.node;

  		node.addEventListener("change", handleDomEvent, false);

  		if (node.attachEvent) {
  			node.addEventListener("click", handleDomEvent, false);
  		}
  	},

  	unrender: function () {
  		var node = this.element.node;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("click", handleDomEvent, false);
  	},

  	getValue: function () {
  		return this.element.node.checked;
  	}
  });

  var Binding_CheckboxBinding = CheckboxBinding;

  var SelectBinding = Binding_Binding.extend({
  	getInitialValue: function () {
  		var options = this.element.options,
  		    len,
  		    i,
  		    value,
  		    optionWasSelected;

  		if (this.element.getAttribute("value") !== undefined) {
  			return;
  		}

  		i = len = options.length;

  		if (!len) {
  			return;
  		}

  		// take the final selected option...
  		while (i--) {
  			if (options[i].getAttribute("selected")) {
  				value = options[i].getAttribute("value");
  				optionWasSelected = true;
  				break;
  			}
  		}

  		// or the first non-disabled option, if none are selected
  		if (!optionWasSelected) {
  			while (++i < len) {
  				if (!options[i].getAttribute("disabled")) {
  					value = options[i].getAttribute("value");
  					break;
  				}
  			}
  		}

  		// This is an optimisation (aka hack) that allows us to forgo some
  		// other more expensive work
  		if (value !== undefined) {
  			this.element.attributes.value.value = value;
  		}

  		return value;
  	},

  	render: function () {
  		this.element.node.addEventListener("change", handleDomEvent, false);
  	},

  	unrender: function () {
  		this.element.node.removeEventListener("change", handleDomEvent, false);
  	},

  	// TODO this method is an anomaly... is it necessary?
  	setValue: function (value) {
  		this.root.viewmodel.set(this.keypath, value);
  	},

  	getValue: function () {
  		var options, i, len, option, optionValue;

  		options = this.element.node.options;
  		len = options.length;

  		for (i = 0; i < len; i += 1) {
  			option = options[i];

  			if (options[i].selected) {
  				optionValue = option._ractive ? option._ractive.value : option.value;
  				return optionValue;
  			}
  		}
  	},

  	forceUpdate: function () {
  		var _this = this;

  		var value = this.getValue();

  		if (value !== undefined) {
  			this.attribute.locked = true;
  			global_runloop.scheduleTask(function () {
  				return _this.attribute.locked = false;
  			});
  			this.root.viewmodel.set(this.keypath, value);
  		}
  	}
  });

  var Binding_SelectBinding = SelectBinding;

  var MultipleSelectBinding = Binding_SelectBinding.extend({
  	getInitialValue: function () {
  		return this.element.options.filter(function (option) {
  			return option.getAttribute("selected");
  		}).map(function (option) {
  			return option.getAttribute("value");
  		});
  	},

  	render: function () {
  		var valueFromModel;

  		this.element.node.addEventListener("change", handleDomEvent, false);

  		valueFromModel = this.root.viewmodel.get(this.keypath);

  		if (valueFromModel === undefined) {
  			// get value from DOM, if possible
  			this.handleChange();
  		}
  	},

  	unrender: function () {
  		this.element.node.removeEventListener("change", handleDomEvent, false);
  	},

  	setValue: function () {
  		throw new Error("TODO not implemented yet");
  	},

  	getValue: function () {
  		var selectedValues, options, i, len, option, optionValue;

  		selectedValues = [];
  		options = this.element.node.options;
  		len = options.length;

  		for (i = 0; i < len; i += 1) {
  			option = options[i];

  			if (option.selected) {
  				optionValue = option._ractive ? option._ractive.value : option.value;
  				selectedValues.push(optionValue);
  			}
  		}

  		return selectedValues;
  	},

  	handleChange: function () {
  		var attribute, previousValue, value;

  		attribute = this.attribute;
  		previousValue = attribute.value;

  		value = this.getValue();

  		if (previousValue === undefined || !arrayContentsMatch(value, previousValue)) {
  			Binding_SelectBinding.prototype.handleChange.call(this);
  		}

  		return this;
  	},

  	forceUpdate: function () {
  		var _this = this;

  		var value = this.getValue();

  		if (value !== undefined) {
  			this.attribute.locked = true;
  			global_runloop.scheduleTask(function () {
  				return _this.attribute.locked = false;
  			});
  			this.root.viewmodel.set(this.keypath, value);
  		}
  	},

  	updateModel: function () {
  		if (this.attribute.value === undefined || !this.attribute.value.length) {
  			this.root.viewmodel.set(this.keypath, this.initialValue);
  		}
  	}
  });

  var Binding_MultipleSelectBinding = MultipleSelectBinding;

  var FileListBinding = Binding_Binding.extend({
  	render: function () {
  		this.element.node.addEventListener("change", handleDomEvent, false);
  	},

  	unrender: function () {
  		this.element.node.removeEventListener("change", handleDomEvent, false);
  	},

  	getValue: function () {
  		return this.element.node.files;
  	}
  });

  var Binding_FileListBinding = FileListBinding;

  var NumericBinding = Binding_GenericBinding.extend({
  	getInitialValue: function () {
  		return undefined;
  	},

  	getValue: function () {
  		var value = parseFloat(this.element.node.value);
  		return isNaN(value) ? undefined : value;
  	}
  });

  var init_createTwowayBinding = createTwowayBinding;

  function createTwowayBinding(element) {
  	var attributes = element.attributes,
  	    type,
  	    Binding,
  	    bindName,
  	    bindChecked,
  	    binding;

  	// if this is a late binding, and there's already one, it
  	// needs to be torn down
  	if (element.binding) {
  		element.binding.teardown();
  		element.binding = null;
  	}

  	// contenteditable
  	if (
  	// if the contenteditable attribute is true or is bindable and may thus become true
  	(element.getAttribute("contenteditable") || !!attributes.contenteditable && isBindable(attributes.contenteditable)) && isBindable(attributes.value)) {
  		Binding = Binding_ContentEditableBinding;
  	}

  	// <input>
  	else if (element.name === "input") {
  		type = element.getAttribute("type");

  		if (type === "radio" || type === "checkbox") {
  			bindName = isBindable(attributes.name);
  			bindChecked = isBindable(attributes.checked);

  			// we can either bind the name attribute, or the checked attribute - not both
  			if (bindName && bindChecked) {
  				warnIfDebug("A radio input can have two-way binding on its name attribute, or its checked attribute - not both", { ractive: element.root });
  			}

  			if (bindName) {
  				Binding = type === "radio" ? Binding_RadioNameBinding : Binding_CheckboxNameBinding;
  			} else if (bindChecked) {
  				Binding = type === "radio" ? Binding_RadioBinding : Binding_CheckboxBinding;
  			}
  		} else if (type === "file" && isBindable(attributes.value)) {
  			Binding = Binding_FileListBinding;
  		} else if (isBindable(attributes.value)) {
  			Binding = type === "number" || type === "range" ? NumericBinding : Binding_GenericBinding;
  		}
  	}

  	// <select>
  	else if (element.name === "select" && isBindable(attributes.value)) {
  		Binding = element.getAttribute("multiple") ? Binding_MultipleSelectBinding : Binding_SelectBinding;
  	}

  	// <textarea>
  	else if (element.name === "textarea" && isBindable(attributes.value)) {
  		Binding = Binding_GenericBinding;
  	}

  	if (Binding && (binding = new Binding(element)) && binding.keypath) {
  		return binding;
  	}
  }

  function isBindable(attribute) {
  	return attribute && attribute.isBindable;
  }

  // and this element also has a value attribute to bind

  var EventHandler_prototype_bubble = EventHandler$bubble;

  function EventHandler$bubble() {
  	var hasAction = this.getAction();

  	if (hasAction && !this.hasListener) {
  		this.listen();
  	} else if (!hasAction && this.hasListener) {
  		this.unrender();
  	}
  }

  // This function may be overwritten, if the event directive
  // includes parameters
  var EventHandler_prototype_fire = EventHandler$fire;
  function EventHandler$fire(event) {
  	shared_fireEvent(this.root, this.getAction(), { event: event });
  }

  var getAction = EventHandler$getAction;

  function EventHandler$getAction() {
  	return this.action.toString().trim();
  }

  var EventHandler_prototype_init = EventHandler$init;

  var eventPattern = /^event(?:\.(.+))?/;
  function EventHandler$init(element, name, template) {
  	var _this = this;

  	var action, refs, ractive;

  	this.element = element;
  	this.root = element.root;
  	this.parentFragment = element.parentFragment;
  	this.name = name;

  	if (name.indexOf("*") !== -1) {
  		fatal("Only component proxy-events may contain \"*\" wildcards, <%s on-%s=\"...\"/> is not valid", element.name, name);
  		this.invalid = true;
  	}

  	if (template.m) {
  		refs = template.a.r;

  		// This is a method call
  		this.method = template.m;
  		this.keypaths = [];
  		this.fn = shared_getFunctionFromString(template.a.s, refs.length);

  		this.parentFragment = element.parentFragment;
  		ractive = this.root;

  		// Create resolvers for each reference
  		this.refResolvers = [];
  		refs.forEach(function (ref, i) {
  			var match = undefined;

  			// special case - the `event` object
  			if (match = eventPattern.exec(ref)) {
  				_this.keypaths[i] = {
  					eventObject: true,
  					refinements: match[1] ? match[1].split(".") : []
  				};
  			} else {
  				_this.refResolvers.push(Resolvers_createReferenceResolver(_this, ref, function (keypath) {
  					return _this.resolve(i, keypath);
  				}));
  			}
  		});

  		this.fire = fireMethodCall;
  	} else {
  		// Get action ('foo' in 'on-click='foo')
  		action = template.n || template;
  		if (typeof action !== "string") {
  			action = new virtualdom_Fragment({
  				template: action,
  				root: this.root,
  				owner: this
  			});
  		}

  		this.action = action;

  		// Get parameters
  		if (template.d) {
  			this.dynamicParams = new virtualdom_Fragment({
  				template: template.d,
  				root: this.root,
  				owner: this.element
  			});

  			this.fire = fireEventWithDynamicParams;
  		} else if (template.a) {
  			this.params = template.a;
  			this.fire = fireEventWithParams;
  		}
  	}
  }

  function fireMethodCall(event) {
  	var ractive, values, args;

  	ractive = this.root;

  	if (typeof ractive[this.method] !== "function") {
  		throw new Error("Attempted to call a non-existent method (\"" + this.method + "\")");
  	}

  	values = this.keypaths.map(function (keypath) {
  		var value, len, i;

  		if (keypath === undefined) {
  			// not yet resolved
  			return undefined;
  		}

  		// TODO the refinements stuff would be better handled at parse time
  		if (keypath.eventObject) {
  			value = event;

  			if (len = keypath.refinements.length) {
  				for (i = 0; i < len; i += 1) {
  					value = value[keypath.refinements[i]];
  				}
  			}
  		} else {
  			value = ractive.viewmodel.get(keypath);
  		}

  		return value;
  	});

  	shared_eventStack.enqueue(ractive, event);

  	args = this.fn.apply(null, values);
  	ractive[this.method].apply(ractive, args);

  	shared_eventStack.dequeue(ractive);
  }

  function fireEventWithParams(event) {
  	shared_fireEvent(this.root, this.getAction(), { event: event, args: this.params });
  }

  function fireEventWithDynamicParams(event) {
  	var args = this.dynamicParams.getArgsList();

  	// need to strip [] from ends if a string!
  	if (typeof args === "string") {
  		args = args.substr(1, args.length - 2);
  	}

  	shared_fireEvent(this.root, this.getAction(), { event: event, args: args });
  }

  var shared_genericHandler = genericHandler;
  function genericHandler(event) {
  	var storage,
  	    handler,
  	    indices,
  	    index = {};

  	storage = this._ractive;
  	handler = storage.events[event.type];

  	if (indices = Resolvers_findIndexRefs(handler.element.parentFragment)) {
  		index = Resolvers_findIndexRefs.resolve(indices);
  	}

  	handler.fire({
  		node: this,
  		original: event,
  		index: index,
  		keypath: storage.keypath.str,
  		context: storage.root.viewmodel.get(storage.keypath)
  	});
  }

  var listen = EventHandler$listen;

  var customHandlers = {},
      touchEvents = {
  	touchstart: true,
  	touchmove: true,
  	touchend: true,
  	touchcancel: true,
  	//not w3c, but supported in some browsers
  	touchleave: true
  };
  function EventHandler$listen() {
  	var definition,
  	    name = this.name;

  	if (this.invalid) {
  		return;
  	}

  	if (definition = findInViewHierarchy("events", this.root, name)) {
  		this.custom = definition(this.node, getCustomHandler(name));
  	} else {
  		// Looks like we're dealing with a standard DOM event... but let's check
  		if (!("on" + name in this.node) && !(window && "on" + name in window) && !isJsdom) {

  			// okay to use touch events if this browser doesn't support them
  			if (!touchEvents[name]) {
  				warnOnceIfDebug(missingPlugin(name, "event"), { node: this.node });
  			}

  			return;
  		}

  		this.node.addEventListener(name, shared_genericHandler, false);
  	}

  	this.hasListener = true;
  }

  function getCustomHandler(name) {
  	if (!customHandlers[name]) {
  		customHandlers[name] = function (event) {
  			var storage = event.node._ractive;

  			event.index = storage.index;
  			event.keypath = storage.keypath.str;
  			event.context = storage.root.viewmodel.get(storage.keypath);

  			storage.events[name].fire(event);
  		};
  	}

  	return customHandlers[name];
  }

  var EventHandler_prototype_rebind = EventHandler$rebind;

  function EventHandler$rebind(oldKeypath, newKeypath) {
  	var fragment;
  	if (this.method) {
  		fragment = this.element.parentFragment;
  		this.refResolvers.forEach(rebind);

  		return;
  	}

  	if (typeof this.action !== "string") {
  		rebind(this.action);
  	}

  	if (this.dynamicParams) {
  		rebind(this.dynamicParams);
  	}

  	function rebind(thing) {
  		thing && thing.rebind(oldKeypath, newKeypath);
  	}
  }

  var EventHandler_prototype_render = EventHandler$render;

  function EventHandler$render() {
  	this.node = this.element.node;
  	// store this on the node itself, so it can be retrieved by a
  	// universal handler
  	this.node._ractive.events[this.name] = this;

  	if (this.method || this.getAction()) {
  		this.listen();
  	}
  }

  var prototype_resolve = EventHandler$resolve;

  function EventHandler$resolve(index, keypath) {
  	this.keypaths[index] = keypath;
  }

  var EventHandler_prototype_unbind = EventHandler$unbind;
  function EventHandler$unbind() {
  	if (this.method) {
  		this.refResolvers.forEach(methodCallers__unbind);
  		return;
  	}

  	// Tear down dynamic name
  	if (typeof this.action !== "string") {
  		this.action.unbind();
  	}

  	// Tear down dynamic parameters
  	if (this.dynamicParams) {
  		this.dynamicParams.unbind();
  	}
  }

  var EventHandler_prototype_unrender = EventHandler$unrender;
  function EventHandler$unrender() {

  	if (this.custom) {
  		this.custom.teardown();
  	} else {
  		this.node.removeEventListener(this.name, shared_genericHandler, false);
  	}

  	this.hasListener = false;
  }

  var EventHandler = function (element, name, template) {
  	this.init(element, name, template);
  };

  EventHandler.prototype = {
  	bubble: EventHandler_prototype_bubble,
  	fire: EventHandler_prototype_fire,
  	getAction: getAction,
  	init: EventHandler_prototype_init,
  	listen: listen,
  	rebind: EventHandler_prototype_rebind,
  	render: EventHandler_prototype_render,
  	resolve: prototype_resolve,
  	unbind: EventHandler_prototype_unbind,
  	unrender: EventHandler_prototype_unrender
  };

  var _EventHandler = EventHandler;

  var createEventHandlers = function (element, template) {
  	var i,
  	    name,
  	    names,
  	    handler,
  	    result = [];

  	for (name in template) {
  		if (template.hasOwnProperty(name)) {
  			names = name.split("-");
  			i = names.length;

  			while (i--) {
  				handler = new _EventHandler(element, names[i], template[name]);
  				result.push(handler);
  			}
  		}
  	}

  	return result;
  };

  var Decorator = function (element, template) {
  	var self = this,
  	    ractive,
  	    name,
  	    fragment;

  	this.element = element;
  	this.root = ractive = element.root;

  	name = template.n || template;

  	if (typeof name !== "string") {
  		fragment = new virtualdom_Fragment({
  			template: name,
  			root: ractive,
  			owner: element
  		});

  		name = fragment.toString();
  		fragment.unbind();

  		if (name === "") {
  			// empty string okay, just no decorator
  			return;
  		}
  	}

  	if (template.a) {
  		this.params = template.a;
  	} else if (template.d) {
  		this.fragment = new virtualdom_Fragment({
  			template: template.d,
  			root: ractive,
  			owner: element
  		});

  		this.params = this.fragment.getArgsList();

  		this.fragment.bubble = function () {
  			this.dirtyArgs = this.dirtyValue = true;
  			self.params = this.getArgsList();

  			if (self.ready) {
  				self.update();
  			}
  		};
  	}

  	this.fn = findInViewHierarchy("decorators", ractive, name);

  	if (!this.fn) {
  		fatal(missingPlugin(name, "decorator"));
  	}
  };

  Decorator.prototype = {
  	init: function () {
  		var node, result, args;

  		node = this.element.node;

  		if (this.params) {
  			args = [node].concat(this.params);
  			result = this.fn.apply(this.root, args);
  		} else {
  			result = this.fn.call(this.root, node);
  		}

  		if (!result || !result.teardown) {
  			throw new Error("Decorator definition must return an object with a teardown method");
  		}

  		// TODO does this make sense?
  		this.actual = result;
  		this.ready = true;
  	},

  	update: function () {
  		if (this.actual.update) {
  			this.actual.update.apply(this.root, this.params);
  		} else {
  			this.actual.teardown(true);
  			this.init();
  		}
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		if (this.fragment) {
  			this.fragment.rebind(oldKeypath, newKeypath);
  		}
  	},

  	teardown: function (updating) {
  		this.torndown = true;
  		if (this.ready) {
  			this.actual.teardown();
  		}

  		if (!updating && this.fragment) {
  			this.fragment.unbind();
  		}
  	}
  };

  var _Decorator = Decorator;

  function select__bubble() {
  	var _this = this;

  	if (!this.dirty) {
  		this.dirty = true;

  		global_runloop.scheduleTask(function () {
  			sync(_this);
  			_this.dirty = false;
  		});
  	}

  	this.parentFragment.bubble(); // default behaviour
  }

  function sync(selectElement) {
  	var selectNode, selectValue, isMultiple, options, optionWasSelected;

  	selectNode = selectElement.node;

  	if (!selectNode) {
  		return;
  	}

  	options = toArray(selectNode.options);

  	selectValue = selectElement.getAttribute("value");
  	isMultiple = selectElement.getAttribute("multiple");

  	// If the <select> has a specified value, that should override
  	// these options
  	if (selectValue !== undefined) {
  		options.forEach(function (o) {
  			var optionValue, shouldSelect;

  			optionValue = o._ractive ? o._ractive.value : o.value;
  			shouldSelect = isMultiple ? valueContains(selectValue, optionValue) : selectValue == optionValue;

  			if (shouldSelect) {
  				optionWasSelected = true;
  			}

  			o.selected = shouldSelect;
  		});

  		if (!optionWasSelected) {
  			if (options[0]) {
  				options[0].selected = true;
  			}

  			if (selectElement.binding) {
  				selectElement.binding.forceUpdate();
  			}
  		}
  	}

  	// Otherwise the value should be initialised according to which
  	// <option> element is selected, if twoway binding is in effect
  	else if (selectElement.binding) {
  		selectElement.binding.forceUpdate();
  	}
  }

  function valueContains(selectValue, optionValue) {
  	var i = selectValue.length;
  	while (i--) {
  		if (selectValue[i] == optionValue) {
  			return true;
  		}
  	}
  }

  function special_option__init(option, template) {
  	option.select = findParentSelect(option.parent);

  	// we might be inside a <datalist> element
  	if (!option.select) {
  		return;
  	}

  	option.select.options.push(option);

  	// If the value attribute is missing, use the element's content
  	if (!template.a) {
  		template.a = {};
  	}

  	// ...as long as it isn't disabled
  	if (template.a.value === undefined && !template.a.hasOwnProperty("disabled")) {
  		template.a.value = template.f;
  	}

  	// If there is a `selected` attribute, but the <select>
  	// already has a value, delete it
  	if ("selected" in template.a && option.select.getAttribute("value") !== undefined) {
  		delete template.a.selected;
  	}
  }

  function special_option__unbind(option) {
  	if (option.select) {
  		removeFromArray(option.select.options, option);
  	}
  }

  function findParentSelect(element) {
  	if (!element) {
  		return;
  	}

  	do {
  		if (element.name === "select") {
  			return element;
  		}
  	} while (element = element.parent);
  }

  var Element_prototype_init = Element$init;
  function Element$init(options) {
  	var parentFragment, template, ractive, binding, bindings, twoway, bindingAttrs;

  	this.type = ELEMENT;

  	// stuff we'll need later
  	parentFragment = this.parentFragment = options.parentFragment;
  	template = this.template = options.template;

  	this.parent = options.pElement || parentFragment.pElement;

  	this.root = ractive = parentFragment.root;
  	this.index = options.index;
  	this.key = options.key;

  	this.name = enforceCase(template.e);

  	// Special case - <option> elements
  	if (this.name === "option") {
  		special_option__init(this, template);
  	}

  	// Special case - <select> elements
  	if (this.name === "select") {
  		this.options = [];
  		this.bubble = select__bubble; // TODO this is a kludge
  	}

  	// Special case - <form> elements
  	if (this.name === "form") {
  		this.formBindings = [];
  	}

  	// handle binding attributes first (twoway, lazy)
  	bindingAttrs = processBindingAttributes(this, template);

  	// create attributes
  	this.attributes = createAttributes(this, template.a);
  	this.conditionalAttributes = createConditionalAttributes(this, template.m);

  	// append children, if there are any
  	if (template.f) {
  		this.fragment = new virtualdom_Fragment({
  			template: template.f,
  			root: ractive,
  			owner: this,
  			pElement: this,
  			cssIds: null
  		});
  	}

  	// the element setting should override the ractive setting
  	twoway = ractive.twoway;
  	if (bindingAttrs.twoway === false) twoway = false;else if (bindingAttrs.twoway === true) twoway = true;

  	this.twoway = twoway;
  	this.lazy = bindingAttrs.lazy;

  	// create twoway binding
  	if (twoway && (binding = init_createTwowayBinding(this, template.a))) {
  		this.binding = binding;

  		// register this with the root, so that we can do ractive.updateModel()
  		bindings = this.root._twowayBindings[binding.keypath.str] || (this.root._twowayBindings[binding.keypath.str] = []);
  		bindings.push(binding);
  	}

  	// create event proxies
  	if (template.v) {
  		this.eventHandlers = createEventHandlers(this, template.v);
  	}

  	// create decorator
  	if (template.o) {
  		this.decorator = new _Decorator(this, template.o);
  	}

  	// create transitions
  	this.intro = template.t0 || template.t1;
  	this.outro = template.t0 || template.t2;
  }

  var Element_prototype_rebind = Element$rebind;
  function Element$rebind(oldKeypath, newKeypath) {
  	var i, storage, liveQueries, ractive;

  	if (this.attributes) {
  		this.attributes.forEach(rebind);
  	}

  	if (this.conditionalAttributes) {
  		this.conditionalAttributes.forEach(rebind);
  	}

  	if (this.eventHandlers) {
  		this.eventHandlers.forEach(rebind);
  	}

  	if (this.decorator) {
  		rebind(this.decorator);
  	}

  	// rebind children
  	if (this.fragment) {
  		rebind(this.fragment);
  	}

  	// Update live queries, if necessary
  	if (liveQueries = this.liveQueries) {
  		ractive = this.root;

  		i = liveQueries.length;
  		while (i--) {
  			liveQueries[i]._makeDirty();
  		}
  	}

  	if (this.node && (storage = this.node._ractive)) {

  		// adjust keypath if needed
  		assignNewKeypath(storage, "keypath", oldKeypath, newKeypath);
  	}

  	function rebind(thing) {
  		thing.rebind(oldKeypath, newKeypath);
  	}
  }

  function special_img__render(img) {
  	var loadHandler;

  	// if this is an <img>, and we're in a crap browser, we may need to prevent it
  	// from overriding width and height when it loads the src
  	if (img.attributes.width || img.attributes.height) {
  		img.node.addEventListener("load", loadHandler = function () {
  			var width = img.getAttribute("width"),
  			    height = img.getAttribute("height");

  			if (width !== undefined) {
  				img.node.setAttribute("width", width);
  			}

  			if (height !== undefined) {
  				img.node.setAttribute("height", height);
  			}

  			img.node.removeEventListener("load", loadHandler, false);
  		}, false);
  	}
  }

  function form__render(element) {
  	element.node.addEventListener("reset", handleReset, false);
  }

  function form__unrender(element) {
  	element.node.removeEventListener("reset", handleReset, false);
  }

  function handleReset() {
  	var element = this._ractive.proxy;

  	global_runloop.start();
  	element.formBindings.forEach(updateModel);
  	global_runloop.end();
  }

  function updateModel(binding) {
  	binding.root.viewmodel.set(binding.keypath, binding.resetValue);
  }

  var Transition_prototype_init = Transition$init;
  function Transition$init(element, template, isIntro) {
  	var ractive, name, fragment;

  	this.element = element;
  	this.root = ractive = element.root;
  	this.isIntro = isIntro;

  	name = template.n || template;

  	if (typeof name !== "string") {
  		fragment = new virtualdom_Fragment({
  			template: name,
  			root: ractive,
  			owner: element
  		});

  		name = fragment.toString();
  		fragment.unbind();

  		if (name === "") {
  			// empty string okay, just no transition
  			return;
  		}
  	}

  	this.name = name;

  	if (template.a) {
  		this.params = template.a;
  	} else if (template.d) {
  		// TODO is there a way to interpret dynamic arguments without all the
  		// 'dependency thrashing'?
  		fragment = new virtualdom_Fragment({
  			template: template.d,
  			root: ractive,
  			owner: element
  		});

  		this.params = fragment.getArgsList();
  		fragment.unbind();
  	}

  	this._fn = findInViewHierarchy("transitions", ractive, name);

  	if (!this._fn) {
  		warnOnceIfDebug(missingPlugin(name, "transition"), { ractive: this.root });
  	}
  }

  var camelCase = function (hyphenatedStr) {
  	return hyphenatedStr.replace(/-([a-zA-Z])/g, function (match, $1) {
  		return $1.toUpperCase();
  	});
  };

  var helpers_prefix__prefix, prefixCache, helpers_prefix__testStyle;

  if (!isClient) {
  	helpers_prefix__prefix = null;
  } else {
  	prefixCache = {};
  	helpers_prefix__testStyle = createElement("div").style;

  	helpers_prefix__prefix = function (prop) {
  		var i, vendor, capped;

  		prop = camelCase(prop);

  		if (!prefixCache[prop]) {
  			if (helpers_prefix__testStyle[prop] !== undefined) {
  				prefixCache[prop] = prop;
  			} else {
  				// test vendors...
  				capped = prop.charAt(0).toUpperCase() + prop.substring(1);

  				i = vendors.length;
  				while (i--) {
  					vendor = vendors[i];
  					if (helpers_prefix__testStyle[vendor + capped] !== undefined) {
  						prefixCache[prop] = vendor + capped;
  						break;
  					}
  				}
  			}
  		}

  		return prefixCache[prop];
  	};
  }

  var helpers_prefix = helpers_prefix__prefix;

  var getStyle, prototype_getStyle__getComputedStyle;

  if (!isClient) {
  	getStyle = null;
  } else {
  	prototype_getStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;

  	getStyle = function (props) {
  		var computedStyle, styles, i, prop, value;

  		computedStyle = prototype_getStyle__getComputedStyle(this.node);

  		if (typeof props === "string") {
  			value = computedStyle[helpers_prefix(props)];
  			if (value === "0px") {
  				value = 0;
  			}
  			return value;
  		}

  		if (!isArray(props)) {
  			throw new Error("Transition$getStyle must be passed a string, or an array of strings representing CSS properties");
  		}

  		styles = {};

  		i = props.length;
  		while (i--) {
  			prop = props[i];
  			value = computedStyle[helpers_prefix(prop)];
  			if (value === "0px") {
  				value = 0;
  			}
  			styles[prop] = value;
  		}

  		return styles;
  	};
  }

  var prototype_getStyle = getStyle;

  var setStyle = function (style, value) {
  	var prop;

  	if (typeof style === "string") {
  		this.node.style[helpers_prefix(style)] = value;
  	} else {
  		for (prop in style) {
  			if (style.hasOwnProperty(prop)) {
  				this.node.style[helpers_prefix(prop)] = style[prop];
  			}
  		}
  	}

  	return this;
  };

  var Ticker = function (options) {
  	var easing;

  	this.duration = options.duration;
  	this.step = options.step;
  	this.complete = options.complete;

  	// easing
  	if (typeof options.easing === "string") {
  		easing = options.root.easing[options.easing];

  		if (!easing) {
  			warnOnceIfDebug(missingPlugin(options.easing, "easing"));
  			easing = linear;
  		}
  	} else if (typeof options.easing === "function") {
  		easing = options.easing;
  	} else {
  		easing = linear;
  	}

  	this.easing = easing;

  	this.start = utils_getTime();
  	this.end = this.start + this.duration;

  	this.running = true;
  	shared_animations.add(this);
  };

  Ticker.prototype = {
  	tick: function (now) {
  		var elapsed, eased;

  		if (!this.running) {
  			return false;
  		}

  		if (now > this.end) {
  			if (this.step) {
  				this.step(1);
  			}

  			if (this.complete) {
  				this.complete(1);
  			}

  			return false;
  		}

  		elapsed = now - this.start;
  		eased = this.easing(elapsed / this.duration);

  		if (this.step) {
  			this.step(eased);
  		}

  		return true;
  	},

  	stop: function () {
  		if (this.abort) {
  			this.abort();
  		}

  		this.running = false;
  	}
  };

  var shared_Ticker = Ticker;
  function linear(t) {
  	return t;
  }

  var unprefixPattern = new RegExp("^-(?:" + vendors.join("|") + ")-");

  var unprefix = function (prop) {
  	return prop.replace(unprefixPattern, "");
  };

  var vendorPattern = new RegExp("^(?:" + vendors.join("|") + ")([A-Z])");

  var hyphenate = function (str) {
  	var hyphenated;

  	if (!str) {
  		return ""; // edge case
  	}

  	if (vendorPattern.test(str)) {
  		str = "-" + str;
  	}

  	hyphenated = str.replace(/[A-Z]/g, function (match) {
  		return "-" + match.toLowerCase();
  	});

  	return hyphenated;
  };

  var createTransitions,
      animateStyle_createTransitions__testStyle,
      TRANSITION,
      TRANSITIONEND,
      CSS_TRANSITIONS_ENABLED,
      TRANSITION_DURATION,
      TRANSITION_PROPERTY,
      TRANSITION_TIMING_FUNCTION,
      canUseCssTransitions = {},
      cannotUseCssTransitions = {};

  if (!isClient) {
  	createTransitions = null;
  } else {
  	animateStyle_createTransitions__testStyle = createElement("div").style;

  	// determine some facts about our environment
  	(function () {
  		if (animateStyle_createTransitions__testStyle.transition !== undefined) {
  			TRANSITION = "transition";
  			TRANSITIONEND = "transitionend";
  			CSS_TRANSITIONS_ENABLED = true;
  		} else if (animateStyle_createTransitions__testStyle.webkitTransition !== undefined) {
  			TRANSITION = "webkitTransition";
  			TRANSITIONEND = "webkitTransitionEnd";
  			CSS_TRANSITIONS_ENABLED = true;
  		} else {
  			CSS_TRANSITIONS_ENABLED = false;
  		}
  	})();

  	if (TRANSITION) {
  		TRANSITION_DURATION = TRANSITION + "Duration";
  		TRANSITION_PROPERTY = TRANSITION + "Property";
  		TRANSITION_TIMING_FUNCTION = TRANSITION + "TimingFunction";
  	}

  	createTransitions = function (t, to, options, changedProperties, resolve) {

  		// Wait a beat (otherwise the target styles will be applied immediately)
  		// TODO use a fastdom-style mechanism?
  		setTimeout(function () {

  			var hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;

  			checkComplete = function () {
  				if (jsTransitionsComplete && cssTransitionsComplete) {
  					// will changes to events and fire have an unexpected consequence here?
  					t.root.fire(t.name + ":end", t.node, t.isIntro);
  					resolve();
  				}
  			};

  			// this is used to keep track of which elements can use CSS to animate
  			// which properties
  			hashPrefix = (t.node.namespaceURI || "") + t.node.tagName;

  			t.node.style[TRANSITION_PROPERTY] = changedProperties.map(helpers_prefix).map(hyphenate).join(",");
  			t.node.style[TRANSITION_TIMING_FUNCTION] = hyphenate(options.easing || "linear");
  			t.node.style[TRANSITION_DURATION] = options.duration / 1000 + "s";

  			transitionEndHandler = function (event) {
  				var index;

  				index = changedProperties.indexOf(camelCase(unprefix(event.propertyName)));
  				if (index !== -1) {
  					changedProperties.splice(index, 1);
  				}

  				if (changedProperties.length) {
  					// still transitioning...
  					return;
  				}

  				t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);

  				cssTransitionsComplete = true;
  				checkComplete();
  			};

  			t.node.addEventListener(TRANSITIONEND, transitionEndHandler, false);

  			setTimeout(function () {
  				var i = changedProperties.length,
  				    hash,
  				    originalValue,
  				    index,
  				    propertiesToTransitionInJs = [],
  				    prop,
  				    suffix;

  				while (i--) {
  					prop = changedProperties[i];
  					hash = hashPrefix + prop;

  					if (CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[hash]) {
  						t.node.style[helpers_prefix(prop)] = to[prop];

  						// If we're not sure if CSS transitions are supported for
  						// this tag/property combo, find out now
  						if (!canUseCssTransitions[hash]) {
  							originalValue = t.getStyle(prop);

  							// if this property is transitionable in this browser,
  							// the current style will be different from the target style
  							canUseCssTransitions[hash] = t.getStyle(prop) != to[prop];
  							cannotUseCssTransitions[hash] = !canUseCssTransitions[hash];

  							// Reset, if we're going to use timers after all
  							if (cannotUseCssTransitions[hash]) {
  								t.node.style[helpers_prefix(prop)] = originalValue;
  							}
  						}
  					}

  					if (!CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[hash]) {
  						// we need to fall back to timer-based stuff
  						if (originalValue === undefined) {
  							originalValue = t.getStyle(prop);
  						}

  						// need to remove this from changedProperties, otherwise transitionEndHandler
  						// will get confused
  						index = changedProperties.indexOf(prop);
  						if (index === -1) {
  							warnIfDebug("Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!", { node: t.node });
  						} else {
  							changedProperties.splice(index, 1);
  						}

  						// TODO Determine whether this property is animatable at all

  						suffix = /[^\d]*$/.exec(to[prop])[0];

  						// ...then kick off a timer-based transition
  						propertiesToTransitionInJs.push({
  							name: helpers_prefix(prop),
  							interpolator: shared_interpolate(parseFloat(originalValue), parseFloat(to[prop])),
  							suffix: suffix
  						});
  					}
  				}

  				// javascript transitions
  				if (propertiesToTransitionInJs.length) {
  					new shared_Ticker({
  						root: t.root,
  						duration: options.duration,
  						easing: camelCase(options.easing || ""),
  						step: function (pos) {
  							var prop, i;

  							i = propertiesToTransitionInJs.length;
  							while (i--) {
  								prop = propertiesToTransitionInJs[i];
  								t.node.style[prop.name] = prop.interpolator(pos) + prop.suffix;
  							}
  						},
  						complete: function () {
  							jsTransitionsComplete = true;
  							checkComplete();
  						}
  					});
  				} else {
  					jsTransitionsComplete = true;
  				}

  				if (!changedProperties.length) {
  					// We need to cancel the transitionEndHandler, and deal with
  					// the fact that it will never fire
  					t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);
  					cssTransitionsComplete = true;
  					checkComplete();
  				}
  			}, 0);
  		}, options.delay || 0);
  	};
  }

  var animateStyle_createTransitions = createTransitions;

  var hidden, vendor, animateStyle_visibility__prefix, animateStyle_visibility__i, visibility;

  if (typeof document !== "undefined") {
  	hidden = "hidden";

  	visibility = {};

  	if (hidden in document) {
  		animateStyle_visibility__prefix = "";
  	} else {
  		animateStyle_visibility__i = vendors.length;
  		while (animateStyle_visibility__i--) {
  			vendor = vendors[animateStyle_visibility__i];
  			hidden = vendor + "Hidden";

  			if (hidden in document) {
  				animateStyle_visibility__prefix = vendor;
  			}
  		}
  	}

  	if (animateStyle_visibility__prefix !== undefined) {
  		document.addEventListener(animateStyle_visibility__prefix + "visibilitychange", onChange);

  		// initialise
  		onChange();
  	} else {
  		// gah, we're in an old browser
  		if ("onfocusout" in document) {
  			document.addEventListener("focusout", onHide);
  			document.addEventListener("focusin", onShow);
  		} else {
  			window.addEventListener("pagehide", onHide);
  			window.addEventListener("blur", onHide);

  			window.addEventListener("pageshow", onShow);
  			window.addEventListener("focus", onShow);
  		}

  		visibility.hidden = false; // until proven otherwise. Not ideal but hey
  	}
  }

  function onChange() {
  	visibility.hidden = document[hidden];
  }

  function onHide() {
  	visibility.hidden = true;
  }

  function onShow() {
  	visibility.hidden = false;
  }

  var animateStyle_visibility = visibility;

  var animateStyle, _animateStyle__getComputedStyle, resolved;

  if (!isClient) {
  	animateStyle = null;
  } else {
  	_animateStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;

  	animateStyle = function (style, value, options) {
  		var _this = this;

  		var to;

  		if (arguments.length === 4) {
  			throw new Error("t.animateStyle() returns a promise - use .then() instead of passing a callback");
  		}

  		// Special case - page isn't visible. Don't animate anything, because
  		// that way you'll never get CSS transitionend events
  		if (animateStyle_visibility.hidden) {
  			this.setStyle(style, value);
  			return resolved || (resolved = utils_Promise.resolve());
  		}

  		if (typeof style === "string") {
  			to = {};
  			to[style] = value;
  		} else {
  			to = style;

  			// shuffle arguments
  			options = value;
  		}

  		// As of 0.3.9, transition authors should supply an `option` object with
  		// `duration` and `easing` properties (and optional `delay`), plus a
  		// callback function that gets called after the animation completes

  		// TODO remove this check in a future version
  		if (!options) {
  			warnOnceIfDebug("The \"%s\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340", this.name);
  			options = this;
  		}

  		var promise = new utils_Promise(function (resolve) {
  			var propertyNames, changedProperties, computedStyle, current, from, i, prop;

  			// Edge case - if duration is zero, set style synchronously and complete
  			if (!options.duration) {
  				_this.setStyle(to);
  				resolve();
  				return;
  			}

  			// Get a list of the properties we're animating
  			propertyNames = Object.keys(to);
  			changedProperties = [];

  			// Store the current styles
  			computedStyle = _animateStyle__getComputedStyle(_this.node);

  			from = {};
  			i = propertyNames.length;
  			while (i--) {
  				prop = propertyNames[i];
  				current = computedStyle[helpers_prefix(prop)];

  				if (current === "0px") {
  					current = 0;
  				}

  				// we need to know if we're actually changing anything
  				if (current != to[prop]) {
  					// use != instead of !==, so we can compare strings with numbers
  					changedProperties.push(prop);

  					// make the computed style explicit, so we can animate where
  					// e.g. height='auto'
  					_this.node.style[helpers_prefix(prop)] = current;
  				}
  			}

  			// If we're not actually changing anything, the transitionend event
  			// will never fire! So we complete early
  			if (!changedProperties.length) {
  				resolve();
  				return;
  			}

  			animateStyle_createTransitions(_this, to, options, changedProperties, resolve);
  		});

  		return promise;
  	};
  }

  var _animateStyle = animateStyle;

  var processParams = function (params, defaults) {
  	if (typeof params === "number") {
  		params = { duration: params };
  	} else if (typeof params === "string") {
  		if (params === "slow") {
  			params = { duration: 600 };
  		} else if (params === "fast") {
  			params = { duration: 200 };
  		} else {
  			params = { duration: 400 };
  		}
  	} else if (!params) {
  		params = {};
  	}

  	return fillGaps({}, params, defaults);
  };

  var prototype_start = Transition$start;

  function Transition$start() {
  	var _this = this;

  	var node, originalStyle, completed;

  	node = this.node = this.element.node;
  	originalStyle = node.getAttribute("style");

  	// create t.complete() - we don't want this on the prototype,
  	// because we don't want `this` silliness when passing it as
  	// an argument
  	this.complete = function (noReset) {
  		if (completed) {
  			return;
  		}

  		if (!noReset && _this.isIntro) {
  			resetStyle(node, originalStyle);
  		}

  		node._ractive.transition = null;
  		_this._manager.remove(_this);

  		completed = true;
  	};

  	// If the transition function doesn't exist, abort
  	if (!this._fn) {
  		this.complete();
  		return;
  	}

  	this._fn.apply(this.root, [this].concat(this.params));
  }

  function resetStyle(node, style) {
  	if (style) {
  		node.setAttribute("style", style);
  	} else {

  		// Next line is necessary, to remove empty style attribute!
  		// See http://stackoverflow.com/a/7167553
  		node.getAttribute("style");
  		node.removeAttribute("style");
  	}
  }

  var Transition = function (owner, template, isIntro) {
  	this.init(owner, template, isIntro);
  };

  Transition.prototype = {
  	init: Transition_prototype_init,
  	start: prototype_start,
  	getStyle: prototype_getStyle,
  	setStyle: setStyle,
  	animateStyle: _animateStyle,
  	processParams: processParams
  };

  var _Transition = Transition;

  var Element_prototype_render = Element$render;

  var updateCss, updateScript;

  updateCss = function () {
  	var node = this.node,
  	    content = this.fragment.toString(false);

  	// IE8 has no styleSheet unless there's a type text/css
  	if (window && window.appearsToBeIELessEqual8) {
  		node.type = "text/css";
  	}

  	if (node.styleSheet) {
  		node.styleSheet.cssText = content;
  	} else {

  		while (node.hasChildNodes()) {
  			node.removeChild(node.firstChild);
  		}

  		node.appendChild(document.createTextNode(content));
  	}
  };

  updateScript = function () {
  	if (!this.node.type || this.node.type === "text/javascript") {
  		warnIfDebug("Script tag was updated. This does not cause the code to be re-evaluated!", { ractive: this.root });
  		// As it happens, we ARE in a position to re-evaluate the code if we wanted
  		// to - we could eval() it, or insert it into a fresh (temporary) script tag.
  		// But this would be a terrible idea with unpredictable results, so let's not.
  	}

  	this.node.text = this.fragment.toString(false);
  };
  function Element$render() {
  	var _this = this;

  	var root = this.root,
  	    namespace,
  	    node,
  	    transition;

  	namespace = getNamespace(this);
  	node = this.node = createElement(this.name, namespace);

  	// Is this a top-level node of a component? If so, we may need to add
  	// a data-ractive-css attribute, for CSS encapsulation
  	if (this.parentFragment.cssIds) {
  		this.node.setAttribute("data-ractive-css", this.parentFragment.cssIds.map(function (x) {
  			return "{" + x + "}";
  		}).join(" "));
  	}

  	// Add _ractive property to the node - we use this object to store stuff
  	// related to proxy events, two-way bindings etc
  	defineProperty(this.node, "_ractive", {
  		value: {
  			proxy: this,
  			keypath: getInnerContext(this.parentFragment),
  			events: create(null),
  			root: root
  		}
  	});

  	// Render attributes
  	this.attributes.forEach(function (a) {
  		return a.render(node);
  	});
  	this.conditionalAttributes.forEach(function (a) {
  		return a.render(node);
  	});

  	// Render children
  	if (this.fragment) {
  		// Special case - <script> element
  		if (this.name === "script") {
  			this.bubble = updateScript;
  			this.node.text = this.fragment.toString(false); // bypass warning initially
  			this.fragment.unrender = noop; // TODO this is a kludge
  		}

  		// Special case - <style> element
  		else if (this.name === "style") {
  			this.bubble = updateCss;
  			this.bubble();
  			this.fragment.unrender = noop;
  		}

  		// Special case - contenteditable
  		else if (this.binding && this.getAttribute("contenteditable")) {
  			this.fragment.unrender = noop;
  		} else {
  			this.node.appendChild(this.fragment.render());
  		}
  	}

  	// deal with two-way bindings
  	if (this.binding) {
  		this.binding.render();
  		this.node._ractive.binding = this.binding;
  	}

  	// Add proxy event handlers
  	if (this.eventHandlers) {
  		this.eventHandlers.forEach(function (h) {
  			return h.render();
  		});
  	}

  	if (this.name === "option") {
  		processOption(this);
  	}

  	// Special cases
  	if (this.name === "img") {
  		// if this is an <img>, and we're in a crap browser, we may
  		// need to prevent it from overriding width and height when
  		// it loads the src
  		special_img__render(this);
  	} else if (this.name === "form") {
  		// forms need to keep track of their bindings, in case of reset
  		form__render(this);
  	} else if (this.name === "input" || this.name === "textarea") {
  		// inputs and textareas should store their initial value as
  		// `defaultValue` in case of reset
  		this.node.defaultValue = this.node.value;
  	} else if (this.name === "option") {
  		// similarly for option nodes
  		this.node.defaultSelected = this.node.selected;
  	}

  	// apply decorator(s)
  	if (this.decorator && this.decorator.fn) {
  		global_runloop.scheduleTask(function () {
  			if (!_this.decorator.torndown) {
  				_this.decorator.init();
  			}
  		}, true);
  	}

  	// trigger intro transition
  	if (root.transitionsEnabled && this.intro) {
  		transition = new _Transition(this, this.intro, true);
  		global_runloop.registerTransition(transition);
  		global_runloop.scheduleTask(function () {
  			return transition.start();
  		}, true);

  		this.transition = transition;
  	}

  	if (this.node.autofocus) {
  		// Special case. Some browsers (*cough* Firefix *cough*) have a problem
  		// with dynamically-generated elements having autofocus, and they won't
  		// allow you to programmatically focus the element until it's in the DOM
  		global_runloop.scheduleTask(function () {
  			return _this.node.focus();
  		}, true);
  	}

  	updateLiveQueries(this);
  	return this.node;
  }

  function getNamespace(element) {
  	var namespace, xmlns, parent;

  	// Use specified namespace...
  	if (xmlns = element.getAttribute("xmlns")) {
  		namespace = xmlns;
  	}

  	// ...or SVG namespace, if this is an <svg> element
  	else if (element.name === "svg") {
  		namespace = namespaces.svg;
  	} else if (parent = element.parent) {
  		// ...or HTML, if the parent is a <foreignObject>
  		if (parent.name === "foreignObject") {
  			namespace = namespaces.html;
  		}

  		// ...or inherit from the parent node
  		else {
  			namespace = parent.node.namespaceURI;
  		}
  	} else {
  		namespace = element.root.el.namespaceURI;
  	}

  	return namespace;
  }

  function processOption(option) {
  	var optionValue, selectValue, i;

  	if (!option.select) {
  		return;
  	}

  	selectValue = option.select.getAttribute("value");
  	if (selectValue === undefined) {
  		return;
  	}

  	optionValue = option.getAttribute("value");

  	if (option.select.node.multiple && isArray(selectValue)) {
  		i = selectValue.length;
  		while (i--) {
  			if (optionValue == selectValue[i]) {
  				option.node.selected = true;
  				break;
  			}
  		}
  	} else {
  		option.node.selected = optionValue == selectValue;
  	}
  }

  function updateLiveQueries(element) {
  	var instance, liveQueries, i, selector, query;

  	// Does this need to be added to any live queries?
  	instance = element.root;

  	do {
  		liveQueries = instance._liveQueries;

  		i = liveQueries.length;
  		while (i--) {
  			selector = liveQueries[i];
  			query = liveQueries["_" + selector];

  			if (query._test(element)) {
  				// keep register of applicable selectors, for when we teardown
  				(element.liveQueries || (element.liveQueries = [])).push(query);
  			}
  		}
  	} while (instance = instance.parent);
  }

  var Element_prototype_toString = function () {
  	var str, escape;

  	if (this.template.y) {
  		// DOCTYPE declaration
  		return "<!DOCTYPE" + this.template.dd + ">";
  	}

  	str = "<" + this.template.e;

  	str += this.attributes.map(stringifyAttribute).join("") + this.conditionalAttributes.map(stringifyAttribute).join("");

  	// Special case - selected options
  	if (this.name === "option" && optionIsSelected(this)) {
  		str += " selected";
  	}

  	// Special case - two-way radio name bindings
  	if (this.name === "input" && inputIsCheckedRadio(this)) {
  		str += " checked";
  	}

  	str += ">";

  	// Special case - textarea
  	if (this.name === "textarea" && this.getAttribute("value") !== undefined) {
  		str += escapeHtml(this.getAttribute("value"));
  	}

  	// Special case - contenteditable
  	else if (this.getAttribute("contenteditable") !== undefined) {
  		str += this.getAttribute("value") || "";
  	}

  	if (this.fragment) {
  		escape = this.name !== "script" && this.name !== "style";
  		str += this.fragment.toString(escape);
  	}

  	// add a closing tag if this isn't a void element
  	if (!voidElementNames.test(this.template.e)) {
  		str += "</" + this.template.e + ">";
  	}

  	return str;
  };

  function optionIsSelected(element) {
  	var optionValue, selectValue, i;

  	optionValue = element.getAttribute("value");

  	if (optionValue === undefined || !element.select) {
  		return false;
  	}

  	selectValue = element.select.getAttribute("value");

  	if (selectValue == optionValue) {
  		return true;
  	}

  	if (element.select.getAttribute("multiple") && isArray(selectValue)) {
  		i = selectValue.length;
  		while (i--) {
  			if (selectValue[i] == optionValue) {
  				return true;
  			}
  		}
  	}
  }

  function inputIsCheckedRadio(element) {
  	var attributes, typeAttribute, valueAttribute, nameAttribute;

  	attributes = element.attributes;

  	typeAttribute = attributes.type;
  	valueAttribute = attributes.value;
  	nameAttribute = attributes.name;

  	if (!typeAttribute || typeAttribute.value !== "radio" || !valueAttribute || !nameAttribute.interpolator) {
  		return;
  	}

  	if (valueAttribute.value === nameAttribute.interpolator.value) {
  		return true;
  	}
  }

  function stringifyAttribute(attribute) {
  	var str = attribute.toString();
  	return str ? " " + str : "";
  }

  var Element_prototype_unbind = Element$unbind;
  function Element$unbind() {
  	if (this.fragment) {
  		this.fragment.unbind();
  	}

  	if (this.binding) {
  		this.binding.unbind();
  	}

  	if (this.eventHandlers) {
  		this.eventHandlers.forEach(methodCallers__unbind);
  	}

  	// Special case - <option>
  	if (this.name === "option") {
  		special_option__unbind(this);
  	}

  	this.attributes.forEach(methodCallers__unbind);
  	this.conditionalAttributes.forEach(methodCallers__unbind);
  }

  var Element_prototype_unrender = Element$unrender;

  function Element$unrender(shouldDestroy) {
  	var binding, bindings, transition;

  	if (transition = this.transition) {
  		transition.complete();
  	}

  	// Detach as soon as we can
  	if (this.name === "option") {
  		// <option> elements detach immediately, so that
  		// their parent <select> element syncs correctly, and
  		// since option elements can't have transitions anyway
  		this.detach();
  	} else if (shouldDestroy) {
  		global_runloop.detachWhenReady(this);
  	}

  	// Children first. that way, any transitions on child elements will be
  	// handled by the current transitionManager
  	if (this.fragment) {
  		this.fragment.unrender(false);
  	}

  	if (binding = this.binding) {
  		this.binding.unrender();

  		this.node._ractive.binding = null;
  		bindings = this.root._twowayBindings[binding.keypath.str];
  		bindings.splice(bindings.indexOf(binding), 1);
  	}

  	// Remove event handlers
  	if (this.eventHandlers) {
  		this.eventHandlers.forEach(methodCallers__unrender);
  	}

  	if (this.decorator) {
  		global_runloop.registerDecorator(this.decorator);
  	}

  	// trigger outro transition if necessary
  	if (this.root.transitionsEnabled && this.outro) {
  		transition = new _Transition(this, this.outro, false);
  		global_runloop.registerTransition(transition);
  		global_runloop.scheduleTask(function () {
  			return transition.start();
  		});
  	}

  	// Remove this node from any live queries
  	if (this.liveQueries) {
  		removeFromLiveQueries(this);
  	}

  	if (this.name === "form") {
  		form__unrender(this);
  	}
  }

  function removeFromLiveQueries(element) {
  	var query, selector, i;

  	i = element.liveQueries.length;
  	while (i--) {
  		query = element.liveQueries[i];
  		selector = query.selector;

  		query._remove(element.node);
  	}
  }

  var Element = function (options) {
  	this.init(options);
  };

  Element.prototype = {
  	bubble: Element_prototype_bubble,
  	detach: Element_prototype_detach,
  	find: Element_prototype_find,
  	findAll: Element_prototype_findAll,
  	findAllComponents: Element_prototype_findAllComponents,
  	findComponent: Element_prototype_findComponent,
  	findNextNode: Element_prototype_findNextNode,
  	firstNode: Element_prototype_firstNode,
  	getAttribute: getAttribute,
  	init: Element_prototype_init,
  	rebind: Element_prototype_rebind,
  	render: Element_prototype_render,
  	toString: Element_prototype_toString,
  	unbind: Element_prototype_unbind,
  	unrender: Element_prototype_unrender
  };

  var _Element = Element;

  var deIndent__empty = /^\s*$/,
      deIndent__leadingWhitespace = /^\s*/;

  var deIndent = function (str) {
  	var lines, firstLine, lastLine, minIndent;

  	lines = str.split("\n");

  	// remove first and last line, if they only contain whitespace
  	firstLine = lines[0];
  	if (firstLine !== undefined && deIndent__empty.test(firstLine)) {
  		lines.shift();
  	}

  	lastLine = lastItem(lines);
  	if (lastLine !== undefined && deIndent__empty.test(lastLine)) {
  		lines.pop();
  	}

  	minIndent = lines.reduce(reducer, null);

  	if (minIndent) {
  		str = lines.map(function (line) {
  			return line.replace(minIndent, "");
  		}).join("\n");
  	}

  	return str;
  };

  function reducer(previous, line) {
  	var lineIndent = deIndent__leadingWhitespace.exec(line)[0];

  	if (previous === null || lineIndent.length < previous.length) {
  		return lineIndent;
  	}

  	return previous;
  }

  var Partial_getPartialTemplate = getPartialTemplate;

  function getPartialTemplate(ractive, name, parentFragment) {
  	var partial;

  	// If the partial in instance or view heirarchy instances, great
  	if (partial = getPartialFromRegistry(ractive, name, parentFragment || {})) {
  		return partial;
  	}

  	// Does it exist on the page as a script tag?
  	partial = template_parser.fromId(name, { noThrow: true });

  	if (partial) {
  		// is this necessary?
  		partial = deIndent(partial);

  		// parse and register to this ractive instance
  		var parsed = template_parser.parse(partial, template_parser.getParseOptions(ractive));

  		// register (and return main partial if there are others in the template)
  		return ractive.partials[name] = parsed.t;
  	}
  }

  function getPartialFromRegistry(ractive, name, parentFragment) {
  	var fn = undefined,
  	    partial = findParentPartial(name, parentFragment.owner);

  	// if there was an instance up-hierarchy, cool
  	if (partial) return partial;

  	// find first instance in the ractive or view hierarchy that has this partial
  	var instance = findInstance("partials", ractive, name);

  	if (!instance) {
  		return;
  	}

  	partial = instance.partials[name];

  	// partial is a function?
  	if (typeof partial === "function") {
  		fn = partial.bind(instance);
  		fn.isOwner = instance.partials.hasOwnProperty(name);
  		partial = fn.call(ractive, template_parser);
  	}

  	if (!partial && partial !== "") {
  		warnIfDebug(noRegistryFunctionReturn, name, "partial", "partial", { ractive: ractive });
  		return;
  	}

  	// If this was added manually to the registry,
  	// but hasn't been parsed, parse it now
  	if (!template_parser.isParsed(partial)) {

  		// use the parseOptions of the ractive instance on which it was found
  		var parsed = template_parser.parse(partial, template_parser.getParseOptions(instance));

  		// Partials cannot contain nested partials!
  		// TODO add a test for this
  		if (parsed.p) {
  			warnIfDebug("Partials ({{>%s}}) cannot contain nested inline partials", name, { ractive: ractive });
  		}

  		// if fn, use instance to store result, otherwise needs to go
  		// in the correct point in prototype chain on instance or constructor
  		var target = fn ? instance : findOwner(instance, name);

  		// may be a template with partials, which need to be registered and main template extracted
  		target.partials[name] = partial = parsed.t;
  	}

  	// store for reset
  	if (fn) {
  		partial._fn = fn;
  	}

  	return partial.v ? partial.t : partial;
  }

  function findOwner(ractive, key) {
  	return ractive.partials.hasOwnProperty(key) ? ractive : findConstructor(ractive.constructor, key);
  }

  function findConstructor(constructor, key) {
  	if (!constructor) {
  		return;
  	}
  	return constructor.partials.hasOwnProperty(key) ? constructor : findConstructor(constructor._Parent, key);
  }

  function findParentPartial(name, parent) {
  	if (parent) {
  		if (parent.template && parent.template.p && parent.template.p[name]) {
  			return parent.template.p[name];
  		} else if (parent.parentFragment && parent.parentFragment.owner) {
  			return findParentPartial(name, parent.parentFragment.owner);
  		}
  	}
  }

  var applyIndent = function (string, indent) {
  	var indented;

  	if (!indent) {
  		return string;
  	}

  	indented = string.split("\n").map(function (line, notFirstLine) {
  		return notFirstLine ? indent + line : line;
  	}).join("\n");

  	return indented;
  };

  var missingPartialMessage = "Could not find template for partial \"%s\"";

  var Partial = function (options) {
  	var parentFragment, template;

  	parentFragment = this.parentFragment = options.parentFragment;

  	this.root = parentFragment.root;
  	this.type = PARTIAL;
  	this.index = options.index;
  	this.name = options.template.r;
  	this.rendered = false;

  	this.fragment = this.fragmentToRender = this.fragmentToUnrender = null;

  	Mustache.init(this, options);

  	// If this didn't resolve, it most likely means we have a named partial
  	// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial
  	// whose name is the value of `foo`')
  	if (!this.keypath) {
  		if (template = Partial_getPartialTemplate(this.root, this.name, parentFragment)) {
  			shared_unbind.call(this); // prevent any further changes
  			this.isNamed = true;
  			this.setTemplate(template);
  		} else {
  			warnOnceIfDebug(missingPartialMessage, this.name);
  		}
  	}
  };

  Partial.prototype = {
  	bubble: function () {
  		this.parentFragment.bubble();
  	},

  	detach: function () {
  		return this.fragment.detach();
  	},

  	find: function (selector) {
  		return this.fragment.find(selector);
  	},

  	findAll: function (selector, query) {
  		return this.fragment.findAll(selector, query);
  	},

  	findComponent: function (selector) {
  		return this.fragment.findComponent(selector);
  	},

  	findAllComponents: function (selector, query) {
  		return this.fragment.findAllComponents(selector, query);
  	},

  	firstNode: function () {
  		return this.fragment.firstNode();
  	},

  	findNextNode: function () {
  		return this.parentFragment.findNextNode(this);
  	},

  	getPartialName: function () {
  		if (this.isNamed && this.name) return this.name;else if (this.value === undefined) return this.name;else return this.value;
  	},

  	getValue: function () {
  		return this.fragment.getValue();
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		// named partials aren't bound, so don't rebind
  		if (!this.isNamed) {
  			Mustache_rebind.call(this, oldKeypath, newKeypath);
  		}

  		if (this.fragment) {
  			this.fragment.rebind(oldKeypath, newKeypath);
  		}
  	},

  	render: function () {
  		this.docFrag = document.createDocumentFragment();
  		this.update();

  		this.rendered = true;
  		return this.docFrag;
  	},

  	resolve: Mustache.resolve,

  	setValue: function (value) {
  		var template;

  		if (value !== undefined && value === this.value) {
  			// nothing has changed, so no work to be done
  			return;
  		}

  		if (value !== undefined) {
  			template = Partial_getPartialTemplate(this.root, "" + value, this.parentFragment);
  		}

  		// we may be here if we have a partial like `{{>foo}}` and `foo` is the
  		// name of both a data property (whose value ISN'T the name of a partial)
  		// and a partial. In those cases, this becomes a named partial
  		if (!template && this.name && (template = Partial_getPartialTemplate(this.root, this.name, this.parentFragment))) {
  			shared_unbind.call(this);
  			this.isNamed = true;
  		}

  		if (!template) {
  			warnOnceIfDebug(missingPartialMessage, this.name, { ractive: this.root });
  		}

  		this.value = value;

  		this.setTemplate(template || []);

  		this.bubble();

  		if (this.rendered) {
  			global_runloop.addView(this);
  		}
  	},

  	setTemplate: function (template) {
  		if (this.fragment) {
  			this.fragment.unbind();
  			if (this.rendered) {
  				this.fragmentToUnrender = this.fragment;
  			}
  		}

  		this.fragment = new virtualdom_Fragment({
  			template: template,
  			root: this.root,
  			owner: this,
  			pElement: this.parentFragment.pElement
  		});

  		this.fragmentToRender = this.fragment;
  	},

  	toString: function (toString) {
  		var string, previousItem, lastLine, match;

  		string = this.fragment.toString(toString);

  		previousItem = this.parentFragment.items[this.index - 1];

  		if (!previousItem || previousItem.type !== TEXT) {
  			return string;
  		}

  		lastLine = previousItem.text.split("\n").pop();

  		if (match = /^\s+$/.exec(lastLine)) {
  			return applyIndent(string, match[0]);
  		}

  		return string;
  	},

  	unbind: function () {
  		if (!this.isNamed) {
  			// dynamic partial - need to unbind self
  			shared_unbind.call(this);
  		}

  		if (this.fragment) {
  			this.fragment.unbind();
  		}
  	},

  	unrender: function (shouldDestroy) {
  		if (this.rendered) {
  			if (this.fragment) {
  				this.fragment.unrender(shouldDestroy);
  			}
  			this.rendered = false;
  		}
  	},

  	update: function () {
  		var target, anchor;

  		if (this.fragmentToUnrender) {
  			this.fragmentToUnrender.unrender(true);
  			this.fragmentToUnrender = null;
  		}

  		if (this.fragmentToRender) {
  			this.docFrag.appendChild(this.fragmentToRender.render());
  			this.fragmentToRender = null;
  		}

  		if (this.rendered) {
  			target = this.parentFragment.getNode();
  			anchor = this.parentFragment.findNextNode(this);
  			target.insertBefore(this.docFrag, anchor);
  		}
  	}
  };

  var _Partial = Partial;

  // finds the component constructor in the registry or view hierarchy registries

  var Component_getComponent = getComponent;
  function getComponent(ractive, name) {

  	var Component,
  	    instance = findInstance("components", ractive, name);

  	if (instance) {
  		Component = instance.components[name];

  		// best test we have for not Ractive.extend
  		if (!Component._Parent) {
  			// function option, execute and store for reset
  			var fn = Component.bind(instance);
  			fn.isOwner = instance.components.hasOwnProperty(name);
  			Component = fn();

  			if (!Component) {
  				warnIfDebug(noRegistryFunctionReturn, name, "component", "component", { ractive: ractive });

  				return;
  			}

  			if (typeof Component === "string") {
  				// allow string lookup
  				Component = getComponent(ractive, Component);
  			}

  			Component._fn = fn;
  			instance.components[name] = Component;
  		}
  	}

  	return Component;
  }

  var Component_prototype_detach = Component$detach;
  var Component_prototype_detach__detachHook = new hooks_Hook("detach");
  function Component$detach() {
  	var detached = this.instance.fragment.detach();
  	Component_prototype_detach__detachHook.fire(this.instance);
  	return detached;
  }

  var Component_prototype_find = Component$find;

  function Component$find(selector) {
  	return this.instance.fragment.find(selector);
  }

  var Component_prototype_findAll = Component$findAll;

  function Component$findAll(selector, query) {
  	return this.instance.fragment.findAll(selector, query);
  }

  var Component_prototype_findAllComponents = Component$findAllComponents;

  function Component$findAllComponents(selector, query) {
  	query._test(this, true);

  	if (this.instance.fragment) {
  		this.instance.fragment.findAllComponents(selector, query);
  	}
  }

  var Component_prototype_findComponent = Component$findComponent;

  function Component$findComponent(selector) {
  	if (!selector || selector === this.name) {
  		return this.instance;
  	}

  	if (this.instance.fragment) {
  		return this.instance.fragment.findComponent(selector);
  	}

  	return null;
  }

  var Component_prototype_findNextNode = Component$findNextNode;

  function Component$findNextNode() {
  	return this.parentFragment.findNextNode(this);
  }

  var Component_prototype_firstNode = Component$firstNode;

  function Component$firstNode() {
  	if (this.rendered) {
  		return this.instance.fragment.firstNode();
  	}

  	return null;
  }

  var processWrapper = function (wrapper, array, methodName, newIndices) {
  	var root = wrapper.root;
  	var keypath = wrapper.keypath;

  	if (!!newIndices) {
  		root.viewmodel.smartUpdate(keypath, array, newIndices);
  	} else {
  		// If this is a sort or reverse, we just do root.set()...
  		// TODO use merge logic?
  		root.viewmodel.mark(keypath);
  	}
  };

  var patchedArrayProto = [],
      mutatorMethods = ["pop", "push", "reverse", "shift", "sort", "splice", "unshift"],
      testObj,
      patchArrayMethods,
      unpatchArrayMethods;

  mutatorMethods.forEach(function (methodName) {
  	var method = function () {
  		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
  			args[_key] = arguments[_key];
  		}

  		var newIndices, result, wrapper, i;

  		newIndices = shared_getNewIndices(this, methodName, args);

  		// apply the underlying method
  		result = Array.prototype[methodName].apply(this, arguments);

  		// trigger changes
  		global_runloop.start();

  		this._ractive.setting = true;
  		i = this._ractive.wrappers.length;
  		while (i--) {
  			wrapper = this._ractive.wrappers[i];

  			global_runloop.addRactive(wrapper.root);
  			processWrapper(wrapper, this, methodName, newIndices);
  		}

  		global_runloop.end();

  		this._ractive.setting = false;
  		return result;
  	};

  	defineProperty(patchedArrayProto, methodName, {
  		value: method
  	});
  });

  // can we use prototype chain injection?
  // http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection
  testObj = {};

  if (testObj.__proto__) {
  	// yes, we can
  	patchArrayMethods = function (array) {
  		array.__proto__ = patchedArrayProto;
  	};

  	unpatchArrayMethods = function (array) {
  		array.__proto__ = Array.prototype;
  	};
  } else {
  	// no, we can't
  	patchArrayMethods = function (array) {
  		var i, methodName;

  		i = mutatorMethods.length;
  		while (i--) {
  			methodName = mutatorMethods[i];
  			defineProperty(array, methodName, {
  				value: patchedArrayProto[methodName],
  				configurable: true
  			});
  		}
  	};

  	unpatchArrayMethods = function (array) {
  		var i;

  		i = mutatorMethods.length;
  		while (i--) {
  			delete array[mutatorMethods[i]];
  		}
  	};
  }

  patchArrayMethods.unpatch = unpatchArrayMethods;
  var patch = patchArrayMethods;

  var arrayAdaptor,

  // helpers
  ArrayWrapper, array_index__errorMessage;

  arrayAdaptor = {
  	filter: function (object) {
  		// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,
  		// or the array didn't trigger the get() itself
  		return isArray(object) && (!object._ractive || !object._ractive.setting);
  	},
  	wrap: function (ractive, array, keypath) {
  		return new ArrayWrapper(ractive, array, keypath);
  	}
  };

  ArrayWrapper = function (ractive, array, keypath) {
  	this.root = ractive;
  	this.value = array;
  	this.keypath = getKeypath(keypath);

  	// if this array hasn't already been ractified, ractify it
  	if (!array._ractive) {

  		// define a non-enumerable _ractive property to store the wrappers
  		defineProperty(array, "_ractive", {
  			value: {
  				wrappers: [],
  				instances: [],
  				setting: false
  			},
  			configurable: true
  		});

  		patch(array);
  	}

  	// store the ractive instance, so we can handle transitions later
  	if (!array._ractive.instances[ractive._guid]) {
  		array._ractive.instances[ractive._guid] = 0;
  		array._ractive.instances.push(ractive);
  	}

  	array._ractive.instances[ractive._guid] += 1;
  	array._ractive.wrappers.push(this);
  };

  ArrayWrapper.prototype = {
  	get: function () {
  		return this.value;
  	},
  	teardown: function () {
  		var array, storage, wrappers, instances, index;

  		array = this.value;
  		storage = array._ractive;
  		wrappers = storage.wrappers;
  		instances = storage.instances;

  		// if teardown() was invoked because we're clearing the cache as a result of
  		// a change that the array itself triggered, we can save ourselves the teardown
  		// and immediate setup
  		if (storage.setting) {
  			return false; // so that we don't remove it from this.root.viewmodel.wrapped
  		}

  		index = wrappers.indexOf(this);
  		if (index === -1) {
  			throw new Error(array_index__errorMessage);
  		}

  		wrappers.splice(index, 1);

  		// if nothing else depends on this array, we can revert it to its
  		// natural state
  		if (!wrappers.length) {
  			delete array._ractive;
  			patch.unpatch(this.value);
  		} else {
  			// remove ractive instance if possible
  			instances[this.root._guid] -= 1;
  			if (!instances[this.root._guid]) {
  				index = instances.indexOf(this.root);

  				if (index === -1) {
  					throw new Error(array_index__errorMessage);
  				}

  				instances.splice(index, 1);
  			}
  		}
  	}
  };

  array_index__errorMessage = "Something went wrong in a rather interesting way";
  var array_index = arrayAdaptor;

  var numeric = /^\s*[0-9]+\s*$/;

  var createBranch = function (key) {
  	return numeric.test(key) ? [] : {};
  };

  var magicAdaptor, MagicWrapper;

  try {
  	Object.defineProperty({}, "test", { value: 0 });

  	magicAdaptor = {
  		filter: function (object, keypath, ractive) {
  			var parentWrapper, parentValue;

  			if (!keypath) {
  				return false;
  			}

  			keypath = getKeypath(keypath);

  			// If the parent value is a wrapper, other than a magic wrapper,
  			// we shouldn't wrap this property
  			if ((parentWrapper = ractive.viewmodel.wrapped[keypath.parent.str]) && !parentWrapper.magic) {
  				return false;
  			}

  			parentValue = ractive.viewmodel.get(keypath.parent);

  			// if parentValue is an array that doesn't include this member,
  			// we should return false otherwise lengths will get messed up
  			if (isArray(parentValue) && /^[0-9]+$/.test(keypath.lastKey)) {
  				return false;
  			}

  			return parentValue && (typeof parentValue === "object" || typeof parentValue === "function");
  		},
  		wrap: function (ractive, property, keypath) {
  			return new MagicWrapper(ractive, property, keypath);
  		}
  	};

  	MagicWrapper = function (ractive, value, keypath) {
  		var objKeypath, template, siblings;

  		keypath = getKeypath(keypath);

  		this.magic = true;

  		this.ractive = ractive;
  		this.keypath = keypath;
  		this.value = value;

  		this.prop = keypath.lastKey;

  		objKeypath = keypath.parent;
  		this.obj = objKeypath.isRoot ? ractive.viewmodel.data : ractive.viewmodel.get(objKeypath);

  		template = this.originalDescriptor = Object.getOwnPropertyDescriptor(this.obj, this.prop);

  		// Has this property already been wrapped?
  		if (template && template.set && (siblings = template.set._ractiveWrappers)) {

  			// Yes. Register this wrapper to this property, if it hasn't been already
  			if (siblings.indexOf(this) === -1) {
  				siblings.push(this);
  			}

  			return; // already wrapped
  		}

  		// No, it hasn't been wrapped
  		createAccessors(this, value, template);
  	};

  	MagicWrapper.prototype = {
  		get: function () {
  			return this.value;
  		},
  		reset: function (value) {
  			if (this.updating) {
  				return;
  			}

  			this.updating = true;
  			this.obj[this.prop] = value; // trigger set() accessor
  			global_runloop.addRactive(this.ractive);
  			this.ractive.viewmodel.mark(this.keypath, { keepExistingWrapper: true });
  			this.updating = false;
  			return true;
  		},
  		set: function (key, value) {
  			if (this.updating) {
  				return;
  			}

  			if (!this.obj[this.prop]) {
  				this.updating = true;
  				this.obj[this.prop] = createBranch(key);
  				this.updating = false;
  			}

  			this.obj[this.prop][key] = value;
  		},
  		teardown: function () {
  			var template, set, value, wrappers, index;

  			// If this method was called because the cache was being cleared as a
  			// result of a set()/update() call made by this wrapper, we return false
  			// so that it doesn't get torn down
  			if (this.updating) {
  				return false;
  			}

  			template = Object.getOwnPropertyDescriptor(this.obj, this.prop);
  			set = template && template.set;

  			if (!set) {
  				// most likely, this was an array member that was spliced out
  				return;
  			}

  			wrappers = set._ractiveWrappers;

  			index = wrappers.indexOf(this);
  			if (index !== -1) {
  				wrappers.splice(index, 1);
  			}

  			// Last one out, turn off the lights
  			if (!wrappers.length) {
  				value = this.obj[this.prop];

  				Object.defineProperty(this.obj, this.prop, this.originalDescriptor || {
  					writable: true,
  					enumerable: true,
  					configurable: true
  				});

  				this.obj[this.prop] = value;
  			}
  		}
  	};
  } catch (err) {
  	magicAdaptor = false; // no magic in this browser
  }

  var adaptors_magic = magicAdaptor;

  function createAccessors(originalWrapper, value, template) {

  	var object, property, oldGet, oldSet, get, set;

  	object = originalWrapper.obj;
  	property = originalWrapper.prop;

  	// Is this template configurable?
  	if (template && !template.configurable) {
  		// Special case - array length
  		if (property === "length") {
  			return;
  		}

  		throw new Error("Cannot use magic mode with property \"" + property + "\" - object is not configurable");
  	}

  	// Time to wrap this property
  	if (template) {
  		oldGet = template.get;
  		oldSet = template.set;
  	}

  	get = oldGet || function () {
  		return value;
  	};

  	set = function (v) {
  		if (oldSet) {
  			oldSet(v);
  		}

  		value = oldGet ? oldGet() : v;
  		set._ractiveWrappers.forEach(updateWrapper);
  	};

  	function updateWrapper(wrapper) {
  		var keypath, ractive;

  		wrapper.value = value;

  		if (wrapper.updating) {
  			return;
  		}

  		ractive = wrapper.ractive;
  		keypath = wrapper.keypath;

  		wrapper.updating = true;
  		global_runloop.start(ractive);

  		ractive.viewmodel.mark(keypath);

  		global_runloop.end();
  		wrapper.updating = false;
  	}

  	// Create an array of wrappers, in case other keypaths/ractives depend on this property.
  	// Handily, we can store them as a property of the set function. Yay JavaScript.
  	set._ractiveWrappers = [originalWrapper];
  	Object.defineProperty(object, property, { get: get, set: set, enumerable: true, configurable: true });
  }

  var magicArrayAdaptor, MagicArrayWrapper;

  if (adaptors_magic) {
  	magicArrayAdaptor = {
  		filter: function (object, keypath, ractive) {
  			return adaptors_magic.filter(object, keypath, ractive) && array_index.filter(object);
  		},

  		wrap: function (ractive, array, keypath) {
  			return new MagicArrayWrapper(ractive, array, keypath);
  		}
  	};

  	MagicArrayWrapper = function (ractive, array, keypath) {
  		this.value = array;

  		this.magic = true;

  		this.magicWrapper = adaptors_magic.wrap(ractive, array, keypath);
  		this.arrayWrapper = array_index.wrap(ractive, array, keypath);
  	};

  	MagicArrayWrapper.prototype = {
  		get: function () {
  			return this.value;
  		},
  		teardown: function () {
  			this.arrayWrapper.teardown();
  			this.magicWrapper.teardown();
  		},
  		reset: function (value) {
  			return this.magicWrapper.reset(value);
  		}
  	};
  }

  var magicArray = magicArrayAdaptor;

  var prototype_adapt = Viewmodel$adapt;

  var prefixers = {};
  function Viewmodel$adapt(keypath, value) {
  	var len, i, adaptor, wrapped;

  	if (!this.adaptors) return;

  	// Do we have an adaptor for this value?
  	len = this.adaptors.length;
  	for (i = 0; i < len; i += 1) {
  		adaptor = this.adaptors[i];

  		if (adaptor.filter(value, keypath, this.ractive)) {
  			wrapped = this.wrapped[keypath] = adaptor.wrap(this.ractive, value, keypath, getPrefixer(keypath));
  			wrapped.value = value;
  			return;
  		}
  	}
  }

  function prefixKeypath(obj, prefix) {
  	var prefixed = {},
  	    key;

  	if (!prefix) {
  		return obj;
  	}

  	prefix += ".";

  	for (key in obj) {
  		if (obj.hasOwnProperty(key)) {
  			prefixed[prefix + key] = obj[key];
  		}
  	}

  	return prefixed;
  }

  function getPrefixer(rootKeypath) {
  	var rootDot;

  	if (!prefixers[rootKeypath]) {
  		rootDot = rootKeypath ? rootKeypath + "." : "";

  		prefixers[rootKeypath] = function (relativeKeypath, value) {
  			var obj;

  			if (typeof relativeKeypath === "string") {
  				obj = {};
  				obj[rootDot + relativeKeypath] = value;
  				return obj;
  			}

  			if (typeof relativeKeypath === "object") {
  				// 'relativeKeypath' is in fact a hash, not a keypath
  				return rootDot ? prefixKeypath(relativeKeypath, rootKeypath) : relativeKeypath;
  			}
  		};
  	}

  	return prefixers[rootKeypath];
  }

  // TEMP

  var helpers_getUpstreamChanges = getUpstreamChanges;
  function getUpstreamChanges(changes) {
  	var upstreamChanges = [rootKeypath],
  	    i,
  	    keypath;

  	i = changes.length;
  	while (i--) {
  		keypath = changes[i].parent;

  		while (keypath && !keypath.isRoot) {
  			if (changes.indexOf(keypath) === -1) {
  				addToArray(upstreamChanges, keypath);
  			}
  			keypath = keypath.parent;
  		}
  	}

  	return upstreamChanges;
  }

  var applyChanges_notifyPatternObservers = notifyPatternObservers;

  function notifyPatternObservers(viewmodel, keypath, onlyDirect) {
  	var potentialWildcardMatches;

  	updateMatchingPatternObservers(viewmodel, keypath);

  	if (onlyDirect) {
  		return;
  	}

  	potentialWildcardMatches = keypath.wildcardMatches();
  	potentialWildcardMatches.forEach(function (upstreamPattern) {
  		cascade(viewmodel, upstreamPattern, keypath);
  	});
  }

  function cascade(viewmodel, upstreamPattern, keypath) {
  	var group, map, actualChildKeypath;

  	// TODO should be one or the other
  	upstreamPattern = upstreamPattern.str || upstreamPattern;

  	group = viewmodel.depsMap.patternObservers;
  	map = group && group[upstreamPattern];

  	if (!map) {
  		return;
  	}

  	map.forEach(function (childKeypath) {
  		actualChildKeypath = keypath.join(childKeypath.lastKey); // 'foo.bar.baz'

  		updateMatchingPatternObservers(viewmodel, actualChildKeypath);
  		cascade(viewmodel, childKeypath, actualChildKeypath);
  	});
  }

  function updateMatchingPatternObservers(viewmodel, keypath) {
  	viewmodel.patternObservers.forEach(function (observer) {
  		if (observer.regex.test(keypath.str)) {
  			observer.update(keypath);
  		}
  	});
  }

  var applyChanges = Viewmodel$applyChanges;

  function Viewmodel$applyChanges() {
  	var _this = this;

  	var self = this,
  	    changes,
  	    upstreamChanges,
  	    hash = {},
  	    bindings;

  	changes = this.changes;

  	if (!changes.length) {
  		// TODO we end up here on initial render. Perhaps we shouldn't?
  		return;
  	}

  	function invalidateComputation(computation) {
  		var key = computation.key;

  		if (computation.viewmodel === self) {
  			self.clearCache(key.str);
  			computation.invalidate();

  			changes.push(key);
  			cascade(key);
  		} else {
  			computation.viewmodel.mark(key);
  		}
  	}

  	function cascade(keypath) {
  		var map, computations;

  		if (self.noCascade.hasOwnProperty(keypath.str)) {
  			return;
  		}

  		if (computations = self.deps.computed[keypath.str]) {
  			computations.forEach(invalidateComputation);
  		}

  		if (map = self.depsMap.computed[keypath.str]) {
  			map.forEach(cascade);
  		}
  	}

  	changes.slice().forEach(cascade);

  	upstreamChanges = helpers_getUpstreamChanges(changes);
  	upstreamChanges.forEach(function (keypath) {
  		var computations;

  		// make sure we haven't already been down this particular keypath in this turn
  		if (changes.indexOf(keypath) === -1 && (computations = self.deps.computed[keypath.str])) {
  			computations.forEach(invalidateComputation);
  		}
  	});

  	this.changes = [];

  	// Pattern observers are a weird special case
  	if (this.patternObservers.length) {
  		upstreamChanges.forEach(function (keypath) {
  			return applyChanges_notifyPatternObservers(_this, keypath, true);
  		});
  		changes.forEach(function (keypath) {
  			return applyChanges_notifyPatternObservers(_this, keypath);
  		});
  	}

  	if (this.deps.observers) {
  		upstreamChanges.forEach(function (keypath) {
  			return notifyUpstreamDependants(_this, null, keypath, "observers");
  		});
  		notifyAllDependants(this, changes, "observers");
  	}

  	if (this.deps["default"]) {
  		bindings = [];
  		upstreamChanges.forEach(function (keypath) {
  			return notifyUpstreamDependants(_this, bindings, keypath, "default");
  		});

  		if (bindings.length) {
  			notifyBindings(this, bindings, changes);
  		}

  		notifyAllDependants(this, changes, "default");
  	}

  	// Return a hash of keypaths to updated values
  	changes.forEach(function (keypath) {
  		hash[keypath.str] = _this.get(keypath);
  	});

  	this.implicitChanges = {};
  	this.noCascade = {};

  	return hash;
  }

  function notifyUpstreamDependants(viewmodel, bindings, keypath, groupName) {
  	var dependants, value;

  	if (dependants = findDependants(viewmodel, keypath, groupName)) {
  		value = viewmodel.get(keypath);

  		dependants.forEach(function (d) {
  			// don't "set" the parent value, refine it
  			// i.e. not data = value, but data[foo] = fooValue
  			if (bindings && d.refineValue) {
  				bindings.push(d);
  			} else {
  				d.setValue(value);
  			}
  		});
  	}
  }

  function notifyBindings(viewmodel, bindings, changes) {

  	bindings.forEach(function (binding) {
  		var useSet = false,
  		    i = 0,
  		    length = changes.length,
  		    refinements = [];

  		while (i < length) {
  			var keypath = changes[i];

  			if (keypath === binding.keypath) {
  				useSet = true;
  				break;
  			}

  			if (keypath.slice(0, binding.keypath.length) === binding.keypath) {
  				refinements.push(keypath);
  			}

  			i++;
  		}

  		if (useSet) {
  			binding.setValue(viewmodel.get(binding.keypath));
  		}

  		if (refinements.length) {
  			binding.refineValue(refinements);
  		}
  	});
  }

  function notifyAllDependants(viewmodel, keypaths, groupName) {
  	var queue = [];

  	addKeypaths(keypaths);
  	queue.forEach(dispatch);

  	function addKeypaths(keypaths) {
  		keypaths.forEach(addKeypath);
  		keypaths.forEach(cascade);
  	}

  	function addKeypath(keypath) {
  		var deps = findDependants(viewmodel, keypath, groupName);

  		if (deps) {
  			queue.push({
  				keypath: keypath,
  				deps: deps
  			});
  		}
  	}

  	function cascade(keypath) {
  		var childDeps;

  		if (childDeps = viewmodel.depsMap[groupName][keypath.str]) {
  			addKeypaths(childDeps);
  		}
  	}

  	function dispatch(set) {
  		var value = viewmodel.get(set.keypath);
  		set.deps.forEach(function (d) {
  			return d.setValue(value);
  		});
  	}
  }

  function findDependants(viewmodel, keypath, groupName) {
  	var group = viewmodel.deps[groupName];
  	return group ? group[keypath.str] : null;
  }

  var capture = Viewmodel$capture;

  function Viewmodel$capture() {
  	this.captureGroups.push([]);
  }

  var clearCache = Viewmodel$clearCache;

  function Viewmodel$clearCache(keypath, keepExistingWrapper) {
  	var cacheMap, wrapper;

  	if (!keepExistingWrapper) {
  		// Is there a wrapped property at this keypath?
  		if (wrapper = this.wrapped[keypath]) {
  			// Did we unwrap it?
  			if (wrapper.teardown() !== false) {
  				// Is this right?
  				// What's the meaning of returning false from teardown?
  				// Could there be a GC ramification if this is a "real" ractive.teardown()?
  				this.wrapped[keypath] = null;
  			}
  		}
  	}

  	this.cache[keypath] = undefined;

  	if (cacheMap = this.cacheMap[keypath]) {
  		while (cacheMap.length) {
  			this.clearCache(cacheMap.pop());
  		}
  	}
  }

  var UnresolvedDependency = function (computation, ref) {
  	this.computation = computation;
  	this.viewmodel = computation.viewmodel;
  	this.ref = ref;

  	// TODO this seems like a red flag!
  	this.root = this.viewmodel.ractive;
  	this.parentFragment = this.root.component && this.root.component.parentFragment;
  };

  UnresolvedDependency.prototype = {
  	resolve: function (keypath) {
  		this.computation.softDeps.push(keypath);
  		this.computation.unresolvedDeps[keypath.str] = null;
  		this.viewmodel.register(keypath, this.computation, "computed");
  	}
  };

  var Computation_UnresolvedDependency = UnresolvedDependency;

  var Computation = function (key, signature) {
  	this.key = key;

  	this.getter = signature.getter;
  	this.setter = signature.setter;

  	this.hardDeps = signature.deps || [];
  	this.softDeps = [];
  	this.unresolvedDeps = {};

  	this.depValues = {};

  	this._dirty = this._firstRun = true;
  };

  Computation.prototype = {
  	constructor: Computation,

  	init: function (viewmodel) {
  		var _this = this;

  		var initial;

  		this.viewmodel = viewmodel;
  		this.bypass = true;

  		initial = viewmodel.get(this.key);
  		viewmodel.clearCache(this.key.str);

  		this.bypass = false;

  		if (this.setter && initial !== undefined) {
  			this.set(initial);
  		}

  		if (this.hardDeps) {
  			this.hardDeps.forEach(function (d) {
  				return viewmodel.register(d, _this, "computed");
  			});
  		}
  	},

  	invalidate: function () {
  		this._dirty = true;
  	},

  	get: function () {
  		var _this = this;

  		var newDeps,
  		    dependenciesChanged,
  		    dependencyValuesChanged = false;

  		if (this.getting) {
  			// prevent double-computation (e.g. caused by array mutation inside computation)
  			var msg = "The " + this.key.str + " computation indirectly called itself. This probably indicates a bug in the computation. It is commonly caused by `array.sort(...)` - if that's the case, clone the array first with `array.slice().sort(...)`";
  			warnOnce(msg);
  			return this.value;
  		}

  		this.getting = true;

  		if (this._dirty) {
  			// determine whether the inputs have changed, in case this depends on
  			// other computed values
  			if (this._firstRun || !this.hardDeps.length && !this.softDeps.length) {
  				dependencyValuesChanged = true;
  			} else {
  				[this.hardDeps, this.softDeps].forEach(function (deps) {
  					var keypath, value, i;

  					if (dependencyValuesChanged) {
  						return;
  					}

  					i = deps.length;
  					while (i--) {
  						keypath = deps[i];
  						value = _this.viewmodel.get(keypath);

  						if (!isEqual(value, _this.depValues[keypath.str])) {
  							_this.depValues[keypath.str] = value;
  							dependencyValuesChanged = true;

  							return;
  						}
  					}
  				});
  			}

  			if (dependencyValuesChanged) {
  				this.viewmodel.capture();

  				try {
  					this.value = this.getter();
  				} catch (err) {
  					warnIfDebug("Failed to compute \"%s\"", this.key.str);
  					logIfDebug(err.stack || err);

  					this.value = void 0;
  				}

  				newDeps = this.viewmodel.release();
  				dependenciesChanged = this.updateDependencies(newDeps);

  				if (dependenciesChanged) {
  					[this.hardDeps, this.softDeps].forEach(function (deps) {
  						deps.forEach(function (keypath) {
  							_this.depValues[keypath.str] = _this.viewmodel.get(keypath);
  						});
  					});
  				}
  			}

  			this._dirty = false;
  		}

  		this.getting = this._firstRun = false;
  		return this.value;
  	},

  	set: function (value) {
  		if (this.setting) {
  			this.value = value;
  			return;
  		}

  		if (!this.setter) {
  			throw new Error("Computed properties without setters are read-only. (This may change in a future version of Ractive!)");
  		}

  		this.setter(value);
  	},

  	updateDependencies: function (newDeps) {
  		var i, oldDeps, keypath, dependenciesChanged, unresolved;

  		oldDeps = this.softDeps;

  		// remove dependencies that are no longer used
  		i = oldDeps.length;
  		while (i--) {
  			keypath = oldDeps[i];

  			if (newDeps.indexOf(keypath) === -1) {
  				dependenciesChanged = true;
  				this.viewmodel.unregister(keypath, this, "computed");
  			}
  		}

  		// create references for any new dependencies
  		i = newDeps.length;
  		while (i--) {
  			keypath = newDeps[i];

  			if (oldDeps.indexOf(keypath) === -1 && (!this.hardDeps || this.hardDeps.indexOf(keypath) === -1)) {
  				dependenciesChanged = true;

  				// if this keypath is currently unresolved, we need to mark
  				// it as such. TODO this is a bit muddy...
  				if (isUnresolved(this.viewmodel, keypath) && !this.unresolvedDeps[keypath.str]) {
  					unresolved = new Computation_UnresolvedDependency(this, keypath.str);
  					newDeps.splice(i, 1);

  					this.unresolvedDeps[keypath.str] = unresolved;
  					global_runloop.addUnresolved(unresolved);
  				} else {
  					this.viewmodel.register(keypath, this, "computed");
  				}
  			}
  		}

  		if (dependenciesChanged) {
  			this.softDeps = newDeps.slice();
  		}

  		return dependenciesChanged;
  	}
  };

  function isUnresolved(viewmodel, keypath) {
  	var key = keypath.firstKey;

  	return !(key in viewmodel.data) && !(key in viewmodel.computations) && !(key in viewmodel.mappings);
  }

  var Computation_Computation = Computation;

  var compute = Viewmodel$compute;
  function Viewmodel$compute(key, signature) {
  	var computation = new Computation_Computation(key, signature);

  	if (this.ready) {
  		computation.init(this);
  	}

  	return this.computations[key.str] = computation;
  }

  var FAILED_LOOKUP = { FAILED_LOOKUP: true };

  var viewmodel_prototype_get = Viewmodel$get;

  var viewmodel_prototype_get__empty = {};
  function Viewmodel$get(keypath, options) {
  	var cache = this.cache,
  	    value,
  	    computation,
  	    wrapped,
  	    captureGroup,
  	    keypathStr = keypath.str,
  	    key;

  	options = options || viewmodel_prototype_get__empty;

  	// capture the keypath, if we're inside a computation
  	if (options.capture && (captureGroup = lastItem(this.captureGroups))) {
  		if (! ~captureGroup.indexOf(keypath)) {
  			captureGroup.push(keypath);
  		}
  	}

  	if (hasOwn.call(this.mappings, keypath.firstKey)) {
  		return this.mappings[keypath.firstKey].get(keypath, options);
  	}

  	if (keypath.isSpecial) {
  		return keypath.value;
  	}

  	if (cache[keypathStr] === undefined) {

  		// Is this a computed property?
  		if ((computation = this.computations[keypathStr]) && !computation.bypass) {
  			value = computation.get();
  			this.adapt(keypathStr, value);
  		}

  		// Is this a wrapped property?
  		else if (wrapped = this.wrapped[keypathStr]) {
  			value = wrapped.value;
  		}

  		// Is it the root?
  		else if (keypath.isRoot) {
  			this.adapt("", this.data);
  			value = this.data;
  		}

  		// No? Then we need to retrieve the value one key at a time
  		else {
  			value = retrieve(this, keypath);
  		}

  		cache[keypathStr] = value;
  	} else {
  		value = cache[keypathStr];
  	}

  	if (!options.noUnwrap && (wrapped = this.wrapped[keypathStr])) {
  		value = wrapped.get();
  	}

  	if (keypath.isRoot && options.fullRootGet) {
  		for (key in this.mappings) {
  			value[key] = this.mappings[key].getValue();
  		}
  	}

  	return value === FAILED_LOOKUP ? void 0 : value;
  }

  function retrieve(viewmodel, keypath) {

  	var parentValue, cacheMap, value, wrapped;

  	parentValue = viewmodel.get(keypath.parent);

  	if (wrapped = viewmodel.wrapped[keypath.parent.str]) {
  		parentValue = wrapped.get();
  	}

  	if (parentValue === null || parentValue === undefined) {
  		return;
  	}

  	// update cache map
  	if (!(cacheMap = viewmodel.cacheMap[keypath.parent.str])) {
  		viewmodel.cacheMap[keypath.parent.str] = [keypath.str];
  	} else {
  		if (cacheMap.indexOf(keypath.str) === -1) {
  			cacheMap.push(keypath.str);
  		}
  	}

  	// If this property doesn't exist, we return a sentinel value
  	// so that we know to query parent scope (if such there be)
  	if (typeof parentValue === "object" && !(keypath.lastKey in parentValue)) {
  		return viewmodel.cache[keypath.str] = FAILED_LOOKUP;
  	}

  	value = parentValue[keypath.lastKey];

  	// Do we have an adaptor for this value?
  	viewmodel.adapt(keypath.str, value, false);

  	// Update cache
  	viewmodel.cache[keypath.str] = value;
  	return value;
  }

  var viewmodel_prototype_init = Viewmodel$init;

  function Viewmodel$init() {
  	var key;

  	for (key in this.computations) {
  		this.computations[key].init(this);
  	}
  }

  var prototype_map = Viewmodel$map;

  function Viewmodel$map(key, options) {
  	var mapping = this.mappings[key.str] = new Mapping(key, options);
  	mapping.initViewmodel(this);
  	return mapping;
  }

  var Mapping = function (localKey, options) {
  	this.localKey = localKey;
  	this.keypath = options.keypath;
  	this.origin = options.origin;

  	this.deps = [];
  	this.unresolved = [];

  	this.resolved = false;
  };

  Mapping.prototype = {
  	forceResolution: function () {
  		// TODO warn, as per #1692?
  		this.keypath = this.localKey;
  		this.setup();
  	},

  	get: function (keypath, options) {
  		if (!this.resolved) {
  			return undefined;
  		}
  		return this.origin.get(this.map(keypath), options);
  	},

  	getValue: function () {
  		if (!this.keypath) {
  			return undefined;
  		}
  		return this.origin.get(this.keypath);
  	},

  	initViewmodel: function (viewmodel) {
  		this.local = viewmodel;
  		this.setup();
  	},

  	map: function (keypath) {
  		if (typeof this.keypath === undefined) {
  			return this.localKey;
  		}
  		return keypath.replace(this.localKey, this.keypath);
  	},

  	register: function (keypath, dependant, group) {
  		this.deps.push({ keypath: keypath, dep: dependant, group: group });

  		if (this.resolved) {
  			this.origin.register(this.map(keypath), dependant, group);
  		}
  	},

  	resolve: function (keypath) {
  		if (this.keypath !== undefined) {
  			this.unbind(true);
  		}

  		this.keypath = keypath;
  		this.setup();
  	},

  	set: function (keypath, value) {
  		if (!this.resolved) {
  			this.forceResolution();
  		}

  		this.origin.set(this.map(keypath), value);
  	},

  	setup: function () {
  		var _this = this;

  		if (this.keypath === undefined) {
  			return;
  		}

  		this.resolved = true;

  		// accumulated dependants can now be registered
  		if (this.deps.length) {
  			this.deps.forEach(function (d) {
  				var keypath = _this.map(d.keypath);
  				_this.origin.register(keypath, d.dep, d.group);

  				// TODO this is a bit of a red flag... all deps should be the same?
  				if (d.dep.setValue) {
  					d.dep.setValue(_this.origin.get(keypath));
  				} else if (d.dep.invalidate) {
  					d.dep.invalidate();
  				} else {
  					throw new Error("An unexpected error occurred. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!");
  				}
  			});

  			this.origin.mark(this.keypath);
  		}
  	},

  	setValue: function (value) {
  		if (!this.keypath) {
  			throw new Error("Mapping does not have keypath, cannot set value. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!");
  		}

  		this.origin.set(this.keypath, value);
  	},

  	unbind: function (keepLocal) {
  		var _this = this;

  		if (!keepLocal) {
  			delete this.local.mappings[this.localKey];
  		}

  		if (!this.resolved) {
  			return;
  		}

  		this.deps.forEach(function (d) {
  			_this.origin.unregister(_this.map(d.keypath), d.dep, d.group);
  		});

  		if (this.tracker) {
  			this.origin.unregister(this.keypath, this.tracker);
  		}
  	},

  	unregister: function (keypath, dependant, group) {
  		var deps, i;

  		if (!this.resolved) {
  			return;
  		}

  		deps = this.deps;
  		i = deps.length;

  		while (i--) {
  			if (deps[i].dep === dependant) {
  				deps.splice(i, 1);
  				break;
  			}
  		}
  		this.origin.unregister(this.map(keypath), dependant, group);
  	}
  };

  var mark = Viewmodel$mark;

  function Viewmodel$mark(keypath, options) {
  	var computation,
  	    keypathStr = keypath.str;

  	// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)
  	// should not be picked up by pattern observers
  	if (options) {
  		if (options.implicit) {
  			this.implicitChanges[keypathStr] = true;
  		}
  		if (options.noCascade) {
  			this.noCascade[keypathStr] = true;
  		}
  	}

  	if (computation = this.computations[keypathStr]) {
  		computation.invalidate();
  	}

  	if (this.changes.indexOf(keypath) === -1) {
  		this.changes.push(keypath);
  	}

  	// pass on keepExistingWrapper, if we can
  	var keepExistingWrapper = options ? options.keepExistingWrapper : false;

  	this.clearCache(keypathStr, keepExistingWrapper);

  	if (this.ready) {
  		this.onchange();
  	}
  }

  var mapOldToNewIndex = function (oldArray, newArray) {
  	var usedIndices, firstUnusedIndex, newIndices, changed;

  	usedIndices = {};
  	firstUnusedIndex = 0;

  	newIndices = oldArray.map(function (item, i) {
  		var index, start, len;

  		start = firstUnusedIndex;
  		len = newArray.length;

  		do {
  			index = newArray.indexOf(item, start);

  			if (index === -1) {
  				changed = true;
  				return -1;
  			}

  			start = index + 1;
  		} while (usedIndices[index] && start < len);

  		// keep track of the first unused index, so we don't search
  		// the whole of newArray for each item in oldArray unnecessarily
  		if (index === firstUnusedIndex) {
  			firstUnusedIndex += 1;
  		}

  		if (index !== i) {
  			changed = true;
  		}

  		usedIndices[index] = true;
  		return index;
  	});

  	return newIndices;
  };

  var merge = Viewmodel$merge;

  var comparators = {};
  function Viewmodel$merge(keypath, currentArray, array, options) {
  	var oldArray, newArray, comparator, newIndices;

  	this.mark(keypath);

  	if (options && options.compare) {

  		comparator = getComparatorFunction(options.compare);

  		try {
  			oldArray = currentArray.map(comparator);
  			newArray = array.map(comparator);
  		} catch (err) {
  			// fallback to an identity check - worst case scenario we have
  			// to do more DOM manipulation than we thought...
  			warnIfDebug("merge(): \"%s\" comparison failed. Falling back to identity checking", keypath);

  			oldArray = currentArray;
  			newArray = array;
  		}
  	} else {
  		oldArray = currentArray;
  		newArray = array;
  	}

  	// find new indices for members of oldArray
  	newIndices = mapOldToNewIndex(oldArray, newArray);

  	this.smartUpdate(keypath, array, newIndices, currentArray.length !== array.length);
  }

  function stringify(item) {
  	return JSON.stringify(item);
  }

  function getComparatorFunction(comparator) {
  	// If `compare` is `true`, we use JSON.stringify to compare
  	// objects that are the same shape, but non-identical - i.e.
  	// { foo: 'bar' } !== { foo: 'bar' }
  	if (comparator === true) {
  		return stringify;
  	}

  	if (typeof comparator === "string") {
  		if (!comparators[comparator]) {
  			comparators[comparator] = function (item) {
  				return item[comparator];
  			};
  		}

  		return comparators[comparator];
  	}

  	if (typeof comparator === "function") {
  		return comparator;
  	}

  	throw new Error("The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)");
  }

  var register = Viewmodel$register;

  function Viewmodel$register(keypath, dependant) {
  	var group = arguments[2] === undefined ? "default" : arguments[2];

  	var mapping, depsByKeypath, deps;

  	if (dependant.isStatic) {
  		return; // TODO we should never get here if a dependant is static...
  	}

  	if (mapping = this.mappings[keypath.firstKey]) {
  		mapping.register(keypath, dependant, group);
  	} else {
  		depsByKeypath = this.deps[group] || (this.deps[group] = {});
  		deps = depsByKeypath[keypath.str] || (depsByKeypath[keypath.str] = []);

  		deps.push(dependant);

  		if (!this.depsMap[group]) {
  			this.depsMap[group] = {};
  		}

  		if (!keypath.isRoot) {
  			register__updateDependantsMap(this, keypath, group);
  		}
  	}
  }

  function register__updateDependantsMap(viewmodel, keypath, group) {
  	var map, parent, keypathStr;

  	// update dependants map
  	while (!keypath.isRoot) {
  		map = viewmodel.depsMap[group];
  		parent = map[keypath.parent.str] || (map[keypath.parent.str] = []);

  		keypathStr = keypath.str;

  		// TODO find an alternative to this nasty approach
  		if (parent["_" + keypathStr] === undefined) {
  			parent["_" + keypathStr] = 0;
  			parent.push(keypath);
  		}

  		parent["_" + keypathStr] += 1;
  		keypath = keypath.parent;
  	}
  }

  var release = Viewmodel$release;

  function Viewmodel$release() {
  	return this.captureGroups.pop();
  }

  var reset = Viewmodel$reset;

  function Viewmodel$reset(data) {
  	this.data = data;
  	this.clearCache("");
  }

  var prototype_set = Viewmodel$set;

  function Viewmodel$set(keypath, value) {
  	var options = arguments[2] === undefined ? {} : arguments[2];

  	var mapping, computation, wrapper, keepExistingWrapper;

  	// unless data is being set for data tracking purposes
  	if (!options.noMapping) {
  		// If this data belongs to a different viewmodel,
  		// pass the change along
  		if (mapping = this.mappings[keypath.firstKey]) {
  			return mapping.set(keypath, value);
  		}
  	}

  	computation = this.computations[keypath.str];
  	if (computation) {
  		if (computation.setting) {
  			// let the other computation set() handle things...
  			return;
  		}
  		computation.set(value);
  		value = computation.get();
  	}

  	if (isEqual(this.cache[keypath.str], value)) {
  		return;
  	}

  	wrapper = this.wrapped[keypath.str];

  	// If we have a wrapper with a `reset()` method, we try and use it. If the
  	// `reset()` method returns false, the wrapper should be torn down, and
  	// (most likely) a new one should be created later
  	if (wrapper && wrapper.reset) {
  		keepExistingWrapper = wrapper.reset(value) !== false;

  		if (keepExistingWrapper) {
  			value = wrapper.get();
  		}
  	}

  	if (!computation && !keepExistingWrapper) {
  		resolveSet(this, keypath, value);
  	}

  	if (!options.silent) {
  		this.mark(keypath);
  	} else {
  		// We're setting a parent of the original target keypath (i.e.
  		// creating a fresh branch) - we need to clear the cache, but
  		// not mark it as a change
  		this.clearCache(keypath.str);
  	}
  }

  function resolveSet(viewmodel, keypath, value) {
  	var wrapper, parentValue, wrapperSet, valueSet;

  	wrapperSet = function () {
  		if (wrapper.set) {
  			wrapper.set(keypath.lastKey, value);
  		} else {
  			parentValue = wrapper.get();
  			valueSet();
  		}
  	};

  	valueSet = function () {
  		if (!parentValue) {
  			parentValue = createBranch(keypath.lastKey);
  			viewmodel.set(keypath.parent, parentValue, { silent: true });
  		}
  		parentValue[keypath.lastKey] = value;
  	};

  	wrapper = viewmodel.wrapped[keypath.parent.str];

  	if (wrapper) {
  		wrapperSet();
  	} else {
  		parentValue = viewmodel.get(keypath.parent);

  		// may have been wrapped via the above .get()
  		// call on viewmodel if this is first access via .set()!
  		if (wrapper = viewmodel.wrapped[keypath.parent.str]) {
  			wrapperSet();
  		} else {
  			valueSet();
  		}
  	}
  }

  var smartUpdate = Viewmodel$smartUpdate;

  var implicitOption = { implicit: true },
      noCascadeOption = { noCascade: true };
  function Viewmodel$smartUpdate(keypath, array, newIndices) {
  	var _this = this;

  	var dependants, oldLength, i;

  	oldLength = newIndices.length;

  	// Indices that are being removed should be marked as dirty
  	newIndices.forEach(function (newIndex, oldIndex) {
  		if (newIndex === -1) {
  			_this.mark(keypath.join(oldIndex), noCascadeOption);
  		}
  	});

  	// Update the model
  	// TODO allow existing array to be updated in place, rather than replaced?
  	this.set(keypath, array, { silent: true });

  	if (dependants = this.deps["default"][keypath.str]) {
  		dependants.filter(canShuffle).forEach(function (d) {
  			return d.shuffle(newIndices, array);
  		});
  	}

  	if (oldLength !== array.length) {
  		this.mark(keypath.join("length"), implicitOption);

  		for (i = newIndices.touchedFrom; i < array.length; i += 1) {
  			this.mark(keypath.join(i));
  		}

  		// don't allow removed indexes beyond end of new array to trigger recomputations
  		// TODO is this still necessary, now that computations are lazy?
  		for (i = array.length; i < oldLength; i += 1) {
  			this.mark(keypath.join(i), noCascadeOption);
  		}
  	}
  }

  function canShuffle(dependant) {
  	return typeof dependant.shuffle === "function";
  }

  var prototype_teardown = Viewmodel$teardown;

  function Viewmodel$teardown() {
  	var _this = this;

  	var unresolvedImplicitDependency;

  	// Clear entire cache - this has the desired side-effect
  	// of unwrapping adapted values (e.g. arrays)
  	Object.keys(this.cache).forEach(function (keypath) {
  		return _this.clearCache(keypath);
  	});

  	// Teardown any failed lookups - we don't need them to resolve any more
  	while (unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop()) {
  		unresolvedImplicitDependency.teardown();
  	}
  }

  var unregister = Viewmodel$unregister;

  function Viewmodel$unregister(keypath, dependant) {
  	var group = arguments[2] === undefined ? "default" : arguments[2];

  	var mapping, deps, index;

  	if (dependant.isStatic) {
  		return;
  	}

  	if (mapping = this.mappings[keypath.firstKey]) {
  		return mapping.unregister(keypath, dependant, group);
  	}

  	deps = this.deps[group][keypath.str];
  	index = deps.indexOf(dependant);

  	if (index === -1) {
  		throw new Error("Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks");
  	}

  	deps.splice(index, 1);

  	if (keypath.isRoot) {
  		return;
  	}

  	unregister__updateDependantsMap(this, keypath, group);
  }

  function unregister__updateDependantsMap(viewmodel, keypath, group) {
  	var map, parent;

  	// update dependants map
  	while (!keypath.isRoot) {
  		map = viewmodel.depsMap[group];
  		parent = map[keypath.parent.str];

  		parent["_" + keypath.str] -= 1;

  		if (!parent["_" + keypath.str]) {
  			// remove from parent deps map
  			removeFromArray(parent, keypath);
  			parent["_" + keypath.str] = undefined;
  		}

  		keypath = keypath.parent;
  	}
  }

  var Viewmodel = function (options) {
  	var adapt = options.adapt;
  	var data = options.data;
  	var ractive = options.ractive;
  	var computed = options.computed;
  	var mappings = options.mappings;
  	var key;
  	var mapping;

  	// TODO is it possible to remove this reference?
  	this.ractive = ractive;

  	this.adaptors = adapt;
  	this.onchange = options.onchange;

  	this.cache = {}; // we need to be able to use hasOwnProperty, so can't inherit from null
  	this.cacheMap = create(null);

  	this.deps = {
  		computed: create(null),
  		"default": create(null)
  	};
  	this.depsMap = {
  		computed: create(null),
  		"default": create(null)
  	};

  	this.patternObservers = [];

  	this.specials = create(null);

  	this.wrapped = create(null);
  	this.computations = create(null);

  	this.captureGroups = [];
  	this.unresolvedImplicitDependencies = [];

  	this.changes = [];
  	this.implicitChanges = {};
  	this.noCascade = {};

  	this.data = data;

  	// set up explicit mappings
  	this.mappings = create(null);
  	for (key in mappings) {
  		this.map(getKeypath(key), mappings[key]);
  	}

  	if (data) {
  		// if data exists locally, but is missing on the parent,
  		// we transfer ownership to the parent
  		for (key in data) {
  			if ((mapping = this.mappings[key]) && mapping.getValue() === undefined) {
  				mapping.setValue(data[key]);
  			}
  		}
  	}

  	for (key in computed) {
  		if (mappings && key in mappings) {
  			fatal("Cannot map to a computed property ('%s')", key);
  		}

  		this.compute(getKeypath(key), computed[key]);
  	}

  	this.ready = true;
  };

  Viewmodel.prototype = {
  	adapt: prototype_adapt,
  	applyChanges: applyChanges,
  	capture: capture,
  	clearCache: clearCache,
  	compute: compute,
  	get: viewmodel_prototype_get,
  	init: viewmodel_prototype_init,
  	map: prototype_map,
  	mark: mark,
  	merge: merge,
  	register: register,
  	release: release,
  	reset: reset,
  	set: prototype_set,
  	smartUpdate: smartUpdate,
  	teardown: prototype_teardown,
  	unregister: unregister
  };

  var viewmodel_Viewmodel = Viewmodel;

  function HookQueue(event) {
  	this.hook = new hooks_Hook(event);
  	this.inProcess = {};
  	this.queue = {};
  }

  HookQueue.prototype = {

  	constructor: HookQueue,

  	begin: function (ractive) {
  		this.inProcess[ractive._guid] = true;
  	},

  	end: function (ractive) {

  		var parent = ractive.parent;

  		// If this is *isn't* a child of a component that's in process,
  		// it should call methods or fire at this point
  		if (!parent || !this.inProcess[parent._guid]) {
  			fire(this, ractive);
  		}
  		// elsewise, handoff to parent to fire when ready
  		else {
  			getChildQueue(this.queue, parent).push(ractive);
  		}

  		delete this.inProcess[ractive._guid];
  	}
  };

  function getChildQueue(queue, ractive) {
  	return queue[ractive._guid] || (queue[ractive._guid] = []);
  }

  function fire(hookQueue, ractive) {

  	var childQueue = getChildQueue(hookQueue.queue, ractive);

  	hookQueue.hook.fire(ractive);

  	// queue is "live" because components can end up being
  	// added while hooks fire on parents that modify data values.
  	while (childQueue.length) {
  		fire(hookQueue, childQueue.shift());
  	}

  	delete hookQueue.queue[ractive._guid];
  }

  var hooks_HookQueue = HookQueue;

  var helpers_getComputationSignatures = getComputationSignatures;

  var helpers_getComputationSignatures__pattern = /\$\{([^\}]+)\}/g;
  function getComputationSignatures(ractive, computed) {
  	var signatures = {},
  	    key;

  	for (key in computed) {
  		signatures[key] = getComputationSignature(ractive, key, computed[key]);
  	}

  	return signatures;
  }

  function getComputationSignature(ractive, key, signature) {
  	var getter, setter;

  	if (typeof signature === "function") {
  		getter = helpers_getComputationSignatures__bind(signature, ractive);
  	}

  	if (typeof signature === "string") {
  		getter = createFunctionFromString(ractive, signature);
  	}

  	if (typeof signature === "object") {
  		if (typeof signature.get === "string") {
  			getter = createFunctionFromString(ractive, signature.get);
  		} else if (typeof signature.get === "function") {
  			getter = helpers_getComputationSignatures__bind(signature.get, ractive);
  		} else {
  			fatal("`%s` computation must have a `get()` method", key);
  		}

  		if (typeof signature.set === "function") {
  			setter = helpers_getComputationSignatures__bind(signature.set, ractive);
  		}
  	}

  	return { getter: getter, setter: setter };
  }

  function createFunctionFromString(ractive, str) {
  	var functionBody, hasThis, fn;

  	functionBody = "return (" + str.replace(helpers_getComputationSignatures__pattern, function (match, keypath) {
  		hasThis = true;
  		return "__ractive.get(\"" + keypath + "\")";
  	}) + ");";

  	if (hasThis) {
  		functionBody = "var __ractive = this; " + functionBody;
  	}

  	fn = new Function(functionBody);
  	return hasThis ? fn.bind(ractive) : fn;
  }

  function helpers_getComputationSignatures__bind(fn, context) {
  	return /this/.test(fn.toString()) ? fn.bind(context) : fn;
  }

  var constructHook = new hooks_Hook("construct");
  var configHook = new hooks_Hook("config");
  var initHook = new hooks_HookQueue("init");
  var initialise__uid = 0;

  var initialise__registryNames = ["adaptors", "components", "decorators", "easing", "events", "interpolators", "partials", "transitions"];

  var initialise = initialiseRactiveInstance;

  function initialiseRactiveInstance(ractive) {
  	var userOptions = arguments[1] === undefined ? {} : arguments[1];
  	var options = arguments[2] === undefined ? {} : arguments[2];

  	var el, viewmodel;

  	if (_Ractive.DEBUG) {
  		welcome();
  	}

  	initialiseProperties(ractive, options);

  	// TODO remove this, eventually
  	defineProperty(ractive, "data", { get: deprecateRactiveData });

  	// TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it
  	constructHook.fire(ractive, userOptions);

  	// Add registries
  	initialise__registryNames.forEach(function (name) {
  		ractive[name] = utils_object__extend(create(ractive.constructor[name] || null), userOptions[name]);
  	});

  	// Create a viewmodel
  	viewmodel = new viewmodel_Viewmodel({
  		adapt: getAdaptors(ractive, ractive.adapt, userOptions),
  		data: custom_data.init(ractive.constructor, ractive, userOptions),
  		computed: helpers_getComputationSignatures(ractive, utils_object__extend(create(ractive.constructor.prototype.computed), userOptions.computed)),
  		mappings: options.mappings,
  		ractive: ractive,
  		onchange: function () {
  			return global_runloop.addRactive(ractive);
  		}
  	});

  	ractive.viewmodel = viewmodel;

  	// This can't happen earlier, because computed properties may call `ractive.get()`, etc
  	viewmodel.init();

  	// init config from Parent and options
  	config_config.init(ractive.constructor, ractive, userOptions);

  	configHook.fire(ractive);
  	initHook.begin(ractive);

  	// // If this is a component with a function `data` property, call the function
  	// // with `ractive` as context (unless the child was also a function)
  	// if ( typeof ractive.constructor.prototype.data === 'function' && typeof userOptions.data !== 'function' ) {
  	// 	viewmodel.reset( ractive.constructor.prototype.data.call( ractive ) || fatal( '`data` functions must return a data object' ) );
  	// }

  	// Render virtual DOM
  	if (ractive.template) {
  		var cssIds = undefined;

  		if (options.cssIds || ractive.cssId) {
  			cssIds = options.cssIds ? options.cssIds.slice() : [];

  			if (ractive.cssId) {
  				cssIds.push(ractive.cssId);
  			}
  		}

  		ractive.fragment = new virtualdom_Fragment({
  			template: ractive.template,
  			root: ractive,
  			owner: ractive, // saves doing `if ( this.parent ) { /*...*/ }` later on
  			cssIds: cssIds
  		});
  	}

  	initHook.end(ractive);

  	// render automatically ( if `el` is specified )
  	if (el = getElement(ractive.el)) {
  		var promise = ractive.render(el, ractive.append);

  		if (_Ractive.DEBUG_PROMISES) {
  			promise["catch"](function (err) {
  				warnOnceIfDebug("Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\n  Ractive.DEBUG_PROMISES = false;");
  				warnIfDebug("An error happened during rendering", { ractive: ractive });
  				err.stack && logIfDebug(err.stack);

  				throw err;
  			});
  		}
  	}
  }

  function getAdaptors(ractive, protoAdapt, userOptions) {
  	var adapt, magic, modifyArrays;

  	protoAdapt = protoAdapt.map(lookup);
  	adapt = ensureArray(userOptions.adapt).map(lookup);

  	adapt = initialise__combine(protoAdapt, adapt);

  	magic = "magic" in userOptions ? userOptions.magic : ractive.magic;
  	modifyArrays = "modifyArrays" in userOptions ? userOptions.modifyArrays : ractive.modifyArrays;

  	if (magic) {
  		if (!environment__magic) {
  			throw new Error("Getters and setters (magic mode) are not supported in this browser");
  		}

  		if (modifyArrays) {
  			adapt.push(magicArray);
  		}

  		adapt.push(adaptors_magic);
  	}

  	if (modifyArrays) {
  		adapt.push(array_index);
  	}

  	return adapt;

  	function lookup(adaptor) {
  		if (typeof adaptor === "string") {
  			adaptor = findInViewHierarchy("adaptors", ractive, adaptor);

  			if (!adaptor) {
  				fatal(missingPlugin(adaptor, "adaptor"));
  			}
  		}

  		return adaptor;
  	}
  }

  function initialise__combine(a, b) {
  	var c = a.slice(),
  	    i = b.length;

  	while (i--) {
  		if (! ~c.indexOf(b[i])) {
  			c.push(b[i]);
  		}
  	}

  	return c;
  }

  function initialiseProperties(ractive, options) {
  	// Generate a unique identifier, for places where you'd use a weak map if it
  	// existed
  	ractive._guid = "r-" + initialise__uid++;

  	// events
  	ractive._subs = create(null);

  	// storage for item configuration from instantiation to reset,
  	// like dynamic functions or original values
  	ractive._config = {};

  	// two-way bindings
  	ractive._twowayBindings = create(null);

  	// animations (so we can stop any in progress at teardown)
  	ractive._animations = [];

  	// nodes registry
  	ractive.nodes = {};

  	// live queries
  	ractive._liveQueries = [];
  	ractive._liveComponentQueries = [];

  	// bound data functions
  	ractive._boundFunctions = [];

  	// observers
  	ractive._observers = [];

  	// properties specific to inline components
  	if (options.component) {
  		ractive.parent = options.parent;
  		ractive.container = options.container || null;
  		ractive.root = ractive.parent.root;

  		ractive.component = options.component;
  		options.component.instance = ractive;

  		// for hackability, this could be an open option
  		// for any ractive instance, but for now, just
  		// for components and just for ractive...
  		ractive._inlinePartials = options.inlinePartials;
  	} else {
  		ractive.root = ractive;
  		ractive.parent = ractive.container = null;
  	}
  }

  function deprecateRactiveData() {
  	throw new Error("Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead");
  }

  function ComplexParameter(component, template, callback) {
  	this.parentFragment = component.parentFragment;
  	this.callback = callback;

  	this.fragment = new virtualdom_Fragment({
  		template: template,
  		root: component.root,
  		owner: this
  	});

  	this.update();
  }

  var initialise_ComplexParameter = ComplexParameter;

  ComplexParameter.prototype = {
  	bubble: function () {
  		if (!this.dirty) {
  			this.dirty = true;
  			global_runloop.addView(this);
  		}
  	},

  	update: function () {
  		this.callback(this.fragment.getValue());
  		this.dirty = false;
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		this.fragment.rebind(oldKeypath, newKeypath);
  	},

  	unbind: function () {
  		this.fragment.unbind();
  	}
  };

  var createInstance = function (component, Component, attributes, yieldTemplate, partials) {
  	var instance,
  	    parentFragment,
  	    ractive,
  	    fragment,
  	    container,
  	    inlinePartials = {},
  	    data = {},
  	    mappings = {},
  	    ready,
  	    resolvers = [];

  	parentFragment = component.parentFragment;
  	ractive = component.root;

  	partials = partials || {};
  	utils_object__extend(inlinePartials, partials);

  	// Make contents available as a {{>content}} partial
  	partials.content = yieldTemplate || [];

  	// set a default partial for yields with no name
  	inlinePartials[""] = partials.content;

  	if (Component.defaults.el) {
  		warnIfDebug("The <%s/> component has a default `el` property; it has been disregarded", component.name);
  	}

  	// find container
  	fragment = parentFragment;
  	while (fragment) {
  		if (fragment.owner.type === YIELDER) {
  			container = fragment.owner.container;
  			break;
  		}

  		fragment = fragment.parent;
  	}

  	// each attribute represents either a) data or b) a mapping
  	if (attributes) {
  		Object.keys(attributes).forEach(function (key) {
  			var attribute = attributes[key],
  			    parsed,
  			    resolver;

  			if (typeof attribute === "string") {
  				// it's static data
  				parsed = parseJSON(attribute);
  				data[key] = parsed ? parsed.value : attribute;
  			} else if (attribute === 0) {
  				// it had no '=', so we'll call it true
  				data[key] = true;
  			} else if (isArray(attribute)) {
  				// this represents dynamic data
  				if (isSingleInterpolator(attribute)) {
  					mappings[key] = {
  						origin: component.root.viewmodel,
  						keypath: undefined
  					};

  					resolver = createResolver(component, attribute[0], function (keypath) {
  						if (keypath.isSpecial) {
  							if (ready) {
  								instance.set(key, keypath.value); // TODO use viewmodel?
  							} else {
  								data[key] = keypath.value;

  								// TODO errr.... would be better if we didn't have to do this
  								delete mappings[key];
  							}
  						} else {
  							if (ready) {
  								instance.viewmodel.mappings[key].resolve(keypath);
  							} else {
  								// resolved immediately
  								mappings[key].keypath = keypath;
  							}
  						}
  					});
  				} else {
  					resolver = new initialise_ComplexParameter(component, attribute, function (value) {
  						if (ready) {
  							instance.set(key, value); // TODO use viewmodel?
  						} else {
  							data[key] = value;
  						}
  					});
  				}

  				resolvers.push(resolver);
  			} else {
  				throw new Error("erm wut");
  			}
  		});
  	}

  	instance = create(Component.prototype);

  	initialise(instance, {
  		el: null,
  		append: true,
  		data: data,
  		partials: partials,
  		magic: ractive.magic || Component.defaults.magic,
  		modifyArrays: ractive.modifyArrays,
  		// need to inherit runtime parent adaptors
  		adapt: ractive.adapt
  	}, {
  		parent: ractive,
  		component: component,
  		container: container,
  		mappings: mappings,
  		inlinePartials: inlinePartials,
  		cssIds: parentFragment.cssIds
  	});

  	ready = true;
  	component.resolvers = resolvers;

  	return instance;
  };

  function createResolver(component, template, callback) {
  	var resolver;

  	if (template.r) {
  		resolver = Resolvers_createReferenceResolver(component, template.r, callback);
  	} else if (template.x) {
  		resolver = new Resolvers_ExpressionResolver(component, component.parentFragment, template.x, callback);
  	} else if (template.rx) {
  		resolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(component, template.rx, callback);
  	}

  	return resolver;
  }

  function isSingleInterpolator(template) {
  	return template.length === 1 && template[0].t === INTERPOLATOR;
  }

  // TODO how should event arguments be handled? e.g.
  // <widget on-foo='bar:1,2,3'/>
  // The event 'bar' will be fired on the parent instance
  // when 'foo' fires on the child, but the 1,2,3 arguments
  // will be lost

  var initialise_propagateEvents = propagateEvents;

  function propagateEvents(component, eventsDescriptor) {
  	var eventName;

  	for (eventName in eventsDescriptor) {
  		if (eventsDescriptor.hasOwnProperty(eventName)) {
  			propagateEvent(component.instance, component.root, eventName, eventsDescriptor[eventName]);
  		}
  	}
  }

  function propagateEvent(childInstance, parentInstance, eventName, proxyEventName) {
  	if (typeof proxyEventName !== "string") {
  		fatal("Components currently only support simple events - you cannot include arguments. Sorry!");
  	}

  	childInstance.on(eventName, function () {
  		var event, args;

  		// semi-weak test, but what else? tag the event obj ._isEvent ?
  		if (arguments.length && arguments[0] && arguments[0].node) {
  			event = Array.prototype.shift.call(arguments);
  		}

  		args = Array.prototype.slice.call(arguments);

  		shared_fireEvent(parentInstance, proxyEventName, { event: event, args: args });

  		// cancel bubbling
  		return false;
  	});
  }

  var initialise_updateLiveQueries = function (component) {
  	var ancestor, query;

  	// If there's a live query for this component type, add it
  	ancestor = component.root;
  	while (ancestor) {
  		if (query = ancestor._liveComponentQueries["_" + component.name]) {
  			query.push(component.instance);
  		}

  		ancestor = ancestor.parent;
  	}
  };

  var Component_prototype_init = Component$init;
  function Component$init(options, Component) {
  	var parentFragment, root;

  	if (!Component) {
  		throw new Error("Component \"" + this.name + "\" not found");
  	}

  	parentFragment = this.parentFragment = options.parentFragment;
  	root = parentFragment.root;

  	this.root = root;
  	this.type = COMPONENT;
  	this.name = options.template.e;
  	this.index = options.index;
  	this.indexRefBindings = {};
  	this.yielders = {};
  	this.resolvers = [];

  	createInstance(this, Component, options.template.a, options.template.f, options.template.p);
  	initialise_propagateEvents(this, options.template.v);

  	// intro, outro and decorator directives have no effect
  	if (options.template.t0 || options.template.t1 || options.template.t2 || options.template.o) {
  		warnIfDebug("The \"intro\", \"outro\" and \"decorator\" directives have no effect on components", { ractive: this.instance });
  	}

  	initialise_updateLiveQueries(this);
  }

  var Component_prototype_rebind = Component$rebind;

  function Component$rebind(oldKeypath, newKeypath) {
  	var query;

  	this.resolvers.forEach(rebind);

  	for (var k in this.yielders) {
  		if (this.yielders[k][0]) {
  			rebind(this.yielders[k][0]);
  		}
  	}

  	if (query = this.root._liveComponentQueries["_" + this.name]) {
  		query._makeDirty();
  	}

  	function rebind(x) {
  		x.rebind(oldKeypath, newKeypath);
  	}
  }

  var Component_prototype_render = Component$render;

  function Component$render() {
  	var instance = this.instance;

  	instance.render(this.parentFragment.getNode());

  	this.rendered = true;
  	return instance.fragment.detach();
  }

  var Component_prototype_toString = Component$toString;

  function Component$toString() {
  	return this.instance.fragment.toString();
  }

  var Component_prototype_unbind = Component$unbind;

  var Component_prototype_unbind__teardownHook = new hooks_Hook("teardown");
  function Component$unbind() {
  	var instance = this.instance;

  	this.resolvers.forEach(methodCallers__unbind);

  	removeFromLiveComponentQueries(this);

  	instance._observers.forEach(cancel);

  	// teardown the instance
  	instance.fragment.unbind();
  	instance.viewmodel.teardown();

  	if (instance.fragment.rendered && instance.el.__ractive_instances__) {
  		removeFromArray(instance.el.__ractive_instances__, instance);
  	}

  	Component_prototype_unbind__teardownHook.fire(instance);
  }

  function removeFromLiveComponentQueries(component) {
  	var instance, query;

  	instance = component.root;

  	do {
  		if (query = instance._liveComponentQueries["_" + component.name]) {
  			query._remove(component);
  		}
  	} while (instance = instance.parent);
  }

  var Component_prototype_unrender = Component$unrender;

  function Component$unrender(shouldDestroy) {
  	this.shouldDestroy = shouldDestroy;
  	this.instance.unrender();
  }

  var Component = function (options, Constructor) {
  	this.init(options, Constructor);
  };

  Component.prototype = {
  	detach: Component_prototype_detach,
  	find: Component_prototype_find,
  	findAll: Component_prototype_findAll,
  	findAllComponents: Component_prototype_findAllComponents,
  	findComponent: Component_prototype_findComponent,
  	findNextNode: Component_prototype_findNextNode,
  	firstNode: Component_prototype_firstNode,
  	init: Component_prototype_init,
  	rebind: Component_prototype_rebind,
  	render: Component_prototype_render,
  	toString: Component_prototype_toString,
  	unbind: Component_prototype_unbind,
  	unrender: Component_prototype_unrender
  };

  var _Component = Component;

  var Comment = function (options) {
  	this.type = COMMENT;
  	this.value = options.template.c;
  };

  Comment.prototype = {
  	detach: shared_detach,

  	firstNode: function () {
  		return this.node;
  	},

  	render: function () {
  		if (!this.node) {
  			this.node = document.createComment(this.value);
  		}

  		return this.node;
  	},

  	toString: function () {
  		return "<!--" + this.value + "-->";
  	},

  	unrender: function (shouldDestroy) {
  		if (shouldDestroy) {
  			this.node.parentNode.removeChild(this.node);
  		}
  	}
  };

  var items_Comment = Comment;

  var Yielder = function (options) {
  	var container, component;

  	this.type = YIELDER;

  	this.container = container = options.parentFragment.root;
  	this.component = component = container.component;

  	this.container = container;
  	this.containerFragment = options.parentFragment;
  	this.parentFragment = component.parentFragment;

  	var name = this.name = options.template.n || "";

  	var template = container._inlinePartials[name];

  	if (!template) {
  		warnIfDebug("Could not find template for partial \"" + name + "\"", { ractive: options.root });
  		template = [];
  	}

  	this.fragment = new virtualdom_Fragment({
  		owner: this,
  		root: container.parent,
  		template: template,
  		pElement: this.containerFragment.pElement
  	});

  	// even though only one yielder is allowed, we need to have an array of them
  	// as it's possible to cause a yielder to be created before the last one
  	// was destroyed in the same turn of the runloop
  	if (!isArray(component.yielders[name])) {
  		component.yielders[name] = [this];
  	} else {
  		component.yielders[name].push(this);
  	}

  	global_runloop.scheduleTask(function () {
  		if (component.yielders[name].length > 1) {
  			throw new Error("A component template can only have one {{yield" + (name ? " " + name : "") + "}} declaration at a time");
  		}
  	});
  };

  Yielder.prototype = {
  	detach: function () {
  		return this.fragment.detach();
  	},

  	find: function (selector) {
  		return this.fragment.find(selector);
  	},

  	findAll: function (selector, query) {
  		return this.fragment.findAll(selector, query);
  	},

  	findComponent: function (selector) {
  		return this.fragment.findComponent(selector);
  	},

  	findAllComponents: function (selector, query) {
  		return this.fragment.findAllComponents(selector, query);
  	},

  	findNextNode: function () {
  		return this.containerFragment.findNextNode(this);
  	},

  	firstNode: function () {
  		return this.fragment.firstNode();
  	},

  	getValue: function (options) {
  		return this.fragment.getValue(options);
  	},

  	render: function () {
  		return this.fragment.render();
  	},

  	unbind: function () {
  		this.fragment.unbind();
  	},

  	unrender: function (shouldDestroy) {
  		this.fragment.unrender(shouldDestroy);
  		removeFromArray(this.component.yielders[this.name], this);
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		this.fragment.rebind(oldKeypath, newKeypath);
  	},

  	toString: function () {
  		return this.fragment.toString();
  	}
  };

  var items_Yielder = Yielder;

  var Doctype = function (options) {
  	this.declaration = options.template.a;
  };

  Doctype.prototype = {
  	init: noop,
  	render: noop,
  	unrender: noop,
  	teardown: noop,
  	toString: function () {
  		return "<!DOCTYPE" + this.declaration + ">";
  	}
  };

  var items_Doctype = Doctype;

  var Fragment_prototype_init = Fragment$init;

  function Fragment$init(options) {
  	var _this = this;

  	this.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute
  	this.parent = this.owner.parentFragment;

  	// inherited properties
  	this.root = options.root;
  	this.pElement = options.pElement;
  	this.context = options.context;
  	this.index = options.index;
  	this.key = options.key;
  	this.registeredIndexRefs = [];

  	// encapsulated styles should be inherited until they get applied by an element
  	this.cssIds = "cssIds" in options ? options.cssIds : this.parent ? this.parent.cssIds : null;

  	this.items = options.template.map(function (template, i) {
  		return createItem({
  			parentFragment: _this,
  			pElement: options.pElement,
  			template: template,
  			index: i
  		});
  	});

  	this.value = this.argsList = null;
  	this.dirtyArgs = this.dirtyValue = true;

  	this.bound = true;
  }

  function createItem(options) {
  	if (typeof options.template === "string") {
  		return new items_Text(options);
  	}

  	switch (options.template.t) {
  		case YIELDER:
  			return new items_Yielder(options);
  		case INTERPOLATOR:
  			return new items_Interpolator(options);
  		case SECTION:
  			return new _Section(options);
  		case TRIPLE:
  			return new _Triple(options);
  		case ELEMENT:
  			var constructor = undefined;
  			if (constructor = Component_getComponent(options.parentFragment.root, options.template.e)) {
  				return new _Component(options, constructor);
  			}
  			return new _Element(options);
  		case PARTIAL:
  			return new _Partial(options);
  		case COMMENT:
  			return new items_Comment(options);
  		case DOCTYPE:
  			return new items_Doctype(options);

  		default:
  			throw new Error("Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!");
  	}
  }

  var Fragment_prototype_rebind = Fragment$rebind;
  function Fragment$rebind(oldKeypath, newKeypath) {

  	// assign new context keypath if needed
  	if (!this.owner || this.owner.hasContext) {
  		assignNewKeypath(this, "context", oldKeypath, newKeypath);
  	}

  	this.items.forEach(function (item) {
  		if (item.rebind) {
  			item.rebind(oldKeypath, newKeypath);
  		}
  	});
  }

  var Fragment_prototype_render = Fragment$render;

  function Fragment$render() {
  	var result;

  	if (this.items.length === 1) {
  		result = this.items[0].render();
  	} else {
  		result = document.createDocumentFragment();

  		this.items.forEach(function (item) {
  			result.appendChild(item.render());
  		});
  	}

  	this.rendered = true;
  	return result;
  }

  var Fragment_prototype_toString = Fragment$toString;

  function Fragment$toString(escape) {
  	if (!this.items) {
  		return "";
  	}

  	return this.items.map(escape ? toEscapedString : Fragment_prototype_toString__toString).join("");
  }

  function Fragment_prototype_toString__toString(item) {
  	return item.toString();
  }

  function toEscapedString(item) {
  	return item.toString(true);
  }

  var Fragment_prototype_unbind = Fragment$unbind;

  function Fragment$unbind() {
  	if (!this.bound) {
  		return;
  	}

  	this.items.forEach(unbindItem);
  	this.bound = false;
  }

  function unbindItem(item) {
  	if (item.unbind) {
  		item.unbind();
  	}
  }

  var Fragment_prototype_unrender = Fragment$unrender;

  function Fragment$unrender(shouldDestroy) {
  	if (!this.rendered) {
  		throw new Error("Attempted to unrender a fragment that was not rendered");
  	}

  	this.items.forEach(function (i) {
  		return i.unrender(shouldDestroy);
  	});
  	this.rendered = false;
  }

  var Fragment = function (options) {
  	this.init(options);
  };

  Fragment.prototype = {
  	bubble: prototype_bubble,
  	detach: Fragment_prototype_detach,
  	find: Fragment_prototype_find,
  	findAll: Fragment_prototype_findAll,
  	findAllComponents: Fragment_prototype_findAllComponents,
  	findComponent: Fragment_prototype_findComponent,
  	findNextNode: prototype_findNextNode,
  	firstNode: prototype_firstNode,
  	getArgsList: getArgsList,
  	getNode: getNode,
  	getValue: prototype_getValue,
  	init: Fragment_prototype_init,
  	rebind: Fragment_prototype_rebind,
  	registerIndexRef: function (idx) {
  		var idxs = this.registeredIndexRefs;
  		if (idxs.indexOf(idx) === -1) {
  			idxs.push(idx);
  		}
  	},
  	render: Fragment_prototype_render,
  	toString: Fragment_prototype_toString,
  	unbind: Fragment_prototype_unbind,
  	unregisterIndexRef: function (idx) {
  		var idxs = this.registeredIndexRefs;
  		idxs.splice(idxs.indexOf(idx), 1);
  	},
  	unrender: Fragment_prototype_unrender
  };

  var virtualdom_Fragment = Fragment;

  var prototype_reset = Ractive$reset;
  var shouldRerender = ["template", "partials", "components", "decorators", "events"],
      resetHook = new hooks_Hook("reset");
  function Ractive$reset(data) {
  	var promise, wrapper, changes, i, rerender;

  	data = data || {};

  	if (typeof data !== "object") {
  		throw new Error("The reset method takes either no arguments, or an object containing new data");
  	}

  	// If the root object is wrapped, try and use the wrapper's reset value
  	if ((wrapper = this.viewmodel.wrapped[""]) && wrapper.reset) {
  		if (wrapper.reset(data) === false) {
  			// reset was rejected, we need to replace the object
  			this.viewmodel.reset(data);
  		}
  	} else {
  		this.viewmodel.reset(data);
  	}

  	// reset config items and track if need to rerender
  	changes = config_config.reset(this);

  	i = changes.length;
  	while (i--) {
  		if (shouldRerender.indexOf(changes[i]) > -1) {
  			rerender = true;
  			break;
  		}
  	}

  	if (rerender) {
  		var component = undefined;

  		this.viewmodel.mark(rootKeypath);

  		// Is this is a component, we need to set the `shouldDestroy`
  		// flag, otherwise it will assume by default that a parent node
  		// will be detached, and therefore it doesn't need to bother
  		// detaching its own nodes
  		if (component = this.component) {
  			component.shouldDestroy = true;
  		}

  		this.unrender();

  		if (component) {
  			component.shouldDestroy = false;
  		}

  		// If the template changed, we need to destroy the parallel DOM
  		// TODO if we're here, presumably it did?
  		if (this.fragment.template !== this.template) {
  			this.fragment.unbind();

  			this.fragment = new virtualdom_Fragment({
  				template: this.template,
  				root: this,
  				owner: this
  			});
  		}

  		promise = this.render(this.el, this.anchor);
  	} else {
  		promise = global_runloop.start(this, true);
  		this.viewmodel.mark(rootKeypath);
  		global_runloop.end();
  	}

  	resetHook.fire(this, data);

  	return promise;
  }

  var resetPartial = function (name, partial) {
  	var promise,
  	    collection = [];

  	function collect(source, dest, ractive) {
  		// if this is a component and it has its own partial, bail
  		if (ractive && ractive.partials[name]) return;

  		source.forEach(function (item) {
  			// queue to rerender if the item is a partial and the current name matches
  			if (item.type === PARTIAL && item.getPartialName() === name) {
  				dest.push(item);
  			}

  			// if it has a fragment, process its items
  			if (item.fragment) {
  				collect(item.fragment.items, dest, ractive);
  			}

  			// or if it has fragments
  			if (isArray(item.fragments)) {
  				collect(item.fragments, dest, ractive);
  			}

  			// or if it is itself a fragment, process its items
  			else if (isArray(item.items)) {
  				collect(item.items, dest, ractive);
  			}

  			// or if it is a component, step in and process its items
  			else if (item.type === COMPONENT && item.instance) {
  				collect(item.instance.fragment.items, dest, item.instance);
  			}

  			// if the item is an element, process its attributes too
  			if (item.type === ELEMENT) {
  				if (isArray(item.attributes)) {
  					collect(item.attributes, dest, ractive);
  				}

  				if (isArray(item.conditionalAttributes)) {
  					collect(item.conditionalAttributes, dest, ractive);
  				}
  			}
  		});
  	}

  	collect(this.fragment.items, collection);
  	this.partials[name] = partial;

  	promise = global_runloop.start(this, true);

  	collection.forEach(function (item) {
  		item.value = undefined;
  		item.setValue(name);
  	});

  	global_runloop.end();

  	return promise;
  };

  // TODO should resetTemplate be asynchronous? i.e. should it be a case
  // of outro, update template, intro? I reckon probably not, since that
  // could be achieved with unrender-resetTemplate-render. Also, it should
  // conceptually be similar to resetPartial, which couldn't be async

  var resetTemplate = Ractive$resetTemplate;
  function Ractive$resetTemplate(template) {
  	var transitionsEnabled, component;

  	template_template.init(null, this, { template: template });

  	transitionsEnabled = this.transitionsEnabled;
  	this.transitionsEnabled = false;

  	// Is this is a component, we need to set the `shouldDestroy`
  	// flag, otherwise it will assume by default that a parent node
  	// will be detached, and therefore it doesn't need to bother
  	// detaching its own nodes
  	if (component = this.component) {
  		component.shouldDestroy = true;
  	}

  	this.unrender();

  	if (component) {
  		component.shouldDestroy = false;
  	}

  	// remove existing fragment and create new one
  	this.fragment.unbind();
  	this.fragment = new virtualdom_Fragment({
  		template: this.template,
  		root: this,
  		owner: this
  	});

  	this.render(this.el, this.anchor);

  	this.transitionsEnabled = transitionsEnabled;
  }

  var reverse = makeArrayMethod("reverse");

  var Ractive_prototype_set = Ractive$set;

  function Ractive$set(keypath, value) {
  	var map, promise;

  	promise = global_runloop.start(this, true);

  	// Set multiple keypaths in one go
  	if (isObject(keypath)) {
  		map = keypath;

  		for (keypath in map) {
  			if (map.hasOwnProperty(keypath)) {
  				value = map[keypath];
  				set(this, keypath, value);
  			}
  		}
  	}

  	// Set a single keypath
  	else {
  		set(this, keypath, value);
  	}

  	global_runloop.end();

  	return promise;
  }

  function set(ractive, keypath, value) {
  	keypath = getKeypath(normalise(keypath));

  	if (keypath.isPattern) {
  		getMatchingKeypaths(ractive, keypath).forEach(function (keypath) {
  			ractive.viewmodel.set(keypath, value);
  		});
  	} else {
  		ractive.viewmodel.set(keypath, value);
  	}
  }

  var shift = makeArrayMethod("shift");

  var prototype_sort = makeArrayMethod("sort");

  var splice = makeArrayMethod("splice");

  var subtract = Ractive$subtract;
  function Ractive$subtract(keypath, d) {
  	return shared_add(this, keypath, d === undefined ? -1 : -d);
  }

  // Teardown. This goes through the root fragment and all its children, removing observers
  // and generally cleaning up after itself

  var Ractive_prototype_teardown = Ractive$teardown;

  var Ractive_prototype_teardown__teardownHook = new hooks_Hook("teardown");
  function Ractive$teardown() {
  	var promise;

  	this.fragment.unbind();
  	this.viewmodel.teardown();

  	this._observers.forEach(cancel);

  	if (this.fragment.rendered && this.el.__ractive_instances__) {
  		removeFromArray(this.el.__ractive_instances__, this);
  	}

  	this.shouldDestroy = true;
  	promise = this.fragment.rendered ? this.unrender() : utils_Promise.resolve();

  	Ractive_prototype_teardown__teardownHook.fire(this);

  	this._boundFunctions.forEach(deleteFunctionCopy);

  	return promise;
  }

  function deleteFunctionCopy(bound) {
  	delete bound.fn[bound.prop];
  }

  var toggle = Ractive$toggle;
  function Ractive$toggle(keypath) {
  	var _this = this;

  	if (typeof keypath !== "string") {
  		throw new TypeError(badArguments);
  	}

  	var changes = undefined;

  	if (/\*/.test(keypath)) {
  		changes = {};

  		getMatchingKeypaths(this, getKeypath(normalise(keypath))).forEach(function (keypath) {
  			changes[keypath.str] = !_this.viewmodel.get(keypath);
  		});

  		return this.set(changes);
  	}

  	return this.set(keypath, !this.get(keypath));
  }

  var toHTML = Ractive$toHTML;

  function Ractive$toHTML() {
  	return this.fragment.toString(true);
  }

  var Ractive_prototype_unrender = Ractive$unrender;
  var unrenderHook = new hooks_Hook("unrender");
  function Ractive$unrender() {
  	var promise, shouldDestroy;

  	if (!this.fragment.rendered) {
  		warnIfDebug("ractive.unrender() was called on a Ractive instance that was not rendered");
  		return utils_Promise.resolve();
  	}

  	promise = global_runloop.start(this, true);

  	// If this is a component, and the component isn't marked for destruction,
  	// don't detach nodes from the DOM unnecessarily
  	shouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;

  	// Cancel any animations in progress
  	while (this._animations[0]) {
  		this._animations[0].stop(); // it will remove itself from the index
  	}

  	this.fragment.unrender(shouldDestroy);

  	removeFromArray(this.el.__ractive_instances__, this);

  	unrenderHook.fire(this);

  	global_runloop.end();
  	return promise;
  }

  var unshift = makeArrayMethod("unshift");

  var Ractive_prototype_update = Ractive$update;
  var updateHook = new hooks_Hook("update");
  function Ractive$update(keypath) {
  	var promise;

  	keypath = getKeypath(keypath) || rootKeypath;

  	promise = global_runloop.start(this, true);
  	this.viewmodel.mark(keypath);
  	global_runloop.end();

  	updateHook.fire(this, keypath);

  	return promise;
  }

  var prototype_updateModel = Ractive$updateModel;

  function Ractive$updateModel(keypath, cascade) {
  	var values, key, bindings;

  	if (typeof keypath === "string" && !cascade) {
  		bindings = this._twowayBindings[keypath];
  	} else {
  		bindings = [];

  		for (key in this._twowayBindings) {
  			if (!keypath || getKeypath(key).equalsOrStartsWith(keypath)) {
  				// TODO is this right?
  				bindings.push.apply(bindings, this._twowayBindings[key]);
  			}
  		}
  	}

  	values = consolidate(this, bindings);
  	return this.set(values);
  }

  function consolidate(ractive, bindings) {
  	var values = {},
  	    checkboxGroups = [];

  	bindings.forEach(function (b) {
  		var oldValue, newValue;

  		// special case - radio name bindings
  		if (b.radioName && !b.element.node.checked) {
  			return;
  		}

  		// special case - checkbox name bindings come in groups, so
  		// we want to get the value once at most
  		if (b.checkboxName) {
  			if (!checkboxGroups[b.keypath.str] && !b.changed()) {
  				checkboxGroups.push(b.keypath);
  				checkboxGroups[b.keypath.str] = b;
  			}

  			return;
  		}

  		oldValue = b.attribute.value;
  		newValue = b.getValue();

  		if (arrayContentsMatch(oldValue, newValue)) {
  			return;
  		}

  		if (!isEqual(oldValue, newValue)) {
  			values[b.keypath.str] = newValue;
  		}
  	});

  	// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`
  	if (checkboxGroups.length) {
  		checkboxGroups.forEach(function (keypath) {
  			var binding, oldValue, newValue;

  			binding = checkboxGroups[keypath.str]; // one to represent the entire group
  			oldValue = binding.attribute.value;
  			newValue = binding.getValue();

  			if (!arrayContentsMatch(oldValue, newValue)) {
  				values[keypath.str] = newValue;
  			}
  		});
  	}

  	return values;
  }

  var prototype = {
  	add: prototype_add,
  	animate: prototype_animate,
  	detach: prototype_detach,
  	find: prototype_find,
  	findAll: prototype_findAll,
  	findAllComponents: prototype_findAllComponents,
  	findComponent: prototype_findComponent,
  	findContainer: findContainer,
  	findParent: findParent,
  	fire: prototype_fire,
  	get: prototype_get,
  	insert: insert,
  	merge: prototype_merge,
  	observe: observe,
  	observeOnce: observeOnce,
  	off: off,
  	on: on,
  	once: once,
  	pop: pop,
  	push: push,
  	render: prototype_render,
  	reset: prototype_reset,
  	resetPartial: resetPartial,
  	resetTemplate: resetTemplate,
  	reverse: reverse,
  	set: Ractive_prototype_set,
  	shift: shift,
  	sort: prototype_sort,
  	splice: splice,
  	subtract: subtract,
  	teardown: Ractive_prototype_teardown,
  	toggle: toggle,
  	toHTML: toHTML,
  	toHtml: toHTML,
  	unrender: Ractive_prototype_unrender,
  	unshift: unshift,
  	update: Ractive_prototype_update,
  	updateModel: prototype_updateModel
  };

  var wrapMethod = function (method, superMethod, force) {

  	if (force || needsSuper(method, superMethod)) {

  		return function () {

  			var hasSuper = ("_super" in this),
  			    _super = this._super,
  			    result;

  			this._super = superMethod;

  			result = method.apply(this, arguments);

  			if (hasSuper) {
  				this._super = _super;
  			}

  			return result;
  		};
  	} else {
  		return method;
  	}
  };

  function needsSuper(method, superMethod) {
  	return typeof superMethod === "function" && /_super/.test(method);
  }

  var unwrapExtended = unwrap;

  function unwrap(Child) {
  	var options = {};

  	while (Child) {
  		addRegistries(Child, options);
  		addOtherOptions(Child, options);

  		if (Child._Parent !== _Ractive) {
  			Child = Child._Parent;
  		} else {
  			Child = false;
  		}
  	}

  	return options;
  }

  function addRegistries(Child, options) {
  	config_registries.forEach(function (r) {
  		addRegistry(r.useDefaults ? Child.prototype : Child, options, r.name);
  	});
  }

  function addRegistry(target, options, name) {
  	var registry,
  	    keys = Object.keys(target[name]);

  	if (!keys.length) {
  		return;
  	}

  	if (!(registry = options[name])) {
  		registry = options[name] = {};
  	}

  	keys.filter(function (key) {
  		return !(key in registry);
  	}).forEach(function (key) {
  		return registry[key] = target[name][key];
  	});
  }

  function addOtherOptions(Child, options) {
  	Object.keys(Child.prototype).forEach(function (key) {
  		if (key === "computed") {
  			return;
  		}

  		var value = Child.prototype[key];

  		if (!(key in options)) {
  			options[key] = value._method ? value._method : value;
  		}

  		// is it a wrapped function?
  		else if (typeof options[key] === "function" && typeof value === "function" && options[key]._method) {

  			var result = undefined,
  			    needsSuper = value._method;

  			if (needsSuper) {
  				value = value._method;
  			}

  			// rewrap bound directly to parent fn
  			result = wrapMethod(options[key]._method, value);

  			if (needsSuper) {
  				result._method = result;
  			}

  			options[key] = result;
  		}
  	});
  }

  var _extend = _extend__extend;

  function _extend__extend() {
  	for (var _len = arguments.length, options = Array(_len), _key = 0; _key < _len; _key++) {
  		options[_key] = arguments[_key];
  	}

  	if (!options.length) {
  		return extendOne(this);
  	} else {
  		return options.reduce(extendOne, this);
  	}
  }

  function extendOne(Parent) {
  	var options = arguments[1] === undefined ? {} : arguments[1];

  	var Child, proto;

  	// if we're extending with another Ractive instance...
  	//
  	//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);
  	//   var Spiderman = Human.extend( Spider );
  	//
  	// ...inherit prototype methods and default options as well
  	if (options.prototype instanceof _Ractive) {
  		options = unwrapExtended(options);
  	}

  	Child = function (options) {
  		if (!(this instanceof Child)) return new Child(options);
  		initialise(this, options);
  	};

  	proto = create(Parent.prototype);
  	proto.constructor = Child;

  	// Static properties
  	defineProperties(Child, {
  		// alias prototype as defaults
  		defaults: { value: proto },

  		// extendable
  		extend: { value: _extend__extend, writable: true, configurable: true },

  		// Parent - for IE8, can't use Object.getPrototypeOf
  		_Parent: { value: Parent }
  	});

  	// extend configuration
  	config_config.extend(Parent, proto, options);

  	custom_data.extend(Parent, proto, options);

  	if (options.computed) {
  		proto.computed = utils_object__extend(create(Parent.prototype.computed), options.computed);
  	}

  	Child.prototype = proto;

  	return Child;
  }

  var getNodeInfo = function (node) {
  	var info = {},
  	    priv,
  	    indices;

  	if (!node || !(priv = node._ractive)) {
  		return info;
  	}

  	info.ractive = priv.root;
  	info.keypath = priv.keypath.str;
  	info.index = {};

  	// find all index references and resolve them
  	if (indices = Resolvers_findIndexRefs(priv.proxy.parentFragment)) {
  		info.index = Resolvers_findIndexRefs.resolve(indices);
  	}

  	return info;
  };

  var Ractive, properties;

  // Main Ractive required object
  Ractive = function (options) {
  	if (!(this instanceof Ractive)) return new Ractive(options);
  	initialise(this, options);
  };

  // Ractive properties
  properties = {

  	// debug flag
  	DEBUG: { writable: true, value: true },
  	DEBUG_PROMISES: { writable: true, value: true },

  	// static methods:
  	extend: { value: _extend },
  	getNodeInfo: { value: getNodeInfo },
  	parse: { value: _parse },

  	// Namespaced constructors
  	Promise: { value: utils_Promise },

  	// support
  	svg: { value: svg },
  	magic: { value: environment__magic },

  	// version
  	VERSION: { value: "0.7.3" },

  	// Plugins
  	adaptors: { writable: true, value: {} },
  	components: { writable: true, value: {} },
  	decorators: { writable: true, value: {} },
  	easing: { writable: true, value: static_easing },
  	events: { writable: true, value: {} },
  	interpolators: { writable: true, value: static_interpolators },
  	partials: { writable: true, value: {} },
  	transitions: { writable: true, value: {} }
  };

  // Ractive properties
  defineProperties(Ractive, properties);

  Ractive.prototype = utils_object__extend(prototype, config_defaults);

  Ractive.prototype.constructor = Ractive;

  // alias prototype as defaults
  Ractive.defaults = Ractive.prototype;

  // Ractive.js makes liberal use of things like Array.prototype.indexOf. In
  // older browsers, these are made available via a shim - here, we do a quick
  // pre-flight check to make sure that either a) we're not in a shit browser,
  // or b) we're using a Ractive-legacy.js build
  var FUNCTION = "function";

  if (typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== "undefined" && typeof window.addEventListener !== FUNCTION) {
  	throw new Error("It looks like you're attempting to use Ractive.js in an older browser. You'll need to use one of the 'legacy builds' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.");
  }

  var _Ractive = Ractive;

  return _Ractive;

}));


},{}],"/Users/cameron/Desktop/HoverCards/deckard/app/service/index.js":[function(require,module,exports){
var _ = require('underscore');

module.exports = function(identity, callback) {
	if (!_.isObject(identity)) {
		return setImmediate(function() {
			callback({ message: 'Missing \'identity\'', status: 400 });
		});
	}
	chrome.runtime.sendMessage({ type: 'service', identity: identity }, function(combined_response) {
		if (chrome.runtime.lastError || _.isEmpty(combined_response)) {
			return callback(_.extend(chrome.runtime.lastError, { status: 500 }));
		}
		callback(combined_response[0], combined_response[1]);
	});
};

},{"underscore":"/Users/cameron/.nvm/versions/node/v4.1.1/lib/node_modules/underscore/underscore.js"}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/urls/index.js":[function(require,module,exports){
var _   = require('underscore');
var url = require('url');

var hostnames_to_urls = {};

// TODO Browserify freaks out unless they're explicitly listed out
// Can't use require-globify since this isn't necessarily a browserify file
// Can't do a loop through apis and construct the require since this is used by browserify
_.each([require('../imgur/urls'),
        require('../instagram/urls'),
        require('../reddit/urls'),
        require('../soundcloud/urls'),
        require('../twitter/urls'),
        require('../youtube/urls')], function(api_urls) {
	_.each(api_urls.hostnames_parsed, function(hostname_parsed) {
		hostnames_to_urls[hostname_parsed] = hostnames_to_urls[hostname_parsed] || [];
		hostnames_to_urls[hostname_parsed].push(api_urls);
	});
});

var urls = {};

urls.parse = function(url_string) {
	if (_.isEmpty(url_string)) {
		return;
	}
	var url_object = url.parse(url_string, true, true);
	return _.chain(hostnames_to_urls[url_object.hostname])
	        .invoke('parse', url_object)
	        .compact()
	        .first()
	        .value();
};

urls.represent = function(identity, comment) {
	return require('../' + identity.api + '/urls').represent(identity, comment);
};

urls.print = function(identity, comment) {
	if (!identity) {
		return identity;
	}
	return (urls.represent(identity, comment) || [])[0];
};

module.exports = urls;

},{"../imgur/urls":"/Users/cameron/Desktop/HoverCards/hovercardsshared/imgur/urls.js","../instagram/urls":"/Users/cameron/Desktop/HoverCards/hovercardsshared/instagram/urls.js","../reddit/urls":"/Users/cameron/Desktop/HoverCards/hovercardsshared/reddit/urls.js","../soundcloud/urls":"/Users/cameron/Desktop/HoverCards/hovercardsshared/soundcloud/urls.js","../twitter/urls":"/Users/cameron/Desktop/HoverCards/hovercardsshared/twitter/urls.js","../youtube/urls":"/Users/cameron/Desktop/HoverCards/hovercardsshared/youtube/urls.js","underscore":"/Users/cameron/.nvm/versions/node/v4.1.1/lib/node_modules/underscore/underscore.js","url":"/Users/cameron/Desktop/HoverCards/deckard/node_modules/browserify/node_modules/url/url.js"}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/youtube/urls.js":[function(require,module,exports){
var _   = require('underscore');
var url = require('url');

var urls = {};

urls.hostnames_parsed = ['youtube.com', 'www.youtube.com', 'm.youtube.com', 'youtu.be'];

urls.parse = function(url_obj) {
	var path_parts = url_obj.pathname.replace(/^\//, '').replace(/\/$/, '').split('/') || [];
	switch (url_obj.hostname) {
		case 'youtube.com':
		case 'www.youtube.com':
		case 'm.youtube.com':
			switch (path_parts[0]) {
				case 'watch':
					return !_.isEmpty(url_obj.query.v) && _.extend({ api: 'youtube', type: 'content', id: url_obj.query.v.replace(/[?&].*/, '') },
					                                               url_obj.query.t && { time_offset: url_obj.query.t });
				case 'embed':
				case 'v':
					return !_.isEmpty(path_parts[1]) && _.extend({ api: 'youtube', type: 'content', id: path_parts[1].replace(/[?&].*/, '') },
					                                             url_obj.query.start && { time_offset: url_obj.query.start });
				case 'attribution_link':
					return !_.isEmpty(url_obj.query.u) && urls.parse(url.parse('https://youtube.com' + url_obj.query.u, true, true));
				case 'channel':
					return !_.isEmpty(path_parts[1]) && { api: 'youtube', type: 'account', id: path_parts[1].replace(/[?&].*/, '') };
				case 'user':
					return !_.isEmpty(path_parts[1]) && { api: 'youtube', type: 'account', id: path_parts[1].replace(/[?&].*/, ''), as: 'legacy_username' };
				case 'c':
					return !_.isEmpty(path_parts[1]) && { api: 'youtube', type: 'account', id: 'c/' + path_parts[1].replace(/[?&].*/, ''), as: 'custom_url' };
				default:
					return !_.isEmpty(path_parts[0]) &&
					       !path_parts[0].match(/^(?:account|channels|dashboard|feed|logout|playlist|signin|subscription_(?:center|manager)|t|testtube|upload|yt)$/) &&
					       { api: 'youtube', type: 'account', id: path_parts[0].replace(/[?&].*/, ''), as: 'custom_url' };
			}
			break;
		case 'youtu.be':
			return !_.isEmpty(path_parts[0]) && _.extend({ api: 'youtube', type: 'content', id: path_parts[0].replace(/[?&].*/, '') },
			                                             url_obj.query.t && { time_offset: url_obj.query.t });
	}
};

urls.represent = function(identity, comment) {
	switch (identity.type) {
		case 'content':
			return ['https://www.youtube.com/watch?v=' + identity.id + (_.result(comment, 'id') ? '&lc=' + comment.id : ''),
			        'https://youtu.be/' + identity.id + (_.result(comment, 'id') ? '?lc=' + comment.id : '')];
		case 'account':
			switch (identity.as) {
				case 'custom_url':
					return ['https://www.youtube.com/' + identity.id];
				case 'legacy_username':
					return ['https://www.youtube.com/user/' + identity.id];
				default:
					return ['https://www.youtube.com/channel/' + identity.id];
			}
	}
};

module.exports = urls;

},{"underscore":"/Users/cameron/.nvm/versions/node/v4.1.1/lib/node_modules/underscore/underscore.js","url":"/Users/cameron/Desktop/HoverCards/deckard/node_modules/browserify/node_modules/url/url.js"}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/twitter/urls.js":[function(require,module,exports){
var _ = require('underscore');

var urls = {};

urls.hostnames_parsed = ['twitter.com', 'www.twitter.com', 'm.twitter.com', 'mobile.twitter.com'];

// FROM: https://dev.twitter.com/rest/reference/get/help/configuration
urls.non_username_regex = /^(?:about|accounts?|activity|all|announcements|anywhere|api(?:_?rules|_terms)|apps|auth|badges|blog|business|buttons|contacts|devices|direct_messages|downloads?|edit_announcements|faq|favorites|find_(?:sources|users)|follow(?:ers|ing)|friend(?:s|_?request)|goodies|hashtag|help|home|i|im_account|inbox|invitations|invite|jobs|list|log(?:in|o|out)|me|media_signup|mentions|messages|mockview|newtwitter|notifications|nudge|oauth|phoenix_search|positions|privacy|public_timeline|related_tweets|replies|retweet(?:ed_of_mine|s|s_by_others)|rules|saved_searches|search|sent|sessions|settings|share|sign(?:in|up)|similar_to|statistics|terms|tos|translate|trends|tweetbutton|twttr|update_discoverability|users|welcome|who_to_follow|widgets|zendesk_auth)$/;

urls.parse = function(url_obj) {
	var path_parts = url_obj.pathname.replace(/^\//, '').replace(/\/$/, '').split('/') || [];
	if (path_parts[0] === 'intent') {
		switch (path_parts[1]) {
			case 'tweet':
				return !_.isEmpty(url_obj.query.in_reply_to) && { api: 'twitter', type: 'content', id: url_obj.query.in_reply_to };
			case 'favorite':
			case 'retweet':
				return !_.isEmpty(url_obj.query.tweet_id) && { api: 'twitter', type: 'content', id: url_obj.query.tweet_id };
			case 'follow':
			case 'user':
				return !_.isEmpty(url_obj.query.screen_name) && { api: 'twitter', type: 'account', id: url_obj.query.screen_name };
			default:
				return;
		}
	}
	if (path_parts.length === 1 && _.isEmpty(path_parts[0]) && (url_obj.hash || '').indexOf('#!') === 0) {
		path_parts = url_obj.hash.replace(/^#!\//, '').replace(/\/$/, '').split('/') || [];
	}
	if (_.isEmpty(path_parts[0]) || path_parts[0].match(urls.non_username_regex)) {
		return;
	}
	var account = { api: 'twitter', type: 'account', id: path_parts[0] };
	if (_.isEmpty(path_parts[1]) || !path_parts[1].match(/^status(?:es)?$/)) {
		return account;
	}
	return !_.isEmpty(path_parts[2]) && { api: 'twitter', type: 'content', id: path_parts[2], account: account };
};

urls.represent = function(identity) {
	switch (identity.type) {
		case 'content':
			return ['https://twitter.com/' + (_.result(identity.account, 'id') || 'screen_name') + '/status/' + identity.id];
		case 'account':
			return ['https://twitter.com/' + identity.id];
	}
};

module.exports = urls;

},{"underscore":"/Users/cameron/.nvm/versions/node/v4.1.1/lib/node_modules/underscore/underscore.js"}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/soundcloud/urls.js":[function(require,module,exports){
var _ = require('underscore');

var urls = {};

urls.hostnames_parsed = ['soundcloud.com', 'www.soundcloud.com', 'm.soundcloud.com'];

urls.non_username_regex  = /^(?:explore|groups|jobs|messages|mobile|notifications|pages|people|pro|settings|stream|tags|terms-of-use|upload(?:-classic)?|you)$/;
urls.non_trackname_regex = /^(?:comments|groups|follow(?:ers|ing)|likes|tracks)$/;

urls.parse = function(url_obj) {
	var path_parts = url_obj.pathname.replace(/^\//, '').replace(/\/$/, '').split('/') || [];
	if (_.isEmpty(path_parts[0]) || path_parts[0].match(urls.non_username_regex)) {
		return;
	}
	var account = { api: 'soundcloud', type: 'account', id: path_parts[0] };
	if (_.isEmpty(path_parts[1]) || path_parts[1].match(urls.non_trackname_regex)) {
		return account;
	}
	var content = { api: 'soundcloud', type: 'content', id: path_parts[1], account: account };
	if (path_parts[1] === 'sets') {
		if (_.isEmpty(path_parts[2])) {
			return account;
		}
		_.extend(content, { id: path_parts[2], as: 'playlist' });
	}
	return content;
};

urls.represent = function(identity, comment) {
	switch (identity.type) {
		case 'content':
			return ['https://soundcloud.com/' + (_.result(identity.account, 'id') || 'screen_name') + (identity.as === 'playlist' ? '/sets' : '') + '/' + identity.id + (_.result(comment, 'id') ? '/comments/' + comment.id : '')];
		case 'account':
			return ['https://soundcloud.com/' + identity.id];
	}
};

module.exports = urls;

},{"underscore":"/Users/cameron/.nvm/versions/node/v4.1.1/lib/node_modules/underscore/underscore.js"}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/reddit/urls.js":[function(require,module,exports){
var _ = require('underscore');

var urls = {};

urls.hostnames_parsed = ['reddit.com', 'www.reddit.com', 'np.reddit.com', 'm.reddit.com', 'redd.it', 'redditmedia.com', 'www.redditmedia.com'];

urls.parse = function(url_obj) {
	var pathname = (url_obj.pathname || '').replace(/\/$/, '');
	var match;
	if ((match = pathname.match(/^\/(?:u(?:ser)?)\/([^/]+)(?:\/[^/]+)?$/)) && match[1]) {
		return { api: 'reddit', type: 'account', id: match[1] };
	}
	if ((match = pathname.match(/^(?:\/r\/([^/]+))?(?:\/comments)?\/([^/]+)(?:\/.+)?$/)) && match[2]) {
		if (match[1]) {
			return { api: 'reddit', type: 'content', id: match[2], subreddit: match[1] };
		}
		if (match[2] === 'r') {
			return;
		}
		return { api: 'reddit', type: 'content', id: match[2] };
	}
};

urls.represent = function(identity, comment) {
	switch (identity.type) {
		case 'content':
			return ['https://www.reddit.com' + (identity.subreddit ? '/r/' + identity.subreddit : '') +
			                                   '/comments/' + identity.id +
			                                   (_.result(comment, 'id') ? '/comment/' + comment.id : ''), 'https://redd.it/' + identity.id];
		case 'account':
			return ['https://www.reddit.com/user/' + identity.id];
	}
};

module.exports = urls;

},{"underscore":"/Users/cameron/.nvm/versions/node/v4.1.1/lib/node_modules/underscore/underscore.js"}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/instagram/urls.js":[function(require,module,exports){
var _ = require('underscore');

var urls = {};

urls.hostnames_parsed = ['instagram.com', 'www.instagram.com', 'instagr.am'];

urls.parse = function(url_obj) {
	var path_parts = url_obj.pathname.replace(/^\//, '').replace(/\/$/, '').split('/') || [];
	if (path_parts[0] === 'p') {
		return !_.isEmpty(path_parts[1]) && { api: 'instagram', type: 'content', id: path_parts[1].replace(/[?&].*/, '').substr(0, 10) };
	}
	return !_.isEmpty(path_parts[0]) &&
	       !path_parts[0].match(/^(?:about|developer|explore|legal|press)$/) &&
	       { api: 'instagram', type: 'account', id: path_parts[0].replace(/[?&].*/, '') };
};

urls.represent = function(identity) {
	switch (identity.type) {
		case 'content':
			return ['https://instagram.com/p/' + identity.id + '/', 'https://instagr.am/p/' + identity.id + '/'];
		case 'account':
			return ['https://instagram.com/' + identity.id + '/', 'https://instagr.am/' + identity.id + '/'];
	}
};

module.exports = urls;

},{"underscore":"/Users/cameron/.nvm/versions/node/v4.1.1/lib/node_modules/underscore/underscore.js"}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/imgur/urls.js":[function(require,module,exports){
var _ = require('underscore');

var urls = {};

urls.hostnames_parsed = ['imgur.com', 'www.imgur.com', 'i.imgur.com', 'm.imgur.com'];

urls.parse = function(url_obj) {
	var path_parts = url_obj.pathname.replace(/^\//, '').replace(/\/$/, '').split('/') || [];
	switch (path_parts[0]) {
		case 'a':
			return !_.isEmpty(path_parts[1]) && { api: 'imgur', type: 'content', id: path_parts[1], as: 'album' };
		case 'gallery':
			return !_.isEmpty(path_parts[1]) && { api: 'imgur', type: 'content', id: path_parts[1], as: 'gallery' };
		case 'user':
			return !_.isEmpty(path_parts[1]) && { api: 'imgur', type: 'account', id: path_parts[1] };
		default:
			return !_.isEmpty(path_parts[0]) && { api: 'imgur', type: 'content', id: path_parts[0].replace(/\..+?$/, ''), as: 'image' };
	}
};

urls.represent = function(identity, comment) {
	switch (identity.type) {
		case 'content':
			return _.compact([
				_.result(comment, 'id') && ('https://imgur.com/gallery/' + _.result(identity, 'id') + '/comment/' + comment.id),
				(identity.as === 'image') && ('https://imgur.com/' + identity.id),
				(identity.as === 'image') && ('https://i.imgur.com/' + identity.id),
				(identity.as === 'album') && ('https://imgur.com/a/' + identity.id),
				'https://imgur.com/gallery/' + identity.id
			]);
		case 'account':
			return ['https://imgur.com/user/' + identity.id];
	}
};

module.exports = urls;

},{"underscore":"/Users/cameron/.nvm/versions/node/v4.1.1/lib/node_modules/underscore/underscore.js"}],"/Users/cameron/Desktop/HoverCards/deckard/node_modules/browserify/node_modules/url/url.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":"/Users/cameron/Desktop/HoverCards/deckard/node_modules/browserify/node_modules/punycode/punycode.js","querystring":"/Users/cameron/Desktop/HoverCards/deckard/node_modules/browserify/node_modules/querystring-es3/index.js"}],"/Users/cameron/Desktop/HoverCards/deckard/node_modules/browserify/node_modules/querystring-es3/index.js":[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":"/Users/cameron/Desktop/HoverCards/deckard/node_modules/browserify/node_modules/querystring-es3/decode.js","./encode":"/Users/cameron/Desktop/HoverCards/deckard/node_modules/browserify/node_modules/querystring-es3/encode.js"}],"/Users/cameron/Desktop/HoverCards/deckard/node_modules/browserify/node_modules/querystring-es3/encode.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],"/Users/cameron/Desktop/HoverCards/deckard/node_modules/browserify/node_modules/querystring-es3/decode.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],"/Users/cameron/Desktop/HoverCards/deckard/node_modules/browserify/node_modules/punycode/punycode.js":[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/cameron/Desktop/HoverCards/deckard/node_modules/jquery/dist/jquery.js":[function(require,module,exports){
/*!
 * jQuery JavaScript Library v2.1.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-04-28T16:01Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.4",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {

	// Support: iOS 8.2 (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];
	nodeType = context.nodeType;

	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	if ( !seed && documentIsHTML ) {

		// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
		if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType !== 1 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;
	parent = doc.defaultView;

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Support tests
	---------------------------------------------------------------------- */
	documentIsHTML = !isXML( doc );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\f]' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// We once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android<4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android<4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Support: Firefox, Chrome, Safari
// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, type, key,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optimization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		if ( elem.ownerDocument.defaultView.opener ) {
			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
		}

		return window.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
		"position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";
		div.innerHTML = "";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Support: node.js jsdom
	// Don't assume that getComputedStyle is a property of the global object
	if ( window.getComputedStyle ) {
		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*.
					// Use string for doubling so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur(),
				// break the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// Ensure the complete handler is called before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// Toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// Handle most common string cases
					ret.replace(rreturn, "") :
					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Document location
	ajaxLocation = window.location.href,

	// Segment location into parts
	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
if ( window.attachEvent ) {
	window.attachEvent( "onunload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				try {
					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {
					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// Support: BlackBerry 5, iOS 3 (original iPhone)
		// If we don't have gBCR, just use 0,0 rather than error
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Support: Safari<7+, Chrome<37+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

},{}],"/Users/cameron/Desktop/HoverCards/deckard/app/common/mixins.js":[function(require,module,exports){
var _ = require('underscore');

var EXTENSION_ID = chrome.i18n.getMessage('@@extension_id');

_.mixin({
	analytics_label: function(identity) {
		return _.chain([identity.api, identity.type])
		        .compact()
		        .union(identity.as && ['as', identity.as])
		        .union(identity['for'] && ['for', _.analytics_label(identity['for'])])
		        .value()
		        .join(' ');
	},
	prefix: function(className) {
		return EXTENSION_ID + '-' + className;
	},
	scrollbar_width: function() {
		var width;
		var scrollDiv = document.createElement('div');
		scrollDiv.style.width = '100px';
		scrollDiv.style.height = '100px';
		scrollDiv.style.overflow = 'scroll';
		scrollDiv.style.position = 'absolute';
		scrollDiv.style.top = '-9999px';
		document.body.appendChild(scrollDiv);
		width = scrollDiv.offsetWidth - scrollDiv.clientWidth;
		document.body.removeChild(scrollDiv);
		return width;
	}
});

},{"underscore":"/Users/cameron/.nvm/versions/node/v4.1.1/lib/node_modules/underscore/underscore.js"}],"/Users/cameron/Desktop/HoverCards/deckard/app/authentication/index.js":[function(require,module,exports){
var _ = require('underscore');

module.exports = function(api, callback) {
	if (_.isEmpty(api)) {
		return setImmediate(function() {
			callback({ message: 'Missing \'api\'', status: 400 });
		});
	}
	chrome.runtime.sendMessage({ type: 'auth', api: api }, function(combined_response) {
		if (chrome.runtime.lastError || _.isEmpty(combined_response)) {
			return callback(_.extend(chrome.runtime.lastError, { status: 500 }));
		}
		callback(combined_response[0], combined_response[1]);
	});
};

},{"underscore":"/Users/cameron/.nvm/versions/node/v4.1.1/lib/node_modules/underscore/underscore.js"}],"/Users/cameron/Desktop/HoverCards/deckard/app/analytics/index.js":[function(require,module,exports){
var _ = require('underscore');

module.exports = function() {
	var args = _.toArray(arguments);
	chrome.runtime.sendMessage({ type: 'analytics', request: args }, ("development" !== 'production') && function() {
		if (_.chain(args).first(2).isEqual(['send', 'exception']).value()) {
			console.error('google analytics', args);
		} else {
			console.debug('google analytics', args);
		}
	});
};

},{"underscore":"/Users/cameron/.nvm/versions/node/v4.1.1/lib/node_modules/underscore/underscore.js"}],"/Users/cameron/Desktop/HoverCards/deckard/app/config.js":[function(require,module,exports){
var _             = require('underscore');
var shared_config = require('hovercardsshared/config');

var config = {
	endpoint: "development" === 'production' ? 'http://hover.cards/v2' : 'http://localhost:5000/v2',
	analytics_id: 'UA-64246820-3',
	apis: {
		imgur: {},
		instagram: {
			client_on_auth: true,
			client_auth_url: 'https://instagram.com/oauth/authorize/?client_id=41e56061c1e34fbbb16ab1d095dad78b&redirect_uri=https://EXTENSION_ID.chromiumapp.org/callback&response_type=token'
		},
		reddit: {
			key: '0jXqEudQPqSL6w'
		},
		soundcloud: {
			key: '78a827254bd7a5e3bba61aa18922bf2e'
		},
		twitter: {},
		youtube: {}
	}
};

var apis = _.intersection(_.keys(config.apis), _.keys(shared_config.apis));

config.apis = _.chain(config.apis)
               .pick(apis)
               .each(function(api_config, api) { _.defaults(api_config, shared_config.apis[api]); })
               .value();

module.exports = config;

},{"hovercardsshared/config":"/Users/cameron/Desktop/HoverCards/hovercardsshared/config.js","underscore":"/Users/cameron/.nvm/versions/node/v4.1.1/lib/node_modules/underscore/underscore.js"}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/config.js":[function(require,module,exports){
module.exports = {
	counts: {
		grid:   21,
		listed: 20
	},
	apis: {
		imgur:      require('./imgur/config'),
		instagram:  require('./instagram/config'),
		reddit:     require('./reddit/config'),
		soundcloud: require('./soundcloud/config'),
		twitter:    require('./twitter/config'),
		youtube:    require('./youtube/config')
	}
};

},{"./imgur/config":"/Users/cameron/Desktop/HoverCards/hovercardsshared/imgur/config.json","./instagram/config":"/Users/cameron/Desktop/HoverCards/hovercardsshared/instagram/config.json","./reddit/config":"/Users/cameron/Desktop/HoverCards/hovercardsshared/reddit/config.json","./soundcloud/config":"/Users/cameron/Desktop/HoverCards/hovercardsshared/soundcloud/config.json","./twitter/config":"/Users/cameron/Desktop/HoverCards/hovercardsshared/twitter/config.json","./youtube/config":"/Users/cameron/Desktop/HoverCards/hovercardsshared/youtube/config.json"}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/youtube/config.json":[function(require,module,exports){
module.exports={
	"discussion_apis": ["youtube", "reddit", "twitter"],
	"content-security-policy": {
		"img-src": ["https://yt3.ggpht.com", "https://*.googleusercontent.com"],
		"script-src": ["https://s.ytimg.com"]
	}
}

},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/twitter/config.json":[function(require,module,exports){
module.exports={
	"can_auth": true,
	"discussion_apis": ["twitter", "reddit"]
}

},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/soundcloud/config.json":[function(require,module,exports){
module.exports={
	"discussion_apis": ["soundcloud", "reddit", "twitter"],
	"content-security-policy": {
		"img-src": ["https://i1.sndcdn.com"],
		"frame-src": ["https://w.soundcloud.com"]
	}
}

},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/reddit/config.json":[function(require,module,exports){
module.exports={
	"discussion_apis": ["reddit", "twitter"]
}

},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/instagram/config.json":[function(require,module,exports){
module.exports={
	"can_auth": true,
	"discussion_apis": ["instagram", "reddit", "twitter"],
	"content-security-policy": {
		"img-src": ["https://scontent.cdninstagram.com"],
		"media-src": ["https://scontent.cdninstagram.com"]
	}
}

},{}],"/Users/cameron/Desktop/HoverCards/hovercardsshared/imgur/config.json":[function(require,module,exports){
module.exports={
	"discussion_apis": ["imgur", "reddit", "twitter"],
	"content-security-policy": {
		"img-src": ["http://i.imgur.com"],
		"media-src": ["http://i.imgur.com"]
	}
}

},{}],"/Users/cameron/.nvm/versions/node/v4.1.1/lib/node_modules/underscore/underscore.js":[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}]},{},[])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhcHAvbGlnaHRib3gvYm90aC5qcyIsImFwcC90ZW1wbGF0ZV9sb2FkaW5nL2luZGV4LmpzIiwiLi4vaG92ZXJjYXJkc3NoYXJlZC95b3V0dWJlL3ZpZGVvLnJhY3QiLCIuLi9ob3ZlcmNhcmRzc2hhcmVkL3lvdXR1YmUvZGlzY3Vzc2lvbi1oZWFkZXIuaHRtbCIsIi4uL2hvdmVyY2FyZHNzaGFyZWQveW91dHViZS9jb250ZW50Lmh0bWwiLCIuLi9ob3ZlcmNhcmRzc2hhcmVkL3lvdXR1YmUvYWNjb3VudC5odG1sIiwiLi4vaG92ZXJjYXJkc3NoYXJlZC95b3V0dWJlL2FjY291bnQtY29udGVudC5odG1sIiwiLi4vaG92ZXJjYXJkc3NoYXJlZC90d2l0dGVyL3R3ZWV0LnJhY3QiLCIuLi9ob3ZlcmNhcmRzc2hhcmVkL3R3aXR0ZXIvZGlzY3Vzc2lvbi5odG1sIiwiLi4vaG92ZXJjYXJkc3NoYXJlZC90d2l0dGVyL2Rpc2N1c3Npb24taGVhZGVyLmh0bWwiLCIuLi9ob3ZlcmNhcmRzc2hhcmVkL3R3aXR0ZXIvYWNjb3VudC5odG1sIiwiLi4vaG92ZXJjYXJkc3NoYXJlZC90d2l0dGVyL2FjY291bnQtY29udGVudC5odG1sIiwiLi4vaG92ZXJjYXJkc3NoYXJlZC9zb3VuZGNsb3VkL3NvbmcucmFjdCIsIi4uL2hvdmVyY2FyZHNzaGFyZWQvc291bmRjbG91ZC9kaXNjdXNzaW9uLWhlYWRlci5odG1sIiwiLi4vaG92ZXJjYXJkc3NoYXJlZC9zb3VuZGNsb3VkL2NvbnRlbnQuaHRtbCIsIi4uL2hvdmVyY2FyZHNzaGFyZWQvc291bmRjbG91ZC9hY2NvdW50Lmh0bWwiLCIuLi9ob3ZlcmNhcmRzc2hhcmVkL3NvdW5kY2xvdWQvYWNjb3VudC1jb250ZW50Lmh0bWwiLCIuLi9ob3ZlcmNhcmRzc2hhcmVkL3JlZGRpdC9kaXNjdXNzaW9uLWhlYWRlci5odG1sIiwiLi4vaG92ZXJjYXJkc3NoYXJlZC9yZWRkaXQvY29udGVudC5odG1sIiwiLi4vaG92ZXJjYXJkc3NoYXJlZC9yZWRkaXQvYWNjb3VudC5odG1sIiwiLi4vaG92ZXJjYXJkc3NoYXJlZC9yZWRkaXQvYWNjb3VudC1jb250ZW50Lmh0bWwiLCIuLi9ob3ZlcmNhcmRzc2hhcmVkL2luc3RhZ3JhbS9kaXNjdXNzaW9uLmh0bWwiLCIuLi9ob3ZlcmNhcmRzc2hhcmVkL2luc3RhZ3JhbS9kaXNjdXNzaW9uLWhlYWRlci5odG1sIiwiLi4vaG92ZXJjYXJkc3NoYXJlZC9pbnN0YWdyYW0vY29udGVudC5odG1sIiwiLi4vaG92ZXJjYXJkc3NoYXJlZC9pbnN0YWdyYW0vYWNjb3VudC5odG1sIiwiLi4vaG92ZXJjYXJkc3NoYXJlZC9pbnN0YWdyYW0vYWNjb3VudC1jb250ZW50Lmh0bWwiLCIuLi9ob3ZlcmNhcmRzc2hhcmVkL2ltZ3VyL2Rpc2N1c3Npb24uaHRtbCIsIi4uL2hvdmVyY2FyZHNzaGFyZWQvaW1ndXIvZGlzY3Vzc2lvbi1oZWFkZXIuaHRtbCIsIi4uL2hvdmVyY2FyZHNzaGFyZWQvaW1ndXIvY29udGVudC5odG1sIiwiLi4vaG92ZXJjYXJkc3NoYXJlZC9pbWd1ci9hY2NvdW50Lmh0bWwiLCIuLi9ob3ZlcmNhcmRzc2hhcmVkL2ltZ3VyL2FjY291bnQtY29udGVudC5odG1sIiwiLi4vaG92ZXJjYXJkc3NoYXJlZC9kaXNjdXNzaW9uL2hlYWRlci5yYWN0IiwiLi4vaG92ZXJjYXJkc3NoYXJlZC9kaXNjdXNzaW9uL2NvbW1lbnQucmFjdCIsIi4uL2hvdmVyY2FyZHNzaGFyZWQvZGlzY3Vzc2lvbi9jYXRjaC1lcnJvcnMucmFjdCIsIi4uL2hvdmVyY2FyZHNzaGFyZWQvY29udGVudC90ZXh0LnJhY3QiLCIuLi9ob3ZlcmNhcmRzc2hhcmVkL2NvbnRlbnQvbWVkaWEucmFjdCIsIi4uL2hvdmVyY2FyZHNzaGFyZWQvY29udGVudC9sYXlvdXQuaHRtbCIsIi4uL2hvdmVyY2FyZHNzaGFyZWQvY29udGVudC9oZWFkZXIucmFjdCIsIi4uL2hvdmVyY2FyZHNzaGFyZWQvY29tbW9uL251bWJlci1kZWNvcmF0b3IuanMiLCIuLi9ob3ZlcmNhcmRzc2hhcmVkL2NvbW1vbi9kYXRlLWRlY29yYXRvci5qcyIsIi4uL2hvdmVyY2FyZHNzaGFyZWQvY29tbW9uL2NhdGNoLWVycm9ycy5yYWN0IiwiLi4vaG92ZXJjYXJkc3NoYXJlZC9hY2NvdW50L2xheW91dC5odG1sIiwiLi4vaG92ZXJjYXJkc3NoYXJlZC9hY2NvdW50L2FjY291bnQucmFjdCIsIi4uL2hvdmVyY2FyZHNzaGFyZWQvYWNjb3VudC1jb250ZW50L2NhdGNoLWVycm9ycy5yYWN0Iiwibm9kZV9tb2R1bGVzL3JhY3RpdmUvcmFjdGl2ZS5qcyIsImFwcC9zZXJ2aWNlL2luZGV4LmpzIiwiLi4vaG92ZXJjYXJkc3NoYXJlZC91cmxzL2luZGV4LmpzIiwiLi4vaG92ZXJjYXJkc3NoYXJlZC95b3V0dWJlL3VybHMuanMiLCIuLi9ob3ZlcmNhcmRzc2hhcmVkL3R3aXR0ZXIvdXJscy5qcyIsIi4uL2hvdmVyY2FyZHNzaGFyZWQvc291bmRjbG91ZC91cmxzLmpzIiwiLi4vaG92ZXJjYXJkc3NoYXJlZC9yZWRkaXQvdXJscy5qcyIsIi4uL2hvdmVyY2FyZHNzaGFyZWQvaW5zdGFncmFtL3VybHMuanMiLCIuLi9ob3ZlcmNhcmRzc2hhcmVkL2ltZ3VyL3VybHMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwibm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsImFwcC9jb21tb24vbWl4aW5zLmpzIiwiYXBwL2F1dGhlbnRpY2F0aW9uL2luZGV4LmpzIiwiYXBwL2FuYWx5dGljcy9pbmRleC5qcyIsImFwcC9jb25maWcuanMiLCIuLi9ob3ZlcmNhcmRzc2hhcmVkL2NvbmZpZy5qcyIsIi4uL2hvdmVyY2FyZHNzaGFyZWQveW91dHViZS9jb25maWcuanNvbiIsIi4uL2hvdmVyY2FyZHNzaGFyZWQvdHdpdHRlci9jb25maWcuanNvbiIsIi4uL2hvdmVyY2FyZHNzaGFyZWQvc291bmRjbG91ZC9jb25maWcuanNvbiIsIi4uL2hvdmVyY2FyZHNzaGFyZWQvcmVkZGl0L2NvbmZpZy5qc29uIiwiLi4vaG92ZXJjYXJkc3NoYXJlZC9pbnN0YWdyYW0vY29uZmlnLmpzb24iLCIuLi9ob3ZlcmNhcmRzc2hhcmVkL2ltZ3VyL2NvbmZpZy5qc29uIiwiLi4vLi4vLi4vLm52bS92ZXJzaW9ucy9ub2RlL3Y0LjEuMS9saWIvbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqRUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTs7QUNBQTs7OztBQ0FBOztBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ0xBOztBQ0FBOztBQ0FBOztBQ0FBOzs7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlKQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzdWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25zQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMS9SQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsInZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxucmVxdWlyZSgnLi4vY29tbW9uL21peGlucycpO1xuXG52YXIgRVhURU5TSU9OX0lEID0gY2hyb21lLmkxOG4uZ2V0TWVzc2FnZSgnQEBleHRlbnNpb25faWQnKTtcblxudmFyIE5hbWVTcGFjZSA9ICcuJyArIEVYVEVOU0lPTl9JRDtcblxudmFyIENsaWNrID0gJ2NsaWNrJyArIE5hbWVTcGFjZTtcblxuJCgnaHRtbCcpLm9uKENsaWNrLCAnLicgKyBfLnByZWZpeCgnaG92ZXJjYXJkX19ib3gnKSwgZnVuY3Rpb24oKSB7XG5cdHZhciBob3ZlcmNhcmQgPSAkKHRoaXMpLnBhcmVudHMoJy4nICsgXy5wcmVmaXgoJ2hvdmVyY2FyZCcpKTtcblx0JC5saWdodGJveChob3ZlcmNhcmQuZGF0YShFWFRFTlNJT05fSUQgKyAnLWlkZW50aXR5JyksIGhvdmVyY2FyZCk7XG59KTtcbiIsInZhciBfICAgICAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBSYWN0aXZlICAgICAgICA9IHJlcXVpcmUoJ3JhY3RpdmUnKTtcbnZhciBhdXRoZW50aWNhdGlvbiA9IHJlcXVpcmUoJy4uL2F1dGhlbnRpY2F0aW9uJyk7XG52YXIgY29uZmlnICAgICAgICAgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcbnZhciBzZXJ2aWNlICAgICAgICA9IHJlcXVpcmUoJy4uL3NlcnZpY2UnKTtcbnZhciB1cmxzICAgICAgICAgICA9IHJlcXVpcmUoJ2hvdmVyY2FyZHNzaGFyZWQvdXJscycpO1xucmVxdWlyZSgnLi4vY29tbW9uL21peGlucycpO1xuXG5SYWN0aXZlLkRFQlVHID0gXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbic7XG5cblJhY3RpdmUucHJvdG90eXBlLm9ic2VydmVVbnRpbCA9IGZ1bmN0aW9uKGtleXBhdGgsIGhhbmRsZXIsIG9wdGlvbnMpIHtcblx0aWYgKHRoaXMuZ2V0KGtleXBhdGgpKSB7XG5cdFx0aGFuZGxlcih0aGlzLmdldChrZXlwYXRoKSk7XG5cdFx0cmV0dXJuIHsgY2FuY2VsOiBfLm5vb3AgfTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gdGhpcy5vYnNlcnZlT25jZShrZXlwYXRoLCBoYW5kbGVyLCBvcHRpb25zKTtcblx0fVxufTtcblxuUmFjdGl2ZS5wcm90b3R5cGUuc2VydmljZSA9IGZ1bmN0aW9uKGtleXBhdGgsIGlkZW50aXR5LCBoYW5kbGVyKSB7XG5cdHZhciByYWN0aXZlID0gdGhpcztcblx0dmFyIHZhbCAgICAgPSByYWN0aXZlLmdldChrZXlwYXRoKTtcblx0aWYgKHZhbCAmJiAodmFsLmxvYWRpbmcgfHwgdmFsLmxvYWRlZCkpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0cmFjdGl2ZS5zZXQoa2V5cGF0aCArICcubG9hZGluZycsIHRydWUpO1xuXHRyYWN0aXZlLnNldChrZXlwYXRoICsgJy5sb2FkZWQnLCAgZmFsc2UpO1xuXHRzZXJ2aWNlKGlkZW50aXR5IHx8IHZhbCwgZnVuY3Rpb24gdHJ5X3NlcnZpY2UoZXJyLCBkYXRhKSB7XG5cdFx0aWYgKGVycikge1xuXHRcdFx0cmFjdGl2ZS5zZXQoa2V5cGF0aCArICcuZXJyJywgICAgIGVycik7XG5cdFx0XHRyYWN0aXZlLnNldChrZXlwYXRoICsgJy5sb2FkZWQnLCAgdHJ1ZSk7XG5cdFx0XHRyYWN0aXZlLnNldChrZXlwYXRoICsgJy5sb2FkaW5nJywgZmFsc2UpO1xuXHRcdFx0aWYgKGVyci5zdGF0dXMgPT09IDQwMSkge1xuXHRcdFx0XHRyYWN0aXZlLnNldChrZXlwYXRoICsgJy5lcnIuYXV0aGVudGljYXRlJywgZnVuY3Rpb24gYXV0aGVudGljYXRlKCkge1xuXHRcdFx0XHRcdHJhY3RpdmUuc2V0KGtleXBhdGggKyAnLmVyci5hdXRoZW50aWNhdGUnLCBfLm5vb3ApO1xuXHRcdFx0XHRcdGF1dGhlbnRpY2F0aW9uKChpZGVudGl0eSB8fCB2YWwpLmFwaSwgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdHJhY3RpdmUuc2V0KGtleXBhdGggKyAnLmVycicsIGVycik7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByYWN0aXZlLnNldChrZXlwYXRoICsgJy5lcnIuYXV0aGVudGljYXRlJywgYXV0aGVudGljYXRlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJhY3RpdmUuc2V0KGtleXBhdGggKyAnLmxvYWRpbmcnLCB0cnVlKTtcblx0XHRcdFx0XHRcdHJhY3RpdmUuc2V0KGtleXBhdGggKyAnLmxvYWRlZCcsICBmYWxzZSk7XG5cdFx0XHRcdFx0XHRyYWN0aXZlLnNldChrZXlwYXRoICsgJy5lcnInLCAgICAgbnVsbCk7XG5cdFx0XHRcdFx0XHRzZXJ2aWNlKGlkZW50aXR5IHx8IHZhbCwgdHJ5X3NlcnZpY2UpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAoaGFuZGxlciB8fCBfLm5vb3ApKHJhY3RpdmUuZ2V0KGtleXBhdGggKyAnLmVycicpKTtcblx0XHR9XG5cdFx0cmFjdGl2ZS5zZXQoa2V5cGF0aCwgXy5leHRlbmQoZGF0YSwgeyBsb2FkZWQ6IHRydWUsIGxvYWRpbmc6IGZhbHNlIH0pKTtcblx0XHQoaGFuZGxlciB8fCBfLm5vb3ApKG51bGwsIHJhY3RpdmUuZ2V0KGtleXBhdGgpKTtcblx0fSk7XG59O1xuXG4vLyBUT0RPIFB1dCB0aGlzIGluIHNoYXJlZCBwa2dcbnZhciBnbG9iYWxfZGF0YSA9IHtcblx0XzogXyxcblx0Y29weTogZnVuY3Rpb24obmFtZSwgYXBpKSB7XG5cdFx0dmFyIHJlc3QgPSBfLnJlc3QoYXJndW1lbnRzLCAyKTtcblx0XHRuYW1lID0gKG5hbWUgfHwgJycpLnJlcGxhY2UoL1xcLS9nLCAnXycpO1xuXHRcdHJldHVybiAoIV8uaXNFbXB0eShhcGkpICYmIGNocm9tZS5pMThuLmdldE1lc3NhZ2UoYXBpICsgJ18nICsgbmFtZSwgcmVzdCkpIHx8IGNocm9tZS5pMThuLmdldE1lc3NhZ2UobmFtZSwgcmVzdCk7XG5cdH0sXG5cdGhhc19tZWRpYTogZnVuY3Rpb24oY29udGVudCkge1xuXHRcdHJldHVybiBjb250ZW50ICYmIChjb250ZW50LnZpZGVvIHx8IGNvbnRlbnQuZ2lmIHx8IGNvbnRlbnQuaW1hZ2VzIHx8IGNvbnRlbnQuaW1hZ2UpO1xuXHR9LFxuXHRwcmVmaXg6IF8ucHJlZml4LFxuXHR0aW1lc3RhbXA6IGZ1bmN0aW9uKHRpbWVfaW5fbWlsbGkpIHtcblx0XHR2YXIgdGltZV9pbl9zZWMgPSBNYXRoLmZsb29yKHRpbWVfaW5fbWlsbGkgLyAxMDAwKSAlIDYwICsgJyc7XG5cdFx0dmFyIHRpbWVfaW5fbWluID0gTWF0aC5mbG9vcih0aW1lX2luX21pbGxpIC8gKDYwICogMTAwMCkpICUgNjAgKyAnJztcblx0XHR3aGlsZSAodGltZV9pbl9zZWMubGVuZ3RoIDwgMikge1xuXHRcdFx0dGltZV9pbl9zZWMgPSAnMCcgKyB0aW1lX2luX3NlYztcblx0XHR9XG5cdFx0cmV0dXJuIHRpbWVfaW5fbWluICsgJzonICsgdGltZV9pbl9zZWM7XG5cdH0sXG5cdHVybDogdXJscy5wcmludFxufTtcblxudmFyIEhvdmVyQ2FyZFJhY3RpdmUgPSBSYWN0aXZlLmV4dGVuZCh7XG5cdGRhdGE6ICAgICAgIGdsb2JhbF9kYXRhLFxuXHRwYXJ0aWFsczogICBfLmNoYWluKHsnaW1ndXIvYWNjb3VudC1jb250ZW50JzogcmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2hvdmVyY2FyZHNzaGFyZWQvaW1ndXIvYWNjb3VudC1jb250ZW50Lmh0bWwnKSwnaW1ndXIvYWNjb3VudCc6IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9ob3ZlcmNhcmRzc2hhcmVkL2ltZ3VyL2FjY291bnQuaHRtbCcpLCdpbWd1ci9jb250ZW50JzogcmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2hvdmVyY2FyZHNzaGFyZWQvaW1ndXIvY29udGVudC5odG1sJyksJ2ltZ3VyL2Rpc2N1c3Npb24taGVhZGVyJzogcmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2hvdmVyY2FyZHNzaGFyZWQvaW1ndXIvZGlzY3Vzc2lvbi1oZWFkZXIuaHRtbCcpLCdpbWd1ci9kaXNjdXNzaW9uJzogcmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2hvdmVyY2FyZHNzaGFyZWQvaW1ndXIvZGlzY3Vzc2lvbi5odG1sJyksJ2luc3RhZ3JhbS9hY2NvdW50LWNvbnRlbnQnOiByZXF1aXJlKCcuLi8uLi9ub2RlX21vZHVsZXMvaG92ZXJjYXJkc3NoYXJlZC9pbnN0YWdyYW0vYWNjb3VudC1jb250ZW50Lmh0bWwnKSwnaW5zdGFncmFtL2FjY291bnQnOiByZXF1aXJlKCcuLi8uLi9ub2RlX21vZHVsZXMvaG92ZXJjYXJkc3NoYXJlZC9pbnN0YWdyYW0vYWNjb3VudC5odG1sJyksJ2luc3RhZ3JhbS9jb250ZW50JzogcmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2hvdmVyY2FyZHNzaGFyZWQvaW5zdGFncmFtL2NvbnRlbnQuaHRtbCcpLCdpbnN0YWdyYW0vZGlzY3Vzc2lvbi1oZWFkZXInOiByZXF1aXJlKCcuLi8uLi9ub2RlX21vZHVsZXMvaG92ZXJjYXJkc3NoYXJlZC9pbnN0YWdyYW0vZGlzY3Vzc2lvbi1oZWFkZXIuaHRtbCcpLCdpbnN0YWdyYW0vZGlzY3Vzc2lvbic6IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9ob3ZlcmNhcmRzc2hhcmVkL2luc3RhZ3JhbS9kaXNjdXNzaW9uLmh0bWwnKSwncmVkZGl0L2FjY291bnQtY29udGVudCc6IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9ob3ZlcmNhcmRzc2hhcmVkL3JlZGRpdC9hY2NvdW50LWNvbnRlbnQuaHRtbCcpLCdyZWRkaXQvYWNjb3VudCc6IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9ob3ZlcmNhcmRzc2hhcmVkL3JlZGRpdC9hY2NvdW50Lmh0bWwnKSwncmVkZGl0L2NvbnRlbnQnOiByZXF1aXJlKCcuLi8uLi9ub2RlX21vZHVsZXMvaG92ZXJjYXJkc3NoYXJlZC9yZWRkaXQvY29udGVudC5odG1sJyksJ3JlZGRpdC9kaXNjdXNzaW9uLWhlYWRlcic6IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9ob3ZlcmNhcmRzc2hhcmVkL3JlZGRpdC9kaXNjdXNzaW9uLWhlYWRlci5odG1sJyksJ3JlZGRpdC9kaXNjdXNzaW9uJzogcmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2hvdmVyY2FyZHNzaGFyZWQvcmVkZGl0L2Rpc2N1c3Npb24uaHRtbCcpLCdzb3VuZGNsb3VkL2FjY291bnQtY29udGVudCc6IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9ob3ZlcmNhcmRzc2hhcmVkL3NvdW5kY2xvdWQvYWNjb3VudC1jb250ZW50Lmh0bWwnKSwnc291bmRjbG91ZC9hY2NvdW50JzogcmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2hvdmVyY2FyZHNzaGFyZWQvc291bmRjbG91ZC9hY2NvdW50Lmh0bWwnKSwnc291bmRjbG91ZC9jb250ZW50JzogcmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2hvdmVyY2FyZHNzaGFyZWQvc291bmRjbG91ZC9jb250ZW50Lmh0bWwnKSwnc291bmRjbG91ZC9kaXNjdXNzaW9uLWhlYWRlcic6IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9ob3ZlcmNhcmRzc2hhcmVkL3NvdW5kY2xvdWQvZGlzY3Vzc2lvbi1oZWFkZXIuaHRtbCcpLCdzb3VuZGNsb3VkL2Rpc2N1c3Npb24nOiByZXF1aXJlKCcuLi8uLi9ub2RlX21vZHVsZXMvaG92ZXJjYXJkc3NoYXJlZC9zb3VuZGNsb3VkL2Rpc2N1c3Npb24uaHRtbCcpLCd0d2l0dGVyL2FjY291bnQtY29udGVudCc6IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9ob3ZlcmNhcmRzc2hhcmVkL3R3aXR0ZXIvYWNjb3VudC1jb250ZW50Lmh0bWwnKSwndHdpdHRlci9hY2NvdW50JzogcmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2hvdmVyY2FyZHNzaGFyZWQvdHdpdHRlci9hY2NvdW50Lmh0bWwnKSwndHdpdHRlci9jb250ZW50JzogcmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2hvdmVyY2FyZHNzaGFyZWQvdHdpdHRlci9jb250ZW50Lmh0bWwnKSwndHdpdHRlci9kaXNjdXNzaW9uLWhlYWRlcic6IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9ob3ZlcmNhcmRzc2hhcmVkL3R3aXR0ZXIvZGlzY3Vzc2lvbi1oZWFkZXIuaHRtbCcpLCd0d2l0dGVyL2Rpc2N1c3Npb24nOiByZXF1aXJlKCcuLi8uLi9ub2RlX21vZHVsZXMvaG92ZXJjYXJkc3NoYXJlZC90d2l0dGVyL2Rpc2N1c3Npb24uaHRtbCcpLCd5b3V0dWJlL2FjY291bnQtY29udGVudCc6IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9ob3ZlcmNhcmRzc2hhcmVkL3lvdXR1YmUvYWNjb3VudC1jb250ZW50Lmh0bWwnKSwneW91dHViZS9hY2NvdW50JzogcmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2hvdmVyY2FyZHNzaGFyZWQveW91dHViZS9hY2NvdW50Lmh0bWwnKSwneW91dHViZS9jb250ZW50JzogcmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2hvdmVyY2FyZHNzaGFyZWQveW91dHViZS9jb250ZW50Lmh0bWwnKSwneW91dHViZS9kaXNjdXNzaW9uLWhlYWRlcic6IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9ob3ZlcmNhcmRzc2hhcmVkL3lvdXR1YmUvZGlzY3Vzc2lvbi1oZWFkZXIuaHRtbCcpLCd5b3V0dWJlL2Rpc2N1c3Npb24nOiByZXF1aXJlKCcuLi8uLi9ub2RlX21vZHVsZXMvaG92ZXJjYXJkc3NoYXJlZC95b3V0dWJlL2Rpc2N1c3Npb24uaHRtbCcpfSlcblx0ICAgICAgICAgICAgIC5leHRlbmQoeydhY2NvdW50L2xheW91dCc6IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9ob3ZlcmNhcmRzc2hhcmVkL2FjY291bnQvbGF5b3V0Lmh0bWwnKSwnY29udGVudC9sYXlvdXQnOiByZXF1aXJlKCcuLi8uLi9ub2RlX21vZHVsZXMvaG92ZXJjYXJkc3NoYXJlZC9jb250ZW50L2xheW91dC5odG1sJyl9KVxuXHQgICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbihtZW1vLCB0ZW1wbGF0ZSwga2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgbWVtb1trZXkucmVwbGFjZSgnLycsICctJyldID0gdGVtcGxhdGU7XG5cdCAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW87XG5cdCAgICAgICAgICAgICB9LCB7fSlcblx0ICAgICAgICAgICAgIC52YWx1ZSgpLFxuXHRjb21wb25lbnRzOiBfLmNoYWluKHsnYWNjb3VudC1jb250ZW50L2NhdGNoLWVycm9ycyc6IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9ob3ZlcmNhcmRzc2hhcmVkL2FjY291bnQtY29udGVudC9jYXRjaC1lcnJvcnMucmFjdCcpLCdhY2NvdW50L2FjY291bnQnOiByZXF1aXJlKCcuLi8uLi9ub2RlX21vZHVsZXMvaG92ZXJjYXJkc3NoYXJlZC9hY2NvdW50L2FjY291bnQucmFjdCcpLCdjb21tb24vY2F0Y2gtZXJyb3JzJzogcmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2hvdmVyY2FyZHNzaGFyZWQvY29tbW9uL2NhdGNoLWVycm9ycy5yYWN0JyksJ2NvbnRlbnQvaGVhZGVyJzogcmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2hvdmVyY2FyZHNzaGFyZWQvY29udGVudC9oZWFkZXIucmFjdCcpLCdjb250ZW50L21lZGlhJzogcmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2hvdmVyY2FyZHNzaGFyZWQvY29udGVudC9tZWRpYS5yYWN0JyksJ2NvbnRlbnQvdGV4dCc6IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9ob3ZlcmNhcmRzc2hhcmVkL2NvbnRlbnQvdGV4dC5yYWN0JyksJ2Rpc2N1c3Npb24vY2F0Y2gtZXJyb3JzJzogcmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2hvdmVyY2FyZHNzaGFyZWQvZGlzY3Vzc2lvbi9jYXRjaC1lcnJvcnMucmFjdCcpLCdkaXNjdXNzaW9uL2NvbW1lbnQnOiByZXF1aXJlKCcuLi8uLi9ub2RlX21vZHVsZXMvaG92ZXJjYXJkc3NoYXJlZC9kaXNjdXNzaW9uL2NvbW1lbnQucmFjdCcpLCdkaXNjdXNzaW9uL2hlYWRlcic6IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9ob3ZlcmNhcmRzc2hhcmVkL2Rpc2N1c3Npb24vaGVhZGVyLnJhY3QnKSwnc291bmRjbG91ZC9zb25nJzogcmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2hvdmVyY2FyZHNzaGFyZWQvc291bmRjbG91ZC9zb25nLnJhY3QnKSwndHdpdHRlci90d2VldCc6IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9ob3ZlcmNhcmRzc2hhcmVkL3R3aXR0ZXIvdHdlZXQucmFjdCcpLCd5b3V0dWJlL3ZpZGVvJzogcmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2hvdmVyY2FyZHNzaGFyZWQveW91dHViZS92aWRlby5yYWN0Jyl9KVxuXHQgICAgICAgICAgICAgLmV4dGVuZCh7J2NhdGNoLWVycm9ycyc6IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9ob3ZlcmNhcmRzc2hhcmVkL2NvbW1vbi9jYXRjaC1lcnJvcnMucmFjdCcpfSlcblx0ICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24obWVtbywgb2JqLCBrZXkpIHtcblx0ICAgICAgICAgICAgICAgICBvYmouZGF0YSA9IF8uZXh0ZW5kKG9iai5kYXRhIHx8IHt9LCBnbG9iYWxfZGF0YSk7XG5cdCAgICAgICAgICAgICAgICAgdmFyIGtleV9wYXJ0cyA9IGtleS5zcGxpdCgvWy8tXS9nKTtcblx0ICAgICAgICAgICAgICAgICB3aGlsZSAoa2V5X3BhcnRzWzBdICYmIF8uaXNFcXVhbChrZXlfcGFydHNbMF0sIGtleV9wYXJ0c1sxXSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAga2V5X3BhcnRzLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgIG1lbW9ba2V5X3BhcnRzLmpvaW4oJy0nKV0gPSBSYWN0aXZlLmV4dGVuZChvYmopO1xuXHQgICAgICAgICAgICAgICAgIHJldHVybiBtZW1vO1xuXHQgICAgICAgICAgICAgfSwge30pXG5cdCAgICAgICAgICAgICAudmFsdWUoKSxcblx0ZGVjb3JhdG9yczogIF8uY2hhaW4oeydkYXRlLWRlY29yYXRvcic6IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9ob3ZlcmNhcmRzc2hhcmVkL2NvbW1vbi9kYXRlLWRlY29yYXRvci5qcycpLCdudW1iZXItZGVjb3JhdG9yJzogcmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2hvdmVyY2FyZHNzaGFyZWQvY29tbW9uL251bWJlci1kZWNvcmF0b3IuanMnKX0pXG5cdCAgICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbihtZW1vLCB0ZW1wbGF0ZSwga2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgIG1lbW9ba2V5LnJlcGxhY2UoLy1kZWNvcmF0b3IkLywgJycpXSA9IHRlbXBsYXRlO1xuXHQgICAgICAgICAgICAgICAgICByZXR1cm4gbWVtbztcblx0ICAgICAgICAgICAgICB9LCB7fSlcblx0ICAgICAgICAgICAgICAudmFsdWUoKVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBpZGVudGl0eSkge1xuXHR2YXIgcmFjdGl2ZSA9IG9iai5kYXRhKCdyYWN0aXZlJyk7XG5cblx0aWYgKCFyYWN0aXZlKSB7XG5cdFx0cmFjdGl2ZSA9IG5ldyBIb3ZlckNhcmRSYWN0aXZlKHtcblx0XHRcdHRlbXBsYXRlOiAne3s+dHlwZStcIi1sYXlvdXRcIn19Jyxcblx0XHRcdGRhdGE6ICAgICBfLmNsb25lKGlkZW50aXR5KSxcblx0XHRcdGVsOiAgICAgICBvYmpcblx0XHR9KTtcblx0XHRvYmouZGF0YSgncmFjdGl2ZScsIHJhY3RpdmUpO1xuXHRcdHJhY3RpdmUuc2V0KCdzY3JvbGxwb3MnLCAwKTtcblx0XHRyYWN0aXZlLnNldCgnc2Nyb2xscG9zYm90dG9tJywgMjEpO1xuXG5cdFx0c3dpdGNoIChpZGVudGl0eS50eXBlKSB7XG5cdFx0XHRjYXNlICdjb250ZW50Jzpcblx0XHRcdFx0cmFjdGl2ZS5zZXJ2aWNlKCdjb250ZW50JywgaWRlbnRpdHksIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuXHRcdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIGdpdmVuX2Rpc2N1c3Npb25zID0gXy5lYWNoKGRhdGEuZGlzY3Vzc2lvbnMsIF8ucGFydGlhbChfLmV4dGVuZCwgXywgeyBsb2FkZWQ6IHRydWUgfSkpIHx8IFtdO1xuXHRcdFx0XHRcdGRlbGV0ZSBkYXRhLmRpc2N1c3Npb25zO1xuXHRcdFx0XHRcdHZhciBkZWZhdWx0X2Rpc2N1c3Npb25zID0gXy5jaGFpbihjb25maWcuYXBpc1tkYXRhLmFwaV0pXG5cdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlc3VsdCgnZGlzY3Vzc2lvbl9hcGlzJywgW10pXG5cdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihhcGkpIHtcblx0XHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChhcGkgPT09IGRhdGEuYXBpKSA/IF8uZGVmYXVsdHMoeyB0eXBlOiAnZGlzY3Vzc2lvbicsIGxvYWRlZDogZmFsc2UgfSwgZGF0YSkgOlxuXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBhcGk6IGFwaSwgdHlwZTogJ2Rpc2N1c3Npb24nLCBmb3I6IF8uY2xvbmUoZGF0YSksIGxvYWRlZDogZmFsc2UgfTtcblx0XHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgIC52YWx1ZSgpO1xuXHRcdFx0XHRcdHJhY3RpdmUuc2V0KCdkaXNjdXNzaW9ucycsIF8uY2hhaW4oZ2l2ZW5fZGlzY3Vzc2lvbnMpXG5cdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51bmlvbihkZWZhdWx0X2Rpc2N1c3Npb25zKVxuXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAudW5pcShfLnByb3BlcnR5KCdhcGknKSlcblx0XHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnZhbHVlKCkpO1xuXHRcdFx0XHRcdHJhY3RpdmUuc2V0KCdkaXNjdXNzaW9uX2knLCAwKTtcblx0XHRcdFx0XHRyYWN0aXZlLm9ic2VydmVVbnRpbCgnZXhwYW5kZWQnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJhY3RpdmUub2JzZXJ2ZSgnZGlzY3Vzc2lvbl9pJywgZnVuY3Rpb24oaSkge1xuXHRcdFx0XHRcdFx0XHRyYWN0aXZlLnNlcnZpY2UoJ2Rpc2N1c3Npb25zLicgKyBpKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdhY2NvdW50Jzpcblx0XHRcdFx0cmFjdGl2ZS5zZXQoJ2FjY291bnRzJywgW2lkZW50aXR5XSk7XG5cdFx0XHRcdHJhY3RpdmUuc2V0KCdhY2NvdW50X2knLCAwKTtcblx0XHRcdFx0cmFjdGl2ZS5vYnNlcnZlKCdhY2NvdW50X2knLCBmdW5jdGlvbihpKSB7XG5cdFx0XHRcdFx0cmFjdGl2ZS5zZXJ2aWNlKCdhY2NvdW50cy4nICsgaSwgbnVsbCwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChkYXRhLmNvbnRlbnQpIHtcblx0XHRcdFx0XHRcdFx0cmFjdGl2ZS5zZXQoJ2FjY291bnRzLicgKyBpICsgJy5jb250ZW50LmxvYWRlZCcsIHRydWUpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmFjdGl2ZS5zZXQoJ2FjY291bnRzLicgKyBpICsgJy5jb250ZW50JywgXy5kZWZhdWx0cyh7IHR5cGU6ICdhY2NvdW50X2NvbnRlbnQnLCBsb2FkZWQ6IGZhbHNlIH0sIGRhdGEpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJhY3RpdmUub2JzZXJ2ZVVudGlsKCdleHBhbmRlZCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyYWN0aXZlLnNlcnZpY2UoJ2FjY291bnRzLicgKyBpICsgJy5jb250ZW50Jyk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdHJhY3RpdmUuc2V0KCdhY2NvdW50cycsIF8uY2hhaW4ocmFjdGl2ZS5nZXQoJ2FjY291bnRzJykpXG5cdFx0XHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgLnVuaW9uKGRhdGEuYWNjb3VudHMpXG5cdFx0XHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgLnVuaXEoXy5wcm9wZXJ0eSgnYXBpJykpXG5cdFx0XHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgLnZhbHVlKCkpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJhY3RpdmU7XG59O1xuIiwidmFyIGNvbXBvbmVudCA9IG1vZHVsZTtcblxuXHQvLyBGSVhNRSBUaGlzIGlzIHNvIGphbmt5LCBJIGxvdmUvaGF0ZSBpdFxuXG5cdGZ1bmN0aW9uIGdpdmVzY3JpcHQoc3JjLCB0ZXh0KSB7XG5cdFx0dmFyIHNjcmlwdCAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblx0XHRzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuXHRcdGlmIChzcmMpIHtcblx0XHRcdHNjcmlwdC5zcmMgPSBzcmM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNjcmlwdC50ZXh0ID0gKHRleHQgfHwgJycpICsgJzsgZG9jdW1lbnQuY3VycmVudFNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpOyc7XG5cdFx0fVxuXHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblx0XHRyZXR1cm4gc2NyaXB0O1xuXHR9XG5cblx0Y29tcG9uZW50LmV4cG9ydHMgPSB7XG5cdFx0b25pbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBfID0gdGhpcy5nZXQoJ18nKTtcblxuXHRcdFx0dGhpcy5zZXQoJ3VuaXF1ZWlkJywgXy51bmlxdWVJZChfLnByZWZpeCgneW91dHViZS12aWRlby0nKSkpO1xuXHRcdFx0dGhpcy5vYnNlcnZlKCdleHBhbmRlZCcsIGZ1bmN0aW9uKGV4cGFuZGVkKSB7XG5cdFx0XHRcdHZhciBpZCA9IHRoaXMuZ2V0KCd1bmlxdWVpZCcpO1xuXHRcdFx0XHRnaXZlc2NyaXB0KG51bGwsICd3aW5kb3dbXFwnJyArIGlkICArICctbXV0ZWRcXCddID0gJyArICF0aGlzLmdldCgnZXhwYW5kZWQnKSArICc7JyArXG5cdFx0XHRcdCdpZiAod2luZG93W1xcJycgKyBpZCAgKyAnXFwnXSAmJiB3aW5kb3dbXFwnJyArIGlkICArICdcXCddLm11dGUpIHsnICtcblx0XHRcdFx0XHQnd2luZG93W1xcJycgKyBpZCAgKyAnLW11dGVkXFwnXSA/IHdpbmRvd1tcXCcnICsgaWQgICsgJ1xcJ10ubXV0ZSgpIDogd2luZG93W1xcJycgKyBpZCAgKyAnXFwnXS51bk11dGUoKTsnICtcblx0XHRcdFx0J30nKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0W3NyYz1cImh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2lmcmFtZV9hcGlcIl0nKS5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Z2l2ZXNjcmlwdCgnaHR0cHM6Ly93d3cueW91dHViZS5jb20vaWZyYW1lX2FwaScpO1xuXHRcdH0sXG5cdFx0b25jb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzLmdldCgndW5pcXVlaWQnKTtcblx0XHRcdGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKS5zZXRBdHRyaWJ1dGUoJ2FsbG93RnVsbFNjcmVlbicsICcnKTtcblx0XHRcdGdpdmVzY3JpcHQobnVsbCwgJ3dpbmRvd1tcXCcnICsgaWQgICsgJy10aW1lb3V0XFwnXSA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkgeycgK1xuXHRcdFx0XHQnaWYgKCFZVCB8fCAhWVQuUGxheWVyKSB7JyArXG5cdFx0XHRcdFx0J3JldHVybjsnICtcblx0XHRcdFx0J30nICtcblx0XHRcdFx0J2NsZWFySW50ZXJ2YWwod2luZG93W1xcJycgKyBpZCAgKyAnLXRpbWVvdXRcXCddKTsnICtcblx0XHRcdFx0J2RlbGV0ZSB3aW5kb3dbXFwnJyArIGlkICArICctdGltZW91dFxcJ107JyArXG5cdFx0XHRcdCd3aW5kb3dbXFwnJyArIGlkICArICdcXCddID0gbmV3IFlULlBsYXllcihcXCcnICsgaWQgKyAnXFwnLCB7JyArXG5cdFx0XHRcdFx0J2V2ZW50czogeycgK1xuXHRcdFx0XHRcdFx0J29uUmVhZHk6IGZ1bmN0aW9uKGV2ZW50KSB7JyArXG5cdFx0XHRcdFx0XHRcdCd3aW5kb3dbXFwnJyArIGlkICArICctbXV0ZWRcXCddID8gZXZlbnQudGFyZ2V0Lm11dGUoKSA6IGV2ZW50LnRhcmdldC51bk11dGUoKTsnICtcblx0XHRcdFx0XHRcdCd9JyArXG5cdFx0XHRcdFx0J30nICtcblx0XHRcdFx0J30pOycgK1xuXHRcdFx0J30sIDUwMCknKTtcblx0XHR9XG5cdH07XG5cbmNvbXBvbmVudC5leHBvcnRzLnRlbXBsYXRlID0geyB2OjMsXG4gIHQ6WyB7IHQ6NyxcbiAgICAgIGU6XCJpZnJhbWVcIixcbiAgICAgIGE6eyBcImNsYXNzXCI6WyB7IHQ6MixcbiAgICAgICAgICAgIHI6XCJjbGFzc1wiIH0gXSxcbiAgICAgICAgc3JjOlsgXCJodHRwczovL3d3dy55b3V0dWJlLmNvbS9lbWJlZC9cIixcbiAgICAgICAgICB7IHQ6MixcbiAgICAgICAgICAgIHI6XCJpZFwiIH0sXG4gICAgICAgICAgXCI/ZW5hYmxlanNhcGk9MSZhdXRvcGxheT0xJnNob3dpbmZvPTBcIiBdLFxuICAgICAgICBpZDpbIHsgdDoyLFxuICAgICAgICAgICAgcjpcInVuaXF1ZWlkXCIgfSBdIH0gfSxcbiAgICBcIiBcIiBdIH0iLCJtb2R1bGUuZXhwb3J0cz17XCJ2XCI6MyxcInRcIjpbe1widFwiOjcsXCJlXCI6XCJkaXNjdXNzaW9uLWhlYWRlclwiLFwiYVwiOntcImNvbnRlbnRcIjpbe1widFwiOjIsXCJyXCI6XCJjb250ZW50XCJ9XX0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwic3BhblwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImVtXCIsXCJvXCI6e1wiblwiOlwibnVtYmVyXCIsXCJkXCI6W3tcInRcIjoyLFwiclwiOlwiY29udGVudC5zdGF0cy52aWV3c1wifV19fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiY29weVwiXSxcInNcIjpcIl8wKFxcXCJ2aWV3c1xcXCIsXFxcInlvdXR1YmVcXFwiKVwifX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInNwYW5cIixcImZcIjpbe1widFwiOjcsXCJlXCI6XCJlbVwiLFwib1wiOntcIm5cIjpcIm51bWJlclwiLFwiZFwiOlt7XCJ0XCI6MixcInJcIjpcImNvbnRlbnQuc3RhdHMubGlrZXNcIn1dfX0sXCIgXCIse1widFwiOjIsXCJ4XCI6e1wiclwiOltcImNvcHlcIl0sXCJzXCI6XCJfMChcXFwibGlrZXNcXFwiLFxcXCJ5b3V0dWJlXFxcIilcIn19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJzcGFuXCIsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZW1cIixcIm9cIjp7XCJuXCI6XCJudW1iZXJcIixcImRcIjpbe1widFwiOjIsXCJyXCI6XCJjb250ZW50LnN0YXRzLmRpc2xpa2VzXCJ9XX19LFwiIFwiLHtcInRcIjoyLFwieFwiOntcInJcIjpbXCJjb3B5XCJdLFwic1wiOlwiXzAoXFxcImRpc2xpa2VzXFxcIixcXFwieW91dHViZVxcXCIpXCJ9fV19XX1dfSIsIm1vZHVsZS5leHBvcnRzPXtcInZcIjozLFwidFwiOlt7XCJ0XCI6NyxcImVcIjpcImNvbnRlbnQtaGVhZGVyXCJ9LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcInByZWZpeFwiXSxcInNcIjpcIl8wKFxcXCJjb250ZW50LWNvbnRhaW5lclxcXCIpXCJ9fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcImZsZXgtcm93XFxcIilcIn19XX0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwieW91dHViZS12aWRlb1wiLFwiYVwiOntcImNsYXNzXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJwcmVmaXhcIl0sXCJzXCI6XCJfMChcXFwiY29udGVudC1jb250YWluZXItdmlkZW9cXFwiKVwifX1dLFwiaWRcIjpbe1widFwiOjIsXCJyXCI6XCJjb250ZW50LmlkXCJ9XX19XX1dfSIsIm1vZHVsZS5leHBvcnRzPXtcInZcIjozLFwidFwiOlt7XCJ0XCI6NCxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcImFjY291bnQtY292ZXJcXFwiKVwifX1dLFwic3R5bGVcIjpbXCJiYWNrZ3JvdW5kLWltYWdlOnVybCgnXCIse1widFwiOjIsXCJyXCI6XCJhY2NvdW50LmJhbm5lclwifSxcIicpXCJdfX1dLFwiblwiOjUwLFwiclwiOlwiYWNjb3VudC5iYW5uZXJcIn0se1widFwiOjcsXCJlXCI6XCJhY2NvdW50XCIsXCJhXCI6e1wiYWNjb3VudFwiOlt7XCJ0XCI6MixcInJcIjpcImFjY291bnRcIn1dfSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJzcGFuXCIsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZW1cIixcIm9cIjp7XCJuXCI6XCJudW1iZXJcIixcImRcIjpbe1widFwiOjIsXCJyXCI6XCJhY2NvdW50LnN0YXRzLmNvbnRlbnRcIn1dfX0sXCIgXCIse1widFwiOjIsXCJ4XCI6e1wiclwiOltcImNvcHlcIl0sXCJzXCI6XCJfMChcXFwiY29udGVudFxcXCIsXFxcInlvdXR1YmVcXFwiKVwifX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInNwYW5cIixcImZcIjpbe1widFwiOjcsXCJlXCI6XCJlbVwiLFwib1wiOntcIm5cIjpcIm51bWJlclwiLFwiZFwiOlt7XCJ0XCI6MixcInJcIjpcImFjY291bnQuc3RhdHMuZm9sbG93ZXJzXCJ9XX19LFwiIFwiLHtcInRcIjoyLFwieFwiOntcInJcIjpbXCJjb3B5XCJdLFwic1wiOlwiXzAoXFxcImZvbGxvd2Vyc1xcXCIsXFxcInlvdXR1YmVcXFwiKVwifX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInNwYW5cIixcImZcIjpbe1widFwiOjcsXCJlXCI6XCJlbVwiLFwib1wiOntcIm5cIjpcIm51bWJlclwiLFwiZFwiOlt7XCJ0XCI6MixcInJcIjpcImFjY291bnQuc3RhdHMudmlld3NcIn1dfX0sXCIgXCIse1widFwiOjIsXCJ4XCI6e1wiclwiOltcImNvcHlcIl0sXCJzXCI6XCJfMChcXFwidmlld3NcXFwiLFxcXCJ5b3V0dWJlXFxcIilcIn19XX1dfV19IiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjMsXCJ0XCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcInByZWZpeFwiXSxcInNcIjpcIl8wKFxcXCJpbWFnZS1jb250YWluZXJcXFwiKVwifX1dfSxcImZcIjpbe1widFwiOjQsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcInByZWZpeFwiXSxcInNcIjpcIl8wKFxcXCJpbWFnZS1pdGVtXFxcIilcIn19XX0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiYVwiLFwiYVwiOntcImhyZWZcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcInVybFwiLFwiLlwiXSxcInNcIjpcIl8wKF8xKVwifX1dLFwidGFyZ2V0XCI6XCJfYmxhbmtcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiaW1nXCIsXCJhXCI6e1wic3JjXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJpbWFnZS5tZWRpdW1cIixcImltYWdlLmxhcmdlXCIsXCJpbWFnZS5zbWFsbFwiXSxcInNcIjpcIl8wfHxfMXx8XzJcIn19XX19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwic3BhblwiLFwiZlwiOlt7XCJ0XCI6MixcInJcIjpcIm5hbWVcIn1dfV19XX1dLFwiclwiOlwiYWNjb3VudC5jb250ZW50LmNvbnRlbnRcIn1dfV19IiwidmFyIGNvbXBvbmVudCA9IG1vZHVsZTtcblxuXG5cbmNvbXBvbmVudC5leHBvcnRzLnRlbXBsYXRlID0geyB2OjMsXG4gIHQ6WyB7IHQ6NCxcbiAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICBlOlwidHdpdHRlci10d2VldFwiLFxuICAgICAgICAgIGE6eyB0d2VldDpbIHsgdDoyLFxuICAgICAgICAgICAgICAgIHI6XCJ0d2VldC5yZXBvc3RlZF9jb250ZW50XCIgfSBdLFxuICAgICAgICAgICAgaXNyZXR3ZWV0OlwidHJ1ZVwiIH0gfSBdLFxuICAgICAgbjo1MCxcbiAgICAgIHI6XCJ0d2VldC5yZXBvc3RlZF9jb250ZW50XCIgfSxcbiAgICB7IHQ6NCxcbiAgICAgIG46NTEsXG4gICAgICBmOlsgeyB0OjQsXG4gICAgICAgICAgbjo1MCxcbiAgICAgICAgICB4OnsgcjpbIFwidHdlZXQucmVwbGllZF90b19jb250ZW50XCIsXG4gICAgICAgICAgICAgIFwiaW5jb252ZXJzYXRpb25cIiBdLFxuICAgICAgICAgICAgczpcIl8wJiYhXzFcIiB9LFxuICAgICAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICAgICAgZTpcImRpdlwiLFxuICAgICAgICAgICAgICBhOnsgXCJjbGFzc1wiOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCJwcmVmaXhcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMChcXFwidHdlZXQtY29udmVyc2F0aW9uXFxcIilcIiB9IH0gXSB9LFxuICAgICAgICAgICAgICBmOlsgeyB0OjcsXG4gICAgICAgICAgICAgICAgICBlOlwidHdpdHRlci10d2VldFwiLFxuICAgICAgICAgICAgICAgICAgYTp7IGluY29udmVyc2F0aW9uOlwidHJ1ZVwiIH0gfSBdIH0gXSB9LFxuICAgICAgICB7IHQ6NCxcbiAgICAgICAgICBuOjUwLFxuICAgICAgICAgIHg6eyByOlsgXCJ0d2VldC5yZXBsaWVkX3RvX2NvbnRlbnRcIixcbiAgICAgICAgICAgICAgXCJpbmNvbnZlcnNhdGlvblwiIF0sXG4gICAgICAgICAgICBzOlwiIShfMCYmIV8xKVwiIH0sXG4gICAgICAgICAgZjpbIFwiIFwiLFxuICAgICAgICAgICAgeyB0OjQsXG4gICAgICAgICAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICAgICAgICAgIGU6XCJ0d2l0dGVyLXR3ZWV0XCIsXG4gICAgICAgICAgICAgICAgICBhOnsgdHdlZXQ6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgIHI6XCJ0d2VldC5yZXBsaWVkX3RvX2NvbnRlbnRcIiB9IF0gfSB9IF0sXG4gICAgICAgICAgICAgIG46NTAsXG4gICAgICAgICAgICAgIHI6XCJ0d2VldC5yZXBsaWVkX3RvX2NvbnRlbnRcIiB9LFxuICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICB7IHQ6NyxcbiAgICAgICAgICAgICAgZTpcImRpdlwiLFxuICAgICAgICAgICAgICBhOnsgXCJjbGFzc1wiOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCJpc3JldHdlZXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicHJlZml4XCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICBzOlwiXzA/XzEoXFxcImNvbW1lbnQtaXRlbV9yZXR3ZWV0XFxcIik6XFxcIlxcXCJcIiB9IH0gXSB9LFxuICAgICAgICAgICAgICBmOlsgeyB0OjcsXG4gICAgICAgICAgICAgICAgICBlOlwiZGlzY3Vzc2lvbi1jb21tZW50XCIsXG4gICAgICAgICAgICAgICAgICBhOnsgY29tbWVudDpbIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcIl9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInR3ZWV0XCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wLmRlZmF1bHRzKHtjb250ZW50Ol8xfSxfMSlcIiB9IH0gXSB9LFxuICAgICAgICAgICAgICAgICAgZjpbIHsgdDo0LFxuICAgICAgICAgICAgICAgICAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZTpcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhOnsgXCJjbGFzc1wiOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCJwcmVmaXhcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMChcXFwiY29tbWVudC10ZXh0LWltYWdlXFxcIilcIiB9IH0gXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmOlsgeyB0OjcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlOlwiY29udGVudC1tZWRpYVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYTp7IGNvbnRlbnQ6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHI6XCJ0d2VldFwiIH0gXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VkOlwiMVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb250YXV0b3BsYXk6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6eyByOlsgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM6XCJ0cnVlXCIgfSB9IF0gfSB9IF0gfSBdLFxuICAgICAgICAgICAgICAgICAgICAgIG46NTAsXG4gICAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcImhhc19tZWRpYVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInR3ZWV0XCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMChfMSlcIiB9IH0sXG4gICAgICAgICAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgICAgICAgICB7IHQ6NCxcbiAgICAgICAgICAgICAgICAgICAgICBmOlsgeyB0OjcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGU6XCJkaXZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYTp7IFwiY2xhc3NcIjpbIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwicHJlZml4XCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzOlwiXzAoXFxcImNvbW1lbnQtdGV4dC1xdW90ZVxcXCIpXCIgfSB9IF0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZjpbIHsgdDo3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTpcInR3aXR0ZXItdHdlZXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6eyB0d2VldDpbIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcjpcInR3ZWV0LnF1b3RlZF9jb250ZW50XCIgfSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2F2YXRhcmltYWdlczpcInRydWVcIiB9IH0gXSB9IF0sXG4gICAgICAgICAgICAgICAgICAgICAgbjo1MCxcbiAgICAgICAgICAgICAgICAgICAgICByOlwidHdlZXQucXVvdGVkX2NvbnRlbnRcIiB9IF0gfSBdIH0gXSB9IF0sXG4gICAgICByOlwidHdlZXQucmVwb3N0ZWRfY29udGVudFwiIH0gXSB9IiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjMsXCJ0XCI6W3tcInRcIjo0LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInR3aXR0ZXItdHdlZXRcIixcImFcIjp7XCJ0d2VldFwiOlt7XCJ0XCI6MixcInJcIjpcIi5cIn1dfX1dLFwiclwiOlwiZGlzY3Vzc2lvbi5jb21tZW50c1wifV19IiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjMsXCJ0XCI6W3tcInRcIjo3LFwiZVwiOlwiZGlzY3Vzc2lvbi1oZWFkZXJcIixcImFcIjp7XCJjb250ZW50XCI6W3tcInRcIjoyLFwiclwiOlwiY29udGVudFwifV19LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInNwYW5cIixcImZcIjpbe1widFwiOjcsXCJlXCI6XCJlbVwiLFwib1wiOntcIm5cIjpcIm51bWJlclwiLFwiZFwiOlt7XCJ0XCI6MixcInJcIjpcImNvbnRlbnQuc3RhdHMucmVwb3N0c1wifV19fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiY29weVwiXSxcInNcIjpcIl8wKFxcXCJyZXBvc3RzXFxcIixcXFwidHdpdHRlclxcXCIpXCJ9fV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwic3BhblwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImVtXCIsXCJvXCI6e1wiblwiOlwibnVtYmVyXCIsXCJkXCI6W3tcInRcIjoyLFwiclwiOlwiY29udGVudC5zdGF0cy5saWtlc1wifV19fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiY29weVwiXSxcInNcIjpcIl8wKFxcXCJsaWtlc1xcXCIsXFxcInR3aXR0ZXJcXFwiKVwifX1dfV19XX0iLCJtb2R1bGUuZXhwb3J0cz17XCJ2XCI6MyxcInRcIjpbe1widFwiOjQsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcInByZWZpeFwiXSxcInNcIjpcIl8wKFxcXCJhY2NvdW50LWNvdmVyXFxcIilcIn19XSxcInN0eWxlXCI6W1wiYmFja2dyb3VuZC1pbWFnZTp1cmwoJ1wiLHtcInRcIjoyLFwiclwiOlwiYWNjb3VudC5iYW5uZXJcIn0sXCInKVwiXX19XSxcIm5cIjo1MCxcInJcIjpcImFjY291bnQuYmFubmVyXCJ9LHtcInRcIjo3LFwiZVwiOlwiYWNjb3VudFwiLFwiYVwiOntcImFjY291bnRcIjpbe1widFwiOjIsXCJyXCI6XCJhY2NvdW50XCJ9XX0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwic3BhblwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImVtXCIsXCJvXCI6e1wiblwiOlwibnVtYmVyXCIsXCJkXCI6W3tcInRcIjoyLFwiclwiOlwiYWNjb3VudC5zdGF0cy5jb250ZW50XCJ9XX19LFwiIFwiLHtcInRcIjoyLFwieFwiOntcInJcIjpbXCJjb3B5XCJdLFwic1wiOlwiXzAoXFxcImNvbnRlbnRcXFwiLFxcXCJ0d2l0dGVyXFxcIilcIn19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJzcGFuXCIsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZW1cIixcIm9cIjp7XCJuXCI6XCJudW1iZXJcIixcImRcIjpbe1widFwiOjIsXCJyXCI6XCJhY2NvdW50LnN0YXRzLmZvbGxvd2Vyc1wifV19fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiY29weVwiXSxcInNcIjpcIl8wKFxcXCJmb2xsb3dlcnNcXFwiLFxcXCJ0d2l0dGVyXFxcIilcIn19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJzcGFuXCIsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZW1cIixcIm9cIjp7XCJuXCI6XCJudW1iZXJcIixcImRcIjpbe1widFwiOjIsXCJyXCI6XCJhY2NvdW50LnN0YXRzLmZvbGxvd2luZ1wifV19fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiY29weVwiXSxcInNcIjpcIl8wKFxcXCJmb2xsb3dpbmdcXFwiLFxcXCJ0d2l0dGVyXFxcIilcIn19XX1dfV19IiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjMsXCJ0XCI6W3tcInRcIjo0LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInR3aXR0ZXItdHdlZXRcIixcImFcIjp7XCJ0d2VldFwiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiX1wiLFwiYWNjb3VudFwiLFwiLlwiXSxcInNcIjpcIl8wLmRlZmF1bHRzKHthY2NvdW50Ol8xfSxfMilcIn19XX19XSxcInJcIjpcImFjY291bnQuY29udGVudC5jb250ZW50XCJ9XX0iLCJ2YXIgY29tcG9uZW50ID0gbW9kdWxlO1xuXG5cblxuY29tcG9uZW50LmV4cG9ydHMudGVtcGxhdGUgPSB7IHQ6WyAgXSxcbiAgdjozIH0iLCJtb2R1bGUuZXhwb3J0cz17XCJ2XCI6MyxcInRcIjpbe1widFwiOjcsXCJlXCI6XCJkaXNjdXNzaW9uLWhlYWRlclwiLFwiYVwiOntcImNvbnRlbnRcIjpbe1widFwiOjIsXCJyXCI6XCJjb250ZW50XCJ9XX0sXCJmXCI6W3tcInRcIjo0LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInNwYW5cIixcImZcIjpbe1widFwiOjcsXCJlXCI6XCJlbVwiLFwib1wiOntcIm5cIjpcIm51bWJlclwiLFwiZFwiOlt7XCJ0XCI6MixcInJcIjpcImNvbnRlbnQuc3RhdHMuY29udGVudFwifV19fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiY29weVwiXSxcInNcIjpcIl8wKFxcXCJjb250ZW50XFxcIixcXFwic291bmRjbG91ZFxcXCIpXCJ9fV19XSxcIm5cIjo1MCxcInhcIjp7XCJyXCI6W1wiY29udGVudC5hc1wiXSxcInNcIjpcIl8wPT09XFxcInBsYXlsaXN0XFxcIlwifX0se1widFwiOjQsXCJuXCI6NTEsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwic3BhblwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImVtXCIsXCJvXCI6e1wiblwiOlwibnVtYmVyXCIsXCJkXCI6W3tcInRcIjoyLFwiclwiOlwiY29udGVudC5zdGF0cy5saWtlc1wifV19fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiY29weVwiXSxcInNcIjpcIl8wKFxcXCJsaWtlc1xcXCIsXFxcInNvdW5kY2xvdWRcXFwiKVwifX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInNwYW5cIixcImZcIjpbe1widFwiOjcsXCJlXCI6XCJlbVwiLFwib1wiOntcIm5cIjpcIm51bWJlclwiLFwiZFwiOlt7XCJ0XCI6MixcInJcIjpcImNvbnRlbnQuc3RhdHMudmlld3NcIn1dfX0sXCIgXCIse1widFwiOjIsXCJ4XCI6e1wiclwiOltcImNvcHlcIl0sXCJzXCI6XCJfMChcXFwidmlld3NcXFwiLFxcXCJzb3VuZGNsb3VkXFxcIilcIn19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJzcGFuXCIsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZW1cIixcIm9cIjp7XCJuXCI6XCJudW1iZXJcIixcImRcIjpbe1widFwiOjIsXCJyXCI6XCJjb250ZW50LnN0YXRzLmNvbW1lbnRzXCJ9XX19LFwiIFwiLHtcInRcIjoyLFwieFwiOntcInJcIjpbXCJjb3B5XCJdLFwic1wiOlwiXzAoXFxcImNvbW1lbnRzXFxcIixcXFwic291bmRjbG91ZFxcXCIpXCJ9fV19XSxcInhcIjp7XCJyXCI6W1wiY29udGVudC5hc1wiXSxcInNcIjpcIl8wPT09XFxcInBsYXlsaXN0XFxcIlwifX1dfV19IiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjMsXCJ0XCI6W3tcInRcIjo3LFwiZVwiOlwiY29udGVudC1oZWFkZXJcIn0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcImNvbnRlbnQtY29udGFpbmVyXFxcIilcIn19LFwiIFwiLHtcInRcIjoyLFwieFwiOntcInJcIjpbXCJwcmVmaXhcIl0sXCJzXCI6XCJfMChcXFwiZmxleC1yb3dcXFwiKVwifX1dfSxcImZcIjpbe1widFwiOjQsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiaWZyYW1lXCIsXCJhXCI6e1wic3JjXCI6W1wiaHR0cHM6Ly93LnNvdW5kY2xvdWQuY29tL3BsYXllci8/dXJsPVwiLHtcInRcIjoyLFwieFwiOntcInJcIjpbXCJ1cmxcIixcImNvbnRlbnRcIl0sXCJzXCI6XCJlbmNvZGVVUkkoXzAoXzEpKVwifX0sXCImYXV0b19wbGF5PXRydWUmaGlkZV9yZWxhdGVkPXRydWUmc2hvd191c2VyPXRydWUmc2hvd19yZXBvc3RzPWZhbHNlJnZpc3VhbD10cnVlXCJdLFwiY2xhc3NcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcInByZWZpeFwiXSxcInNcIjpcIl8wKFxcXCJjb250ZW50LWNvbnRhaW5lci1pbWFnZVxcXCIpXCJ9fV0sXCJoZWlnaHRcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcImNvbnRlbnQuYXNcIl0sXCJzXCI6XCJfMD09PVxcXCJwbGF5bGlzdFxcXCI/NDIwOjI4MFwifX1dLFwid2lkdGhcIjpcIjY4MFwiLFwic3R5bGVcIjpbXCJoZWlnaHQ6XCIse1widFwiOjIsXCJ4XCI6e1wiclwiOltcImNvbnRlbnQuYXNcIl0sXCJzXCI6XCJfMD09PVxcXCJwbGF5bGlzdFxcXCI/NDIwOjI4MFwifX0sXCJweDt3aWR0aDo2ODBweDtcIl0sXCJzY3JvbGxpbmdcIjpcIm5vXCIsXCJmcmFtZWJvcmRlclwiOlwibm9cIn19XSxcIm5cIjo1MCxcInJcIjpcImV4cGFuZGVkXCJ9LHtcInRcIjo0LFwiblwiOjUxLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImNvbnRlbnQtbWVkaWFcIixcImFcIjp7XCJjbGFzc1wiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcImNvbnRlbnQtY29udGFpbmVyLWltYWdlXFxcIilcIn19XX19XSxcInJcIjpcImV4cGFuZGVkXCJ9XX1dfSIsIm1vZHVsZS5leHBvcnRzPXtcInZcIjozLFwidFwiOlt7XCJ0XCI6NCxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcImFjY291bnQtY292ZXJcXFwiKVwifX1dLFwic3R5bGVcIjpbXCJiYWNrZ3JvdW5kLWltYWdlOnVybCgnXCIse1widFwiOjIsXCJyXCI6XCJhY2NvdW50LmJhbm5lclwifSxcIicpXCJdfX1dLFwiblwiOjUwLFwiclwiOlwiYWNjb3VudC5iYW5uZXJcIn0se1widFwiOjcsXCJlXCI6XCJhY2NvdW50XCIsXCJhXCI6e1wiYWNjb3VudFwiOlt7XCJ0XCI6MixcInJcIjpcImFjY291bnRcIn1dfSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJzcGFuXCIsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZW1cIixcIm9cIjp7XCJuXCI6XCJudW1iZXJcIixcImRcIjpbe1widFwiOjIsXCJyXCI6XCJhY2NvdW50LnN0YXRzLmNvbnRlbnRcIn1dfX0sXCIgXCIse1widFwiOjIsXCJ4XCI6e1wiclwiOltcImNvcHlcIl0sXCJzXCI6XCJfMChcXFwiY29udGVudFxcXCIsXFxcInNvdW5kY2xvdWRcXFwiKVwifX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInNwYW5cIixcImZcIjpbe1widFwiOjcsXCJlXCI6XCJlbVwiLFwib1wiOntcIm5cIjpcIm51bWJlclwiLFwiZFwiOlt7XCJ0XCI6MixcInJcIjpcImFjY291bnQuc3RhdHMuZm9sbG93ZXJzXCJ9XX19LFwiIFwiLHtcInRcIjoyLFwieFwiOntcInJcIjpbXCJjb3B5XCJdLFwic1wiOlwiXzAoXFxcImZvbGxvd2Vyc1xcXCIsXFxcInNvdW5kY2xvdWRcXFwiKVwifX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInNwYW5cIixcImZcIjpbe1widFwiOjcsXCJlXCI6XCJlbVwiLFwib1wiOntcIm5cIjpcIm51bWJlclwiLFwiZFwiOlt7XCJ0XCI6MixcInJcIjpcImFjY291bnQuc3RhdHMuZm9sbG93aW5nXCJ9XX19LFwiIFwiLHtcInRcIjoyLFwieFwiOntcInJcIjpbXCJjb3B5XCJdLFwic1wiOlwiXzAoXFxcImZvbGxvd2luZ1xcXCIsXFxcInNvdW5kY2xvdWRcXFwiKVwifX1dfV19XX0iLCJtb2R1bGUuZXhwb3J0cz17XCJ2XCI6MyxcInRcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcImltYWdlLWNvbnRhaW5lclxcXCIpXCJ9fV19LFwiZlwiOlt7XCJ0XCI6NCxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcImltYWdlLWl0ZW1cXFwiKVwifX0sXCIgXCIse1widFwiOjIsXCJ4XCI6e1wiclwiOltcImFzXCIsXCJwcmVmaXhcIl0sXCJzXCI6XCIoXzA9PT1cXFwicGxheWxpc3RcXFwiKSYmXzEoXFxcInBsYXlsaXN0LWl0ZW1cXFwiKVwifX1dfSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJhXCIsXCJhXCI6e1wiY2xhc3NcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcInByZWZpeFwiXSxcInNcIjpcIl8wKFxcXCJpbWFnZS1pdGVtLXNxdWFyZVxcXCIpXCJ9fV0sXCJocmVmXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJ1cmxcIixcIi5cIl0sXCJzXCI6XCJfMChfMSlcIn19XSxcInRhcmdldFwiOlwiX2JsYW5rXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcInN0eWxlXCI6W1wiYmFja2dyb3VuZC1pbWFnZTp1cmwoJ1wiLHtcInRcIjoyLFwieFwiOntcInJcIjpbXCJpbWFnZS5tZWRpdW1cIixcImltYWdlLmxhcmdlXCIsXCJpbWFnZS5zbWFsbFwiXSxcInNcIjpcIl8wfHxfMXx8XzJcIn19LFwiJylcIl19fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInNwYW5cIixcImZcIjpbe1widFwiOjIsXCJyXCI6XCIubmFtZVwifV19XX1dfV0sXCJyXCI6XCJhY2NvdW50LmNvbnRlbnQuY29udGVudFwifV19XX0iLCJtb2R1bGUuZXhwb3J0cz17XCJ2XCI6MyxcInRcIjpbe1widFwiOjcsXCJlXCI6XCJkaXNjdXNzaW9uLWhlYWRlclwiLFwiYVwiOntcImNvbnRlbnRcIjpbe1widFwiOjIsXCJyXCI6XCJjb250ZW50XCJ9XX0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwic3BhblwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImVtXCIsXCJvXCI6e1wiblwiOlwibnVtYmVyXCIsXCJkXCI6W3tcInRcIjoyLFwiclwiOlwiY29udGVudC5zdGF0cy5zY29yZVwifV19fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiY29weVwiXSxcInNcIjpcIl8wKFxcXCJzY29yZVxcXCIsXFxcInJlZGRpdFxcXCIpXCJ9fV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwic3BhblwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImVtXCIsXCJmXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJjb250ZW50LnN0YXRzLnNjb3JlX3JhdGlvXCJdLFwic1wiOlwicGFyc2VJbnQoXzAqMTAwKVwifX0sXCIlXCJdfSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiY29weVwiXSxcInNcIjpcIl8wKFxcXCJzY29yZV9yYXRpb1xcXCIsXFxcInJlZGRpdFxcXCIpXCJ9fV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwic3BhblwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImVtXCIsXCJvXCI6e1wiblwiOlwibnVtYmVyXCIsXCJkXCI6W3tcInRcIjoyLFwiclwiOlwiY29udGVudC5zdGF0cy5jb21tZW50c1wifV19fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiY29weVwiXSxcInNcIjpcIl8wKFxcXCJjb21tZW50c1xcXCIsXFxcInJlZGRpdFxcXCIpXCJ9fV19XX1dfSIsIm1vZHVsZS5leHBvcnRzPXtcInZcIjozLFwidFwiOlt7XCJ0XCI6NyxcImVcIjpcImNvbnRlbnQtaGVhZGVyXCJ9LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcInByZWZpeFwiXSxcInNcIjpcIl8wKFxcXCJjb250ZW50LWNvbnRhaW5lclxcXCIpXCJ9fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcImZsZXgtcm93XFxcIilcIn19XX0sXCJmXCI6W3tcInRcIjo0LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImNvbnRlbnQtbWVkaWFcIixcImFcIjp7XCJjbGFzc1wiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcImNvbnRlbnQtY29udGFpbmVyLWltYWdlXFxcIilcIn19XX19XSxcIm5cIjo1MCxcInhcIjp7XCJyXCI6W1wiaGFzX21lZGlhXCIsXCJjb250ZW50XCJdLFwic1wiOlwiXzAoXzEpXCJ9fSx7XCJ0XCI6NCxcIm5cIjo1MSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJjb250ZW50LXRleHRcIn1dLFwieFwiOntcInJcIjpbXCJoYXNfbWVkaWFcIixcImNvbnRlbnRcIl0sXCJzXCI6XCJfMChfMSlcIn19XX1dfSIsIm1vZHVsZS5leHBvcnRzPXtcInZcIjozLFwidFwiOlt7XCJ0XCI6NCxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcImFjY291bnQtY292ZXJcXFwiKVwifX1dLFwic3R5bGVcIjpbXCJiYWNrZ3JvdW5kLWltYWdlOnVybCgnXCIse1widFwiOjIsXCJyXCI6XCJhY2NvdW50LmJhbm5lclwifSxcIicpXCJdfX1dLFwiblwiOjUwLFwiclwiOlwiYWNjb3VudC5iYW5uZXJcIn0se1widFwiOjcsXCJlXCI6XCJhY2NvdW50XCIsXCJhXCI6e1wiYWNjb3VudFwiOlt7XCJ0XCI6MixcInJcIjpcImFjY291bnRcIn1dfSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJzcGFuXCIsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZW1cIixcIm9cIjp7XCJuXCI6XCJudW1iZXJcIixcImRcIjpbe1widFwiOjIsXCJyXCI6XCJhY2NvdW50LnN0YXRzLmxpbmtfa2FybWFcIn1dfX0sXCIgXCIse1widFwiOjIsXCJ4XCI6e1wiclwiOltcImNvcHlcIl0sXCJzXCI6XCJfMChcXFwibGluay1rYXJtYVxcXCIsXFxcInJlZGRpdFxcXCIpXCJ9fV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwic3BhblwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImVtXCIsXCJvXCI6e1wiblwiOlwibnVtYmVyXCIsXCJkXCI6W3tcInRcIjoyLFwiclwiOlwiYWNjb3VudC5zdGF0cy5jb21tZW50X2thcm1hXCJ9XX19LFwiIFwiLHtcInRcIjoyLFwieFwiOntcInJcIjpbXCJjb3B5XCJdLFwic1wiOlwiXzAoXFxcImNvbW1lbnQta2FybWFcXFwiLFxcXCJyZWRkaXRcXFwiKVwifX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInNwYW5cIixcImZcIjpbe1widFwiOjcsXCJlXCI6XCJlbVwiLFwib1wiOntcIm5cIjpcImRhdGVcIixcImRcIjpbe1widFwiOjIsXCJyXCI6XCJhY2NvdW50LmRhdGVcIn1dfX0sXCIgXCIse1widFwiOjIsXCJ4XCI6e1wiclwiOltcImNvcHlcIl0sXCJzXCI6XCJfMChcXFwiYWNjb3VudC1hZ2VcXFwiLFxcXCJyZWRkaXRcXFwiKVwifX1dfV19XX0iLCJtb2R1bGUuZXhwb3J0cz17XCJ2XCI6MyxcInRcIjpbe1widFwiOjQsXCJmXCI6W3tcInRcIjo0LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJwcmVmaXhcIl0sXCJzXCI6XCJfMChcXFwicG9zdC1pdGVtXFxcIilcIn19XX0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwic3BhblwiLFwiYVwiOntcImNsYXNzXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJwcmVmaXhcIl0sXCJzXCI6XCJfMChcXFwicG9zdC1pdGVtLXJlcGx5LXRpdGxlXFxcIilcIn19XX0sXCJmXCI6W1wiUG9zdGVkIGluIFwiLHtcInRcIjo3LFwiZVwiOlwiYVwiLFwiYVwiOntcImhyZWZcIjpbXCJodHRwczovL3d3dy5yZWRkaXQuY29tL3IvXCIse1widFwiOjIsXCJyXCI6XCJzdWJyZWRkaXRcIn1dLFwidGFyZ2V0XCI6XCJfYmxhbmtcIn0sXCJmXCI6W1wiL3IvXCIse1widFwiOjIsXCJyXCI6XCJzdWJyZWRkaXRcIn1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImFcIixcImFcIjp7XCJocmVmXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJ1cmxcIixcIi5cIl0sXCJzXCI6XCJfMChfMSlcIn19XSxcInRhcmdldFwiOlwiX2JsYW5rXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInNwYW5cIixcIm9cIjp7XCJuXCI6XCJkYXRlXCIsXCJkXCI6W3tcInRcIjoyLFwiclwiOlwiZGF0ZVwifV19fV19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcInBvc3QtaXRlbS1saW5rXFxcIilcIn19XX0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiYVwiLFwiYVwiOntcImhyZWZcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcIi51cmxcIixcInVybFwiLFwiLlwiXSxcInNcIjpcIl8wfHxfMShfMilcIn19XSxcInRhcmdldFwiOlwiX2JsYW5rXCJ9LFwiZlwiOlt7XCJ0XCI6MixcInJcIjpcIm5hbWVcIn1dfV19XX1dLFwiblwiOjUwLFwieFwiOntcInJcIjpbXCJ0eXBlXCJdLFwic1wiOlwiXzA9PT1cXFwiY29udGVudFxcXCJcIn19LHtcInRcIjo0LFwiblwiOjUxLFwiZlwiOlt7XCJ0XCI6NCxcIm5cIjo1MCxcInhcIjp7XCJyXCI6W1widHlwZVwiXSxcInNcIjpcIl8wPT09XFxcImNvbW1lbnRcXFwiXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJwcmVmaXhcIl0sXCJzXCI6XCJfMChcXFwicG9zdC1pdGVtXFxcIilcIn19XX0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwic3BhblwiLFwiYVwiOntcImNsYXNzXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJwcmVmaXhcIl0sXCJzXCI6XCJfMChcXFwicG9zdC1pdGVtLXRpdGxlXFxcIilcIn19XX0sXCJmXCI6W1wiSW4gcmVzcG9uc2UgdG8gXCIse1widFwiOjcsXCJlXCI6XCJhXCIsXCJhXCI6e1wiaHJlZlwiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiY29udGVudC51cmxcIixcInVybFwiLFwiY29udGVudFwiXSxcInNcIjpcIl8wfHxfMShfMilcIn19XSxcInRhcmdldFwiOlwiX2JsYW5rXCJ9LFwiZlwiOlt7XCJ0XCI6MixcInJcIjpcImNvbnRlbnQubmFtZVwifV19LFwiIGluIFwiLHtcInRcIjo3LFwiZVwiOlwiYVwiLFwiYVwiOntcImhyZWZcIjpbXCJodHRwczovL3d3dy5yZWRkaXQuY29tL3IvXCIse1widFwiOjIsXCJyXCI6XCJjb250ZW50LnN1YnJlZGRpdFwifV0sXCJ0YXJnZXRcIjpcIl9ibGFua1wifSxcImZcIjpbXCIvci9cIix7XCJ0XCI6MixcInJcIjpcImNvbnRlbnQuc3VicmVkZGl0XCJ9XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJhXCIsXCJhXCI6e1wiaHJlZlwiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1widXJsXCIsXCJjb250ZW50XCIsXCIuXCJdLFwic1wiOlwiXzAoXzEsXzIpXCJ9fV0sXCJ0YXJnZXRcIjpcIl9ibGFua1wifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJzcGFuXCIsXCJvXCI6e1wiblwiOlwiZGF0ZVwiLFwiZFwiOlt7XCJ0XCI6MixcInJcIjpcImRhdGVcIn1dfX1dfV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcInByZWZpeFwiXSxcInNcIjpcIl8wKFxcXCJwb3N0LWl0ZW0tcGFyYWdyYXBoXFxcIilcIn19XX0sXCJmXCI6W3tcInRcIjozLFwiclwiOlwidGV4dFwifV19XX1dfV0sXCJ4XCI6e1wiclwiOltcInR5cGVcIl0sXCJzXCI6XCJfMD09PVxcXCJjb250ZW50XFxcIlwifX1dLFwiclwiOlwiYWNjb3VudC5jb250ZW50LmNvbnRlbnRcIn1dfSIsIm1vZHVsZS5leHBvcnRzPXtcInZcIjozLFwidFwiOlt7XCJ0XCI6NCxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXNjdXNzaW9uLWNvbW1lbnRcIixcImFcIjp7XCJjb21tZW50XCI6W3tcInRcIjoyLFwiclwiOlwiLlwifV19fV0sXCJyXCI6XCJkaXNjdXNzaW9uLmNvbW1lbnRzXCJ9XX0iLCJtb2R1bGUuZXhwb3J0cz17XCJ2XCI6MyxcInRcIjpbe1widFwiOjcsXCJlXCI6XCJkaXNjdXNzaW9uLWhlYWRlclwiLFwiYVwiOntcImNvbnRlbnRcIjpbe1widFwiOjIsXCJyXCI6XCJjb250ZW50XCJ9XX0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwic3BhblwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImVtXCIsXCJvXCI6e1wiblwiOlwibnVtYmVyXCIsXCJkXCI6W3tcInRcIjoyLFwiclwiOlwiY29udGVudC5zdGF0cy5saWtlc1wifV19fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiY29weVwiXSxcInNcIjpcIl8wKFxcXCJsaWtlc1xcXCIsXFxcImluc3RhZ3JhbVxcXCIpXCJ9fV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwic3BhblwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImVtXCIsXCJvXCI6e1wiblwiOlwibnVtYmVyXCIsXCJkXCI6W3tcInRcIjoyLFwiclwiOlwiY29udGVudC5zdGF0cy5jb21tZW50c1wifV19fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiY29weVwiXSxcInNcIjpcIl8wKFxcXCJjb21tZW50c1xcXCIsXFxcImluc3RhZ3JhbVxcXCIpXCJ9fV19XX1dfSIsIm1vZHVsZS5leHBvcnRzPXtcInZcIjozLFwidFwiOlt7XCJ0XCI6NyxcImVcIjpcImNvbnRlbnQtaGVhZGVyXCJ9LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcInByZWZpeFwiXSxcInNcIjpcIl8wKFxcXCJjb250ZW50LWNvbnRhaW5lclxcXCIpXCJ9fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcImZsZXgtcm93XFxcIilcIn19XX0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiY29udGVudC1tZWRpYVwiLFwiYVwiOntcImNsYXNzXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJwcmVmaXhcIl0sXCJzXCI6XCJfMChcXFwiY29udGVudC1jb250YWluZXItaW1hZ2VcXFwiKVwifX1dfX1dfV19IiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjMsXCJ0XCI6W3tcInRcIjo0LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJwcmVmaXhcIl0sXCJzXCI6XCJfMChcXFwiYWNjb3VudC1jb3ZlclxcXCIpXCJ9fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcImZsZXgtcm93XFxcIilcIn19XX0sXCJmXCI6W3tcInRcIjo0LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJwcmVmaXhcIl0sXCJzXCI6XCJfMChcXFwiaW5zdGFncmFtLWNvdmVyLWltYWdlc1xcXCIpXCJ9fV0sXCJzdHlsZVwiOltcImJhY2tncm91bmQtaW1hZ2U6IHVybCgnXCIse1widFwiOjIsXCJ4XCI6e1wiclwiOltcImltYWdlLm1lZGl1bVwiLFwiaW1hZ2UubGFyZ2VcIixcImltYWdlLnNtYWxsXCJdLFwic1wiOlwiXzB8fF8xfHxfMlwifX0sXCInKVwiXX19XSxcInhcIjp7XCJyXCI6W1wiX1wiLFwiYWNjb3VudC5jb250ZW50LmNvbnRlbnRcIl0sXCJzXCI6XCJfMC5maXJzdChfMSwzKVwifX1dfV0sXCJuXCI6NTAsXCJ4XCI6e1wiclwiOltcImV4cGFuZGVkXCIsXCJhY2NvdW50LmNvbnRlbnQuY29udGVudFwiXSxcInNcIjpcIiFfMCYmXzFcIn19LHtcInRcIjo3LFwiZVwiOlwiYWNjb3VudFwiLFwiYVwiOntcImFjY291bnRcIjpbe1widFwiOjIsXCJyXCI6XCJhY2NvdW50XCJ9XX0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwic3BhblwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImVtXCIsXCJvXCI6e1wiblwiOlwibnVtYmVyXCIsXCJkXCI6W3tcInRcIjoyLFwiclwiOlwiYWNjb3VudC5zdGF0cy5jb250ZW50XCJ9XX19LFwiIFwiLHtcInRcIjoyLFwieFwiOntcInJcIjpbXCJjb3B5XCJdLFwic1wiOlwiXzAoXFxcImNvbnRlbnRcXFwiLFxcXCJpbnN0YWdyYW1cXFwiKVwifX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInNwYW5cIixcImZcIjpbe1widFwiOjcsXCJlXCI6XCJlbVwiLFwib1wiOntcIm5cIjpcIm51bWJlclwiLFwiZFwiOlt7XCJ0XCI6MixcInJcIjpcImFjY291bnQuc3RhdHMuZm9sbG93ZXJzXCJ9XX19LFwiIFwiLHtcInRcIjoyLFwieFwiOntcInJcIjpbXCJjb3B5XCJdLFwic1wiOlwiXzAoXFxcImZvbGxvd2Vyc1xcXCIsXFxcImluc3RhZ3JhbVxcXCIpXCJ9fV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwic3BhblwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImVtXCIsXCJvXCI6e1wiblwiOlwibnVtYmVyXCIsXCJkXCI6W3tcInRcIjoyLFwiclwiOlwiYWNjb3VudC5zdGF0cy5mb2xsb3dpbmdcIn1dfX0sXCIgXCIse1widFwiOjIsXCJ4XCI6e1wiclwiOltcImNvcHlcIl0sXCJzXCI6XCJfMChcXFwiZm9sbG93aW5nXFxcIixcXFwiaW5zdGFncmFtXFxcIilcIn19XX1dfV19IiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjMsXCJ0XCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcInByZWZpeFwiXSxcInNcIjpcIl8wKFxcXCJpbWFnZS1jb250YWluZXJcXFwiKVwifX1dfSxcImZcIjpbe1widFwiOjQsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcInByZWZpeFwiXSxcInNcIjpcIl8wKFxcXCJpbWFnZS1pdGVtXFxcIilcIn19LFwiIFwiLHtcInRcIjoyLFwieFwiOntcInJcIjpbXCJwcmVmaXhcIl0sXCJzXCI6XCJfMChcXFwiZmxleC1yb3dcXFwiKVwifX1dfSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJhXCIsXCJhXCI6e1wiY2xhc3NcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcInByZWZpeFwiXSxcInNcIjpcIl8wKFxcXCJpbWFnZS1pdGVtLXNxdWFyZVxcXCIpXCJ9fV0sXCJocmVmXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJ1cmxcIixcIi5cIl0sXCJzXCI6XCJfMChfMSlcIn19XSxcInRhcmdldFwiOlwiX2JsYW5rXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcInN0eWxlXCI6W1wiYmFja2dyb3VuZC1pbWFnZTp1cmwoJ1wiLHtcInRcIjoyLFwieFwiOntcInJcIjpbXCJpbWFnZS5tZWRpdW1cIixcImltYWdlLmxhcmdlXCIsXCJpbWFnZS5zbWFsbFwiXSxcInNcIjpcIl8wfHxfMXx8XzJcIn19LFwiJylcIl19fV19XX1dLFwiclwiOlwiYWNjb3VudC5jb250ZW50LmNvbnRlbnRcIn1dfV19IiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjMsXCJ0XCI6W3tcInRcIjo0LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpc2N1c3Npb24tY29tbWVudFwiLFwiYVwiOntcImNvbW1lbnRcIjpbe1widFwiOjIsXCJyXCI6XCIuXCJ9XSxcIm5vYXZhdGFyaW1hZ2VzXCI6XCJ0cnVlXCJ9fV0sXCJyXCI6XCJkaXNjdXNzaW9uLmNvbW1lbnRzXCJ9XX0iLCJtb2R1bGUuZXhwb3J0cz17XCJ2XCI6MyxcInRcIjpbe1widFwiOjcsXCJlXCI6XCJkaXNjdXNzaW9uLWhlYWRlclwiLFwiYVwiOntcImNvbnRlbnRcIjpbe1widFwiOjIsXCJyXCI6XCJjb250ZW50XCJ9XX0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwic3BhblwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImVtXCIsXCJvXCI6e1wiblwiOlwibnVtYmVyXCIsXCJkXCI6W3tcInRcIjoyLFwiclwiOlwiY29udGVudC5zdGF0cy52aWV3c1wifV19fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiY29weVwiXSxcInNcIjpcIl8wKFxcXCJ2aWV3c1xcXCIsXFxcImltZ3VyXFxcIilcIn19XX0sXCIgXCIse1widFwiOjQsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwic3BhblwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImVtXCIsXCJvXCI6e1wiblwiOlwibnVtYmVyXCIsXCJkXCI6W3tcInRcIjoyLFwiclwiOlwiY29udGVudC5zdGF0cy5zY29yZVwifV19fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiY29weVwiXSxcInNcIjpcIl8wKFxcXCJzY29yZVxcXCIsXFxcImltZ3VyXFxcIilcIn19XX1dLFwiblwiOjUwLFwieFwiOntcInJcIjpbXCJfXCIsXCJjb250ZW50LnN0YXRzLnNjb3JlXCJdLFwic1wiOlwiIV8wLmlzVW5kZWZpbmVkKF8xKVwifX1dfV19IiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjMsXCJ0XCI6W3tcInRcIjo0LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImNvbnRlbnQtaGVhZGVyXCJ9XSxcIm5cIjo1MCxcInJcIjpcImV4cGFuZGVkXCJ9LHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcInByZWZpeFwiXSxcInNcIjpcIl8wKFxcXCJjb250ZW50LWNvbnRhaW5lclxcXCIpXCJ9fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcImZsZXgtcm93XFxcIilcIn19XX0sXCJmXCI6W3tcInRcIjo0LFwiZlwiOlt7XCJ0XCI6NCxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJpbWdcIixcImFcIjp7XCJjbGFzc1wiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcImNvbnRlbnQtY29udGFpbmVyLWltYWdlXFxcIilcIn19XSxcInNyY1wiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiLmltYWdlLmxhcmdlXCIsXCIuaW1hZ2UubWVkaXVtXCIsXCIuaW1hZ2Uuc21hbGxcIl0sXCJzXCI6XCJfMHx8XzF8fF8yXCJ9fV19fSxcIiBcIix7XCJ0XCI6NCxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcImNvbnRlbnQtY29udGFpbmVyLXRleHRcXFwiKVwifX1dfSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJiXCIsXCJmXCI6W3tcInRcIjoyLFwiclwiOlwiLm5hbWVcIn1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInBcIixcImZcIjpbe1widFwiOjMsXCJyXCI6XCIudGV4dFwifV19XX1dLFwiblwiOjUwLFwieFwiOntcInJcIjpbXCIubmFtZVwiLFwiLnRleHRcIl0sXCJzXCI6XCJfMHx8XzFcIn19XSxcInJcIjpcImNvbnRlbnQuY29udGVudFwifV0sXCJuXCI6NTAsXCJ4XCI6e1wiclwiOltcImV4cGFuZGVkXCIsXCJjb250ZW50LmNvbnRlbnRcIl0sXCJzXCI6XCJfMCYmXzFcIn19LHtcInRcIjo0LFwiblwiOjUxLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImNvbnRlbnQtbWVkaWFcIixcImFcIjp7XCJjbGFzc1wiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcImNvbnRlbnQtY29udGFpbmVyLWltYWdlXFxcIilcIn19XX19XSxcInhcIjp7XCJyXCI6W1wiZXhwYW5kZWRcIixcImNvbnRlbnQuY29udGVudFwiXSxcInNcIjpcIl8wJiZfMVwifX1dfV19IiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjMsXCJ0XCI6W3tcInRcIjo0LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJwcmVmaXhcIl0sXCJzXCI6XCJfMChcXFwiYWNjb3VudC1jb3ZlclxcXCIpXCJ9fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcImZsZXgtcm93XFxcIilcIn19XX0sXCJmXCI6W3tcInRcIjo0LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJwcmVmaXhcIl0sXCJzXCI6XCJfMChcXFwiaW5zdGFncmFtLWNvdmVyLWltYWdlc1xcXCIpXCJ9fV0sXCJzdHlsZVwiOltcImJhY2tncm91bmQtaW1hZ2U6IHVybCgnXCIse1widFwiOjIsXCJ4XCI6e1wiclwiOltcImltYWdlLm1lZGl1bVwiLFwiaW1hZ2UubGFyZ2VcIixcImltYWdlLnNtYWxsXCJdLFwic1wiOlwiXzB8fF8xfHxfMlwifX0sXCInKVwiXX19XSxcInhcIjp7XCJyXCI6W1wiX1wiLFwiYWNjb3VudC5jb250ZW50LmNvbnRlbnRcIl0sXCJzXCI6XCJfMC5maXJzdChfMSwzKVwifX1dfV0sXCJuXCI6NTAsXCJ4XCI6e1wiclwiOltcImV4cGFuZGVkXCIsXCJhY2NvdW50LmNvbnRlbnQuY29udGVudFwiXSxcInNcIjpcIiFfMCYmXzFcIn19LHtcInRcIjo3LFwiZVwiOlwiYWNjb3VudFwiLFwiYVwiOntcImFjY291bnRcIjpbe1widFwiOjIsXCJyXCI6XCJhY2NvdW50XCJ9XX0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwic3BhblwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImVtXCIsXCJvXCI6e1wiblwiOlwibnVtYmVyXCIsXCJkXCI6W3tcInRcIjoyLFwiclwiOlwiYWNjb3VudC5zdGF0cy5zY29yZVwifV19fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiY29weVwiXSxcInNcIjpcIl8wKFxcXCJzY29yZVxcXCIsXFxcImltZ3VyXFxcIilcIn19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJzcGFuXCIsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZW1cIixcIm9cIjp7XCJuXCI6XCJkYXRlXCIsXCJkXCI6W3tcInRcIjoyLFwiclwiOlwiYWNjb3VudC5kYXRlXCJ9XX19LFwiIFwiLHtcInRcIjoyLFwieFwiOntcInJcIjpbXCJjb3B5XCJdLFwic1wiOlwiXzAoXFxcImFjY291bnQtYWdlXFxcIixcXFwiaW1ndXJcXFwiKVwifX1dfV19XX0iLCJtb2R1bGUuZXhwb3J0cz17XCJ2XCI6MyxcInRcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcImltYWdlLWNvbnRhaW5lclxcXCIpXCJ9fV19LFwiZlwiOlt7XCJ0XCI6NCxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcImltYWdlLWl0ZW1cXFwiKVwifX1dfSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJhXCIsXCJhXCI6e1wiY2xhc3NcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcInByZWZpeFwiXSxcInNcIjpcIl8wKFxcXCJpbWFnZS1pdGVtLXNxdWFyZVxcXCIpXCJ9fV0sXCJocmVmXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJ1cmxcIixcIi5cIl0sXCJzXCI6XCJfMChfMSlcIn19XSxcInRhcmdldFwiOlwiX2JsYW5rXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcInN0eWxlXCI6W1wiYmFja2dyb3VuZC1pbWFnZTp1cmwoJ1wiLHtcInRcIjoyLFwieFwiOntcInJcIjpbXCJpbWFnZS5tZWRpdW1cIixcImltYWdlLmxhcmdlXCIsXCJpbWFnZS5zbWFsbFwiXSxcInNcIjpcIl8wfHxfMXx8XzJcIn19LFwiJylcIl19fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInNwYW5cIixcImZcIjpbe1widFwiOjIsXCJyXCI6XCIubmFtZVwifV19XX1dfV0sXCJyXCI6XCJhY2NvdW50LmNvbnRlbnQuY29udGVudFwifV19XX0iLCJ2YXIgY29tcG9uZW50ID0gbW9kdWxlO1xuXG5cblxuY29tcG9uZW50LmV4cG9ydHMudGVtcGxhdGUgPSB7IHY6MyxcbiAgdDpbIHsgdDo0LFxuICAgICAgZjpbIHsgdDo3LFxuICAgICAgICAgIGU6XCJjb250ZW50LXRleHRcIiB9IF0sXG4gICAgICBuOjUwLFxuICAgICAgeDp7IHI6WyBcImhhc19tZWRpYVwiLFxuICAgICAgICAgIFwiY29udGVudFwiLFxuICAgICAgICAgIFwiY29udGVudC5hcGlcIixcbiAgICAgICAgICBcImNvbnRlbnRfYXBpXCIgXSxcbiAgICAgICAgczpcIl8wKF8xKXx8XzIhPT1fM1wiIH0gfSxcbiAgICB7IHQ6NyxcbiAgICAgIGU6XCJkaXZcIixcbiAgICAgIGE6eyBcImNsYXNzXCI6WyB7IHQ6MixcbiAgICAgICAgICAgIHg6eyByOlsgXCJwcmVmaXhcIiBdLFxuICAgICAgICAgICAgICBzOlwiXzAoXFxcIm1ldGFcXFwiKVwiIH0gfSxcbiAgICAgICAgICBcIiBcIixcbiAgICAgICAgICB7IHQ6MixcbiAgICAgICAgICAgIHg6eyByOlsgXCJwcmVmaXhcIiBdLFxuICAgICAgICAgICAgICBzOlwiXzAoXFxcImZsZXgtcm93XFxcIilcIiB9IH0gXSB9LFxuICAgICAgZjpbIHsgdDo3LFxuICAgICAgICAgIGU6XCJkaXZcIixcbiAgICAgICAgICBhOnsgXCJjbGFzc1wiOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgeDp7IHI6WyBcInByZWZpeFwiIF0sXG4gICAgICAgICAgICAgICAgICBzOlwiXzAoXFxcIm1ldGEtbWFpblxcXCIpXCIgfSB9IF0gfSxcbiAgICAgICAgICBmOlsgeyB0OjcsXG4gICAgICAgICAgICAgIGU6XCJkaXZcIixcbiAgICAgICAgICAgICAgYTp7IFwiY2xhc3NcIjpbIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwicHJlZml4XCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICBzOlwiXzAoXFxcIm1ldGEtbWFpbi1zdGF0c1xcXCIpXCIgfSB9IF0gfSxcbiAgICAgICAgICAgICAgZjpbIHsgdDo4LFxuICAgICAgICAgICAgICAgICAgcjpcImNvbnRlbnRcIiB9IF0gfSxcbiAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgeyB0OjQsXG4gICAgICAgICAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICAgICAgICAgIGU6XCJkaXZcIixcbiAgICAgICAgICAgICAgICAgIGE6eyBcImNsYXNzXCI6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCJwcmVmaXhcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzOlwiXzAoXFxcIm1ldGEtbWFpbi12YWx1ZVxcXCIpXCIgfSB9IF0gfSxcbiAgICAgICAgICAgICAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICAgICAgICAgICAgICBlOlwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgICAgIGE6eyBcImNsYXNzXCI6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwicHJlZml4XCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMChcXFwiY2xpY2stdG8tdmlld1xcXCIpXCIgfSB9IF0gfSxcbiAgICAgICAgICAgICAgICAgICAgICBmOlsgXCJDbGljayB0byB2aWV3IGZ1bGwgc2l6ZVwiIF0gfSxcbiAgICAgICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgICAgIHsgdDo0LFxuICAgICAgICAgICAgICAgICAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZTpcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZjpbIFwiKyBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHQ6NyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6XCJpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhOnsgXCJjbGFzc1wiOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwicHJlZml4XCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wKFxcXCJuZXR3b3JrXFxcIilcIiB9IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwicHJlZml4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb250ZW50LmFjY291bnQuYWNjb3VudHMuMC5hcGlcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzOlwiXzAoXzEpXCIgfSB9IF0gfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGFjY291bnQuXCIgXSB9IF0sXG4gICAgICAgICAgICAgICAgICAgICAgbjo1MCxcbiAgICAgICAgICAgICAgICAgICAgICByOlwiY29udGVudC5hY2NvdW50cy4wXCIgfSBdIH0gXSxcbiAgICAgICAgICAgICAgbjo1MCxcbiAgICAgICAgICAgICAgeDp7IHI6WyBcImV4cGFuZGVkXCIgXSxcbiAgICAgICAgICAgICAgICBzOlwiIV8wXCIgfSB9IF0gfSxcbiAgICAgICAgXCIgXCIsXG4gICAgICAgIHsgdDo0LFxuICAgICAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICAgICAgZTpcImRpdlwiLFxuICAgICAgICAgICAgICBhOnsgXCJjbGFzc1wiOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCJwcmVmaXhcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMChcXFwibWV0YS1zaWRlXFxcIilcIiB9IH0gXSB9LFxuICAgICAgICAgICAgICBmOlsgeyB0OjcsXG4gICAgICAgICAgICAgICAgICBlOlwiaVwiLFxuICAgICAgICAgICAgICAgICAgYTp7IFwiY2xhc3NcIjpbIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcInByZWZpeFwiIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMChcXFwibmV0d29ya1xcXCIpXCIgfSB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcInByZWZpeFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29udGVudC5hcGlcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzOlwiXzAoXzEpXCIgfSB9IF0gfSB9IF0gfSBdLFxuICAgICAgICAgIG46NTAsXG4gICAgICAgICAgeDp7IHI6WyBcImV4cGFuZGVkXCIgXSxcbiAgICAgICAgICAgIHM6XCIhXzBcIiB9IH0gXSB9IF0gfSIsInZhciBjb21wb25lbnQgPSBtb2R1bGU7XG5cblxuXG5jb21wb25lbnQuZXhwb3J0cy50ZW1wbGF0ZSA9IHsgdjozLFxuICB0OlsgeyB0OjcsXG4gICAgICBlOlwiZGl2XCIsXG4gICAgICBhOnsgXCJjbGFzc1wiOlsgeyB0OjIsXG4gICAgICAgICAgICB4OnsgcjpbIFwicHJlZml4XCIgXSxcbiAgICAgICAgICAgICAgczpcIl8wKFxcXCJjb21tZW50LWl0ZW1cXFwiKVwiIH0gfSBdIH0sXG4gICAgICBmOlsgeyB0OjQsXG4gICAgICAgICAgZjpbIHsgdDo3LFxuICAgICAgICAgICAgICBlOlwiZGl2XCIsXG4gICAgICAgICAgICAgIGE6eyBcImNsYXNzXCI6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcInByZWZpeFwiIF0sXG4gICAgICAgICAgICAgICAgICAgICAgczpcIl8wKFxcXCJjb21tZW50LWltYWdlXFxcIilcIiB9IH0gXSB9LFxuICAgICAgICAgICAgICBmOlsgeyB0OjQsXG4gICAgICAgICAgICAgICAgICBmOlsgeyB0OjcsXG4gICAgICAgICAgICAgICAgICAgICAgZTpcImFcIixcbiAgICAgICAgICAgICAgICAgICAgICBhOnsgaHJlZjpbIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb21tZW50LmFjY291bnRcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wKF8xKVwiIH0gfSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OlwiX2JsYW5rXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTpbIFwiYmFja2dyb3VuZC1pbWFnZTp1cmwoJ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwiLm1lZGl1bVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi5sYXJnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi5zbWFsbFwiIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzOlwiXzB8fF8xfHxfMlwiIH0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCInKVwiIF0gfSB9IF0sXG4gICAgICAgICAgICAgICAgICByOlwiY29tbWVudC5hY2NvdW50LmltYWdlXCIgfSxcbiAgICAgICAgICAgICAgICB7IHQ6NCxcbiAgICAgICAgICAgICAgICAgIG46NTEsXG4gICAgICAgICAgICAgICAgICBmOlsgeyB0OjcsXG4gICAgICAgICAgICAgICAgICAgICAgZTpcImFcIixcbiAgICAgICAgICAgICAgICAgICAgICBhOnsgaHJlZjpbIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb21tZW50LmFjY291bnRcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wKF8xKVwiIH0gfSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OlwiX2JsYW5rXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCI6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwicHJlZml4XCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMChcXFwiY29tbWVudC1pbWFnZS1lbXB0eVxcXCIpXCIgfSB9IF0gfSB9IF0sXG4gICAgICAgICAgICAgICAgICByOlwiY29tbWVudC5hY2NvdW50LmltYWdlXCIgfSBdIH0gXSxcbiAgICAgICAgICBuOjUwLFxuICAgICAgICAgIHg6eyByOlsgXCJub2F2YXRhcmltYWdlc1wiIF0sXG4gICAgICAgICAgICBzOlwiIV8wXCIgfSB9LFxuICAgICAgICBcIiBcIixcbiAgICAgICAgeyB0OjcsXG4gICAgICAgICAgZTpcImRpdlwiLFxuICAgICAgICAgIGE6eyBcImNsYXNzXCI6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICB4OnsgcjpbIFwicHJlZml4XCIgXSxcbiAgICAgICAgICAgICAgICAgIHM6XCJfMChcXFwiY29tbWVudC10ZXh0XFxcIilcIiB9IH0gXSB9LFxuICAgICAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICAgICAgZTpcImFcIixcbiAgICAgICAgICAgICAgYTp7IGhyZWY6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcInVybFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjb21tZW50LmFjY291bnRcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMChfMSlcIiB9IH0gXSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6XCJfYmxhbmtcIiB9LFxuICAgICAgICAgICAgICBmOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICB4OnsgcjpbIFwiY29tbWVudC5hY2NvdW50Lm5hbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcImNvbW1lbnQuYWNjb3VudC5pZFwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiY29weVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiY29tbWVudC5hcGlcIiBdLFxuICAgICAgICAgICAgICAgICAgICBzOlwiXzB8fChfMSYmXzIoXFxcImFjY291bnQtaWQtYXMtbmFtZVxcXCIsXzMsXzEpKXx8XzIoXFxcImFjY291bnQtZW1wdHlcXFwiLF8zKVwiIH0gfSBdIH0sXG4gICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgIHsgdDo3LFxuICAgICAgICAgICAgICBlOlwiYVwiLFxuICAgICAgICAgICAgICBhOnsgaHJlZjpbIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwidXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImNvbW1lbnQuY29udGVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNjdXNzaW9uLmNvbnRlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY29udGVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjb21tZW50XCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICBzOlwiXzAoXzF8fF8yfHxfMyxfNClcIiB9IH0gXSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6XCJfYmxhbmtcIixcbiAgICAgICAgICAgICAgICBcImNsYXNzXCI6XCJuby1ob3ZlcmNhcmRcIiB9LFxuICAgICAgICAgICAgICBmOlsgeyB0OjQsXG4gICAgICAgICAgICAgICAgICBmOlsgeyB0OjcsXG4gICAgICAgICAgICAgICAgICAgICAgZTpcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICBmOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCJ0aW1lc3RhbXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29tbWVudC50aW1lX29mZnNldFwiIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wKF8xKVwiIH0gfSBdIH0gXSxcbiAgICAgICAgICAgICAgICAgIG46NTAsXG4gICAgICAgICAgICAgICAgICB4OnsgcjpbIFwiX1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiY29tbWVudC50aW1lX29mZnNldFwiIF0sXG4gICAgICAgICAgICAgICAgICAgIHM6XCJfMC5pc051bWJlcihfMSlcIiB9IH0sXG4gICAgICAgICAgICAgICAgeyB0OjQsXG4gICAgICAgICAgICAgICAgICBuOjUxLFxuICAgICAgICAgICAgICAgICAgZjpbIHsgdDo3LFxuICAgICAgICAgICAgICAgICAgICAgIGU6XCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgbzp7IG46XCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcjpcImNvbW1lbnQuZGF0ZVwiIH0gXSB9IH0gXSxcbiAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCJfXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJjb21tZW50LnRpbWVfb2Zmc2V0XCIgXSxcbiAgICAgICAgICAgICAgICAgICAgczpcIl8wLmlzTnVtYmVyKF8xKVwiIH0gfSBdIH0sXG4gICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgIHsgdDo3LFxuICAgICAgICAgICAgICBlOlwicFwiLFxuICAgICAgICAgICAgICBmOlsgeyB0OjMsXG4gICAgICAgICAgICAgICAgICByOlwiY29tbWVudC50ZXh0XCIgfSBdIH0sXG4gICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgIHsgdDo4LFxuICAgICAgICAgICAgICByOlwiY29udGVudFwiIH0sXG4gICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgIHsgdDo0LFxuICAgICAgICAgICAgICBmOlsgeyB0OjcsXG4gICAgICAgICAgICAgICAgICBlOlwiZGl2XCIsXG4gICAgICAgICAgICAgICAgICBhOnsgXCJjbGFzc1wiOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwicHJlZml4XCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wKFxcXCJtZXRhLXN0YXRzXFxcIilcIiB9IH0gXSB9LFxuICAgICAgICAgICAgICAgICAgZjpbIHsgdDo0LFxuICAgICAgICAgICAgICAgICAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZTpcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZjpbIHsgdDo3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTpcImVtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvOnsgbjpcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByOlwiLlwiIH0gXSB9IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwiY29weVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3RhdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29tbWVudC5hcGlcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzOlwiXzAoXzEsXzIpXCIgfSB9IF0gfSBdLFxuICAgICAgICAgICAgICAgICAgICAgIG46NTIsXG4gICAgICAgICAgICAgICAgICAgICAgaTpcInN0YXRcIixcbiAgICAgICAgICAgICAgICAgICAgICByOlwiY29tbWVudC5zdGF0c1wiIH0gXSB9IF0sXG4gICAgICAgICAgICAgIG46NTAsXG4gICAgICAgICAgICAgIHI6XCJjb21tZW50LnN0YXRzXCIgfSBdIH0gXSB9LFxuICAgIFwiIFwiLFxuICAgIHsgdDo0LFxuICAgICAgZjpbIHsgdDo3LFxuICAgICAgICAgIGU6XCJkaXZcIixcbiAgICAgICAgICBhOnsgXCJjbGFzc1wiOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgeDp7IHI6WyBcInByZWZpeFwiIF0sXG4gICAgICAgICAgICAgICAgICBzOlwiXzAoXFxcImNvbW1lbnQtcmVwbGllc1xcXCIpXCIgfSB9IF0gfSxcbiAgICAgICAgICBmOlsgeyB0OjQsXG4gICAgICAgICAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICAgICAgICAgIGU6XCJkaXNjdXNzaW9uLWNvbW1lbnRcIixcbiAgICAgICAgICAgICAgICAgIGE6eyBjb21tZW50OlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgICAgICByOlwiLlwiIH0gXSB9IH0gXSxcbiAgICAgICAgICAgICAgcjpcImNvbW1lbnQucmVwbGllc1wiIH0gXSB9IF0sXG4gICAgICBuOjUwLFxuICAgICAgcjpcImNvbW1lbnQucmVwbGllc1wiIH0gXSB9IiwidmFyIGNvbXBvbmVudCA9IG1vZHVsZTtcblxuXG5cbmNvbXBvbmVudC5leHBvcnRzLnRlbXBsYXRlID0geyB2OjMsXG4gIHQ6WyB7IHQ6NyxcbiAgICAgIGU6XCJjYXRjaC1lcnJvcnNcIixcbiAgICAgIGY6WyB7IHQ6NCxcbiAgICAgICAgICBmOlsgXCJZb3UgY2FuJ3QgY29tbWVudCBvbiB0aGlzIHNvIGdvIGF3YXlcIiBdLFxuICAgICAgICAgIG46NTAsXG4gICAgICAgICAgcjpcIm9iamVjdC51bmNvbW1lbnRhYmxlXCIgfSxcbiAgICAgICAgeyB0OjQsXG4gICAgICAgICAgbjo1MSxcbiAgICAgICAgICBmOlsgeyB0OjQsXG4gICAgICAgICAgICAgIG46NTAsXG4gICAgICAgICAgICAgIHg6eyByOlsgXCJfXCIsXG4gICAgICAgICAgICAgICAgICBcIm9iamVjdC5jb21tZW50c1wiIF0sXG4gICAgICAgICAgICAgICAgczpcIl8wLmlzRW1wdHkoXzEpXCIgfSxcbiAgICAgICAgICAgICAgZjpbIFwiVGhpcyBiaXRjaCBhaW4ndCBnb3Qgbm8gY29tbWVudHMhXCIgXSB9LFxuICAgICAgICAgICAgeyB0OjQsXG4gICAgICAgICAgICAgIG46NTAsXG4gICAgICAgICAgICAgIHg6eyByOlsgXCJfXCIsXG4gICAgICAgICAgICAgICAgICBcIm9iamVjdC5jb21tZW50c1wiIF0sXG4gICAgICAgICAgICAgICAgczpcIiEoXzAuaXNFbXB0eShfMSkpXCIgfSxcbiAgICAgICAgICAgICAgZjpbIFwiIFwiLFxuICAgICAgICAgICAgICAgIHsgdDoxNiB9IF0gfSBdLFxuICAgICAgICAgIHI6XCJvYmplY3QudW5jb21tZW50YWJsZVwiIH0gXSB9IF0gfSIsInZhciBjb21wb25lbnQgPSBtb2R1bGU7XG5cblxuXG5jb21wb25lbnQuZXhwb3J0cy50ZW1wbGF0ZSA9IHsgdjozLFxuICB0OlsgeyB0OjQsXG4gICAgICBmOlsgeyB0OjQsXG4gICAgICAgICAgZjpbIHsgdDo3LFxuICAgICAgICAgICAgICBlOlwiZGl2XCIsXG4gICAgICAgICAgICAgIGE6eyBcImNsYXNzXCI6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcInByZWZpeFwiIF0sXG4gICAgICAgICAgICAgICAgICAgICAgczpcIl8wKFxcXCJkZXNjcmlwdGlvblxcXCIpXCIgfSB9LFxuICAgICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgICB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcImRlc2NyaXB0aW9uZXhwYW5kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIl9cIiBdLFxuICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMD9fMS5wcmVmaXgoXFxcImV4cGFuZC1kZXNjcmlwdGlvblxcXCIpOlxcXCJcXFwiXCIgfSB9IF0gfSxcbiAgICAgICAgICAgICAgdjp7IGNsaWNrOnsgbTpcInNldFwiLFxuICAgICAgICAgICAgICAgICAgYTp7IHI6WyBcImV4cGFuZGVkXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgczpcIltcXFwiZGVzY3JpcHRpb25leHBhbmRcXFwiLF8wXVwiIH0gfSB9LFxuICAgICAgICAgICAgICBmOlsgeyB0OjQsXG4gICAgICAgICAgICAgICAgICBmOlsgeyB0OjcsXG4gICAgICAgICAgICAgICAgICAgICAgZTpcImFcIixcbiAgICAgICAgICAgICAgICAgICAgICBhOnsgXCJjbGFzc1wiOlsgXCJuby1ob3ZlcmNhcmQgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCJwcmVmaXhcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wKFxcXCJkZXNjcmlwdGlvbi10aXRsZVxcXCIpXCIgfSB9IF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcInVybFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi5cIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wKF8xKVwiIH0gfSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OlwiX2JsYW5rXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICBmOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHI6XCIubmFtZVwiIH0gXSB9IF0sXG4gICAgICAgICAgICAgICAgICBuOjUwLFxuICAgICAgICAgICAgICAgICAgcjpcIi5uYW1lXCIgfSxcbiAgICAgICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgICAgICB7IHQ6NCxcbiAgICAgICAgICAgICAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICAgICAgICAgICAgICBlOlwicFwiLFxuICAgICAgICAgICAgICAgICAgICAgIGY6WyB7IHQ6MyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcjpcIi50ZXh0XCIgfSBdIH0gXSxcbiAgICAgICAgICAgICAgICAgIG46NTAsXG4gICAgICAgICAgICAgICAgICByOlwiLnRleHRcIiB9IF0gfSBdLFxuICAgICAgICAgIG46NTAsXG4gICAgICAgICAgeDp7IHI6WyBcIi50ZXh0XCIsXG4gICAgICAgICAgICAgIFwiLm5hbWVcIiBdLFxuICAgICAgICAgICAgczpcIl8wfHxfMVwiIH0gfSBdLFxuICAgICAgcjpcImNvbnRlbnRcIiB9IF0gfSIsInZhciBjb21wb25lbnQgPSBtb2R1bGU7XG5cblx0Y29tcG9uZW50LmV4cG9ydHMgPSB7XG5cdFx0b25jb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmFjdGl2ZSA9IHRoaXM7XG5cdFx0XHRpZiAocmFjdGl2ZS5nZXQoJ2NvbnRlbnQudmlkZW8nKSB8fCByYWN0aXZlLmdldCgnY29udGVudC5naWYnKSkge1xuXHRcdFx0XHR2YXIgXyA9IHJhY3RpdmUuZ2V0KCdfJyk7XG5cblx0XHRcdFx0dmFyIGlkID0gXy51bmlxdWVJZChfLnByZWZpeCgndmlkZW8tJykpO1xuXHRcdFx0XHRyYWN0aXZlLnNldCgndW5pcXVlaWQnLCBpZCk7XG5cdFx0XHRcdHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXHRcdFx0XHRpZiAoIXRoaXMuZ2V0KCdkb250YXV0b3BsYXknKSkge1xuXHRcdFx0XHRcdGVsZW1lbnQucGxheSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW1lbnQub25jbGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICghcmFjdGl2ZS5nZXQoJ2V4cGFuZGVkJykpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGVsZW1lbnQucGF1c2VkKSB7XG5cdFx0XHRcdFx0XHRlbGVtZW50LnBsYXkoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZWxlbWVudC5wYXVzZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cbmNvbXBvbmVudC5leHBvcnRzLnRlbXBsYXRlID0geyB2OjMsXG4gIHQ6WyB7IHQ6NCxcbiAgICAgIGY6WyB7IHQ6NCxcbiAgICAgICAgICBmOlsgeyB0OjcsXG4gICAgICAgICAgICAgIGU6XCJ2aWRlb1wiLFxuICAgICAgICAgICAgICBhOnsgXCJjbGFzc1wiOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgIHI6XCJjbGFzc1wiIH0gXSxcbiAgICAgICAgICAgICAgICBzcmM6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgcjpcIi52aWRlb1wiIH0gXSxcbiAgICAgICAgICAgICAgICBwb3N0ZXI6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcImV4cGFuZGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIi5pbWFnZS5tZWRpdW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiLmltYWdlLmxhcmdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIi5pbWFnZS5zbWFsbFwiIF0sXG4gICAgICAgICAgICAgICAgICAgICAgczpcIihfMD8oXzJ8fF8xKTooXzF8fF8yKSl8fF8zXCIgfSB9IF0sXG4gICAgICAgICAgICAgICAgbXV0ZWQ6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcImV4cGFuZGVkXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICBzOlwiXzA/XFxcIlxcXCI6XFxcIm11dGVkXFxcIlwiIH0gfSBdLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xzOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCJleHBhbmRlZFwiIF0sXG4gICAgICAgICAgICAgICAgICAgICAgczpcIl8wP1xcXCJjb250cm9sc1xcXCI6XFxcIlxcXCJcIiB9IH0gXSxcbiAgICAgICAgICAgICAgICBsb29wOlwibG9vcFwiLFxuICAgICAgICAgICAgICAgIGlkOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgIHI6XCJ1bmlxdWVpZFwiIH0gXSB9IH0gXSxcbiAgICAgICAgICBuOjUwLFxuICAgICAgICAgIHI6XCIudmlkZW9cIiB9LFxuICAgICAgICB7IHQ6NCxcbiAgICAgICAgICBuOjUxLFxuICAgICAgICAgIGY6WyB7IHQ6NCxcbiAgICAgICAgICAgICAgbjo1MCxcbiAgICAgICAgICAgICAgeDp7IHI6WyBcIi5naWZcIiBdLFxuICAgICAgICAgICAgICAgIHM6XCJfMFwiIH0sXG4gICAgICAgICAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICAgICAgICAgIGU6XCJ2aWRlb1wiLFxuICAgICAgICAgICAgICAgICAgYTp7IFwiY2xhc3NcIjpbIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcjpcImNsYXNzXCIgfSBdLFxuICAgICAgICAgICAgICAgICAgICBzcmM6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgIHI6XCIuZ2lmXCIgfSBdLFxuICAgICAgICAgICAgICAgICAgICBwb3N0ZXI6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCJleHBhbmRlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLmltYWdlLm1lZGl1bVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLmltYWdlLmxhcmdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuaW1hZ2Uuc21hbGxcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzOlwiKF8wPyhfMnx8XzEpOihfMXx8XzIpKXx8XzNcIiB9IH0gXSxcbiAgICAgICAgICAgICAgICAgICAgbXV0ZWQ6XCJtdXRlZFwiLFxuICAgICAgICAgICAgICAgICAgICBsb29wOlwibG9vcFwiLFxuICAgICAgICAgICAgICAgICAgICBpZDpbIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcjpcInVuaXF1ZWlkXCIgfSBdIH0gfSBdIH0sXG4gICAgICAgICAgICB7IHQ6NCxcbiAgICAgICAgICAgICAgbjo1MCxcbiAgICAgICAgICAgICAgeDp7IHI6WyBcIi5naWZcIixcbiAgICAgICAgICAgICAgICAgIFwiLmltYWdlc1wiIF0sXG4gICAgICAgICAgICAgICAgczpcIighKF8wKSkmJihfMSlcIiB9LFxuICAgICAgICAgICAgICBmOlsgXCIgXCIsXG4gICAgICAgICAgICAgICAgeyB0OjQsXG4gICAgICAgICAgICAgICAgICBmOlsgeyB0OjQsXG4gICAgICAgICAgICAgICAgICAgICAgZjpbIHsgdDo0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmOlsgeyB0OjcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlOlwiaW1nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhOnsgXCJjbGFzc1wiOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByOlwiY2xhc3NcIiB9IF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYzpbIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcIi5sYXJnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLm1lZGl1bVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLnNtYWxsXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wfHxfMXx8XzJcIiB9IH0gXSB9IH0gXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbjo1MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcImlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sbGFwc2VkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi4uLy4uL2ltYWdlcy5sZW5ndGhcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM6XCIhXzB8fCFfMXx8XzI8PTJcIiB9IH0gXSxcbiAgICAgICAgICAgICAgICAgICAgICBuOjUyLFxuICAgICAgICAgICAgICAgICAgICAgIGk6XCJpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgcjpcIi5pbWFnZXNcIiB9LFxuICAgICAgICAgICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgICAgICAgICAgeyB0OjQsXG4gICAgICAgICAgICAgICAgICAgICAgZjpbIHsgdDo3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlOlwiYVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2OnsgY2xpY2s6eyBtOlwidG9nZ2xlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhOnsgcjpbICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzOlwiW1xcXCJjb2xsYXBzZWRcXFwiXVwiIH0gfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmOlsgXCJDbGljayB0byB2aWV3IFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcIi5pbWFnZXMubGVuZ3RoXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wLTFcIiB9IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgbW9yZSBpbWFnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcIi5pbWFnZXMubGVuZ3RoXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wPjI/XFxcInNcXFwiOlxcXCJcXFwiXCIgfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGluIGFsYnVtXCIgXSB9IF0sXG4gICAgICAgICAgICAgICAgICAgICAgbjo1MCxcbiAgICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwiY29sbGFwc2VkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiLmltYWdlcy5sZW5ndGhcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wJiZfMT4yXCIgfSB9IF0sXG4gICAgICAgICAgICAgICAgICBuOjUwLFxuICAgICAgICAgICAgICAgICAgcjpcImV4cGFuZGVkXCIgfSxcbiAgICAgICAgICAgICAgICB7IHQ6NCxcbiAgICAgICAgICAgICAgICAgIG46NTEsXG4gICAgICAgICAgICAgICAgICBmOlsgeyB0OjQsXG4gICAgICAgICAgICAgICAgICAgICAgZjpbIHsgdDo3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlOlwiaW1nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGE6eyBcImNsYXNzXCI6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcjpcImNsYXNzXCIgfSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYzpbIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwiLm1lZGl1bVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIubGFyZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLnNtYWxsXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzOlwiXzB8fF8xfHxfMlwiIH0gfSBdIH0gfSBdLFxuICAgICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCIuaW1hZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuaW1hZ2VzLjBcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wfHxfMVwiIH0gfSBdLFxuICAgICAgICAgICAgICAgICAgcjpcImV4cGFuZGVkXCIgfSBdIH0sXG4gICAgICAgICAgICB7IHQ6NCxcbiAgICAgICAgICAgICAgbjo1MCxcbiAgICAgICAgICAgICAgeDp7IHI6WyBcIi5naWZcIixcbiAgICAgICAgICAgICAgICAgIFwiLmltYWdlc1wiLFxuICAgICAgICAgICAgICAgICAgXCIuaW1hZ2VcIiBdLFxuICAgICAgICAgICAgICAgIHM6XCIoIShfMCkpJiYoKCEoXzEpKSYmKF8yKSlcIiB9LFxuICAgICAgICAgICAgICBmOlsgXCIgXCIsXG4gICAgICAgICAgICAgICAgeyB0OjcsXG4gICAgICAgICAgICAgICAgICBlOlwiaW1nXCIsXG4gICAgICAgICAgICAgICAgICBhOnsgXCJjbGFzc1wiOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgICAgICByOlwiY2xhc3NcIiB9IF0sXG4gICAgICAgICAgICAgICAgICAgIHNyYzpbIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcImV4cGFuZGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuaW1hZ2UubWVkaXVtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuaW1hZ2UubGFyZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi5pbWFnZS5zbWFsbFwiIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHM6XCIoXzA/KF8yfHxfMSk6KF8xfHxfMikpfHxfM1wiIH0gfSBdIH0gfSBdIH0gXSxcbiAgICAgICAgICByOlwiLnZpZGVvXCIgfSBdLFxuICAgICAgcjpcImNvbnRlbnRcIiB9IF0gfSIsIm1vZHVsZS5leHBvcnRzPXtcInZcIjozLFwidFwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6W3tcInRcIjo0LFwiZlwiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiX1wiXSxcInNcIjpcIl8wLnByZWZpeChcXFwiY29udGVudC12aWRlb1xcXCIpXCJ9fV0sXCJuXCI6NTAsXCJyXCI6XCJjb250ZW50LnZpZGVvXCJ9LHtcInRcIjo0LFwiblwiOjUxLFwiZlwiOlt7XCJ0XCI6NCxcIm5cIjo1MCxcInhcIjp7XCJyXCI6W1wiY29udGVudC5naWZcIl0sXCJzXCI6XCJfMFwifSxcImZcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcIl9cIl0sXCJzXCI6XCJfMC5wcmVmaXgoXFxcImNvbnRlbnQtZ2lmXFxcIilcIn19XX0se1widFwiOjQsXCJuXCI6NTAsXCJ4XCI6e1wiclwiOltcImNvbnRlbnQuZ2lmXCIsXCJjb250ZW50LmltYWdlc1wiLFwiY29udGVudC5jb250ZW50XCJdLFwic1wiOlwiKCEoXzApKSYmKF8xfHxfMilcIn0sXCJmXCI6W1wiIFwiLHtcInRcIjoyLFwieFwiOntcInJcIjpbXCJfXCJdLFwic1wiOlwiXzAucHJlZml4KFxcXCJjb250ZW50LWltYWdlc1xcXCIpXCJ9fV19LHtcInRcIjo0LFwiblwiOjUwLFwieFwiOntcInJcIjpbXCJjb250ZW50LmdpZlwiLFwiY29udGVudC5pbWFnZXNcIixcImNvbnRlbnQuY29udGVudFwiLFwiY29udGVudC5pbWFnZVwiXSxcInNcIjpcIighKF8wKSkmJigoIShfMXx8XzIpKSYmKF8zKSlcIn0sXCJmXCI6W1wiIFwiLHtcInRcIjoyLFwieFwiOntcInJcIjpbXCJfXCJdLFwic1wiOlwiXzAucHJlZml4KFxcXCJjb250ZW50LWltYWdlXFxcIilcIn19XX0se1widFwiOjQsXCJuXCI6NTAsXCJ4XCI6e1wiclwiOltcImNvbnRlbnQuZ2lmXCIsXCJjb250ZW50LmltYWdlc1wiLFwiY29udGVudC5jb250ZW50XCIsXCJjb250ZW50LmltYWdlXCJdLFwic1wiOlwiKCEoXzApKSYmKCghKF8xfHxfMikpJiYoIShfMykpKVwifSxcImZcIjpbXCIgXCIse1widFwiOjIsXCJ4XCI6e1wiclwiOltcIl9cIl0sXCJzXCI6XCJfMC5wcmVmaXgoXFxcImNvbnRlbnQtdGV4dFxcXCIpXCJ9fV19XSxcInJcIjpcImNvbnRlbnQudmlkZW9cIn0sXCIgXCIse1widFwiOjIsXCJ4XCI6e1wiclwiOltcIl9cIixcImNvbnRlbnQuYXBpXCJdLFwic1wiOlwiXzAucHJlZml4KFxcXCJjb250ZW50LVxcXCIrXzEpXCJ9fV19LFwiZlwiOlt7XCJ0XCI6NCxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiX1wiXSxcInNcIjpcIl8wLnByZWZpeChcXFwiY29udGVudFxcXCIpXCJ9fV19LFwiZlwiOlt7XCJ0XCI6NCxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiX1wiXSxcInNcIjpcIl8wLnByZWZpeChcXFwibG9hZGluZ1xcXCIpXCJ9fV19fV0sXCJuXCI6NTAsXCJyXCI6XCJjb250ZW50LmxvYWRpbmdcIn0se1widFwiOjQsXCJuXCI6NTEsXCJmXCI6W3tcInRcIjo0LFwiblwiOjUwLFwieFwiOntcInJcIjpbXCJjb250ZW50LmxvYWRlZFwiXSxcInNcIjpcIl8wXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImNhdGNoLWVycm9yc1wiLFwiYVwiOntcIm9iamVjdFwiOlt7XCJ0XCI6MixcInJcIjpcImNvbnRlbnRcIn1dfSxcImZcIjpbe1widFwiOjgsXCJ4XCI6e1wiclwiOltcImNvbnRlbnRcIl0sXCJzXCI6XCJfMC5hcGkrXFxcIi1jb250ZW50XFxcIlwifX1dfV19XSxcInJcIjpcImNvbnRlbnQubG9hZGluZ1wifV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcIl9cIl0sXCJzXCI6XCJfMC5wcmVmaXgoXFxcImRpc2N1c3Npb25cXFwiKVwifX0sXCIgXCIse1widFwiOjIsXCJ4XCI6e1wiclwiOltcInNjcm9sbHBvc1wiLFwic2Nyb2xscG9zYm90dG9tXCIsXCJfXCJdLFwic1wiOlwiXzA+MjAmJl8xPjIwP18yLnByZWZpeChcXFwiZGlzY3Vzc2lvbl9maXhlZFxcXCIpOlxcXCJcXFwiXCJ9fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wic2Nyb2xscG9zYm90dG9tXCIsXCJfXCJdLFwic1wiOlwiXzA8PTIwP18xLnByZWZpeChcXFwiZGlzY3Vzc2lvbl9hdC1ib3R0b21cXFwiKTpcXFwiXFxcIlwifX1dLFwic3R5bGVcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcInNjcm9sbHBvc1wiLFwic2Nyb2xscG9zYm90dG9tXCIsXCJib3htYXJnaW5cIl0sXCJzXCI6XCJfMD4yMCYmXzE+MjA/XFxcInJpZ2h0OiBcXFwiK18yK1xcXCJweCAhaW1wb3J0YW50O1xcXCI6XFxcIlxcXCJcIn19XX0sXCJmXCI6W3tcInRcIjo0LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJfXCJdLFwic1wiOlwiXzAucHJlZml4KFxcXCJmbGV4LXNwcmVhZFxcXCIpXCJ9fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiX1wiXSxcInNcIjpcIl8wLnByZWZpeChcXFwiYWNjb3VudC1zd2l0Y2hlclxcXCIpXCJ9fV19LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJfXCJdLFwic1wiOlwiXzAucHJlZml4KFxcXCJ0YWJzXFxcIilcIn19XX0sXCJmXCI6W3tcInRcIjo0LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInNwYW5cIixcInZcIjp7XCJjbGlja1wiOntcIm1cIjpcInNldFwiLFwiYVwiOntcInJcIjpbXCJpXCJdLFwic1wiOlwiW1xcXCJkaXNjdXNzaW9uX2lcXFwiLF8wXVwifX19LFwiYVwiOntcImNsYXNzXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJfXCJdLFwic1wiOlwiXzAucHJlZml4KFxcXCJ0YWJzX190YWJcXFwiKVwifX0sXCIgXCIse1widFwiOjIsXCJ4XCI6e1wiclwiOltcImlcIixcImRpc2N1c3Npb25faVwiLFwiX1wiXSxcInNcIjpcIl8wPT09XzE/XzIucHJlZml4KFxcXCJ0YWJzX190YWJfc2VsZWN0ZWRcXFwiKTpcXFwiXFxcIlwifX1dfSxcImZcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcImNvcHlcIixcIi5hcGlcIl0sXCJzXCI6XCJfMChfMSlcIn19XX1dLFwiblwiOjUyLFwiaVwiOlwiaVwiLFwiclwiOlwiZGlzY3Vzc2lvbnNcIn1dfV19XSxcIm5cIjo1MCxcInhcIjp7XCJyXCI6W1wiZGlzY3Vzc2lvbnNcIixcImV4cGFuZGVkXCJdLFwic1wiOlwiXzAmJl8xXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJfXCJdLFwic1wiOlwiXzAucHJlZml4KFxcXCJ0ZXN0aW5nXFxcIilcIn19XX0sXCJmXCI6W3tcInRcIjo0LFwiZlwiOlt7XCJ0XCI6NCxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiX1wiXSxcInNcIjpcIl8wLnByZWZpeChcXFwiZGlzY3Vzc2lvbl9faGVhZGVyXFxcIilcIn19XX0sXCJmXCI6W3tcInRcIjo0LFwiblwiOjUzLFwiZlwiOlt7XCJ0XCI6OCxcInhcIjp7XCJyXCI6W1wiYXBpXCJdLFwic1wiOlwiXzArXFxcIi1kaXNjdXNzaW9uLWhlYWRlclxcXCJcIn19XSxcInhcIjp7XCJyXCI6W1wiLlwiLFwiLi4vYXBpXCJdLFwic1wiOlwie2NvbnRlbnQ6XzAsY29udGVudF9hcGk6XzF9XCJ9fV19XSxcIm5cIjo1MCxcInJcIjpcIi5cIn1dLFwiblwiOjUzLFwieFwiOntcInJcIjpbXCJleHBhbmRlZFwiLFwiY29udGVudC5hcGlcIixcImRpc2N1c3Npb25faVwiLFwiZGlzY3Vzc2lvbnNcIixcImNvbnRlbnQubG9hZGVkXCIsXCJjb250ZW50LmVyclwiLFwiY29udGVudFwiXSxcInNcIjpcIl8wPyhfM1tfMl0ubG9hZGVkJiYhXzNbXzJdLmVyciYmXzNbXzJdLmNvbnRlbnQpfHwoXzE9PT1fM1tfMl0uYXBpJiZfNik6KF80JiYhXzUmJl82KVwifX0sXCIgXCIse1widFwiOjQsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcIl9cIl0sXCJzXCI6XCJfMC5wcmVmaXgoXFxcImRpc2N1c3Npb25fX2JvZHlcXFwiKVwifX1dfSxcImZcIjpbe1widFwiOjQsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcIl9cIl0sXCJzXCI6XCJfMC5wcmVmaXgoXFxcImxvYWRpbmdcXFwiKVwifX1dfX1dLFwiblwiOjUwLFwicnhcIjp7XCJyXCI6XCJkaXNjdXNzaW9uc1wiLFwibVwiOlt7XCJ0XCI6MzAsXCJuXCI6XCJkaXNjdXNzaW9uX2lcIn0sXCJsb2FkaW5nXCJdfX0se1widFwiOjQsXCJuXCI6NTEsXCJmXCI6W3tcInRcIjo0LFwiblwiOjUwLFwieFwiOntcInJcIjpbXCJkaXNjdXNzaW9uX2lcIixcImRpc2N1c3Npb25zXCJdLFwic1wiOlwiXzFbXzBdLmxvYWRlZFwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXNjdXNzaW9uLWNhdGNoLWVycm9yc1wiLFwiYVwiOntcIm9iamVjdFwiOlt7XCJ0XCI6MixcInJ4XCI6e1wiclwiOlwiZGlzY3Vzc2lvbnNcIixcIm1cIjpbe1widFwiOjMwLFwiblwiOlwiZGlzY3Vzc2lvbl9pXCJ9XX19XX0sXCJmXCI6W3tcInRcIjo0LFwiblwiOjUzLFwiZlwiOlt7XCJ0XCI6OCxcInhcIjp7XCJyXCI6W1wiZGlzY3Vzc2lvbl9pXCIsXCJkaXNjdXNzaW9uc1wiXSxcInNcIjpcIl8xW18wXS5hcGkrXFxcIi1kaXNjdXNzaW9uXFxcIlwifX1dLFwieFwiOntcInJcIjpbXCJkaXNjdXNzaW9uX2lcIixcImRpc2N1c3Npb25zXCJdLFwic1wiOlwie2Rpc2N1c3Npb246XzFbXzBdfVwifX1dfV19XSxcInJ4XCI6e1wiclwiOlwiZGlzY3Vzc2lvbnNcIixcIm1cIjpbe1widFwiOjMwLFwiblwiOlwiZGlzY3Vzc2lvbl9pXCJ9LFwibG9hZGluZ1wiXX19XX1dLFwiblwiOjUwLFwieFwiOntcInJcIjpbXCJkaXNjdXNzaW9uX2lcIixcImRpc2N1c3Npb25zXCIsXCJleHBhbmRlZFwiXSxcInNcIjpcIl8xJiZfMVtfMF0mJl8yXCJ9fV19XX1dLFwiblwiOjUwLFwiclwiOlwiY29udGVudFwifV19XX0iLCJ2YXIgY29tcG9uZW50ID0gbW9kdWxlO1xuXG5cblxuY29tcG9uZW50LmV4cG9ydHMudGVtcGxhdGUgPSB7IHY6MyxcbiAgdDpbIHsgdDo0LFxuICAgICAgZjpbIHsgdDo3LFxuICAgICAgICAgIGU6XCJkaXZcIixcbiAgICAgICAgICBhOnsgXCJjbGFzc1wiOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgeDp7IHI6WyBcInByZWZpeFwiIF0sXG4gICAgICAgICAgICAgICAgICBzOlwiXzAoXFxcImNvbnRlbnQtYWNjb3VudFxcXCIpXCIgfSB9LFxuICAgICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgICAgeyB0OjIsXG4gICAgICAgICAgICAgICAgeDp7IHI6WyBcInByZWZpeFwiIF0sXG4gICAgICAgICAgICAgICAgICBzOlwiXzAoXFxcImZsZXgtc3ByZWFkXFxcIilcIiB9IH0gXSB9LFxuICAgICAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICAgICAgZTpcImRpdlwiLFxuICAgICAgICAgICAgICBhOnsgXCJjbGFzc1wiOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCJwcmVmaXhcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMChcXFwiZmxleC1jZW50ZXJcXFwiKVwiIH0gfSBdIH0sXG4gICAgICAgICAgICAgIGY6WyB7IHQ6NCxcbiAgICAgICAgICAgICAgICAgIGY6WyB7IHQ6NCxcbiAgICAgICAgICAgICAgICAgICAgICBmOlsgeyB0OjcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGU6XCJhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGE6eyBcImNsYXNzXCI6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcInByZWZpeFwiIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wKFxcXCJjb250ZW50LWFjY291bnQtaW1hZ2VcXFwiKVwiIH0gfSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcInVybFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuYWNjb3VudFwiIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wKF8xKVwiIH0gfSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDpcIl9ibGFua1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOlsgXCJiYWNrZ3JvdW5kLWltYWdlOnVybCgnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcIi5hY2NvdW50LmltYWdlLnNtYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi5hY2NvdW50LmltYWdlLm1lZGl1bVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuYWNjb3VudC5pbWFnZS5sYXJnZVwiIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wfHxfMXx8XzJcIiB9IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIicpXCIgXSB9IH0gXSxcbiAgICAgICAgICAgICAgICAgICAgICBuOjUwLFxuICAgICAgICAgICAgICAgICAgICAgIHI6XCIuYWNjb3VudC5pbWFnZVwiIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgICAgICAgICB7IHQ6NyxcbiAgICAgICAgICAgICAgICAgICAgICBlOlwiZGl2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgZjpbIHsgdDo3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlOlwiYVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhOnsgXCJjbGFzc1wiOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCJwcmVmaXhcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMChcXFwiY29udGVudC1hY2NvdW50LW5hbWVcXFwiKVwiIH0gfSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcInVybFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuYWNjb3VudFwiIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wKF8xKVwiIH0gfSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDpcIl9ibGFua1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGY6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCIuYWNjb3VudC5uYW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuYWNjb3VudC5pZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29weVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLmFjY291bnQuYXBpXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wfHxfMihcXFwiYWNjb3VudC1pZC1hcy1uYW1lXFxcIixfMyxfMSl8fF8yKFxcXCJhY2NvdW50LWVtcHR5XFxcIixfMylcIiB9IH0gXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHQ6NCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZjpbIHsgdDo3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTpcImFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6eyBocmVmOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwidXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wKF8xKVwiIH0gfSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6XCJfYmxhbmtcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjbGFzc1wiOlwibm8taG92ZXJjYXJkXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlOlwiYnJcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHQ6NyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlOlwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG86eyBuOlwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZDpbIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHI6XCIuZGF0ZVwiIH0gXSB9IH0gXSB9IF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG46NTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHI6XCJleHBhbmRlZFwiIH0gXSB9IF0sXG4gICAgICAgICAgICAgICAgICBuOjUwLFxuICAgICAgICAgICAgICAgICAgcjpcIi5hY2NvdW50XCIgfSBdIH0sXG4gICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgIHsgdDo3LFxuICAgICAgICAgICAgICBlOlwiZGl2XCIsXG4gICAgICAgICAgICAgIGY6WyB7IHQ6NCxcbiAgICAgICAgICAgICAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICAgICAgICAgICAgICBlOlwiYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGE6eyBcImNsYXNzXCI6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwicHJlZml4XCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMChcXFwic2hhcmUtYnV0dG9uXFxcIilcIiB9IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwicHJlZml4XCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMChcXFwic2hhcmUtZmFjZWJvb2tcXFwiKVwiIH0gfSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjpbIFwiaHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL3NoYXJlci9zaGFyZXIucGhwP3U9XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMChfMSlcIiB9IH0gXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDpcIl9ibGFua1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgZjpbIFwiU2hhcmVcIiBdIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgICAgICAgICB7IHQ6NyxcbiAgICAgICAgICAgICAgICAgICAgICBlOlwiYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGE6eyBcImNsYXNzXCI6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwicHJlZml4XCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMChcXFwic2hhcmUtYnV0dG9uXFxcIilcIiB9IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwicHJlZml4XCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMChcXFwic2hhcmUtdHdpdHRlclxcXCIpXCIgfSB9IF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOlsgXCJodHRwczovL3R3aXR0ZXIuY29tL2ludGVudC90d2VldD91cmw9XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMChfMSlcIiB9IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiJnZpYT1ob3ZlcmNhcmRzJnNvdXJjZT1odHRwczovL2hvdmVyY2FyZHMuY29tXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDpcIl9ibGFua1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgZjpbIFwiVHdlZXRcIiBdIH0gXSxcbiAgICAgICAgICAgICAgICAgIG46NTAsXG4gICAgICAgICAgICAgICAgICByOlwiZXhwYW5kZWRcIiB9LFxuICAgICAgICAgICAgICAgIHsgdDo0LFxuICAgICAgICAgICAgICAgICAgbjo1MSxcbiAgICAgICAgICAgICAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICAgICAgICAgICAgICBlOlwiYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGE6eyBocmVmOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcInVybFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi5cIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wKF8xKVwiIH0gfSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OlwiX2JsYW5rXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCI6XCJuby1ob3ZlcmNhcmRcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZTpcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbzp7IG46XCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDpbIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByOlwiLmRhdGVcIiB9IF0gfSB9IF0gfSBdLFxuICAgICAgICAgICAgICAgICAgcjpcImV4cGFuZGVkXCIgfSBdIH0gXSB9IF0sXG4gICAgICByOlwiY29udGVudFwiIH0gXSB9IiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbnZhciB1bml0cyA9IFsnJywgJ3gtdGhvdXNhbmQnLCAneC1taWxsaW9uJywgJ3gtYmlsbGlvbicsICd4LXRyaWxsaW9uJ107XG5cbi8vIElmIHRoZSBudW1iZXIgaXMgYWxyZWFkeSBnb2luZyB0byBiZSA0IGRpZ2l0cyBvciBsZXNzLCBsZWF2ZSBpdCBhbG9uZVxuLy8gT3RoZXJ3aXNlLCBtYWtlIGl0IDMgZGlnaXRzLCBhbmQgd2l0aCB0aGUgcHJvcGVyIHVuaXRzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5vZGUsIG51bWJlcikge1xuXHR2YXIgY29weSA9IHRoaXMuZ2V0KCdjb3B5JykgfHwgXy5pZGVudGl0eTtcblx0aWYgKCFfLmlzTnVtYmVyKG51bWJlcikgfHwgXy5pc05hTihudW1iZXIpKSB7XG5cdFx0bm9kZS50ZXh0Q29udGVudCA9IG51bWJlcjtcblx0fSBlbHNlIGlmIChudW1iZXIgPCAxMDAwMCkge1xuXHRcdG5vZGUudGV4dENvbnRlbnQgPSBudW1iZXIudG9Mb2NhbGVTdHJpbmcoKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgbG9nMTAwMCAgICAgID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKG51bWJlcikgLyAzKTtcblx0XHR2YXIgbXVsdGlwbGUxMDAwID0gbnVtYmVyIC8gTWF0aC5wb3coMTAwMCwgbG9nMTAwMCk7XG5cdFx0dmFyIHJvdW5kdG8gICAgICA9IE1hdGgucG93KDEwLCAyIC0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKG11bHRpcGxlMTAwMCkpKTtcblx0XHRtdWx0aXBsZTEwMDAgICAgID0gTWF0aC5yb3VuZChtdWx0aXBsZTEwMDAgKiByb3VuZHRvKSAvIHJvdW5kdG87XG5cblx0XHRpZiAobG9nMTAwMCkge1xuXHRcdFx0bm9kZS50ZXh0Q29udGVudCA9IGNvcHkodW5pdHNbbG9nMTAwMF0sIG51bGwsIG11bHRpcGxlMTAwMC50b0xvY2FsZVN0cmluZygpKTtcblx0XHRcdG5vZGUudGl0bGUgICAgICAgPSBudW1iZXIudG9Mb2NhbGVTdHJpbmcoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gU2hvdWxkbid0IGhhcHBlblxuXHRcdFx0bm9kZS50ZXh0Q29udGVudCA9IG11bHRpcGxlMTAwMC50b0xvY2FsZVN0cmluZygpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4geyB0ZWFyZG93bjogXy5ub29wIH07XG59O1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbnZhciB1bml0cyA9IFtcblx0eyBjb3B5OiAneC1zZWNvbmRzJywgdmFsdWU6IC0xIH0sXG5cdHsgY29weTogJ3gtc2Vjb25kcycsIHZhbHVlOiAxMDAwIH0sXG5cdHsgY29weTogJ3gtbWludXRlcycsIHZhbHVlOiAxMDAwICogNjAgfSxcblx0eyBjb3B5OiAneC1ob3VycycsICAgdmFsdWU6IDEwMDAgKiA2MCAqIDYwIH0sXG5cdHsgY29weTogJ3gtZGF5cycsICAgIHZhbHVlOiAxMDAwICogNjAgKiA2MCAqIDI0IH0sXG5cdHsgY29weTogJ3gtbW9udGhzJywgIHZhbHVlOiAxMDAwICogNjAgKiA2MCAqIDI0ICogMzEgfSxcblx0eyBjb3B5OiAneC15ZWFycycsICAgdmFsdWU6IDEwMDAgKiA2MCAqIDYwICogMjQgKiAzMSAqIDEyIH1cbl07XG5cbi8vIERpc3BsYXkgd2l0aCB0aGUgcHJvcGVyIHVuaXRzLCB0aGVuIHVwZGF0ZSB3aGVuIHdlJ3JlIGdvaW5nIHRvXG4vLyBjaGFuZ2Vcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obm9kZSwgZGF0ZSkge1xuXHR2YXIgY29weSA9IHRoaXMuZ2V0KCdjb3B5JykgfHwgXy5pZGVudGl0eTtcblx0aWYgKCFfLmlzTnVtYmVyKGRhdGUpIHx8IF8uaXNOYU4oZGF0ZSkpIHtcblx0XHRub2RlLnRleHRDb250ZW50ID0gZGF0ZTtcblx0XHRyZXR1cm4geyB0ZWFyZG93bjogXy5ub29wIH07XG5cdH1cblxuXHRkYXRlICAgICAgID0gbmV3IERhdGUoZGF0ZSk7XG5cdG5vZGUudGl0bGUgPSBkYXRlLnRvU3RyaW5nKCk7XG5cblx0dmFyIHRpbWVvdXQ7XG5cdGZ1bmN0aW9uIGRpc3BsYXlfZGF0ZV9hbmRfc2V0X3RpbWVvdXQoKSB7XG5cdFx0dmFyIG5vdyAgICAgICAgICAgICAgICA9IG5ldyBEYXRlKCk7XG5cdFx0dmFyIG5vd193aXRoX2RhdGVfdGltZSA9IG5ldyBEYXRlKERhdGUuVVRDKG5vdy5nZXRVVENGdWxsWWVhcigpLCBub3cuZ2V0VVRDTW9udGgoKSwgbm93LmdldFVUQ0RhdGUoKSxcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZS5nZXRVVENIb3VycygpLCBkYXRlLmdldFVUQ01pbnV0ZXMoKSwgZGF0ZS5nZXRVVENTZWNvbmRzKCksIGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCkpKTtcblx0XHQvLyBUaGlzIGRpZmZlcmVuY2UgcHJldGVuZHMgdGhhdCBtb250aHMgYXJlIGV4YWN0bHkgMzEgZGF5cy5cblx0XHR2YXIgZGlmZmVyZW5jZSA9IG5vdyAtIG5vd193aXRoX2RhdGVfdGltZSArXG5cdFx0ICAgICAgICAgICAgICAgICAxMDAwICogNjAgKiA2MCAqIDI0ICogKG5vdy5nZXRVVENEYXRlKCkgLSBkYXRlLmdldFVUQ0RhdGUoKSArXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMxICogKG5vdy5nZXRVVENNb250aCgpIC0gZGF0ZS5nZXRVVENNb250aCgpICtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTIgKiAobm93LmdldFVUQ0Z1bGxZZWFyKCkgLSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSk7XG5cdFx0dmFyIHVuaXQgID0gdW5pdHNbXy5zb3J0ZWRJbmRleCh1bml0cywgeyB2YWx1ZTogZGlmZmVyZW5jZSB9LCAndmFsdWUnKSAtIDFdO1xuXHRcdHZhciB2YWx1ZSA9IE1hdGguZmxvb3IoZGlmZmVyZW5jZSAvIHVuaXQudmFsdWUpO1xuXG5cdFx0bm9kZS50ZXh0Q29udGVudCA9IGNvcHkodW5pdC5jb3B5LCBudWxsLCB2YWx1ZSk7XG5cdFx0c2V0VGltZW91dChkaXNwbGF5X2RhdGVfYW5kX3NldF90aW1lb3V0LCBkYXRlICsgKHZhbHVlICsgMSkgKiB1bml0LnZhbHVlIC0gbm93KTtcblx0fVxuXHRkaXNwbGF5X2RhdGVfYW5kX3NldF90aW1lb3V0KCk7XG5cblx0cmV0dXJuIHsgdGVhcmRvd246IGZ1bmN0aW9uKCkgeyBjbGVhclRpbWVvdXQodGltZW91dCk7IH0gfTtcbn07XG4iLCJ2YXIgY29tcG9uZW50ID0gbW9kdWxlO1xuXG5cdGNvbXBvbmVudC5leHBvcnRzID0ge1xuXHRcdG9uaW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLm9uKCdhdXRoZW50aWNhdGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5nZXQoJ29iamVjdC5lcnIuYXV0aGVudGljYXRlJykoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuY29tcG9uZW50LmV4cG9ydHMudGVtcGxhdGUgPSB7IHY6MyxcbiAgdDpbIHsgdDo0LFxuICAgICAgZjpbIHsgdDo0LFxuICAgICAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICAgICAgZTpcImRpdlwiLFxuICAgICAgICAgICAgICBhOnsgXCJjbGFzc1wiOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCJfXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICBzOlwiXzAucHJlZml4KFxcXCJlcnJvclxcXCIpXCIgfSB9LFxuICAgICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgICB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcIl9cIiBdLFxuICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMC5wcmVmaXgoXFxcImZsZXgtY2VudGVyXFxcIilcIiB9IH0gXSB9LFxuICAgICAgICAgICAgICBmOlsgeyB0OjcsXG4gICAgICAgICAgICAgICAgICBlOlwiZGl2XCIsXG4gICAgICAgICAgICAgICAgICBhOnsgXCJjbGFzc1wiOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwiX1wiIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMC5wcmVmaXgoXFxcImVycm9yLWltYWdlXFxcIilcIiB9IH0gXSB9IH0sXG4gICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgeyB0OjcsXG4gICAgICAgICAgICAgICAgICBlOlwiZGl2XCIsXG4gICAgICAgICAgICAgICAgICBmOlsgeyB0OjcsXG4gICAgICAgICAgICAgICAgICAgICAgZTpcImJcIixcbiAgICAgICAgICAgICAgICAgICAgICBmOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCIuZXJyLnN0YXR1c1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb3B5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi5hcGlcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMShcXFwiZXJyLVxcXCIrXzArXFxcIi1uYW1lXFxcIixfMixfMShfMikpXCIgfSB9IF0gfSxcbiAgICAgICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgICAgIHsgdDo3LFxuICAgICAgICAgICAgICAgICAgICAgIGU6XCJwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZjpbIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwiLmVyci5zdGF0dXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29weVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuYXBpXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzOlwiXzEoXFxcImVyci1cXFwiK18wK1xcXCItdGV4dFxcXCIsXzIsXzEoXzIpKVwiIH0gfSBdIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgICAgICAgICB7IHQ6NCxcbiAgICAgICAgICAgICAgICAgICAgICBmOlsgeyB0OjcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGU6XCJhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHY6eyBjbGljazpcImF1dGhlbnRpY2F0ZVwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGE6eyBcImNsYXNzXCI6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcIl9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLmFwaVwiIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wLnByZWZpeChfMSlcIiB9IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwiX1wiIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wLnByZWZpeChcXFwic2lnbmluLWN0YVxcXCIpXCIgfSB9IF0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZjpbIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcImNvcHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi5hcGlcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzOlwiXzAoXFxcImVyci00MDEtY3RhXFxcIixfMSxfMChfMSkpXCIgfSB9IF0gfSBdLFxuICAgICAgICAgICAgICAgICAgICAgIG46NTAsXG4gICAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcIi5lcnIuc3RhdHVzXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMD09PTQwMVwiIH0gfSBdIH0gXSB9IF0sXG4gICAgICAgICAgcjpcIm9iamVjdFwiIH0gXSxcbiAgICAgIG46NTAsXG4gICAgICByOlwib2JqZWN0LmVyclwiIH0sXG4gICAgeyB0OjQsXG4gICAgICBuOjUxLFxuICAgICAgZjpbIHsgdDoxNiB9IF0sXG4gICAgICByOlwib2JqZWN0LmVyclwiIH0gXSB9IiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjMsXCJ0XCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcIl9cIl0sXCJzXCI6XCJfMC5wcmVmaXgoXFxcImFjY291bnQtY29udGFpbmVyXFxcIilcIn19XX0sXCJmXCI6W3tcInRcIjo0LFwiZlwiOlt7XCJ0XCI6NCxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcImZsZXgtc3ByZWFkXFxcIilcIn19LFwiIFwiLHtcInRcIjoyLFwieFwiOntcInJcIjpbXCJwcmVmaXhcIl0sXCJzXCI6XCJfMChcXFwiYWNjb3VudC1zd2l0Y2hlclxcXCIpXCJ9fV19LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInNwYW5cIixcImZcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcImFjY291bnRzLjAubmFtZVwiLFwiYWNjb3VudHMuMC5pZFwiLFwiY29weVwiLFwiYWNjb3VudHMuMC5hcGlcIl0sXCJzXCI6XCJfMHx8XzIoXFxcImFjY291bnQtaWQtYXMtbmFtZVxcXCIsXzMsXzEpfHxfMihcXFwiYWNjb3VudC1lbXB0eVxcXCIsXzMpXCJ9fSxcIidzIGFjY291bnRzOlwiXX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJwcmVmaXhcIl0sXCJzXCI6XCJfMChcXFwidGFic1xcXCIpXCJ9fV19LFwiZlwiOlt7XCJ0XCI6NCxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJzcGFuXCIsXCJ2XCI6e1wiY2xpY2tcIjp7XCJtXCI6XCJzZXRcIixcImFcIjp7XCJyXCI6W1wiaVwiXSxcInNcIjpcIltcXFwiYWNjb3VudF9pXFxcIixfMF1cIn19fSxcImFcIjp7XCJjbGFzc1wiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wicHJlZml4XCJdLFwic1wiOlwiXzAoXFxcInRhYnNfX3RhYlxcXCIpXCJ9fSxcIiBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiaVwiLFwiYWNjb3VudF9pXCIsXCJfXCJdLFwic1wiOlwiXzA9PT1fMT9fMi5wcmVmaXgoXFxcInRhYnNfX3RhYl9zZWxlY3RlZFxcXCIpOlxcXCJcXFwiXCJ9fV19LFwiZlwiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiY29weVwiLFwiLmFwaVwiXSxcInNcIjpcIl8wKF8xKVwifX1dfV0sXCJuXCI6NTIsXCJpXCI6XCJpXCIsXCJyXCI6XCJhY2NvdW50c1wifV19XX1dLFwiblwiOjUwLFwieFwiOntcInJcIjpbXCJleHBhbmRlZFwiLFwiYWNjb3VudHMubGVuZ3RoXCJdLFwic1wiOlwiXzAmJl8xPjFcIn19LFwiIFwiLHtcInRcIjo0LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJfXCJdLFwic1wiOlwiXzAucHJlZml4KFxcXCJhY2NvdW50XFxcIilcIn19XX0sXCJmXCI6W3tcInRcIjo0LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJfXCJdLFwic1wiOlwiXzAucHJlZml4KFxcXCJsb2FkaW5nXFxcIilcIn19XX19XSxcIm5cIjo1MCxcInJ4XCI6e1wiclwiOlwiYWNjb3VudHNcIixcIm1cIjpbe1widFwiOjMwLFwiblwiOlwiYWNjb3VudF9pXCJ9LFwibG9hZGluZ1wiXX19LHtcInRcIjo0LFwiblwiOjUxLFwiZlwiOlt7XCJ0XCI6NCxcIm5cIjo1MCxcInhcIjp7XCJyXCI6W1wiYWNjb3VudF9pXCIsXCJhY2NvdW50c1wiXSxcInNcIjpcIl8xW18wXS5sb2FkZWRcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiY2F0Y2gtZXJyb3JzXCIsXCJhXCI6e1wib2JqZWN0XCI6W3tcInRcIjoyLFwicnhcIjp7XCJyXCI6XCJhY2NvdW50c1wiLFwibVwiOlt7XCJ0XCI6MzAsXCJuXCI6XCJhY2NvdW50X2lcIn1dfX1dfSxcImZcIjpbe1widFwiOjQsXCJuXCI6NTMsXCJmXCI6W3tcInRcIjo4LFwieFwiOntcInJcIjpbXCJhY2NvdW50X2lcIixcImFjY291bnRzXCJdLFwic1wiOlwiXzFbXzBdLmFwaStcXFwiLWFjY291bnRcXFwiXCJ9fV0sXCJ4XCI6e1wiclwiOltcImFjY291bnRfaVwiLFwiYWNjb3VudHNcIl0sXCJzXCI6XCJ7YWNjb3VudDpfMVtfMF19XCJ9fV19XX1dLFwicnhcIjp7XCJyXCI6XCJhY2NvdW50c1wiLFwibVwiOlt7XCJ0XCI6MzAsXCJuXCI6XCJhY2NvdW50X2lcIn0sXCJsb2FkaW5nXCJdfX1dfV0sXCJuXCI6NTAsXCJyeFwiOntcInJcIjpcImFjY291bnRzXCIsXCJtXCI6W3tcInRcIjozMCxcIm5cIjpcImFjY291bnRfaVwifV19fSxcIiBcIix7XCJ0XCI6NCxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiX1wiXSxcInNcIjpcIl8wLnByZWZpeChcXFwiYWNjb3VudC1jb250ZW50XFxcIilcIn19XX0sXCJmXCI6W3tcInRcIjo0LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6W3tcInRcIjoyLFwieFwiOntcInJcIjpbXCJfXCJdLFwic1wiOlwiXzAucHJlZml4KFxcXCJsb2FkaW5nXFxcIilcIn19XX19XSxcIm5cIjo1MCxcInJ4XCI6e1wiclwiOlwiYWNjb3VudHNcIixcIm1cIjpbe1widFwiOjMwLFwiblwiOlwiYWNjb3VudF9pXCJ9LFwiY29udGVudFwiLFwibG9hZGluZ1wiXX19LHtcInRcIjo0LFwiblwiOjUxLFwiZlwiOlt7XCJ0XCI6NCxcIm5cIjo1MCxcInhcIjp7XCJyXCI6W1wiYWNjb3VudF9pXCIsXCJhY2NvdW50c1wiXSxcInNcIjpcIl8xW18wXS5jb250ZW50LmxvYWRlZFwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJhY2NvdW50LWNvbnRlbnQtY2F0Y2gtZXJyb3JzXCIsXCJhXCI6e1wib2JqZWN0XCI6W3tcInRcIjoyLFwicnhcIjp7XCJyXCI6XCJhY2NvdW50c1wiLFwibVwiOlt7XCJ0XCI6MzAsXCJuXCI6XCJhY2NvdW50X2lcIn0sXCJjb250ZW50XCJdfX1dfSxcImZcIjpbe1widFwiOjQsXCJuXCI6NTMsXCJmXCI6W3tcInRcIjo4LFwieFwiOntcInJcIjpbXCJhY2NvdW50X2lcIixcImFjY291bnRzXCJdLFwic1wiOlwiXzFbXzBdLmNvbnRlbnQuYXBpK1xcXCItYWNjb3VudC1jb250ZW50XFxcIlwifX1dLFwieFwiOntcInJcIjpbXCJhY2NvdW50X2lcIixcImFjY291bnRzXCJdLFwic1wiOlwie2FjY291bnQ6XzFbXzBdfVwifX1dfV19XSxcInJ4XCI6e1wiclwiOlwiYWNjb3VudHNcIixcIm1cIjpbe1widFwiOjMwLFwiblwiOlwiYWNjb3VudF9pXCJ9LFwiY29udGVudFwiLFwibG9hZGluZ1wiXX19XX1dLFwiblwiOjUwLFwieFwiOntcInJcIjpbXCJleHBhbmRlZFwiLFwiYWNjb3VudF9pXCIsXCJhY2NvdW50c1wiXSxcInNcIjpcIl8wJiZfMltfMV0uY29udGVudFwifX1dLFwiblwiOjUwLFwieFwiOntcInJcIjpbXCJhY2NvdW50c1wiLFwiX1wiLFwiYWNjb3VudF9pXCJdLFwic1wiOlwiXzAmJl8xLmlzTnVtYmVyKF8yKVwifX1dfV19IiwidmFyIGNvbXBvbmVudCA9IG1vZHVsZTtcblxuXG5cbmNvbXBvbmVudC5leHBvcnRzLnRlbXBsYXRlID0geyB2OjMsXG4gIHQ6WyB7IHQ6NCxcbiAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICBlOlwiYVwiLFxuICAgICAgICAgIGE6eyBcImNsYXNzXCI6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICB4OnsgcjpbIFwicHJlZml4XCIgXSxcbiAgICAgICAgICAgICAgICAgIHM6XCJfMChcXFwiYWNjb3VudC1pbWFnZVxcXCIpXCIgfSB9LFxuICAgICAgICAgICAgICBcIiBuby1ob3ZlcmNhcmRcIiBdLFxuICAgICAgICAgICAgaHJlZjpbIHsgdDoyLFxuICAgICAgICAgICAgICAgIHg6eyByOlsgXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhY2NvdW50XCIgXSxcbiAgICAgICAgICAgICAgICAgIHM6XCJfMChfMSlcIiB9IH0gXSxcbiAgICAgICAgICAgIHRhcmdldDpcIl9ibGFua1wiLFxuICAgICAgICAgICAgc3R5bGU6WyBcImJhY2tncm91bmQtaW1hZ2U6dXJsKCdcIixcbiAgICAgICAgICAgICAgeyB0OjIsXG4gICAgICAgICAgICAgICAgeDp7IHI6WyBcIm1lZGl1bVwiLFxuICAgICAgICAgICAgICAgICAgICBcImxhcmdlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic21hbGxcIiBdLFxuICAgICAgICAgICAgICAgICAgczpcIl8wfHxfMXx8XzJcIiB9IH0sXG4gICAgICAgICAgICAgIFwiJylcIiBdIH0gfSBdLFxuICAgICAgcjpcImFjY291bnQuaW1hZ2VcIiB9LFxuICAgIHsgdDo3LFxuICAgICAgZTpcImRpdlwiLFxuICAgICAgYTp7IFwiY2xhc3NcIjpbIHsgdDoyLFxuICAgICAgICAgICAgeDp7IHI6WyBcInByZWZpeFwiIF0sXG4gICAgICAgICAgICAgIHM6XCJfMChcXFwiYWNjb3VudC1uYW1lXFxcIilcIiB9IH0sXG4gICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgeyB0OjIsXG4gICAgICAgICAgICB4OnsgcjpbIFwicHJlZml4XCIgXSxcbiAgICAgICAgICAgICAgczpcIl8wKFxcXCJmbGV4LXJvd1xcXCIpXCIgfSB9IF0gfSxcbiAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICBlOlwiYVwiLFxuICAgICAgICAgIGE6eyBocmVmOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgeDp7IHI6WyBcInVybFwiLFxuICAgICAgICAgICAgICAgICAgICBcImFjY291bnRcIiBdLFxuICAgICAgICAgICAgICAgICAgczpcIl8wKF8xKVwiIH0gfSBdLFxuICAgICAgICAgICAgdGFyZ2V0OlwiX2JsYW5rXCIsXG4gICAgICAgICAgICBcImNsYXNzXCI6XCJuby1ob3ZlcmNhcmRcIiB9LFxuICAgICAgICAgIGY6WyB7IHQ6MixcbiAgICAgICAgICAgICAgeDp7IHI6WyBcImFjY291bnQubmFtZVwiLFxuICAgICAgICAgICAgICAgICAgXCJhY2NvdW50LmlkXCIsXG4gICAgICAgICAgICAgICAgICBcImNvcHlcIixcbiAgICAgICAgICAgICAgICAgIFwiYWNjb3VudC5hcGlcIiBdLFxuICAgICAgICAgICAgICAgIHM6XCJfMHx8XzIoXFxcImFjY291bnQtaWQtYXMtbmFtZVxcXCIsXzMsXzEpfHxfMihcXFwiYWNjb3VudC1lbXB0eVxcXCIsXzMpXCIgfSB9IF0gfSxcbiAgICAgICAgXCIgXCIsXG4gICAgICAgIHsgdDo3LFxuICAgICAgICAgIGU6XCJzcGFuXCIsXG4gICAgICAgICAgYTp7IFwiY2xhc3NcIjpbIHsgdDoyLFxuICAgICAgICAgICAgICAgIHg6eyByOlsgXCJhY2NvdW50LnZlcmlmaWVkXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicHJlZml4XCIgXSxcbiAgICAgICAgICAgICAgICAgIHM6XCJfMD9fMShcXFwidmVyaWZpZWRcXFwiKTpcXFwiXFxcIlwiIH0gfSBdIH0gfSBdIH0sXG4gICAgXCIgXCIsXG4gICAgeyB0OjQsXG4gICAgICBmOlsgeyB0OjcsXG4gICAgICAgICAgZTpcImRpdlwiLFxuICAgICAgICAgIGE6eyBcImNsYXNzXCI6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICB4OnsgcjpbIFwicHJlZml4XCIgXSxcbiAgICAgICAgICAgICAgICAgIHM6XCJfMChcXFwiZGVzY3JpcHRpb25cXFwiKVwiIH0gfSxcbiAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgIHsgdDoyLFxuICAgICAgICAgICAgICAgIHg6eyByOlsgXCJkZXNjcmlwdGlvbmV4cGFuZFwiLFxuICAgICAgICAgICAgICAgICAgICBcIl9cIiBdLFxuICAgICAgICAgICAgICAgICAgczpcIl8wP18xLnByZWZpeChcXFwiZXhwYW5kLWRlc2NyaXB0aW9uXFxcIik6XFxcIlxcXCJcIiB9IH0gXSB9LFxuICAgICAgICAgIHY6eyBjbGljazp7IG06XCJzZXRcIixcbiAgICAgICAgICAgICAgYTp7IHI6WyBcImV4cGFuZGVkXCIgXSxcbiAgICAgICAgICAgICAgICBzOlwiW1xcXCJkZXNjcmlwdGlvbmV4cGFuZFxcXCIsXzBdXCIgfSB9IH0sXG4gICAgICAgICAgZjpbIHsgdDo3LFxuICAgICAgICAgICAgICBlOlwicFwiLFxuICAgICAgICAgICAgICBhOnsgXCJjbGFzc1wiOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCJwcmVmaXhcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMChcXFwidGV4dC1jZW50ZXJcXFwiKVwiIH0gfSBdIH0sXG4gICAgICAgICAgICAgIGY6WyB7IHQ6MyxcbiAgICAgICAgICAgICAgICAgIHI6XCJhY2NvdW50LnRleHRcIiB9IF0gfSBdIH0gXSxcbiAgICAgIG46NTAsXG4gICAgICByOlwiYWNjb3VudC50ZXh0XCIgfSxcbiAgICB7IHQ6NyxcbiAgICAgIGU6XCJkaXZcIixcbiAgICAgIGE6eyBcImNsYXNzXCI6WyB7IHQ6MixcbiAgICAgICAgICAgIHg6eyByOlsgXCJwcmVmaXhcIiBdLFxuICAgICAgICAgICAgICBzOlwiXzAoXFxcIm1ldGFcXFwiKVwiIH0gfSxcbiAgICAgICAgICBcIiBcIixcbiAgICAgICAgICB7IHQ6MixcbiAgICAgICAgICAgIHg6eyByOlsgXCJwcmVmaXhcIiBdLFxuICAgICAgICAgICAgICBzOlwiXzAoXFxcImZsZXgtcm93XFxcIilcIiB9IH0gXSB9LFxuICAgICAgZjpbIHsgdDo3LFxuICAgICAgICAgIGU6XCJkaXZcIixcbiAgICAgICAgICBhOnsgXCJjbGFzc1wiOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgeDp7IHI6WyBcInByZWZpeFwiIF0sXG4gICAgICAgICAgICAgICAgICBzOlwiXzAoXFxcIm1ldGEtbWFpblxcXCIpXCIgfSB9IF0gfSxcbiAgICAgICAgICBmOlsgeyB0OjcsXG4gICAgICAgICAgICAgIGU6XCJkaXZcIixcbiAgICAgICAgICAgICAgYTp7IFwiY2xhc3NcIjpbIHsgdDoyLFxuICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwicHJlZml4XCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICBzOlwiXzAoXFxcIm1ldGEtbWFpbi1zdGF0c1xcXCIpXCIgfSB9IF0gfSxcbiAgICAgICAgICAgICAgZjpbIHsgdDo4LFxuICAgICAgICAgICAgICAgICAgcjpcImNvbnRlbnRcIiB9IF0gfSxcbiAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgeyB0OjQsXG4gICAgICAgICAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICAgICAgICAgIGU6XCJkaXZcIixcbiAgICAgICAgICAgICAgICAgIGE6eyBcImNsYXNzXCI6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCJwcmVmaXhcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzOlwiXzAoXFxcIm1ldGEtbWFpbi12YWx1ZVxcXCIpXCIgfSB9IF0gfSxcbiAgICAgICAgICAgICAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICAgICAgICAgICAgICBlOlwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgICAgIGE6eyBcImNsYXNzXCI6WyB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwicHJlZml4XCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMChcXFwiY2xpY2stdG8tdmlld1xcXCIpXCIgfSB9IF0gfSxcbiAgICAgICAgICAgICAgICAgICAgICBmOlsgXCJDbGljayB0byB2aWV3IGZ1bGwgcHJvZmlsZVwiIF0gfSxcbiAgICAgICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgICAgIHsgdDo0LFxuICAgICAgICAgICAgICAgICAgICAgIGY6WyB7IHQ6NyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZTpcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZjpbIFwiKyBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHQ6NyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6XCJpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhOnsgXCJjbGFzc1wiOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwicHJlZml4XCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wKFxcXCJuZXR3b3JrXFxcIilcIiB9IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OnsgcjpbIFwicHJlZml4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhY2NvdW50cy4xLmFwaVwiIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMChfMSlcIiB9IH0gXSB9IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYWNjb3VudC5cIiBdIH0gXSxcbiAgICAgICAgICAgICAgICAgICAgICBuOjUwLFxuICAgICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCJhY2NvdW50cy5sZW5ndGhcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgczpcIl8wPjFcIiB9IH0gXSB9IF0sXG4gICAgICAgICAgICAgIG46NTAsXG4gICAgICAgICAgICAgIHg6eyByOlsgXCJleHBhbmRlZFwiIF0sXG4gICAgICAgICAgICAgICAgczpcIiFfMFwiIH0gfSBdIH0sXG4gICAgICAgIFwiIFwiLFxuICAgICAgICB7IHQ6NyxcbiAgICAgICAgICBlOlwiZGl2XCIsXG4gICAgICAgICAgYTp7IFwiY2xhc3NcIjpbIHsgdDoyLFxuICAgICAgICAgICAgICAgIHg6eyByOlsgXCJwcmVmaXhcIiBdLFxuICAgICAgICAgICAgICAgICAgczpcIl8wKFxcXCJtZXRhLXNpZGVcXFwiKVwiIH0gfSBdIH0sXG4gICAgICAgICAgZjpbIHsgdDo3LFxuICAgICAgICAgICAgICBlOlwiaVwiLFxuICAgICAgICAgICAgICBhOnsgXCJjbGFzc1wiOlsgeyB0OjIsXG4gICAgICAgICAgICAgICAgICAgIHg6eyByOlsgXCJwcmVmaXhcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgIHM6XCJfMChcXFwibmV0d29ya1xcXCIpXCIgfSB9LFxuICAgICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgICB7IHQ6MixcbiAgICAgICAgICAgICAgICAgICAgeDp7IHI6WyBcInByZWZpeFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhY2NvdW50LmFwaVwiIF0sXG4gICAgICAgICAgICAgICAgICAgICAgczpcIl8wKF8xKVwiIH0gfSBdIH0gfSBdIH0gXSB9IF0gfSIsInZhciBjb21wb25lbnQgPSBtb2R1bGU7XG5cblxuXG5jb21wb25lbnQuZXhwb3J0cy50ZW1wbGF0ZSA9IHsgdjozLFxuICB0OlsgeyB0OjcsXG4gICAgICBlOlwiY2F0Y2gtZXJyb3JzXCIsXG4gICAgICBmOlsgeyB0OjQsXG4gICAgICAgICAgZjpbIFwiVGhpcyBiaXRjaCBhaW4ndCBnb3Qgbm8gY29udGVudCFcIiBdLFxuICAgICAgICAgIG46NTAsXG4gICAgICAgICAgeDp7IHI6WyBcIl9cIixcbiAgICAgICAgICAgICAgXCJvYmplY3QuY29udGVudFwiIF0sXG4gICAgICAgICAgICBzOlwiXzAuaXNFbXB0eShfMSlcIiB9IH0sXG4gICAgICAgIHsgdDo0LFxuICAgICAgICAgIG46NTEsXG4gICAgICAgICAgZjpbIHsgdDoxNiB9IF0sXG4gICAgICAgICAgeDp7IHI6WyBcIl9cIixcbiAgICAgICAgICAgICAgXCJvYmplY3QuY29udGVudFwiIF0sXG4gICAgICAgICAgICBzOlwiXzAuaXNFbXB0eShfMSlcIiB9IH0gXSB9IF0gfSIsIi8qXG5cdFJhY3RpdmUuanMgdjAuNy4zXG5cdFNhdCBBcHIgMjUgMjAxNSAxMzo1MjozOCBHTVQtMDQwMCAoRURUKSAtIGNvbW1pdCBkYTQwZjgxYzY2MGJhMmYwOWM0NWEwOWE5YzIwZmRkMzRlZTM2ZDgwXG5cblx0aHR0cDovL3JhY3RpdmVqcy5vcmdcblx0aHR0cDovL3R3aXR0ZXIuY29tL1JhY3RpdmVKU1xuXG5cdFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgZ2xvYmFsLlJhY3RpdmUgPSBmYWN0b3J5KClcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIFRFTVBMQVRFX1ZFUlNJT04gPSAzO1xuXG4gIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcblxuICBcdC8vIHJlbmRlciBwbGFjZW1lbnQ6XG4gIFx0ZWw6IHZvaWQgMCxcbiAgXHRhcHBlbmQ6IGZhbHNlLFxuXG4gIFx0Ly8gdGVtcGxhdGU6XG4gIFx0dGVtcGxhdGU6IHsgdjogVEVNUExBVEVfVkVSU0lPTiwgdDogW10gfSxcblxuICBcdC8vIHBhcnNlOiAgICAgLy8gVE9ETyBzdGF0aWMgZGVsaW1pdGVycz9cbiAgXHRwcmVzZXJ2ZVdoaXRlc3BhY2U6IGZhbHNlLFxuICBcdHNhbml0aXplOiBmYWxzZSxcbiAgXHRzdHJpcENvbW1lbnRzOiB0cnVlLFxuICBcdGRlbGltaXRlcnM6IFtcInt7XCIsIFwifX1cIl0sXG4gIFx0dHJpcGxlRGVsaW1pdGVyczogW1wie3t7XCIsIFwifX19XCJdLFxuICBcdGludGVycG9sYXRlOiBmYWxzZSxcblxuICBcdC8vIGRhdGEgJiBiaW5kaW5nOlxuICBcdGRhdGE6IHt9LFxuICBcdGNvbXB1dGVkOiB7fSxcbiAgXHRtYWdpYzogZmFsc2UsXG4gIFx0bW9kaWZ5QXJyYXlzOiB0cnVlLFxuICBcdGFkYXB0OiBbXSxcbiAgXHRpc29sYXRlZDogZmFsc2UsXG4gIFx0dHdvd2F5OiB0cnVlLFxuICBcdGxhenk6IGZhbHNlLFxuXG4gIFx0Ly8gdHJhbnNpdGlvbnM6XG4gIFx0bm9JbnRybzogZmFsc2UsXG4gIFx0dHJhbnNpdGlvbnNFbmFibGVkOiB0cnVlLFxuICBcdGNvbXBsZXRlOiB2b2lkIDAsXG5cbiAgXHQvLyBjc3M6XG4gIFx0Y3NzOiBudWxsLFxuICBcdG5vQ3NzVHJhbnNmb3JtOiBmYWxzZVxuICB9O1xuXG4gIHZhciBjb25maWdfZGVmYXVsdHMgPSBkZWZhdWx0T3B0aW9ucztcblxuICAvLyBUaGVzZSBhcmUgYSBzdWJzZXQgb2YgdGhlIGVhc2luZyBlcXVhdGlvbnMgZm91bmQgYXRcbiAgLy8gaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9kYW5yby9lYXNpbmctanMgLSBsaWNlbnNlIGluZm9cbiAgLy8gZm9sbG93czpcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBlYXNpbmcuanMgdjAuNS40XG4gIC8vIEdlbmVyaWMgc2V0IG9mIGVhc2luZyBmdW5jdGlvbnMgd2l0aCBBTUQgc3VwcG9ydFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGFucm8vZWFzaW5nLWpzXG4gIC8vIFRoaXMgY29kZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICAvLyBodHRwOi8vZGFucm8ubWl0LWxpY2Vuc2Uub3JnL1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBBbGwgZnVuY3Rpb25zIGFkYXB0ZWQgZnJvbSBUaG9tYXMgRnVjaHMgJiBKZXJlbXkgS2FoblxuICAvLyBFYXNpbmcgRXF1YXRpb25zIChjKSAyMDAzIFJvYmVydCBQZW5uZXIsIEJTRCBsaWNlbnNlXG4gIC8vIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZGFucm8vZWFzaW5nLWpzL21hc3Rlci9MSUNFTlNFXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gSW4gdGhhdCBsaWJyYXJ5LCB0aGUgZnVuY3Rpb25zIG5hbWVkIGVhc2VJbiwgZWFzZU91dCwgYW5kXG4gIC8vIGVhc2VJbk91dCBiZWxvdyBhcmUgbmFtZWQgZWFzZUluQ3ViaWMsIGVhc2VPdXRDdWJpYywgYW5kXG4gIC8vICh5b3UgZ3Vlc3NlZCBpdCkgZWFzZUluT3V0Q3ViaWMuXG4gIC8vXG4gIC8vIFlvdSBjYW4gYWRkIGFkZGl0aW9uYWwgZWFzaW5nIGZ1bmN0aW9ucyB0byB0aGlzIGxpc3QsIGFuZCB0aGV5XG4gIC8vIHdpbGwgYmUgZ2xvYmFsbHkgYXZhaWxhYmxlLlxuXG4gIHZhciBzdGF0aWNfZWFzaW5nID0ge1xuICBcdGxpbmVhcjogZnVuY3Rpb24gKHBvcykge1xuICBcdFx0cmV0dXJuIHBvcztcbiAgXHR9LFxuICBcdGVhc2VJbjogZnVuY3Rpb24gKHBvcykge1xuICBcdFx0cmV0dXJuIE1hdGgucG93KHBvcywgMyk7XG4gIFx0fSxcbiAgXHRlYXNlT3V0OiBmdW5jdGlvbiAocG9zKSB7XG4gIFx0XHRyZXR1cm4gTWF0aC5wb3cocG9zIC0gMSwgMykgKyAxO1xuICBcdH0sXG4gIFx0ZWFzZUluT3V0OiBmdW5jdGlvbiAocG9zKSB7XG4gIFx0XHRpZiAoKHBvcyAvPSAwLjUpIDwgMSkge1xuICBcdFx0XHRyZXR1cm4gMC41ICogTWF0aC5wb3cocG9zLCAzKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiAwLjUgKiAoTWF0aC5wb3cocG9zIC0gMiwgMykgKyAyKTtcbiAgXHR9XG4gIH07XG5cbiAgLypnbG9iYWwgY29uc29sZSwgbmF2aWdhdG9yICovXG4gIHZhciBpc0NsaWVudCwgaXNKc2RvbSwgaGFzQ29uc29sZSwgZW52aXJvbm1lbnRfX21hZ2ljLCBuYW1lc3BhY2VzLCBzdmcsIHZlbmRvcnM7XG5cbiAgaXNDbGllbnQgPSB0eXBlb2YgZG9jdW1lbnQgPT09IFwib2JqZWN0XCI7XG5cbiAgaXNKc2RvbSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgL2pzRG9tLy50ZXN0KG5hdmlnYXRvci5hcHBOYW1lKTtcblxuICBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBjb25zb2xlLndhcm4uYXBwbHkgPT09IFwiZnVuY3Rpb25cIjtcblxuICB0cnkge1xuICBcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJ0ZXN0XCIsIHsgdmFsdWU6IDAgfSk7XG4gIFx0ZW52aXJvbm1lbnRfX21hZ2ljID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICBcdGVudmlyb25tZW50X19tYWdpYyA9IGZhbHNlO1xuICB9XG5cbiAgbmFtZXNwYWNlcyA9IHtcbiAgXHRodG1sOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixcbiAgXHRtYXRobWw6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLFxuICBcdHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICBcdHhsaW5rOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgXHR4bWw6IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gIFx0eG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIlxuICB9O1xuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgXHRzdmcgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgXHRzdmcgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKFwiaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNCYXNpY1N0cnVjdHVyZVwiLCBcIjEuMVwiKTtcbiAgfVxuXG4gIHZlbmRvcnMgPSBbXCJvXCIsIFwibXNcIiwgXCJtb3pcIiwgXCJ3ZWJraXRcIl07XG5cbiAgdmFyIGNyZWF0ZUVsZW1lbnQsIG1hdGNoZXMsIGRvbV9fZGl2LCBtZXRob2ROYW1lcywgdW5wcmVmaXhlZCwgcHJlZml4ZWQsIGRvbV9faSwgaiwgbWFrZUZ1bmN0aW9uO1xuXG4gIC8vIFRlc3QgZm9yIFNWRyBzdXBwb3J0XG4gIGlmICghc3ZnKSB7XG4gIFx0Y3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBucykge1xuICBcdFx0aWYgKG5zICYmIG5zICE9PSBuYW1lc3BhY2VzLmh0bWwpIHtcbiAgXHRcdFx0dGhyb3cgXCJUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBuYW1lc3BhY2VzIG90aGVyIHRoYW4gaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC4gVGhlIG1vc3QgbGlrZWx5IGNhdXNlIG9mIHRoaXMgZXJyb3IgaXMgdGhhdCB5b3UncmUgdHJ5aW5nIHRvIHJlbmRlciBTVkcgaW4gYW4gb2xkZXIgYnJvd3Nlci4gU2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L3N2Zy1hbmQtb2xkZXItYnJvd3NlcnMgZm9yIG1vcmUgaW5mb3JtYXRpb25cIjtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gIFx0fTtcbiAgfSBlbHNlIHtcbiAgXHRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIG5zKSB7XG4gIFx0XHRpZiAoIW5zIHx8IG5zID09PSBuYW1lc3BhY2VzLmh0bWwpIHtcbiAgXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIHR5cGUpO1xuICBcdH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFbGVtZW50KGlucHV0KSB7XG4gIFx0dmFyIG91dHB1dDtcblxuICBcdGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ID09PSBcImJvb2xlYW5cIikge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8ICFkb2N1bWVudCB8fCAhaW5wdXQpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIFdlIGFscmVhZHkgaGF2ZSBhIERPTSBub2RlIC0gbm8gd29yayB0byBkby4gKER1Y2sgdHlwaW5nIGFsZXJ0ISlcbiAgXHRpZiAoaW5wdXQubm9kZVR5cGUpIHtcbiAgXHRcdHJldHVybiBpbnB1dDtcbiAgXHR9XG5cbiAgXHQvLyBHZXQgbm9kZSBmcm9tIHN0cmluZ1xuICBcdGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdC8vIHRyeSBJRCBmaXJzdFxuICBcdFx0b3V0cHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaW5wdXQpO1xuXG4gIFx0XHQvLyB0aGVuIGFzIHNlbGVjdG9yLCBpZiBwb3NzaWJsZVxuICBcdFx0aWYgKCFvdXRwdXQgJiYgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcikge1xuICBcdFx0XHRvdXRwdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGlucHV0KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gZGlkIGl0IHdvcms/XG4gIFx0XHRpZiAob3V0cHV0ICYmIG91dHB1dC5ub2RlVHlwZSkge1xuICBcdFx0XHRyZXR1cm4gb3V0cHV0O1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIElmIHdlJ3ZlIGJlZW4gZ2l2ZW4gYSBjb2xsZWN0aW9uIChqUXVlcnksIFplcHRvIGV0YyksIGV4dHJhY3QgdGhlIGZpcnN0IGl0ZW1cbiAgXHRpZiAoaW5wdXRbMF0gJiYgaW5wdXRbMF0ubm9kZVR5cGUpIHtcbiAgXHRcdHJldHVybiBpbnB1dFswXTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICghaXNDbGllbnQpIHtcbiAgXHRtYXRjaGVzID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgXHRkb21fX2RpdiA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIFx0bWV0aG9kTmFtZXMgPSBbXCJtYXRjaGVzXCIsIFwibWF0Y2hlc1NlbGVjdG9yXCJdO1xuXG4gIFx0bWFrZUZ1bmN0aW9uID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgXHRcdHJldHVybiBmdW5jdGlvbiAobm9kZSwgc2VsZWN0b3IpIHtcbiAgXHRcdFx0cmV0dXJuIG5vZGVbbWV0aG9kTmFtZV0oc2VsZWN0b3IpO1xuICBcdFx0fTtcbiAgXHR9O1xuXG4gIFx0ZG9tX19pID0gbWV0aG9kTmFtZXMubGVuZ3RoO1xuXG4gIFx0d2hpbGUgKGRvbV9faS0tICYmICFtYXRjaGVzKSB7XG4gIFx0XHR1bnByZWZpeGVkID0gbWV0aG9kTmFtZXNbZG9tX19pXTtcblxuICBcdFx0aWYgKGRvbV9fZGl2W3VucHJlZml4ZWRdKSB7XG4gIFx0XHRcdG1hdGNoZXMgPSBtYWtlRnVuY3Rpb24odW5wcmVmaXhlZCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRqID0gdmVuZG9ycy5sZW5ndGg7XG4gIFx0XHRcdHdoaWxlIChqLS0pIHtcbiAgXHRcdFx0XHRwcmVmaXhlZCA9IHZlbmRvcnNbZG9tX19pXSArIHVucHJlZml4ZWQuc3Vic3RyKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyB1bnByZWZpeGVkLnN1YnN0cmluZygxKTtcblxuICBcdFx0XHRcdGlmIChkb21fX2RpdltwcmVmaXhlZF0pIHtcbiAgXHRcdFx0XHRcdG1hdGNoZXMgPSBtYWtlRnVuY3Rpb24ocHJlZml4ZWQpO1xuICBcdFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gSUU4Li4uXG4gIFx0aWYgKCFtYXRjaGVzKSB7XG4gIFx0XHRtYXRjaGVzID0gZnVuY3Rpb24gKG5vZGUsIHNlbGVjdG9yKSB7XG4gIFx0XHRcdHZhciBub2RlcywgcGFyZW50Tm9kZSwgaTtcblxuICBcdFx0XHRwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXG4gIFx0XHRcdGlmICghcGFyZW50Tm9kZSkge1xuICBcdFx0XHRcdC8vIGVtcHR5IGR1bW15IDxkaXY+XG4gIFx0XHRcdFx0ZG9tX19kaXYuaW5uZXJIVE1MID0gXCJcIjtcblxuICBcdFx0XHRcdHBhcmVudE5vZGUgPSBkb21fX2RpdjtcbiAgXHRcdFx0XHRub2RlID0gbm9kZS5jbG9uZU5vZGUoKTtcblxuICBcdFx0XHRcdGRvbV9fZGl2LmFwcGVuZENoaWxkKG5vZGUpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0bm9kZXMgPSBwYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuXG4gIFx0XHRcdGkgPSBub2Rlcy5sZW5ndGg7XG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRpZiAobm9kZXNbaV0gPT09IG5vZGUpIHtcbiAgXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH07XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0YWNoTm9kZShub2RlKSB7XG4gIFx0aWYgKG5vZGUgJiYgdHlwZW9mIG5vZGUucGFyZW50Tm9kZSAhPT0gXCJ1bmtub3duXCIgJiYgbm9kZS5wYXJlbnROb2RlKSB7XG4gIFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBzYWZlVG9TdHJpbmdWYWx1ZSh2YWx1ZSkge1xuICBcdHJldHVybiB2YWx1ZSA9PSBudWxsIHx8ICF2YWx1ZS50b1N0cmluZyA/IFwiXCIgOiB2YWx1ZTtcbiAgfVxuXG4gIHZhciBsZWdhY3kgPSBudWxsO1xuXG4gIHZhciBjcmVhdGUsIGRlZmluZVByb3BlcnR5LCBkZWZpbmVQcm9wZXJ0aWVzO1xuXG4gIHRyeSB7XG4gIFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInRlc3RcIiwgeyB2YWx1ZTogMCB9KTtcblxuICBcdGlmIChpc0NsaWVudCkge1xuICBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIFwidGVzdFwiLCB7IHZhbHVlOiAwIH0pO1xuICBcdH1cblxuICBcdGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgXHQvLyBPYmplY3QuZGVmaW5lUHJvcGVydHkgZG9lc24ndCBleGlzdCwgb3Igd2UncmUgaW4gSUU4IHdoZXJlIHlvdSBjYW5cbiAgXHQvLyBvbmx5IHVzZSBpdCB3aXRoIERPTSBvYmplY3RzICh3aGF0IHdlcmUgeW91IHNtb2tpbmcsIE1TRlQ/KVxuICBcdGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgZGVzYykge1xuICBcdFx0b2JqW3Byb3BdID0gZGVzYy52YWx1ZTtcbiAgXHR9O1xuICB9XG5cbiAgdHJ5IHtcbiAgXHR0cnkge1xuICBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoe30sIHsgdGVzdDogeyB2YWx1ZTogMCB9IH0pO1xuICBcdH0gY2F0Y2ggKGVycikge1xuICBcdFx0Ly8gVE9ETyBob3cgZG8gd2UgYWNjb3VudCBmb3IgdGhpcz8gbm9NYWdpYyA9IHRydWU7XG4gIFx0XHR0aHJvdyBlcnI7XG4gIFx0fVxuXG4gIFx0aWYgKGlzQ2xpZW50KSB7XG4gIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjcmVhdGVFbGVtZW50KFwiZGl2XCIpLCB7IHRlc3Q6IHsgdmFsdWU6IDAgfSB9KTtcbiAgXHR9XG5cbiAgXHRkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG4gIH0gY2F0Y2ggKGVycikge1xuICBcdGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqLCBwcm9wcykge1xuICBcdFx0dmFyIHByb3A7XG5cbiAgXHRcdGZvciAocHJvcCBpbiBwcm9wcykge1xuICBcdFx0XHRpZiAocHJvcHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgXHRcdFx0XHRkZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHByb3BzW3Byb3BdKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICB0cnkge1xuICBcdE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgXHRjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgXHQvLyBzaWdoXG4gIFx0Y3JlYXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBGID0gZnVuY3Rpb24gKCkge307XG5cbiAgXHRcdHJldHVybiBmdW5jdGlvbiAocHJvdG8sIHByb3BzKSB7XG4gIFx0XHRcdHZhciBvYmo7XG5cbiAgXHRcdFx0aWYgKHByb3RvID09PSBudWxsKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHt9O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ri5wcm90b3R5cGUgPSBwcm90bztcbiAgXHRcdFx0b2JqID0gbmV3IEYoKTtcblxuICBcdFx0XHRpZiAocHJvcHMpIHtcbiAgXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmosIHByb3BzKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBvYmo7XG4gIFx0XHR9O1xuICBcdH0pKCk7XG4gIH1cblxuICBmdW5jdGlvbiB1dGlsc19vYmplY3RfX2V4dGVuZCh0YXJnZXQpIHtcbiAgXHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdHNvdXJjZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICBcdH1cblxuICBcdHZhciBwcm9wLCBzb3VyY2U7XG5cbiAgXHR3aGlsZSAoc291cmNlID0gc291cmNlcy5zaGlmdCgpKSB7XG4gIFx0XHRmb3IgKHByb3AgaW4gc291cmNlKSB7XG4gIFx0XHRcdGlmIChoYXNPd24uY2FsbChzb3VyY2UsIHByb3ApKSB7XG4gIFx0XHRcdFx0dGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGxHYXBzKHRhcmdldCkge1xuICBcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICBcdFx0c291cmNlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIFx0fVxuXG4gIFx0c291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gcykge1xuICBcdFx0XHRpZiAocy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgXHRcdFx0XHR0YXJnZXRba2V5XSA9IHNba2V5XTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0pO1xuXG4gIFx0cmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIC8vIHRoYW5rcywgaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vaW5zdGFuY2VvZi1jb25zaWRlcmVkLWhhcm1mdWwtb3ItaG93LXRvLXdyaXRlLWEtcm9idXN0LWlzYXJyYXkvXG4gIHZhciBpc19fdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgYXJyYXlMaWtlUGF0dGVybiA9IC9eXFxbb2JqZWN0ICg/OkFycmF5fEZpbGVMaXN0KVxcXSQvO1xuICBmdW5jdGlvbiBpc0FycmF5KHRoaW5nKSB7XG4gIFx0cmV0dXJuIGlzX190b1N0cmluZy5jYWxsKHRoaW5nKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNBcnJheUxpa2Uob2JqKSB7XG4gIFx0cmV0dXJuIGFycmF5TGlrZVBhdHRlcm4udGVzdChpc19fdG9TdHJpbmcuY2FsbChvYmopKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xuICBcdGlmIChhID09PSBudWxsICYmIGIgPT09IG51bGwpIHtcbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cblxuICBcdGlmICh0eXBlb2YgYSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgYiA9PT0gXCJvYmplY3RcIikge1xuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH1cblxuICBcdHJldHVybiBhID09PSBiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNfX2lzTnVtZXJpYyh0aGluZykge1xuICBcdHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdCh0aGluZykpICYmIGlzRmluaXRlKHRoaW5nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT2JqZWN0KHRoaW5nKSB7XG4gIFx0cmV0dXJuIHRoaW5nICYmIGlzX190b1N0cmluZy5jYWxsKHRoaW5nKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbiAgfVxuXG4gIHZhciBub29wID0gZnVuY3Rpb24gKCkge307XG5cbiAgLyogZ2xvYmFsIGNvbnNvbGUgKi9cbiAgdmFyIGFscmVhZHlXYXJuZWQgPSB7fSxcbiAgICAgIGxvZyxcbiAgICAgIHByaW50V2FybmluZyxcbiAgICAgIHdlbGNvbWU7XG5cbiAgaWYgKGhhc0NvbnNvbGUpIHtcbiAgXHQoZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHdlbGNvbWVJbnRybyA9IFtcIiVjUmFjdGl2ZS5qcyAlYzAuNy4zICVjaW4gZGVidWcgbW9kZSwgJWNtb3JlLi4uXCIsIFwiY29sb3I6IHJnYigxMTQsIDE1NywgNTIpOyBmb250LXdlaWdodDogbm9ybWFsO1wiLCBcImNvbG9yOiByZ2IoODUsIDg1LCA4NSk7IGZvbnQtd2VpZ2h0OiBub3JtYWw7XCIsIFwiY29sb3I6IHJnYig4NSwgODUsIDg1KTsgZm9udC13ZWlnaHQ6IG5vcm1hbDtcIiwgXCJjb2xvcjogcmdiKDgyLCAxNDAsIDIyNCk7IGZvbnQtd2VpZ2h0OiBub3JtYWw7IHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1wiXTtcbiAgXHRcdHZhciB3ZWxjb21lTWVzc2FnZSA9IFwiWW91J3JlIHJ1bm5pbmcgUmFjdGl2ZSAwLjcuMyBpbiBkZWJ1ZyBtb2RlIC0gbWVzc2FnZXMgd2lsbCBiZSBwcmludGVkIHRvIHRoZSBjb25zb2xlIHRvIGhlbHAgeW91IGZpeCBwcm9ibGVtcyBhbmQgb3B0aW1pc2UgeW91ciBhcHBsaWNhdGlvbi5cXG5cXG5UbyBkaXNhYmxlIGRlYnVnIG1vZGUsIGFkZCB0aGlzIGxpbmUgYXQgdGhlIHN0YXJ0IG9mIHlvdXIgYXBwOlxcbiAgUmFjdGl2ZS5ERUJVRyA9IGZhbHNlO1xcblxcblRvIGRpc2FibGUgZGVidWcgbW9kZSB3aGVuIHlvdXIgYXBwIGlzIG1pbmlmaWVkLCBhZGQgdGhpcyBzbmlwcGV0OlxcbiAgUmFjdGl2ZS5ERUJVRyA9IC91bm1pbmlmaWVkLy50ZXN0KGZ1bmN0aW9uKCl7Lyp1bm1pbmlmaWVkKi99KTtcXG5cXG5HZXQgaGVscCBhbmQgc3VwcG9ydDpcXG4gIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmdcXG4gIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvdGFnZ2VkL3JhY3RpdmVqc1xcbiAgaHR0cDovL2dyb3Vwcy5nb29nbGUuY29tL2ZvcnVtLyMhZm9ydW0vcmFjdGl2ZS1qc1xcbiAgaHR0cDovL3R3aXR0ZXIuY29tL3JhY3RpdmVqc1xcblxcbkZvdW5kIGEgYnVnPyBSYWlzZSBhbiBpc3N1ZTpcXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXNcXG5cXG5cIjtcblxuICBcdFx0d2VsY29tZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dmFyIGhhc0dyb3VwID0gISFjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICBcdFx0XHRjb25zb2xlW2hhc0dyb3VwID8gXCJncm91cENvbGxhcHNlZFwiIDogXCJsb2dcIl0uYXBwbHkoY29uc29sZSwgd2VsY29tZUludHJvKTtcbiAgXHRcdFx0Y29uc29sZS5sb2cod2VsY29tZU1lc3NhZ2UpO1xuICBcdFx0XHRpZiAoaGFzR3JvdXApIHtcbiAgXHRcdFx0XHRjb25zb2xlLmdyb3VwRW5kKHdlbGNvbWVJbnRybyk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR3ZWxjb21lID0gbm9vcDtcbiAgXHRcdH07XG5cbiAgXHRcdHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChtZXNzYWdlLCBhcmdzKSB7XG4gIFx0XHRcdHdlbGNvbWUoKTtcblxuICBcdFx0XHQvLyBleHRyYWN0IGluZm9ybWF0aW9uIGFib3V0IHRoZSBpbnN0YW5jZSB0aGlzIG1lc3NhZ2UgcGVydGFpbnMgdG8sIGlmIGFwcGxpY2FibGVcbiAgXHRcdFx0aWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdFx0XHR2YXIgb3B0aW9ucyA9IGFyZ3MucG9wKCk7XG4gIFx0XHRcdFx0dmFyIHJhY3RpdmUgPSBvcHRpb25zID8gb3B0aW9ucy5yYWN0aXZlIDogbnVsbDtcblxuICBcdFx0XHRcdGlmIChyYWN0aXZlKSB7XG4gIFx0XHRcdFx0XHQvLyBpZiB0aGlzIGlzIGFuIGluc3RhbmNlIG9mIGEgY29tcG9uZW50IHRoYXQgd2Uga25vdyB0aGUgbmFtZSBvZiwgYWRkXG4gIFx0XHRcdFx0XHQvLyBpdCB0byB0aGUgbWVzc2FnZVxuICBcdFx0XHRcdFx0dmFyIF9uYW1lID0gdW5kZWZpbmVkO1xuICBcdFx0XHRcdFx0aWYgKHJhY3RpdmUuY29tcG9uZW50ICYmIChfbmFtZSA9IHJhY3RpdmUuY29tcG9uZW50Lm5hbWUpKSB7XG4gIFx0XHRcdFx0XHRcdG1lc3NhZ2UgPSBcIjxcIiArIF9uYW1lICsgXCI+IFwiICsgbWVzc2FnZTtcbiAgXHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0dmFyIG5vZGUgPSB1bmRlZmluZWQ7XG4gIFx0XHRcdFx0XHRpZiAobm9kZSA9IG9wdGlvbnMubm9kZSB8fCByYWN0aXZlLmZyYWdtZW50ICYmIHJhY3RpdmUuZnJhZ21lbnQucmVuZGVyZWQgJiYgcmFjdGl2ZS5maW5kKFwiKlwiKSkge1xuICBcdFx0XHRcdFx0XHRhcmdzLnB1c2gobm9kZSk7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0Y29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIFtcIiVjUmFjdGl2ZS5qczogJWNcIiArIG1lc3NhZ2UsIFwiY29sb3I6IHJnYigxMTQsIDE1NywgNTIpO1wiLCBcImNvbG9yOiByZ2IoODUsIDg1LCA4NSk7XCJdLmNvbmNhdChhcmdzKSk7XG4gIFx0XHR9O1xuXG4gIFx0XHRsb2cgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gIFx0XHR9O1xuICBcdH0pKCk7XG4gIH0gZWxzZSB7XG4gIFx0cHJpbnRXYXJuaW5nID0gbG9nID0gd2VsY29tZSA9IG5vb3A7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXQobWVzc2FnZSwgYXJncykge1xuICBcdHJldHVybiBtZXNzYWdlLnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBhcmdzLnNoaWZ0KCk7XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiBmYXRhbChtZXNzYWdlKSB7XG4gIFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgXHR9XG5cbiAgXHRtZXNzYWdlID0gZm9ybWF0KG1lc3NhZ2UsIGFyZ3MpO1xuICBcdHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvZ0lmRGVidWcoKSB7XG4gIFx0aWYgKF9SYWN0aXZlLkRFQlVHKSB7XG4gIFx0XHRsb2cuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuKG1lc3NhZ2UpIHtcbiAgXHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICBcdH1cblxuICBcdG1lc3NhZ2UgPSBmb3JtYXQobWVzc2FnZSwgYXJncyk7XG4gIFx0cHJpbnRXYXJuaW5nKG1lc3NhZ2UsIGFyZ3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UobWVzc2FnZSkge1xuICBcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICBcdFx0YXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIFx0fVxuXG4gIFx0bWVzc2FnZSA9IGZvcm1hdChtZXNzYWdlLCBhcmdzKTtcblxuICBcdGlmIChhbHJlYWR5V2FybmVkW21lc3NhZ2VdKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0YWxyZWFkeVdhcm5lZFttZXNzYWdlXSA9IHRydWU7XG4gIFx0cHJpbnRXYXJuaW5nKG1lc3NhZ2UsIGFyZ3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FybklmRGVidWcoKSB7XG4gIFx0aWYgKF9SYWN0aXZlLkRFQlVHKSB7XG4gIFx0XHR3YXJuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2VJZkRlYnVnKCkge1xuICBcdGlmIChfUmFjdGl2ZS5ERUJVRykge1xuICBcdFx0d2Fybk9uY2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgXHR9XG4gIH1cblxuICAvLyBFcnJvciBtZXNzYWdlcyB0aGF0IGFyZSB1c2VkIChvciBjb3VsZCBiZSkgaW4gbXVsdGlwbGUgcGxhY2VzXG4gIHZhciBiYWRBcmd1bWVudHMgPSBcIkJhZCBhcmd1bWVudHNcIjtcbiAgdmFyIG5vUmVnaXN0cnlGdW5jdGlvblJldHVybiA9IFwiQSBmdW5jdGlvbiB3YXMgc3BlY2lmaWVkIGZvciBcXFwiJXNcXFwiICVzLCBidXQgbm8gJXMgd2FzIHJldHVybmVkXCI7XG4gIHZhciBtaXNzaW5nUGx1Z2luID0gZnVuY3Rpb24gKG5hbWUsIHR5cGUpIHtcbiAgICByZXR1cm4gXCJNaXNzaW5nIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgXCIgKyB0eXBlICsgXCIgcGx1Z2luLiBZb3UgbWF5IG5lZWQgdG8gZG93bmxvYWQgYSBwbHVnaW4gdmlhIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L3BsdWdpbnMjXCIgKyB0eXBlICsgXCJzXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gZmluZEluVmlld0hpZXJhcmNoeShyZWdpc3RyeU5hbWUsIHJhY3RpdmUsIG5hbWUpIHtcbiAgXHR2YXIgaW5zdGFuY2UgPSBmaW5kSW5zdGFuY2UocmVnaXN0cnlOYW1lLCByYWN0aXZlLCBuYW1lKTtcbiAgXHRyZXR1cm4gaW5zdGFuY2UgPyBpbnN0YW5jZVtyZWdpc3RyeU5hbWVdW25hbWVdIDogbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRJbnN0YW5jZShyZWdpc3RyeU5hbWUsIHJhY3RpdmUsIG5hbWUpIHtcbiAgXHR3aGlsZSAocmFjdGl2ZSkge1xuICBcdFx0aWYgKG5hbWUgaW4gcmFjdGl2ZVtyZWdpc3RyeU5hbWVdKSB7XG4gIFx0XHRcdHJldHVybiByYWN0aXZlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAocmFjdGl2ZS5pc29sYXRlZCkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmFjdGl2ZSA9IHJhY3RpdmUucGFyZW50O1xuICBcdH1cbiAgfVxuXG4gIHZhciBpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIChmcm9tLCB0bywgcmFjdGl2ZSwgdHlwZSkge1xuICBcdGlmIChmcm9tID09PSB0bykge1xuICBcdFx0cmV0dXJuIHNuYXAodG8pO1xuICBcdH1cblxuICBcdGlmICh0eXBlKSB7XG5cbiAgXHRcdHZhciBpbnRlcnBvbCA9IGZpbmRJblZpZXdIaWVyYXJjaHkoXCJpbnRlcnBvbGF0b3JzXCIsIHJhY3RpdmUsIHR5cGUpO1xuICBcdFx0aWYgKGludGVycG9sKSB7XG4gIFx0XHRcdHJldHVybiBpbnRlcnBvbChmcm9tLCB0bykgfHwgc25hcCh0byk7XG4gIFx0XHR9XG5cbiAgXHRcdGZhdGFsKG1pc3NpbmdQbHVnaW4odHlwZSwgXCJpbnRlcnBvbGF0b3JcIikpO1xuICBcdH1cblxuICBcdHJldHVybiBzdGF0aWNfaW50ZXJwb2xhdG9ycy5udW1iZXIoZnJvbSwgdG8pIHx8IHN0YXRpY19pbnRlcnBvbGF0b3JzLmFycmF5KGZyb20sIHRvKSB8fCBzdGF0aWNfaW50ZXJwb2xhdG9ycy5vYmplY3QoZnJvbSwgdG8pIHx8IHNuYXAodG8pO1xuICB9O1xuXG4gIHZhciBzaGFyZWRfaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZTtcblxuICBmdW5jdGlvbiBzbmFwKHRvKSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0bztcbiAgXHR9O1xuICB9XG5cbiAgdmFyIGludGVycG9sYXRvcnMgPSB7XG4gIFx0bnVtYmVyOiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgXHRcdHZhciBkZWx0YTtcblxuICBcdFx0aWYgKCFpc19faXNOdW1lcmljKGZyb20pIHx8ICFpc19faXNOdW1lcmljKHRvKSkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0ZnJvbSA9ICtmcm9tO1xuICBcdFx0dG8gPSArdG87XG5cbiAgXHRcdGRlbHRhID0gdG8gLSBmcm9tO1xuXG4gIFx0XHRpZiAoIWRlbHRhKSB7XG4gIFx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGZyb207XG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBmdW5jdGlvbiAodCkge1xuICBcdFx0XHRyZXR1cm4gZnJvbSArIHQgKiBkZWx0YTtcbiAgXHRcdH07XG4gIFx0fSxcblxuICBcdGFycmF5OiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgXHRcdHZhciBpbnRlcm1lZGlhdGUsIGludGVycG9sYXRvcnMsIGxlbiwgaTtcblxuICBcdFx0aWYgKCFpc0FycmF5KGZyb20pIHx8ICFpc0FycmF5KHRvKSkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0aW50ZXJtZWRpYXRlID0gW107XG4gIFx0XHRpbnRlcnBvbGF0b3JzID0gW107XG5cbiAgXHRcdGkgPSBsZW4gPSBNYXRoLm1pbihmcm9tLmxlbmd0aCwgdG8ubGVuZ3RoKTtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0aW50ZXJwb2xhdG9yc1tpXSA9IHNoYXJlZF9pbnRlcnBvbGF0ZShmcm9tW2ldLCB0b1tpXSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHN1cnBsdXMgdmFsdWVzIC0gZG9uJ3QgaW50ZXJwb2xhdGUsIGJ1dCBkb24ndCBleGNsdWRlIHRoZW0gZWl0aGVyXG4gIFx0XHRmb3IgKGkgPSBsZW47IGkgPCBmcm9tLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRcdGludGVybWVkaWF0ZVtpXSA9IGZyb21baV07XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAoaSA9IGxlbjsgaSA8IHRvLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRcdGludGVybWVkaWF0ZVtpXSA9IHRvW2ldO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgXHRcdFx0dmFyIGkgPSBsZW47XG5cbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdGludGVybWVkaWF0ZVtpXSA9IGludGVycG9sYXRvcnNbaV0odCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gaW50ZXJtZWRpYXRlO1xuICBcdFx0fTtcbiAgXHR9LFxuXG4gIFx0b2JqZWN0OiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgXHRcdHZhciBwcm9wZXJ0aWVzLCBsZW4sIGludGVycG9sYXRvcnMsIGludGVybWVkaWF0ZSwgcHJvcDtcblxuICBcdFx0aWYgKCFpc09iamVjdChmcm9tKSB8fCAhaXNPYmplY3QodG8pKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRwcm9wZXJ0aWVzID0gW107XG4gIFx0XHRpbnRlcm1lZGlhdGUgPSB7fTtcbiAgXHRcdGludGVycG9sYXRvcnMgPSB7fTtcblxuICBcdFx0Zm9yIChwcm9wIGluIGZyb20pIHtcbiAgXHRcdFx0aWYgKGhhc093bi5jYWxsKGZyb20sIHByb3ApKSB7XG4gIFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKHRvLCBwcm9wKSkge1xuICBcdFx0XHRcdFx0cHJvcGVydGllcy5wdXNoKHByb3ApO1xuICBcdFx0XHRcdFx0aW50ZXJwb2xhdG9yc1twcm9wXSA9IHNoYXJlZF9pbnRlcnBvbGF0ZShmcm9tW3Byb3BdLCB0b1twcm9wXSk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdGludGVybWVkaWF0ZVtwcm9wXSA9IGZyb21bcHJvcF07XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAocHJvcCBpbiB0bykge1xuICBcdFx0XHRpZiAoaGFzT3duLmNhbGwodG8sIHByb3ApICYmICFoYXNPd24uY2FsbChmcm9tLCBwcm9wKSkge1xuICBcdFx0XHRcdGludGVybWVkaWF0ZVtwcm9wXSA9IHRvW3Byb3BdO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGxlbiA9IHByb3BlcnRpZXMubGVuZ3RoO1xuXG4gIFx0XHRyZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgXHRcdFx0dmFyIGkgPSBsZW4sXG4gIFx0XHRcdCAgICBwcm9wO1xuXG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRwcm9wID0gcHJvcGVydGllc1tpXTtcblxuICBcdFx0XHRcdGludGVybWVkaWF0ZVtwcm9wXSA9IGludGVycG9sYXRvcnNbcHJvcF0odCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gaW50ZXJtZWRpYXRlO1xuICBcdFx0fTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIHN0YXRpY19pbnRlcnBvbGF0b3JzID0gaW50ZXJwb2xhdG9ycztcblxuICAvLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGEga2V5cGF0aCBzdWNoIGFzICdmb28uYmFyLmJheicsIGFuZCByZXR1cm5zXG4gIC8vIGFsbCB0aGUgdmFyaWFudHMgb2YgdGhhdCBrZXlwYXRoIHRoYXQgaW5jbHVkZSBhIHdpbGRjYXJkIGluIHBsYWNlXG4gIC8vIG9mIGEga2V5LCBzdWNoIGFzICdmb28uYmFyLionLCAnZm9vLiouYmF6JywgJ2Zvby4qLionIGFuZCBzbyBvbi5cbiAgLy8gVGhlc2UgYXJlIHRoZW4gY2hlY2tlZCBhZ2FpbnN0IHRoZSBkZXBlbmRhbnRzIG1hcCAocmFjdGl2ZS52aWV3bW9kZWwuZGVwc01hcClcbiAgLy8gdG8gc2VlIGlmIGFueSBwYXR0ZXJuIG9ic2VydmVycyBhcmUgZG93bnN0cmVhbSBvZiBvbmUgb3IgbW9yZSBvZlxuICAvLyB0aGVzZSB3aWxkY2FyZCBrZXlwYXRocyAoZS5nLiAnZm9vLmJhci4qLnN0YXR1cycpXG4gIHZhciB1dGlsc19nZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMgPSBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXM7XG5cbiAgdmFyIHN0YXJNYXBzID0ge307XG4gIGZ1bmN0aW9uIGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyhrZXlwYXRoKSB7XG4gIFx0dmFyIGtleXMsIHN0YXJNYXAsIG1hcHBlciwgaSwgcmVzdWx0LCB3aWxkY2FyZEtleXBhdGg7XG5cbiAgXHRrZXlzID0ga2V5cGF0aC5zcGxpdChcIi5cIik7XG4gIFx0aWYgKCEoc3Rhck1hcCA9IHN0YXJNYXBzW2tleXMubGVuZ3RoXSkpIHtcbiAgXHRcdHN0YXJNYXAgPSBnZXRTdGFyTWFwKGtleXMubGVuZ3RoKTtcbiAgXHR9XG5cbiAgXHRyZXN1bHQgPSBbXTtcblxuICBcdG1hcHBlciA9IGZ1bmN0aW9uIChzdGFyLCBpKSB7XG4gIFx0XHRyZXR1cm4gc3RhciA/IFwiKlwiIDoga2V5c1tpXTtcbiAgXHR9O1xuXG4gIFx0aSA9IHN0YXJNYXAubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdHdpbGRjYXJkS2V5cGF0aCA9IHN0YXJNYXBbaV0ubWFwKG1hcHBlcikuam9pbihcIi5cIik7XG5cbiAgXHRcdGlmICghcmVzdWx0Lmhhc093blByb3BlcnR5KHdpbGRjYXJkS2V5cGF0aCkpIHtcbiAgXHRcdFx0cmVzdWx0LnB1c2god2lsZGNhcmRLZXlwYXRoKTtcbiAgXHRcdFx0cmVzdWx0W3dpbGRjYXJkS2V5cGF0aF0gPSB0cnVlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYWxsIHRoZSBwb3NzaWJsZSB0cnVlL2ZhbHNlIGNvbWJpbmF0aW9ucyBmb3JcbiAgLy8gYSBnaXZlbiBudW1iZXIgLSBlLmcuIGZvciB0d28sIHRoZSBwb3NzaWJsZSBjb21iaW5hdGlvbnMgYXJlXG4gIC8vIFsgdHJ1ZSwgdHJ1ZSBdLCBbIHRydWUsIGZhbHNlIF0sIFsgZmFsc2UsIHRydWUgXSwgWyBmYWxzZSwgZmFsc2UgXS5cbiAgLy8gSXQgZG9lcyBzbyBieSBnZXR0aW5nIGFsbCB0aGUgYmluYXJ5IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIGUuZy4gMTFcbiAgZnVuY3Rpb24gZ2V0U3Rhck1hcChudW0pIHtcbiAgXHR2YXIgb25lcyA9IFwiXCIsXG4gIFx0ICAgIG1heCxcbiAgXHQgICAgYmluYXJ5LFxuICBcdCAgICBzdGFyTWFwLFxuICBcdCAgICBtYXBwZXIsXG4gIFx0ICAgIGksXG4gIFx0ICAgIGosXG4gIFx0ICAgIGwsXG4gIFx0ICAgIG1hcDtcblxuICBcdGlmICghc3Rhck1hcHNbbnVtXSkge1xuICBcdFx0c3Rhck1hcCA9IFtdO1xuXG4gIFx0XHR3aGlsZSAob25lcy5sZW5ndGggPCBudW0pIHtcbiAgXHRcdFx0b25lcyArPSAxO1xuICBcdFx0fVxuXG4gIFx0XHRtYXggPSBwYXJzZUludChvbmVzLCAyKTtcblxuICBcdFx0bWFwcGVyID0gZnVuY3Rpb24gKGRpZ2l0KSB7XG4gIFx0XHRcdHJldHVybiBkaWdpdCA9PT0gXCIxXCI7XG4gIFx0XHR9O1xuXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDw9IG1heDsgaSArPSAxKSB7XG4gIFx0XHRcdGJpbmFyeSA9IGkudG9TdHJpbmcoMik7XG4gIFx0XHRcdHdoaWxlIChiaW5hcnkubGVuZ3RoIDwgbnVtKSB7XG4gIFx0XHRcdFx0YmluYXJ5ID0gXCIwXCIgKyBiaW5hcnk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRtYXAgPSBbXTtcbiAgXHRcdFx0bCA9IGJpbmFyeS5sZW5ndGg7XG4gIFx0XHRcdGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgXHRcdFx0XHRtYXAucHVzaChtYXBwZXIoYmluYXJ5W2pdKSk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0c3Rhck1hcFtpXSA9IG1hcDtcbiAgXHRcdH1cblxuICBcdFx0c3Rhck1hcHNbbnVtXSA9IHN0YXJNYXA7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHN0YXJNYXBzW251bV07XG4gIH1cblxuICB2YXIgcmVmUGF0dGVybiA9IC9cXFtcXHMqKFxcKnxbMC05XXxbMS05XVswLTldKylcXHMqXFxdL2c7XG4gIHZhciBwYXR0ZXJuUGF0dGVybiA9IC9cXCovO1xuICB2YXIga2V5cGF0aENhY2hlID0ge307XG5cbiAgdmFyIEtleXBhdGggPSBmdW5jdGlvbiAoc3RyKSB7XG4gIFx0dmFyIGtleXMgPSBzdHIuc3BsaXQoXCIuXCIpO1xuXG4gIFx0dGhpcy5zdHIgPSBzdHI7XG5cbiAgXHRpZiAoc3RyWzBdID09PSBcIkBcIikge1xuICBcdFx0dGhpcy5pc1NwZWNpYWwgPSB0cnVlO1xuICBcdFx0dGhpcy52YWx1ZSA9IGRlY29kZUtleXBhdGgoc3RyKTtcbiAgXHR9XG5cbiAgXHR0aGlzLmZpcnN0S2V5ID0ga2V5c1swXTtcbiAgXHR0aGlzLmxhc3RLZXkgPSBrZXlzLnBvcCgpO1xuXG4gIFx0dGhpcy5pc1BhdHRlcm4gPSBwYXR0ZXJuUGF0dGVybi50ZXN0KHN0cik7XG5cbiAgXHR0aGlzLnBhcmVudCA9IHN0ciA9PT0gXCJcIiA/IG51bGwgOiBnZXRLZXlwYXRoKGtleXMuam9pbihcIi5cIikpO1xuICBcdHRoaXMuaXNSb290ID0gIXN0cjtcbiAgfTtcblxuICBLZXlwYXRoLnByb3RvdHlwZSA9IHtcbiAgXHRlcXVhbHNPclN0YXJ0c1dpdGg6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRyZXR1cm4ga2V5cGF0aCA9PT0gdGhpcyB8fCB0aGlzLnN0YXJ0c1dpdGgoa2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdGpvaW46IGZ1bmN0aW9uIChzdHIpIHtcbiAgXHRcdHJldHVybiBnZXRLZXlwYXRoKHRoaXMuaXNSb290ID8gU3RyaW5nKHN0cikgOiB0aGlzLnN0ciArIFwiLlwiICsgc3RyKTtcbiAgXHR9LFxuXG4gIFx0cmVwbGFjZTogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdGlmICh0aGlzID09PSBvbGRLZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiBuZXdLZXlwYXRoO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5zdGFydHNXaXRoKG9sZEtleXBhdGgpKSB7XG4gIFx0XHRcdHJldHVybiBuZXdLZXlwYXRoID09PSBudWxsID8gbmV3S2V5cGF0aCA6IGdldEtleXBhdGgodGhpcy5zdHIucmVwbGFjZShvbGRLZXlwYXRoLnN0ciArIFwiLlwiLCBuZXdLZXlwYXRoLnN0ciArIFwiLlwiKSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRpZiAoIWtleXBhdGgpIHtcbiAgXHRcdFx0Ly8gVE9ETyB1bmRlciB3aGF0IGNpcmN1bXN0YW5jZXMgZG9lcyB0aGlzIGhhcHBlbj9cbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ga2V5cGF0aCAmJiB0aGlzLnN0ci5zdWJzdHIoMCwga2V5cGF0aC5zdHIubGVuZ3RoICsgMSkgPT09IGtleXBhdGguc3RyICsgXCIuXCI7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJCYWQgY29lcmNpb25cIik7XG4gIFx0fSxcblxuICBcdHZhbHVlT2Y6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkJhZCBjb2VyY2lvblwiKTtcbiAgXHR9LFxuXG4gIFx0d2lsZGNhcmRNYXRjaGVzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fd2lsZGNhcmRNYXRjaGVzIHx8ICh0aGlzLl93aWxkY2FyZE1hdGNoZXMgPSB1dGlsc19nZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXModGhpcy5zdHIpKTtcbiAgXHR9XG4gIH07XG4gIGZ1bmN0aW9uIGFzc2lnbk5ld0tleXBhdGgodGFyZ2V0LCBwcm9wZXJ0eSwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdHZhciBleGlzdGluZ0tleXBhdGggPSB0YXJnZXRbcHJvcGVydHldO1xuXG4gIFx0aWYgKGV4aXN0aW5nS2V5cGF0aCAmJiAoZXhpc3RpbmdLZXlwYXRoLmVxdWFsc09yU3RhcnRzV2l0aChuZXdLZXlwYXRoKSB8fCAhZXhpc3RpbmdLZXlwYXRoLmVxdWFsc09yU3RhcnRzV2l0aChvbGRLZXlwYXRoKSkpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHR0YXJnZXRbcHJvcGVydHldID0gZXhpc3RpbmdLZXlwYXRoID8gZXhpc3RpbmdLZXlwYXRoLnJlcGxhY2Uob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkgOiBuZXdLZXlwYXRoO1xuICBcdHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlS2V5cGF0aChrZXlwYXRoKSB7XG4gIFx0dmFyIHZhbHVlID0ga2V5cGF0aC5zbGljZSgyKTtcblxuICBcdGlmIChrZXlwYXRoWzFdID09PSBcImlcIikge1xuICBcdFx0cmV0dXJuIGlzX19pc051bWVyaWModmFsdWUpID8gK3ZhbHVlIDogdmFsdWU7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiB2YWx1ZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRLZXlwYXRoKHN0cikge1xuICBcdGlmIChzdHIgPT0gbnVsbCkge1xuICBcdFx0cmV0dXJuIHN0cjtcbiAgXHR9XG5cbiAgXHQvLyBUT0RPIGl0ICptYXkqIGJlIHdvcnRoIGhhdmluZyB0d28gdmVyc2lvbnMgb2YgdGhpcyBmdW5jdGlvbiAtIG9uZSB3aGVyZVxuICBcdC8vIGtleXBhdGhDYWNoZSBpbmhlcml0cyBmcm9tIG51bGwsIGFuZCBvbmUgZm9yIElFOC4gRGVwZW5kcyBvbiBob3dcbiAgXHQvLyBtdWNoIG9mIGFuIG92ZXJoZWFkIGhhc093blByb3BlcnR5IGlzIC0gcHJvYmFibHkgbmVnbGlnaWJsZVxuICBcdGlmICgha2V5cGF0aENhY2hlLmhhc093blByb3BlcnR5KHN0cikpIHtcbiAgXHRcdGtleXBhdGhDYWNoZVtzdHJdID0gbmV3IEtleXBhdGgoc3RyKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ga2V5cGF0aENhY2hlW3N0cl07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNYXRjaGluZ0tleXBhdGhzKHJhY3RpdmUsIGtleXBhdGgpIHtcbiAgXHR2YXIga2V5cywga2V5LCBtYXRjaGluZ0tleXBhdGhzO1xuXG4gIFx0a2V5cyA9IGtleXBhdGguc3RyLnNwbGl0KFwiLlwiKTtcbiAgXHRtYXRjaGluZ0tleXBhdGhzID0gW3Jvb3RLZXlwYXRoXTtcblxuICBcdHdoaWxlIChrZXkgPSBrZXlzLnNoaWZ0KCkpIHtcbiAgXHRcdGlmIChrZXkgPT09IFwiKlwiKSB7XG4gIFx0XHRcdC8vIGV4cGFuZCB0byBmaW5kIGFsbCB2YWxpZCBjaGlsZCBrZXlwYXRoc1xuICBcdFx0XHRtYXRjaGluZ0tleXBhdGhzID0gbWF0Y2hpbmdLZXlwYXRocy5yZWR1Y2UoZXhwYW5kLCBbXSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRpZiAobWF0Y2hpbmdLZXlwYXRoc1swXSA9PT0gcm9vdEtleXBhdGgpIHtcbiAgXHRcdFx0XHQvLyBmaXJzdCBrZXlcbiAgXHRcdFx0XHRtYXRjaGluZ0tleXBhdGhzWzBdID0gZ2V0S2V5cGF0aChrZXkpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdG1hdGNoaW5nS2V5cGF0aHMgPSBtYXRjaGluZ0tleXBhdGhzLm1hcChjb25jYXRlbmF0ZShrZXkpKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBtYXRjaGluZ0tleXBhdGhzO1xuXG4gIFx0ZnVuY3Rpb24gZXhwYW5kKG1hdGNoaW5nS2V5cGF0aHMsIGtleXBhdGgpIHtcbiAgXHRcdHZhciB3cmFwcGVyLCB2YWx1ZSwga2V5cztcblxuICBcdFx0aWYgKGtleXBhdGguaXNSb290KSB7XG4gIFx0XHRcdGtleXMgPSBbXS5jb25jYXQoT2JqZWN0LmtleXMocmFjdGl2ZS52aWV3bW9kZWwuZGF0YSksIE9iamVjdC5rZXlzKHJhY3RpdmUudmlld21vZGVsLm1hcHBpbmdzKSwgT2JqZWN0LmtleXMocmFjdGl2ZS52aWV3bW9kZWwuY29tcHV0YXRpb25zKSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR3cmFwcGVyID0gcmFjdGl2ZS52aWV3bW9kZWwud3JhcHBlZFtrZXlwYXRoLnN0cl07XG4gIFx0XHRcdHZhbHVlID0gd3JhcHBlciA/IHdyYXBwZXIuZ2V0KCkgOiByYWN0aXZlLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRcdFx0a2V5cyA9IHZhbHVlID8gT2JqZWN0LmtleXModmFsdWUpIDogbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGtleXMpIHtcbiAgXHRcdFx0a2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdFx0XHRpZiAoa2V5ICE9PSBcIl9yYWN0aXZlXCIgfHwgIWlzQXJyYXkodmFsdWUpKSB7XG4gIFx0XHRcdFx0XHRtYXRjaGluZ0tleXBhdGhzLnB1c2goa2V5cGF0aC5qb2luKGtleSkpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBtYXRjaGluZ0tleXBhdGhzO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmNhdGVuYXRlKGtleSkge1xuICBcdHJldHVybiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0cmV0dXJuIGtleXBhdGguam9pbihrZXkpO1xuICBcdH07XG4gIH1cbiAgZnVuY3Rpb24gbm9ybWFsaXNlKHJlZikge1xuICBcdHJldHVybiByZWYgPyByZWYucmVwbGFjZShyZWZQYXR0ZXJuLCBcIi4kMVwiKSA6IFwiXCI7XG4gIH1cblxuICB2YXIgcm9vdEtleXBhdGggPSBnZXRLZXlwYXRoKFwiXCIpO1xuXG4gIHZhciBzaGFyZWRfYWRkID0gYWRkO1xuICB2YXIgc2hhcmVkX2FkZF9fZXJyb3JNZXNzYWdlID0gXCJDYW5ub3QgYWRkIHRvIGEgbm9uLW51bWVyaWMgdmFsdWVcIjtcbiAgZnVuY3Rpb24gYWRkKHJvb3QsIGtleXBhdGgsIGQpIHtcbiAgXHRpZiAodHlwZW9mIGtleXBhdGggIT09IFwic3RyaW5nXCIgfHwgIWlzX19pc051bWVyaWMoZCkpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkJhZCBhcmd1bWVudHNcIik7XG4gIFx0fVxuXG4gIFx0dmFyIHZhbHVlID0gdW5kZWZpbmVkLFxuICBcdCAgICBjaGFuZ2VzID0gdW5kZWZpbmVkO1xuXG4gIFx0aWYgKC9cXCovLnRlc3Qoa2V5cGF0aCkpIHtcbiAgXHRcdGNoYW5nZXMgPSB7fTtcblxuICBcdFx0Z2V0TWF0Y2hpbmdLZXlwYXRocyhyb290LCBnZXRLZXlwYXRoKG5vcm1hbGlzZShrZXlwYXRoKSkpLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0dmFyIHZhbHVlID0gcm9vdC52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuXG4gIFx0XHRcdGlmICghaXNfX2lzTnVtZXJpYyh2YWx1ZSkpIHtcbiAgXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3Ioc2hhcmVkX2FkZF9fZXJyb3JNZXNzYWdlKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNoYW5nZXNba2V5cGF0aC5zdHJdID0gdmFsdWUgKyBkO1xuICBcdFx0fSk7XG5cbiAgXHRcdHJldHVybiByb290LnNldChjaGFuZ2VzKTtcbiAgXHR9XG5cbiAgXHR2YWx1ZSA9IHJvb3QuZ2V0KGtleXBhdGgpO1xuXG4gIFx0aWYgKCFpc19faXNOdW1lcmljKHZhbHVlKSkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKHNoYXJlZF9hZGRfX2Vycm9yTWVzc2FnZSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJvb3Quc2V0KGtleXBhdGgsICt2YWx1ZSArIGQpO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9hZGQgPSBSYWN0aXZlJGFkZDtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRhZGQoa2V5cGF0aCwgZCkge1xuICBcdHJldHVybiBzaGFyZWRfYWRkKHRoaXMsIGtleXBhdGgsIGQgPT09IHVuZGVmaW5lZCA/IDEgOiArZCk7XG4gIH1cblxuICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG4gIC8vIElmIHdpbmRvdyBkb2Vzbid0IGV4aXN0LCB3ZSBkb24ndCBuZWVkIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICBcdHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gIFx0Ly8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzE1Nzk2NzFcbiAgXHQoZnVuY3Rpb24gKHZlbmRvcnMsIGxhc3RUaW1lLCB3aW5kb3cpIHtcblxuICBcdFx0dmFyIHgsIHNldFRpbWVvdXQ7XG5cbiAgXHRcdGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Zm9yICh4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcbiAgXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgXCJSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl07XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICBcdFx0XHRzZXRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQ7XG5cbiAgXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBcdFx0XHRcdHZhciBjdXJyVGltZSwgdGltZVRvQ2FsbCwgaWQ7XG5cbiAgXHRcdFx0XHRjdXJyVGltZSA9IERhdGUubm93KCk7XG4gIFx0XHRcdFx0dGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcbiAgXHRcdFx0XHRpZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0Y2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcbiAgXHRcdFx0XHR9LCB0aW1lVG9DYWxsKTtcblxuICBcdFx0XHRcdGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICBcdFx0XHRcdHJldHVybiBpZDtcbiAgXHRcdFx0fTtcbiAgXHRcdH1cbiAgXHR9KSh2ZW5kb3JzLCAwLCB3aW5kb3cpO1xuXG4gIFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgfVxuXG4gIHZhciByQUYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cbiAgdmFyIGdldFRpbWU7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnBlcmZvcm1hbmNlICYmIHR5cGVvZiB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRnZXRUaW1lID0gZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgXHR9O1xuICB9IGVsc2Uge1xuICBcdGdldFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gRGF0ZS5ub3coKTtcbiAgXHR9O1xuICB9XG5cbiAgdmFyIHV0aWxzX2dldFRpbWUgPSBnZXRUaW1lO1xuXG4gIHZhciBkZXByZWNhdGlvbnMgPSB7XG4gIFx0Y29uc3RydWN0OiB7XG4gIFx0XHRkZXByZWNhdGVkOiBcImJlZm9yZUluaXRcIixcbiAgXHRcdHJlcGxhY2VtZW50OiBcIm9uY29uc3RydWN0XCJcbiAgXHR9LFxuICBcdHJlbmRlcjoge1xuICBcdFx0ZGVwcmVjYXRlZDogXCJpbml0XCIsXG4gIFx0XHRtZXNzYWdlOiBcIlRoZSBcXFwiaW5pdFxcXCIgbWV0aG9kIGhhcyBiZWVuIGRlcHJlY2F0ZWQgXCIgKyBcImFuZCB3aWxsIGxpa2VseSBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuIFwiICsgXCJZb3UgY2FuIGVpdGhlciB1c2UgdGhlIFxcXCJvbmluaXRcXFwiIG1ldGhvZCB3aGljaCB3aWxsIGZpcmUgXCIgKyBcIm9ubHkgb25jZSBwcmlvciB0bywgYW5kIHJlZ2FyZGxlc3Mgb2YsIGFueSBldmVudHVhbCByYWN0aXZlIFwiICsgXCJpbnN0YW5jZSBiZWluZyByZW5kZXJlZCwgb3IgaWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBcIiArIFwicmVuZGVyZWQgRE9NLCB1c2UgXFxcIm9ucmVuZGVyXFxcIiBpbnN0ZWFkLiBcIiArIFwiU2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L21pZ3JhdGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIlxuICBcdH0sXG4gIFx0Y29tcGxldGU6IHtcbiAgXHRcdGRlcHJlY2F0ZWQ6IFwiY29tcGxldGVcIixcbiAgXHRcdHJlcGxhY2VtZW50OiBcIm9uY29tcGxldGVcIlxuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiBIb29rKGV2ZW50KSB7XG4gIFx0dGhpcy5ldmVudCA9IGV2ZW50O1xuICBcdHRoaXMubWV0aG9kID0gXCJvblwiICsgZXZlbnQ7XG4gIFx0dGhpcy5kZXByZWNhdGUgPSBkZXByZWNhdGlvbnNbZXZlbnRdO1xuICB9XG5cbiAgSG9vay5wcm90b3R5cGUuZmlyZSA9IGZ1bmN0aW9uIChyYWN0aXZlLCBhcmcpIHtcbiAgXHRmdW5jdGlvbiBjYWxsKG1ldGhvZCkge1xuICBcdFx0aWYgKHJhY3RpdmVbbWV0aG9kXSkge1xuICBcdFx0XHRhcmcgPyByYWN0aXZlW21ldGhvZF0oYXJnKSA6IHJhY3RpdmVbbWV0aG9kXSgpO1xuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRjYWxsKHRoaXMubWV0aG9kKTtcblxuICBcdGlmICghcmFjdGl2ZVt0aGlzLm1ldGhvZF0gJiYgdGhpcy5kZXByZWNhdGUgJiYgY2FsbCh0aGlzLmRlcHJlY2F0ZS5kZXByZWNhdGVkKSkge1xuICBcdFx0aWYgKHRoaXMuZGVwcmVjYXRlLm1lc3NhZ2UpIHtcbiAgXHRcdFx0d2FybklmRGVidWcodGhpcy5kZXByZWNhdGUubWVzc2FnZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR3YXJuSWZEZWJ1ZyhcIlRoZSBtZXRob2QgXFxcIiVzXFxcIiBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIFxcXCIlc1xcXCIgYW5kIHdpbGwgbGlrZWx5IGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4gU2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L21pZ3JhdGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIiwgdGhpcy5kZXByZWNhdGUuZGVwcmVjYXRlZCwgdGhpcy5kZXByZWNhdGUucmVwbGFjZW1lbnQpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGFyZyA/IHJhY3RpdmUuZmlyZSh0aGlzLmV2ZW50LCBhcmcpIDogcmFjdGl2ZS5maXJlKHRoaXMuZXZlbnQpO1xuICB9O1xuXG4gIHZhciBob29rc19Ib29rID0gSG9vaztcblxuICBmdW5jdGlvbiBhZGRUb0FycmF5KGFycmF5LCB2YWx1ZSkge1xuICBcdHZhciBpbmRleCA9IGFycmF5LmluZGV4T2YodmFsdWUpO1xuXG4gIFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0YXJyYXkucHVzaCh2YWx1ZSk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlDb250YWlucyhhcnJheSwgdmFsdWUpIHtcbiAgXHRmb3IgKHZhciBpID0gMCwgYyA9IGFycmF5Lmxlbmd0aDsgaSA8IGM7IGkrKykge1xuICBcdFx0aWYgKGFycmF5W2ldID09IHZhbHVlKSB7XG4gIFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5Q29udGVudHNNYXRjaChhLCBiKSB7XG4gIFx0dmFyIGk7XG5cbiAgXHRpZiAoIWlzQXJyYXkoYSkgfHwgIWlzQXJyYXkoYikpIHtcbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9XG5cbiAgXHRpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fVxuXG4gIFx0aSA9IGEubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGlmIChhW2ldICE9PSBiW2ldKSB7XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuc3VyZUFycmF5KHgpIHtcbiAgXHRpZiAodHlwZW9mIHggPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHJldHVybiBbeF07XG4gIFx0fVxuXG4gIFx0aWYgKHggPT09IHVuZGVmaW5lZCkge1xuICBcdFx0cmV0dXJuIFtdO1xuICBcdH1cblxuICBcdHJldHVybiB4O1xuICB9XG5cbiAgZnVuY3Rpb24gbGFzdEl0ZW0oYXJyYXkpIHtcbiAgXHRyZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVGcm9tQXJyYXkoYXJyYXksIG1lbWJlcikge1xuICBcdHZhciBpbmRleCA9IGFycmF5LmluZGV4T2YobWVtYmVyKTtcblxuICBcdGlmIChpbmRleCAhPT0gLTEpIHtcbiAgXHRcdGFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gdG9BcnJheShhcnJheUxpa2UpIHtcbiAgXHR2YXIgYXJyYXkgPSBbXSxcbiAgXHQgICAgaSA9IGFycmF5TGlrZS5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0YXJyYXlbaV0gPSBhcnJheUxpa2VbaV07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGFycmF5O1xuICB9XG5cbiAgdmFyIF9Qcm9taXNlLFxuICAgICAgUEVORElORyA9IHt9LFxuICAgICAgRlVMRklMTEVEID0ge30sXG4gICAgICBSRUpFQ1RFRCA9IHt9O1xuXG4gIGlmICh0eXBlb2YgUHJvbWlzZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0Ly8gdXNlIG5hdGl2ZSBQcm9taXNlXG4gIFx0X1Byb21pc2UgPSBQcm9taXNlO1xuICB9IGVsc2Uge1xuICBcdF9Qcm9taXNlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIFx0XHR2YXIgZnVsZmlsbGVkSGFuZGxlcnMgPSBbXSxcbiAgXHRcdCAgICByZWplY3RlZEhhbmRsZXJzID0gW10sXG4gIFx0XHQgICAgc3RhdGUgPSBQRU5ESU5HLFxuICBcdFx0ICAgIHJlc3VsdCxcbiAgXHRcdCAgICBkaXNwYXRjaEhhbmRsZXJzLFxuICBcdFx0ICAgIG1ha2VSZXNvbHZlcixcbiAgXHRcdCAgICBmdWxmaWwsXG4gIFx0XHQgICAgcmVqZWN0LFxuICBcdFx0ICAgIHByb21pc2U7XG5cbiAgXHRcdG1ha2VSZXNvbHZlciA9IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICBcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHRcdFx0aWYgKHN0YXRlICE9PSBQRU5ESU5HKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0cmVzdWx0ID0gdmFsdWU7XG4gIFx0XHRcdFx0c3RhdGUgPSBuZXdTdGF0ZTtcblxuICBcdFx0XHRcdGRpc3BhdGNoSGFuZGxlcnMgPSBtYWtlRGlzcGF0Y2hlcihzdGF0ZSA9PT0gRlVMRklMTEVEID8gZnVsZmlsbGVkSGFuZGxlcnMgOiByZWplY3RlZEhhbmRsZXJzLCByZXN1bHQpO1xuXG4gIFx0XHRcdFx0Ly8gZGlzcGF0Y2ggb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgaGFuZGxlcnMgYXN5bmNocm9ub3VzbHlcbiAgXHRcdFx0XHR3YWl0KGRpc3BhdGNoSGFuZGxlcnMpO1xuICBcdFx0XHR9O1xuICBcdFx0fTtcblxuICBcdFx0ZnVsZmlsID0gbWFrZVJlc29sdmVyKEZVTEZJTExFRCk7XG4gIFx0XHRyZWplY3QgPSBtYWtlUmVzb2x2ZXIoUkVKRUNURUQpO1xuXG4gIFx0XHR0cnkge1xuICBcdFx0XHRjYWxsYmFjayhmdWxmaWwsIHJlamVjdCk7XG4gIFx0XHR9IGNhdGNoIChlcnIpIHtcbiAgXHRcdFx0cmVqZWN0KGVycik7XG4gIFx0XHR9XG5cbiAgXHRcdHByb21pc2UgPSB7XG4gIFx0XHRcdC8vIGB0aGVuKClgIHJldHVybnMgYSBQcm9taXNlIC0gMi4yLjdcbiAgXHRcdFx0dGhlbjogZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIFx0XHRcdFx0dmFyIHByb21pc2UyID0gbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIChmdWxmaWwsIHJlamVjdCkge1xuXG4gIFx0XHRcdFx0XHR2YXIgcHJvY2Vzc1Jlc29sdXRpb25IYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIsIGhhbmRsZXJzLCBmb3J3YXJkKSB7XG5cbiAgXHRcdFx0XHRcdFx0Ly8gMi4yLjEuMVxuICBcdFx0XHRcdFx0XHRpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRcdFx0XHRcdGhhbmRsZXJzLnB1c2goZnVuY3Rpb24gKHAxcmVzdWx0KSB7XG4gIFx0XHRcdFx0XHRcdFx0XHR2YXIgeDtcblxuICBcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcbiAgXHRcdFx0XHRcdFx0XHRcdFx0eCA9IGhhbmRsZXIocDFyZXN1bHQpO1xuICBcdFx0XHRcdFx0XHRcdFx0XHR1dGlsc19Qcm9taXNlX19yZXNvbHZlKHByb21pc2UyLCB4LCBmdWxmaWwsIHJlamVjdCk7XG4gIFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcbiAgXHRcdFx0XHRcdFx0XHRcdFx0cmVqZWN0KGVycik7XG4gIFx0XHRcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRcdFx0Ly8gRm9yd2FyZCB0aGUgcmVzdWx0IG9mIHByb21pc2UxIHRvIHByb21pc2UyLCBpZiByZXNvbHV0aW9uIGhhbmRsZXJzXG4gIFx0XHRcdFx0XHRcdFx0Ly8gYXJlIG5vdCBnaXZlblxuICBcdFx0XHRcdFx0XHRcdGhhbmRsZXJzLnB1c2goZm9yd2FyZCk7XG4gIFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdH07XG5cbiAgXHRcdFx0XHRcdC8vIDIuMlxuICBcdFx0XHRcdFx0cHJvY2Vzc1Jlc29sdXRpb25IYW5kbGVyKG9uRnVsZmlsbGVkLCBmdWxmaWxsZWRIYW5kbGVycywgZnVsZmlsKTtcbiAgXHRcdFx0XHRcdHByb2Nlc3NSZXNvbHV0aW9uSGFuZGxlcihvblJlamVjdGVkLCByZWplY3RlZEhhbmRsZXJzLCByZWplY3QpO1xuXG4gIFx0XHRcdFx0XHRpZiAoc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByb21pc2UgaGFzIHJlc29sdmVkIGFscmVhZHksIGRpc3BhdGNoIHRoZSBhcHByb3ByaWF0ZSBoYW5kbGVycyBhc3luY2hyb25vdXNseVxuICBcdFx0XHRcdFx0XHR3YWl0KGRpc3BhdGNoSGFuZGxlcnMpO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH0pO1xuXG4gIFx0XHRcdFx0cmV0dXJuIHByb21pc2UyO1xuICBcdFx0XHR9XG4gIFx0XHR9O1xuXG4gIFx0XHRwcm9taXNlW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xuICBcdFx0fTtcblxuICBcdFx0cmV0dXJuIHByb21pc2U7XG4gIFx0fTtcblxuICBcdF9Qcm9taXNlLmFsbCA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICBcdFx0cmV0dXJuIG5ldyBfUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsLCByZWplY3QpIHtcbiAgXHRcdFx0dmFyIHJlc3VsdCA9IFtdLFxuICBcdFx0XHQgICAgcGVuZGluZyxcbiAgXHRcdFx0ICAgIGksXG4gIFx0XHRcdCAgICBwcm9jZXNzUHJvbWlzZTtcblxuICBcdFx0XHRpZiAoIXByb21pc2VzLmxlbmd0aCkge1xuICBcdFx0XHRcdGZ1bGZpbChyZXN1bHQpO1xuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHByb2Nlc3NQcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2UsIGkpIHtcbiAgXHRcdFx0XHRpZiAocHJvbWlzZSAmJiB0eXBlb2YgcHJvbWlzZS50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0XHRcdHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdFx0XHRcdFx0cmVzdWx0W2ldID0gdmFsdWU7XG4gIFx0XHRcdFx0XHRcdC0tcGVuZGluZyB8fCBmdWxmaWwocmVzdWx0KTtcbiAgXHRcdFx0XHRcdH0sIHJlamVjdCk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdHJlc3VsdFtpXSA9IHByb21pc2U7XG4gIFx0XHRcdFx0XHQtLXBlbmRpbmcgfHwgZnVsZmlsKHJlc3VsdCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9O1xuXG4gIFx0XHRcdHBlbmRpbmcgPSBpID0gcHJvbWlzZXMubGVuZ3RoO1xuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0cHJvY2Vzc1Byb21pc2UocHJvbWlzZXNbaV0sIGkpO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcbiAgXHR9O1xuXG4gIFx0X1Byb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0cmV0dXJuIG5ldyBfUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsKSB7XG4gIFx0XHRcdGZ1bGZpbCh2YWx1ZSk7XG4gIFx0XHR9KTtcbiAgXHR9O1xuXG4gIFx0X1Byb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICBcdFx0cmV0dXJuIG5ldyBfUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsLCByZWplY3QpIHtcbiAgXHRcdFx0cmVqZWN0KHJlYXNvbik7XG4gIFx0XHR9KTtcbiAgXHR9O1xuICB9XG5cbiAgdmFyIHV0aWxzX1Byb21pc2UgPSBfUHJvbWlzZTtcblxuICAvLyBUT0RPIHVzZSBNdXRhdGlvbk9ic2VydmVycyBvciBzb21ldGhpbmcgdG8gc2ltdWxhdGUgc2V0SW1tZWRpYXRlXG4gIGZ1bmN0aW9uIHdhaXQoY2FsbGJhY2spIHtcbiAgXHRzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VEaXNwYXRjaGVyKGhhbmRsZXJzLCByZXN1bHQpIHtcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGhhbmRsZXI7XG5cbiAgXHRcdHdoaWxlIChoYW5kbGVyID0gaGFuZGxlcnMuc2hpZnQoKSkge1xuICBcdFx0XHRoYW5kbGVyKHJlc3VsdCk7XG4gIFx0XHR9XG4gIFx0fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHV0aWxzX1Byb21pc2VfX3Jlc29sdmUocHJvbWlzZSwgeCwgZnVsZmlsLCByZWplY3QpIHtcbiAgXHQvLyBQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlXG4gIFx0dmFyIHRoZW47XG5cbiAgXHQvLyAyLjMuMVxuICBcdGlmICh4ID09PSBwcm9taXNlKSB7XG4gIFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBwcm9taXNlJ3MgZnVsZmlsbG1lbnQgaGFuZGxlciBjYW5ub3QgcmV0dXJuIHRoZSBzYW1lIHByb21pc2VcIik7XG4gIFx0fVxuXG4gIFx0Ly8gMi4zLjJcbiAgXHRpZiAoeCBpbnN0YW5jZW9mIF9Qcm9taXNlKSB7XG4gIFx0XHR4LnRoZW4oZnVsZmlsLCByZWplY3QpO1xuICBcdH1cblxuICBcdC8vIDIuMy4zXG4gIFx0ZWxzZSBpZiAoeCAmJiAodHlwZW9mIHggPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgXHRcdHRyeSB7XG4gIFx0XHRcdHRoZW4gPSB4LnRoZW47IC8vIDIuMy4zLjFcbiAgXHRcdH0gY2F0Y2ggKGUpIHtcbiAgXHRcdFx0cmVqZWN0KGUpOyAvLyAyLjMuMy4yXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Ly8gMi4zLjMuM1xuICBcdFx0aWYgKHR5cGVvZiB0aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0dmFyIGNhbGxlZCwgcmVzb2x2ZVByb21pc2UsIHJlamVjdFByb21pc2U7XG5cbiAgXHRcdFx0cmVzb2x2ZVByb21pc2UgPSBmdW5jdGlvbiAoeSkge1xuICBcdFx0XHRcdGlmIChjYWxsZWQpIHtcbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcbiAgXHRcdFx0XHR1dGlsc19Qcm9taXNlX19yZXNvbHZlKHByb21pc2UsIHksIGZ1bGZpbCwgcmVqZWN0KTtcbiAgXHRcdFx0fTtcblxuICBcdFx0XHRyZWplY3RQcm9taXNlID0gZnVuY3Rpb24gKHIpIHtcbiAgXHRcdFx0XHRpZiAoY2FsbGVkKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0fVxuICBcdFx0XHRcdGNhbGxlZCA9IHRydWU7XG4gIFx0XHRcdFx0cmVqZWN0KHIpO1xuICBcdFx0XHR9O1xuXG4gIFx0XHRcdHRyeSB7XG4gIFx0XHRcdFx0dGhlbi5jYWxsKHgsIHJlc29sdmVQcm9taXNlLCByZWplY3RQcm9taXNlKTtcbiAgXHRcdFx0fSBjYXRjaCAoZSkge1xuICBcdFx0XHRcdGlmICghY2FsbGVkKSB7XG4gIFx0XHRcdFx0XHQvLyAyLjMuMy4zLjQuMVxuICBcdFx0XHRcdFx0cmVqZWN0KGUpOyAvLyAyLjMuMy4zLjQuMlxuICBcdFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGZ1bGZpbCh4KTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0ZnVsZmlsKHgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBnZXRJbm5lckNvbnRleHQgPSBmdW5jdGlvbiAoZnJhZ21lbnQpIHtcbiAgXHRkbyB7XG4gIFx0XHRpZiAoZnJhZ21lbnQuY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHJldHVybiBmcmFnbWVudC5jb250ZXh0O1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50KTtcblxuICBcdHJldHVybiByb290S2V5cGF0aDtcbiAgfTtcblxuICB2YXIgc2hhcmVkX3Jlc29sdmVSZWYgPSByZXNvbHZlUmVmO1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVSZWYocmFjdGl2ZSwgcmVmLCBmcmFnbWVudCkge1xuICBcdHZhciBrZXlwYXRoO1xuXG4gIFx0cmVmID0gbm9ybWFsaXNlKHJlZik7XG5cbiAgXHQvLyBJZiBhIHJlZmVyZW5jZSBiZWdpbnMgJ34vJywgaXQncyBhIHRvcC1sZXZlbCByZWZlcmVuY2VcbiAgXHRpZiAocmVmLnN1YnN0cigwLCAyKSA9PT0gXCJ+L1wiKSB7XG4gIFx0XHRrZXlwYXRoID0gZ2V0S2V5cGF0aChyZWYuc3Vic3RyaW5nKDIpKTtcbiAgXHRcdGNyZWF0ZU1hcHBpbmdJZk5lY2Vzc2FyeShyYWN0aXZlLCBrZXlwYXRoLmZpcnN0S2V5LCBmcmFnbWVudCk7XG4gIFx0fVxuXG4gIFx0Ly8gSWYgYSByZWZlcmVuY2UgYmVnaW5zIHdpdGggJy4nLCBpdCdzIGVpdGhlciBhIHJlc3RyaWN0ZWQgcmVmZXJlbmNlIG9yXG4gIFx0Ly8gYW4gYW5jZXN0b3IgcmVmZXJlbmNlLi4uXG4gIFx0ZWxzZSBpZiAocmVmWzBdID09PSBcIi5cIikge1xuICBcdFx0a2V5cGF0aCA9IHJlc29sdmVBbmNlc3RvclJlZihnZXRJbm5lckNvbnRleHQoZnJhZ21lbnQpLCByZWYpO1xuXG4gIFx0XHRpZiAoa2V5cGF0aCkge1xuICBcdFx0XHRjcmVhdGVNYXBwaW5nSWZOZWNlc3NhcnkocmFjdGl2ZSwga2V5cGF0aC5maXJzdEtleSwgZnJhZ21lbnQpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIC4uLm90aGVyd2lzZSB3ZSBuZWVkIHRvIGZpZ3VyZSBvdXQgdGhlIGtleXBhdGggYmFzZWQgb24gY29udGV4dFxuICBcdGVsc2Uge1xuICBcdFx0a2V5cGF0aCA9IHJlc29sdmVBbWJpZ3VvdXNSZWZlcmVuY2UocmFjdGl2ZSwgZ2V0S2V5cGF0aChyZWYpLCBmcmFnbWVudCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGtleXBhdGg7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlQW5jZXN0b3JSZWYoYmFzZUNvbnRleHQsIHJlZikge1xuICBcdHZhciBjb250ZXh0S2V5cztcblxuICBcdC8vIFRPRE8uLi5cbiAgXHRpZiAoYmFzZUNvbnRleHQgIT0gdW5kZWZpbmVkICYmIHR5cGVvZiBiYXNlQ29udGV4dCAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0YmFzZUNvbnRleHQgPSBiYXNlQ29udGV4dC5zdHI7XG4gIFx0fVxuXG4gIFx0Ly8ge3sufX0gbWVhbnMgJ2N1cnJlbnQgY29udGV4dCdcbiAgXHRpZiAocmVmID09PSBcIi5cIikgcmV0dXJuIGdldEtleXBhdGgoYmFzZUNvbnRleHQpO1xuXG4gIFx0Y29udGV4dEtleXMgPSBiYXNlQ29udGV4dCA/IGJhc2VDb250ZXh0LnNwbGl0KFwiLlwiKSA6IFtdO1xuXG4gIFx0Ly8gYW5jZXN0b3IgcmVmZXJlbmNlcyAoc3RhcnRpbmcgXCIuLi9cIikgZ28gdXAgdGhlIHRyZWVcbiAgXHRpZiAocmVmLnN1YnN0cigwLCAzKSA9PT0gXCIuLi9cIikge1xuICBcdFx0d2hpbGUgKHJlZi5zdWJzdHIoMCwgMykgPT09IFwiLi4vXCIpIHtcbiAgXHRcdFx0aWYgKCFjb250ZXh0S2V5cy5sZW5ndGgpIHtcbiAgXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVzb2x2ZSByZWZlcmVuY2UgLSB0b28gbWFueSBcXFwiLi4vXFxcIiBwcmVmaXhlc1wiKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNvbnRleHRLZXlzLnBvcCgpO1xuICBcdFx0XHRyZWYgPSByZWYuc3Vic3RyaW5nKDMpO1xuICBcdFx0fVxuXG4gIFx0XHRjb250ZXh0S2V5cy5wdXNoKHJlZik7XG4gIFx0XHRyZXR1cm4gZ2V0S2V5cGF0aChjb250ZXh0S2V5cy5qb2luKFwiLlwiKSk7XG4gIFx0fVxuXG4gIFx0Ly8gbm90IGFuIGFuY2VzdG9yIHJlZmVyZW5jZSAtIG11c3QgYmUgYSByZXN0cmljdGVkIHJlZmVyZW5jZSAocHJlcGVuZGVkIHdpdGggXCIuXCIgb3IgXCIuL1wiKVxuICBcdGlmICghYmFzZUNvbnRleHQpIHtcbiAgXHRcdHJldHVybiBnZXRLZXlwYXRoKHJlZi5yZXBsYWNlKC9eXFwuXFwvPy8sIFwiXCIpKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gZ2V0S2V5cGF0aChiYXNlQ29udGV4dCArIHJlZi5yZXBsYWNlKC9eXFwuXFwvLywgXCIuXCIpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVBbWJpZ3VvdXNSZWZlcmVuY2UocmFjdGl2ZSwgcmVmLCBmcmFnbWVudCwgaXNQYXJlbnRMb29rdXApIHtcbiAgXHR2YXIgY29udGV4dCwga2V5LCBwYXJlbnRWYWx1ZSwgaGFzQ29udGV4dENoYWluLCBwYXJlbnRLZXlwYXRoO1xuXG4gIFx0aWYgKHJlZi5pc1Jvb3QpIHtcbiAgXHRcdHJldHVybiByZWY7XG4gIFx0fVxuXG4gIFx0a2V5ID0gcmVmLmZpcnN0S2V5O1xuXG4gIFx0d2hpbGUgKGZyYWdtZW50KSB7XG4gIFx0XHRjb250ZXh0ID0gZnJhZ21lbnQuY29udGV4dDtcbiAgXHRcdGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50O1xuXG4gIFx0XHRpZiAoIWNvbnRleHQpIHtcbiAgXHRcdFx0Y29udGludWU7XG4gIFx0XHR9XG5cbiAgXHRcdGhhc0NvbnRleHRDaGFpbiA9IHRydWU7XG4gIFx0XHRwYXJlbnRWYWx1ZSA9IHJhY3RpdmUudmlld21vZGVsLmdldChjb250ZXh0KTtcblxuICBcdFx0aWYgKHBhcmVudFZhbHVlICYmICh0eXBlb2YgcGFyZW50VmFsdWUgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHBhcmVudFZhbHVlID09PSBcImZ1bmN0aW9uXCIpICYmIGtleSBpbiBwYXJlbnRWYWx1ZSkge1xuICBcdFx0XHRyZXR1cm4gY29udGV4dC5qb2luKHJlZi5zdHIpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIFJvb3QvY29tcHV0ZWQvbWFwcGVkIHByb3BlcnR5P1xuICBcdGlmIChpc1Jvb3RQcm9wZXJ0eShyYWN0aXZlLnZpZXdtb2RlbCwga2V5KSkge1xuICBcdFx0cmV0dXJuIHJlZjtcbiAgXHR9XG5cbiAgXHQvLyBJZiB0aGlzIGlzIGFuIGlubGluZSBjb21wb25lbnQsIGFuZCBpdCdzIG5vdCBpc29sYXRlZCwgd2VcbiAgXHQvLyBjYW4gdHJ5IGdvaW5nIHVwIHRoZSBzY29wZSBjaGFpblxuICBcdGlmIChyYWN0aXZlLnBhcmVudCAmJiAhcmFjdGl2ZS5pc29sYXRlZCkge1xuICBcdFx0aGFzQ29udGV4dENoYWluID0gdHJ1ZTtcbiAgXHRcdGZyYWdtZW50ID0gcmFjdGl2ZS5jb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHRcdGtleSA9IGdldEtleXBhdGgoa2V5KTtcblxuICBcdFx0aWYgKHBhcmVudEtleXBhdGggPSByZXNvbHZlQW1iaWd1b3VzUmVmZXJlbmNlKHJhY3RpdmUucGFyZW50LCBrZXksIGZyYWdtZW50LCB0cnVlKSkge1xuICBcdFx0XHQvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhbiBpbnRlci1jb21wb25lbnQgYmluZGluZ1xuICBcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5tYXAoa2V5LCB7XG4gIFx0XHRcdFx0b3JpZ2luOiByYWN0aXZlLnBhcmVudC52aWV3bW9kZWwsXG4gIFx0XHRcdFx0a2V5cGF0aDogcGFyZW50S2V5cGF0aFxuICBcdFx0XHR9KTtcblxuICBcdFx0XHRyZXR1cm4gcmVmO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIElmIHRoZXJlJ3Mgbm8gY29udGV4dCBjaGFpbiwgYW5kIHRoZSBpbnN0YW5jZSBpcyBlaXRoZXIgYSkgaXNvbGF0ZWQgb3JcbiAgXHQvLyBiKSBhbiBvcnBoYW4sIHRoZW4gd2Uga25vdyB0aGF0IHRoZSBrZXlwYXRoIGlzIGlkZW50aWNhbCB0byB0aGUgcmVmZXJlbmNlXG4gIFx0aWYgKCFpc1BhcmVudExvb2t1cCAmJiAhaGFzQ29udGV4dENoYWluKSB7XG4gIFx0XHQvLyB0aGUgZGF0YSBvYmplY3QgbmVlZHMgdG8gaGF2ZSBhIHByb3BlcnR5IGJ5IHRoaXMgbmFtZSxcbiAgXHRcdC8vIHRvIHByZXZlbnQgZnV0dXJlIGZhaWxlZCBsb29rdXBzXG4gIFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5zZXQocmVmLCB1bmRlZmluZWQpO1xuICBcdFx0cmV0dXJuIHJlZjtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVNYXBwaW5nSWZOZWNlc3NhcnkocmFjdGl2ZSwga2V5KSB7XG4gIFx0dmFyIHBhcmVudEtleXBhdGg7XG5cbiAgXHRpZiAoIXJhY3RpdmUucGFyZW50IHx8IHJhY3RpdmUuaXNvbGF0ZWQgfHwgaXNSb290UHJvcGVydHkocmFjdGl2ZS52aWV3bW9kZWwsIGtleSkpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRrZXkgPSBnZXRLZXlwYXRoKGtleSk7XG5cbiAgXHRpZiAocGFyZW50S2V5cGF0aCA9IHJlc29sdmVBbWJpZ3VvdXNSZWZlcmVuY2UocmFjdGl2ZS5wYXJlbnQsIGtleSwgcmFjdGl2ZS5jb21wb25lbnQucGFyZW50RnJhZ21lbnQsIHRydWUpKSB7XG4gIFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5tYXAoa2V5LCB7XG4gIFx0XHRcdG9yaWdpbjogcmFjdGl2ZS5wYXJlbnQudmlld21vZGVsLFxuICBcdFx0XHRrZXlwYXRoOiBwYXJlbnRLZXlwYXRoXG4gIFx0XHR9KTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBpc1Jvb3RQcm9wZXJ0eSh2aWV3bW9kZWwsIGtleSkge1xuICBcdC8vIHNwZWNpYWwgY2FzZSBmb3IgcmVmZXJlbmNlIHRvIHJvb3RcbiAgXHRyZXR1cm4ga2V5ID09PSBcIlwiIHx8IGtleSBpbiB2aWV3bW9kZWwuZGF0YSB8fCBrZXkgaW4gdmlld21vZGVsLmNvbXB1dGF0aW9ucyB8fCBrZXkgaW4gdmlld21vZGVsLm1hcHBpbmdzO1xuICB9XG5cbiAgZnVuY3Rpb24gdGVhcmRvd24oeCkge1xuICAgIHgudGVhcmRvd24oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ldGhvZENhbGxlcnNfX3VuYmluZCh4KSB7XG4gICAgeC51bmJpbmQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ldGhvZENhbGxlcnNfX3VucmVuZGVyKHgpIHtcbiAgICB4LnVucmVuZGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoeCkge1xuICAgIHguY2FuY2VsKCk7XG4gIH1cblxuICB2YXIgVHJhbnNpdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHBhcmVudCkge1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgXHR0aGlzLnBhcmVudCA9IHBhcmVudDtcblxuICBcdHRoaXMuaW50cm9zID0gW107XG4gIFx0dGhpcy5vdXRyb3MgPSBbXTtcblxuICBcdHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgXHR0aGlzLnRvdGFsQ2hpbGRyZW4gPSB0aGlzLm91dHJvQ2hpbGRyZW4gPSAwO1xuXG4gIFx0dGhpcy5kZXRhY2hRdWV1ZSA9IFtdO1xuICBcdHRoaXMuZGVjb3JhdG9yUXVldWUgPSBbXTtcbiAgXHR0aGlzLm91dHJvc0NvbXBsZXRlID0gZmFsc2U7XG5cbiAgXHRpZiAocGFyZW50KSB7XG4gIFx0XHRwYXJlbnQuYWRkQ2hpbGQodGhpcyk7XG4gIFx0fVxuICB9O1xuXG4gIFRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZSA9IHtcbiAgXHRhZGRDaGlsZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gIFx0XHR0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuXG4gIFx0XHR0aGlzLnRvdGFsQ2hpbGRyZW4gKz0gMTtcbiAgXHRcdHRoaXMub3V0cm9DaGlsZHJlbiArPSAxO1xuICBcdH0sXG5cbiAgXHRkZWNyZW1lbnRPdXRyb3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMub3V0cm9DaGlsZHJlbiAtPSAxO1xuICBcdFx0Y2hlY2sodGhpcyk7XG4gIFx0fSxcblxuICBcdGRlY3JlbWVudFRvdGFsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnRvdGFsQ2hpbGRyZW4gLT0gMTtcbiAgXHRcdGNoZWNrKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRhZGQ6IGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XG4gIFx0XHR2YXIgbGlzdCA9IHRyYW5zaXRpb24uaXNJbnRybyA/IHRoaXMuaW50cm9zIDogdGhpcy5vdXRyb3M7XG4gIFx0XHRsaXN0LnB1c2godHJhbnNpdGlvbik7XG4gIFx0fSxcblxuICBcdGFkZERlY29yYXRvcjogZnVuY3Rpb24gKGRlY29yYXRvcikge1xuICBcdFx0dGhpcy5kZWNvcmF0b3JRdWV1ZS5wdXNoKGRlY29yYXRvcik7XG4gIFx0fSxcblxuICBcdHJlbW92ZTogZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgXHRcdHZhciBsaXN0ID0gdHJhbnNpdGlvbi5pc0ludHJvID8gdGhpcy5pbnRyb3MgOiB0aGlzLm91dHJvcztcbiAgXHRcdHJlbW92ZUZyb21BcnJheShsaXN0LCB0cmFuc2l0aW9uKTtcbiAgXHRcdGNoZWNrKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgXHRcdGNoZWNrKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRkZXRhY2hOb2RlczogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5kZWNvcmF0b3JRdWV1ZS5mb3JFYWNoKHRlYXJkb3duKTtcbiAgXHRcdHRoaXMuZGV0YWNoUXVldWUuZm9yRWFjaChkZXRhY2gpO1xuICBcdFx0dGhpcy5jaGlsZHJlbi5mb3JFYWNoKGRldGFjaE5vZGVzKTtcbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gZGV0YWNoKGVsZW1lbnQpIHtcbiAgXHRlbGVtZW50LmRldGFjaCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGV0YWNoTm9kZXModG0pIHtcbiAgXHR0bS5kZXRhY2hOb2RlcygpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2sodG0pIHtcbiAgXHRpZiAoIXRtLnJlYWR5IHx8IHRtLm91dHJvcy5sZW5ndGggfHwgdG0ub3V0cm9DaGlsZHJlbikgcmV0dXJuO1xuXG4gIFx0Ly8gSWYgYWxsIG91dHJvcyBhcmUgY29tcGxldGUsIGFuZCB3ZSBoYXZlbid0IGFscmVhZHkgZG9uZSB0aGlzLFxuICBcdC8vIHdlIG5vdGlmeSB0aGUgcGFyZW50IGlmIHRoZXJlIGlzIG9uZSwgb3RoZXJ3aXNlXG4gIFx0Ly8gc3RhcnQgZGV0YWNoaW5nIG5vZGVzXG4gIFx0aWYgKCF0bS5vdXRyb3NDb21wbGV0ZSkge1xuICBcdFx0aWYgKHRtLnBhcmVudCkge1xuICBcdFx0XHR0bS5wYXJlbnQuZGVjcmVtZW50T3V0cm9zKHRtKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRtLmRldGFjaE5vZGVzKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRtLm91dHJvc0NvbXBsZXRlID0gdHJ1ZTtcbiAgXHR9XG5cbiAgXHQvLyBPbmNlIGV2ZXJ5dGhpbmcgaXMgZG9uZSwgd2UgY2FuIG5vdGlmeSBwYXJlbnQgdHJhbnNpdGlvblxuICBcdC8vIG1hbmFnZXIgYW5kIGNhbGwgdGhlIGNhbGxiYWNrXG4gIFx0aWYgKCF0bS5pbnRyb3MubGVuZ3RoICYmICF0bS50b3RhbENoaWxkcmVuKSB7XG4gIFx0XHRpZiAodHlwZW9mIHRtLmNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0dG0uY2FsbGJhY2soKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRtLnBhcmVudCkge1xuICBcdFx0XHR0bS5wYXJlbnQuZGVjcmVtZW50VG90YWwoKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgZ2xvYmFsX1RyYW5zaXRpb25NYW5hZ2VyID0gVHJhbnNpdGlvbk1hbmFnZXI7XG5cbiAgdmFyIGJhdGNoLFxuICAgICAgcnVubG9vcCxcbiAgICAgIHVucmVzb2x2ZWQgPSBbXSxcbiAgICAgIGNoYW5nZUhvb2sgPSBuZXcgaG9va3NfSG9vayhcImNoYW5nZVwiKTtcblxuICBydW5sb29wID0ge1xuICBcdHN0YXJ0OiBmdW5jdGlvbiAoaW5zdGFuY2UsIHJldHVyblByb21pc2UpIHtcbiAgXHRcdHZhciBwcm9taXNlLCBmdWxmaWxQcm9taXNlO1xuXG4gIFx0XHRpZiAocmV0dXJuUHJvbWlzZSkge1xuICBcdFx0XHRwcm9taXNlID0gbmV3IHV0aWxzX1Byb21pc2UoZnVuY3Rpb24gKGYpIHtcbiAgXHRcdFx0XHRyZXR1cm4gZnVsZmlsUHJvbWlzZSA9IGY7XG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHRiYXRjaCA9IHtcbiAgXHRcdFx0cHJldmlvdXNCYXRjaDogYmF0Y2gsXG4gIFx0XHRcdHRyYW5zaXRpb25NYW5hZ2VyOiBuZXcgZ2xvYmFsX1RyYW5zaXRpb25NYW5hZ2VyKGZ1bGZpbFByb21pc2UsIGJhdGNoICYmIGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyKSxcbiAgXHRcdFx0dmlld3M6IFtdLFxuICBcdFx0XHR0YXNrczogW10sXG4gIFx0XHRcdHJhY3RpdmVzOiBbXSxcbiAgXHRcdFx0aW5zdGFuY2U6IGluc3RhbmNlXG4gIFx0XHR9O1xuXG4gIFx0XHRpZiAoaW5zdGFuY2UpIHtcbiAgXHRcdFx0YmF0Y2gucmFjdGl2ZXMucHVzaChpbnN0YW5jZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBwcm9taXNlO1xuICBcdH0sXG5cbiAgXHRlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGZsdXNoQ2hhbmdlcygpO1xuXG4gIFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5pbml0KCk7XG4gIFx0XHRpZiAoIWJhdGNoLnByZXZpb3VzQmF0Y2ggJiYgISFiYXRjaC5pbnN0YW5jZSkgYmF0Y2guaW5zdGFuY2Uudmlld21vZGVsLmNoYW5nZXMgPSBbXTtcbiAgXHRcdGJhdGNoID0gYmF0Y2gucHJldmlvdXNCYXRjaDtcbiAgXHR9LFxuXG4gIFx0YWRkUmFjdGl2ZTogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdGlmIChiYXRjaCkge1xuICBcdFx0XHRhZGRUb0FycmF5KGJhdGNoLnJhY3RpdmVzLCByYWN0aXZlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmVnaXN0ZXJUcmFuc2l0aW9uOiBmdW5jdGlvbiAodHJhbnNpdGlvbikge1xuICBcdFx0dHJhbnNpdGlvbi5fbWFuYWdlciA9IGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyO1xuICBcdFx0YmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIuYWRkKHRyYW5zaXRpb24pO1xuICBcdH0sXG5cbiAgXHRyZWdpc3RlckRlY29yYXRvcjogZnVuY3Rpb24gKGRlY29yYXRvcikge1xuICBcdFx0YmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIuYWRkRGVjb3JhdG9yKGRlY29yYXRvcik7XG4gIFx0fSxcblxuICBcdGFkZFZpZXc6IGZ1bmN0aW9uICh2aWV3KSB7XG4gIFx0XHRiYXRjaC52aWV3cy5wdXNoKHZpZXcpO1xuICBcdH0sXG5cbiAgXHRhZGRVbnJlc29sdmVkOiBmdW5jdGlvbiAodGhpbmcpIHtcbiAgXHRcdHVucmVzb2x2ZWQucHVzaCh0aGluZyk7XG4gIFx0fSxcblxuICBcdHJlbW92ZVVucmVzb2x2ZWQ6IGZ1bmN0aW9uICh0aGluZykge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHVucmVzb2x2ZWQsIHRoaW5nKTtcbiAgXHR9LFxuXG4gIFx0Ly8gc3luY2hyb25pc2Ugbm9kZSBkZXRhY2htZW50cyB3aXRoIHRyYW5zaXRpb24gZW5kc1xuICBcdGRldGFjaFdoZW5SZWFkeTogZnVuY3Rpb24gKHRoaW5nKSB7XG4gIFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5kZXRhY2hRdWV1ZS5wdXNoKHRoaW5nKTtcbiAgXHR9LFxuXG4gIFx0c2NoZWR1bGVUYXNrOiBmdW5jdGlvbiAodGFzaywgcG9zdFJlbmRlcikge1xuICBcdFx0dmFyIF9iYXRjaDtcblxuICBcdFx0aWYgKCFiYXRjaCkge1xuICBcdFx0XHR0YXNrKCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRfYmF0Y2ggPSBiYXRjaDtcbiAgXHRcdFx0d2hpbGUgKHBvc3RSZW5kZXIgJiYgX2JhdGNoLnByZXZpb3VzQmF0Y2gpIHtcbiAgXHRcdFx0XHQvLyB0aGlzIGNhbid0IGhhcHBlbiB1bnRpbCB0aGUgRE9NIGhhcyBiZWVuIGZ1bGx5IHVwZGF0ZWRcbiAgXHRcdFx0XHQvLyBvdGhlcndpc2UgaW4gc29tZSBzaXR1YXRpb25zICh3aXRoIGNvbXBvbmVudHMgaW5zaWRlIGVsZW1lbnRzKVxuICBcdFx0XHRcdC8vIHRyYW5zaXRpb25zIGFuZCBkZWNvcmF0b3JzIHdpbGwgaW5pdGlhbGlzZSBwcmVtYXR1cmVseVxuICBcdFx0XHRcdF9iYXRjaCA9IF9iYXRjaC5wcmV2aW91c0JhdGNoO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0X2JhdGNoLnRhc2tzLnB1c2godGFzayk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBnbG9iYWxfcnVubG9vcCA9IHJ1bmxvb3A7XG5cbiAgZnVuY3Rpb24gZmx1c2hDaGFuZ2VzKCkge1xuICBcdHZhciBpLCB0aGluZywgY2hhbmdlSGFzaDtcblxuICBcdHdoaWxlIChiYXRjaC5yYWN0aXZlcy5sZW5ndGgpIHtcbiAgXHRcdHRoaW5nID0gYmF0Y2gucmFjdGl2ZXMucG9wKCk7XG4gIFx0XHRjaGFuZ2VIYXNoID0gdGhpbmcudmlld21vZGVsLmFwcGx5Q2hhbmdlcygpO1xuXG4gIFx0XHRpZiAoY2hhbmdlSGFzaCkge1xuICBcdFx0XHRjaGFuZ2VIb29rLmZpcmUodGhpbmcsIGNoYW5nZUhhc2gpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGF0dGVtcHRLZXlwYXRoUmVzb2x1dGlvbigpO1xuXG4gIFx0Ly8gTm93IHRoYXQgY2hhbmdlcyBoYXZlIGJlZW4gZnVsbHkgcHJvcGFnYXRlZCwgd2UgY2FuIHVwZGF0ZSB0aGUgRE9NXG4gIFx0Ly8gYW5kIGNvbXBsZXRlIG90aGVyIHRhc2tzXG4gIFx0Zm9yIChpID0gMDsgaSA8IGJhdGNoLnZpZXdzLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRiYXRjaC52aWV3c1tpXS51cGRhdGUoKTtcbiAgXHR9XG4gIFx0YmF0Y2gudmlld3MubGVuZ3RoID0gMDtcblxuICBcdGZvciAoaSA9IDA7IGkgPCBiYXRjaC50YXNrcy5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0YmF0Y2gudGFza3NbaV0oKTtcbiAgXHR9XG4gIFx0YmF0Y2gudGFza3MubGVuZ3RoID0gMDtcblxuICBcdC8vIElmIHVwZGF0aW5nIHRoZSB2aWV3IGNhdXNlZCBzb21lIG1vZGVsIGJsb3diYWNrIC0gZS5nLiBhIHRyaXBsZVxuICBcdC8vIGNvbnRhaW5pbmcgPG9wdGlvbj4gZWxlbWVudHMgY2F1c2VkIHRoZSBiaW5kaW5nIG9uIHRoZSA8c2VsZWN0PlxuICBcdC8vIHRvIHVwZGF0ZSAtIHRoZW4gd2Ugc3RhcnQgb3ZlclxuICBcdGlmIChiYXRjaC5yYWN0aXZlcy5sZW5ndGgpIHJldHVybiBmbHVzaENoYW5nZXMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dGVtcHRLZXlwYXRoUmVzb2x1dGlvbigpIHtcbiAgXHR2YXIgaSwgaXRlbSwga2V5cGF0aCwgcmVzb2x2ZWQ7XG5cbiAgXHRpID0gdW5yZXNvbHZlZC5sZW5ndGg7XG5cbiAgXHQvLyBzZWUgaWYgd2UgY2FuIHJlc29sdmUgYW55IHVucmVzb2x2ZWQgcmVmZXJlbmNlc1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGl0ZW0gPSB1bnJlc29sdmVkW2ldO1xuXG4gIFx0XHRpZiAoaXRlbS5rZXlwYXRoKSB7XG4gIFx0XHRcdC8vIGl0IHJlc29sdmVkIHNvbWUgb3RoZXIgd2F5LiBUT0RPIGhvdz8gdHdvLXdheSBiaW5kaW5nPyBTZWVtc1xuICBcdFx0XHQvLyB3ZWlyZCB0aGF0IHdlJ2Qgc3RpbGwgZW5kIHVwIGhlcmVcbiAgXHRcdFx0dW5yZXNvbHZlZC5zcGxpY2UoaSwgMSk7XG4gIFx0XHRcdGNvbnRpbnVlOyAvLyBhdm9pZCByZW1vdmluZyB0aGUgd3JvbmcgdGhpbmcgc2hvdWxkIHRoZSBuZXh0IGNvbmRpdGlvbiBiZSB0cnVlXG4gIFx0XHR9XG5cbiAgXHRcdGlmIChrZXlwYXRoID0gc2hhcmVkX3Jlc29sdmVSZWYoaXRlbS5yb290LCBpdGVtLnJlZiwgaXRlbS5wYXJlbnRGcmFnbWVudCkpIHtcbiAgXHRcdFx0KHJlc29sdmVkIHx8IChyZXNvbHZlZCA9IFtdKSkucHVzaCh7XG4gIFx0XHRcdFx0aXRlbTogaXRlbSxcbiAgXHRcdFx0XHRrZXlwYXRoOiBrZXlwYXRoXG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdHVucmVzb2x2ZWQuc3BsaWNlKGksIDEpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChyZXNvbHZlZCkge1xuICBcdFx0cmVzb2x2ZWQuZm9yRWFjaChnbG9iYWxfcnVubG9vcF9fcmVzb2x2ZSk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZ2xvYmFsX3J1bmxvb3BfX3Jlc29sdmUocmVzb2x2ZWQpIHtcbiAgXHRyZXNvbHZlZC5pdGVtLnJlc29sdmUocmVzb2x2ZWQua2V5cGF0aCk7XG4gIH1cblxuICB2YXIgcXVldWUgPSBbXTtcblxuICB2YXIgYW5pbWF0aW9ucyA9IHtcbiAgXHR0aWNrOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgaSwgYW5pbWF0aW9uLCBub3c7XG5cbiAgXHRcdG5vdyA9IHV0aWxzX2dldFRpbWUoKTtcblxuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc3RhcnQoKTtcblxuICBcdFx0Zm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRcdGFuaW1hdGlvbiA9IHF1ZXVlW2ldO1xuXG4gIFx0XHRcdGlmICghYW5pbWF0aW9uLnRpY2sobm93KSkge1xuICBcdFx0XHRcdC8vIGFuaW1hdGlvbiBpcyBjb21wbGV0ZSwgcmVtb3ZlIGl0IGZyb20gdGhlIHN0YWNrLCBhbmQgZGVjcmVtZW50IGkgc28gd2UgZG9uJ3QgbWlzcyBvbmVcbiAgXHRcdFx0XHRxdWV1ZS5zcGxpY2UoaS0tLCAxKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcblxuICBcdFx0aWYgKHF1ZXVlLmxlbmd0aCkge1xuICBcdFx0XHRyQUYoYW5pbWF0aW9ucy50aWNrKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGFuaW1hdGlvbnMucnVubmluZyA9IGZhbHNlO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRhZGQ6IGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgXHRcdHF1ZXVlLnB1c2goYW5pbWF0aW9uKTtcblxuICBcdFx0aWYgKCFhbmltYXRpb25zLnJ1bm5pbmcpIHtcbiAgXHRcdFx0YW5pbWF0aW9ucy5ydW5uaW5nID0gdHJ1ZTtcbiAgXHRcdFx0ckFGKGFuaW1hdGlvbnMudGljayk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdC8vIFRPRE8gb3B0aW1pc2UgdGhpc1xuICBcdGFib3J0OiBmdW5jdGlvbiAoa2V5cGF0aCwgcm9vdCkge1xuICBcdFx0dmFyIGkgPSBxdWV1ZS5sZW5ndGgsXG4gIFx0XHQgICAgYW5pbWF0aW9uO1xuXG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGFuaW1hdGlvbiA9IHF1ZXVlW2ldO1xuXG4gIFx0XHRcdGlmIChhbmltYXRpb24ucm9vdCA9PT0gcm9vdCAmJiBhbmltYXRpb24ua2V5cGF0aCA9PT0ga2V5cGF0aCkge1xuICBcdFx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIHNoYXJlZF9hbmltYXRpb25zID0gYW5pbWF0aW9ucztcblxuICB2YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR2YXIga2V5O1xuXG4gIFx0dGhpcy5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gIFx0Ly8gZnJvbSBhbmQgdG9cbiAgXHRmb3IgKGtleSBpbiBvcHRpb25zKSB7XG4gIFx0XHRpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gIFx0XHRcdHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR0aGlzLmludGVycG9sYXRvciA9IHNoYXJlZF9pbnRlcnBvbGF0ZSh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMucm9vdCwgdGhpcy5pbnRlcnBvbGF0b3IpO1xuICBcdHRoaXMucnVubmluZyA9IHRydWU7XG5cbiAgXHR0aGlzLnRpY2soKTtcbiAgfTtcblxuICBBbmltYXRpb24ucHJvdG90eXBlID0ge1xuICBcdHRpY2s6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBlbGFwc2VkLCB0LCB2YWx1ZSwgdGltZU5vdywgaW5kZXgsIGtleXBhdGg7XG5cbiAgXHRcdGtleXBhdGggPSB0aGlzLmtleXBhdGg7XG5cbiAgXHRcdGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgXHRcdFx0dGltZU5vdyA9IERhdGUubm93KCk7XG4gIFx0XHRcdGVsYXBzZWQgPSB0aW1lTm93IC0gdGhpcy5zdGFydFRpbWU7XG5cbiAgXHRcdFx0aWYgKGVsYXBzZWQgPj0gdGhpcy5kdXJhdGlvbikge1xuICBcdFx0XHRcdGlmIChrZXlwYXRoICE9PSBudWxsKSB7XG4gIFx0XHRcdFx0XHRnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLnJvb3QpO1xuICBcdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoa2V5cGF0aCwgdGhpcy50byk7XG4gIFx0XHRcdFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAodGhpcy5zdGVwKSB7XG4gIFx0XHRcdFx0XHR0aGlzLnN0ZXAoMSwgdGhpcy50byk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0dGhpcy5jb21wbGV0ZSh0aGlzLnRvKTtcblxuICBcdFx0XHRcdGluZGV4ID0gdGhpcy5yb290Ll9hbmltYXRpb25zLmluZGV4T2YodGhpcyk7XG5cbiAgXHRcdFx0XHQvLyBUT0RPIGludmVzdGlnYXRlIHdoeSB0aGlzIGhhcHBlbnNcbiAgXHRcdFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdFx0XHR3YXJuSWZEZWJ1ZyhcIkFuaW1hdGlvbiB3YXMgbm90IGZvdW5kXCIpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdHRoaXMucm9vdC5fYW5pbWF0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gIFx0XHRcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gIFx0XHRcdFx0cmV0dXJuIGZhbHNlOyAvLyByZW1vdmUgZnJvbSB0aGUgc3RhY2tcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHQgPSB0aGlzLmVhc2luZyA/IHRoaXMuZWFzaW5nKGVsYXBzZWQgLyB0aGlzLmR1cmF0aW9uKSA6IGVsYXBzZWQgLyB0aGlzLmR1cmF0aW9uO1xuXG4gIFx0XHRcdGlmIChrZXlwYXRoICE9PSBudWxsKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSB0aGlzLmludGVycG9sYXRvcih0KTtcbiAgXHRcdFx0XHRnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLnJvb3QpO1xuICBcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KGtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICh0aGlzLnN0ZXApIHtcbiAgXHRcdFx0XHR0aGlzLnN0ZXAodCwgdmFsdWUpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIHRydWU7IC8vIGtlZXAgaW4gdGhlIHN0YWNrXG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBmYWxzZTsgLy8gcmVtb3ZlIGZyb20gdGhlIHN0YWNrXG4gIFx0fSxcblxuICBcdHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBpbmRleDtcblxuICBcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cbiAgXHRcdGluZGV4ID0gdGhpcy5yb290Ll9hbmltYXRpb25zLmluZGV4T2YodGhpcyk7XG5cbiAgXHRcdC8vIFRPRE8gaW52ZXN0aWdhdGUgd2h5IHRoaXMgaGFwcGVuc1xuICBcdFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0XHR3YXJuSWZEZWJ1ZyhcIkFuaW1hdGlvbiB3YXMgbm90IGZvdW5kXCIpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnJvb3QuX2FuaW1hdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIGFuaW1hdGVfQW5pbWF0aW9uID0gQW5pbWF0aW9uO1xuXG4gIHZhciBwcm90b3R5cGVfYW5pbWF0ZSA9IFJhY3RpdmUkYW5pbWF0ZTtcblxuICB2YXIgbm9BbmltYXRpb24gPSB7IHN0b3A6IG5vb3AgfTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRhbmltYXRlKGtleXBhdGgsIHRvLCBvcHRpb25zKSB7XG4gIFx0dmFyIHByb21pc2UsIGZ1bGZpbFByb21pc2UsIGssIGFuaW1hdGlvbiwgYW5pbWF0aW9ucywgZWFzaW5nLCBkdXJhdGlvbiwgc3RlcCwgY29tcGxldGUsIG1ha2VWYWx1ZUNvbGxlY3RvciwgY3VycmVudFZhbHVlcywgY29sbGVjdFZhbHVlLCBkdW1teSwgZHVtbXlPcHRpb25zO1xuXG4gIFx0cHJvbWlzZSA9IG5ldyB1dGlsc19Qcm9taXNlKGZ1bmN0aW9uIChmdWxmaWwpIHtcbiAgXHRcdHJldHVybiBmdWxmaWxQcm9taXNlID0gZnVsZmlsO1xuICBcdH0pO1xuXG4gIFx0Ly8gYW5pbWF0ZSBtdWx0aXBsZSBrZXlwYXRoc1xuICBcdGlmICh0eXBlb2Yga2V5cGF0aCA9PT0gXCJvYmplY3RcIikge1xuICBcdFx0b3B0aW9ucyA9IHRvIHx8IHt9O1xuICBcdFx0ZWFzaW5nID0gb3B0aW9ucy5lYXNpbmc7XG4gIFx0XHRkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XG5cbiAgXHRcdGFuaW1hdGlvbnMgPSBbXTtcblxuICBcdFx0Ly8gd2UgZG9uJ3Qgd2FudCB0byBwYXNzIHRoZSBgc3RlcGAgYW5kIGBjb21wbGV0ZWAgaGFuZGxlcnMsIGFzIHRoZXkgd2lsbFxuICBcdFx0Ly8gcnVuIGZvciBlYWNoIGFuaW1hdGlvbiEgU28gaW5zdGVhZCB3ZSdsbCBzdG9yZSB0aGUgaGFuZGxlcnMgYW5kIGNyZWF0ZVxuICBcdFx0Ly8gb3VyIG93bi4uLlxuICBcdFx0c3RlcCA9IG9wdGlvbnMuc3RlcDtcbiAgXHRcdGNvbXBsZXRlID0gb3B0aW9ucy5jb21wbGV0ZTtcblxuICBcdFx0aWYgKHN0ZXAgfHwgY29tcGxldGUpIHtcbiAgXHRcdFx0Y3VycmVudFZhbHVlcyA9IHt9O1xuXG4gIFx0XHRcdG9wdGlvbnMuc3RlcCA9IG51bGw7XG4gIFx0XHRcdG9wdGlvbnMuY29tcGxldGUgPSBudWxsO1xuXG4gIFx0XHRcdG1ha2VWYWx1ZUNvbGxlY3RvciA9IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uICh0LCB2YWx1ZSkge1xuICBcdFx0XHRcdFx0Y3VycmVudFZhbHVlc1trZXlwYXRoXSA9IHZhbHVlO1xuICBcdFx0XHRcdH07XG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAoayBpbiBrZXlwYXRoKSB7XG4gIFx0XHRcdGlmIChrZXlwYXRoLmhhc093blByb3BlcnR5KGspKSB7XG4gIFx0XHRcdFx0aWYgKHN0ZXAgfHwgY29tcGxldGUpIHtcbiAgXHRcdFx0XHRcdGNvbGxlY3RWYWx1ZSA9IG1ha2VWYWx1ZUNvbGxlY3RvcihrKTtcbiAgXHRcdFx0XHRcdG9wdGlvbnMgPSB7IGVhc2luZzogZWFzaW5nLCBkdXJhdGlvbjogZHVyYXRpb24gfTtcblxuICBcdFx0XHRcdFx0aWYgKHN0ZXApIHtcbiAgXHRcdFx0XHRcdFx0b3B0aW9ucy5zdGVwID0gY29sbGVjdFZhbHVlO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdG9wdGlvbnMuY29tcGxldGUgPSBjb21wbGV0ZSA/IGNvbGxlY3RWYWx1ZSA6IG5vb3A7XG4gIFx0XHRcdFx0YW5pbWF0aW9ucy5wdXNoKGFuaW1hdGUodGhpcywgaywga2V5cGF0aFtrXSwgb3B0aW9ucykpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIENyZWF0ZSBhIGR1bW15IGFuaW1hdGlvbiwgdG8gZmFjaWxpdGF0ZSBzdGVwL2NvbXBsZXRlXG4gIFx0XHQvLyBjYWxsYmFja3MsIGFuZCBQcm9taXNlIGZ1bGZpbG1lbnRcbiAgXHRcdGR1bW15T3B0aW9ucyA9IHsgZWFzaW5nOiBlYXNpbmcsIGR1cmF0aW9uOiBkdXJhdGlvbiB9O1xuXG4gIFx0XHRpZiAoc3RlcCkge1xuICBcdFx0XHRkdW1teU9wdGlvbnMuc3RlcCA9IGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRcdFx0cmV0dXJuIHN0ZXAodCwgY3VycmVudFZhbHVlcyk7XG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChjb21wbGV0ZSkge1xuICBcdFx0XHRwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgXHRcdFx0XHRyZXR1cm4gY29tcGxldGUodCwgY3VycmVudFZhbHVlcyk7XG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHRkdW1teU9wdGlvbnMuY29tcGxldGUgPSBmdWxmaWxQcm9taXNlO1xuXG4gIFx0XHRkdW1teSA9IGFuaW1hdGUodGhpcywgbnVsbCwgbnVsbCwgZHVtbXlPcHRpb25zKTtcbiAgXHRcdGFuaW1hdGlvbnMucHVzaChkdW1teSk7XG5cbiAgXHRcdHByb21pc2Uuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dmFyIGFuaW1hdGlvbjtcblxuICBcdFx0XHR3aGlsZSAoYW5pbWF0aW9uID0gYW5pbWF0aW9ucy5wb3AoKSkge1xuICBcdFx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoZHVtbXkpIHtcbiAgXHRcdFx0XHRkdW1teS5zdG9wKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH07XG5cbiAgXHRcdHJldHVybiBwcm9taXNlO1xuICBcdH1cblxuICBcdC8vIGFuaW1hdGUgYSBzaW5nbGUga2V5cGF0aFxuICBcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIFx0aWYgKG9wdGlvbnMuY29tcGxldGUpIHtcbiAgXHRcdHByb21pc2UudGhlbihvcHRpb25zLmNvbXBsZXRlKTtcbiAgXHR9XG5cbiAgXHRvcHRpb25zLmNvbXBsZXRlID0gZnVsZmlsUHJvbWlzZTtcbiAgXHRhbmltYXRpb24gPSBhbmltYXRlKHRoaXMsIGtleXBhdGgsIHRvLCBvcHRpb25zKTtcblxuICBcdHByb21pc2Uuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBhbmltYXRpb24uc3RvcCgpO1xuICBcdH07XG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBhbmltYXRlKHJvb3QsIGtleXBhdGgsIHRvLCBvcHRpb25zKSB7XG4gIFx0dmFyIGVhc2luZywgZHVyYXRpb24sIGFuaW1hdGlvbiwgZnJvbTtcblxuICBcdGlmIChrZXlwYXRoKSB7XG4gIFx0XHRrZXlwYXRoID0gZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpO1xuICBcdH1cblxuICBcdGlmIChrZXlwYXRoICE9PSBudWxsKSB7XG4gIFx0XHRmcm9tID0gcm9vdC52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdH1cblxuICBcdC8vIGNhbmNlbCBhbnkgZXhpc3RpbmcgYW5pbWF0aW9uXG4gIFx0Ly8gVE9ETyB3aGF0IGFib3V0IHVwc3RyZWFtL2Rvd25zdHJlYW0ga2V5cGF0aHM/XG4gIFx0c2hhcmVkX2FuaW1hdGlvbnMuYWJvcnQoa2V5cGF0aCwgcm9vdCk7XG5cbiAgXHQvLyBkb24ndCBib3RoZXIgYW5pbWF0aW5nIHZhbHVlcyB0aGF0IHN0YXkgdGhlIHNhbWVcbiAgXHRpZiAoaXNFcXVhbChmcm9tLCB0bykpIHtcbiAgXHRcdGlmIChvcHRpb25zLmNvbXBsZXRlKSB7XG4gIFx0XHRcdG9wdGlvbnMuY29tcGxldGUob3B0aW9ucy50byk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBub0FuaW1hdGlvbjtcbiAgXHR9XG5cbiAgXHQvLyBlYXNpbmcgZnVuY3Rpb25cbiAgXHRpZiAob3B0aW9ucy5lYXNpbmcpIHtcbiAgXHRcdGlmICh0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRlYXNpbmcgPSBvcHRpb25zLmVhc2luZztcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGVhc2luZyA9IHJvb3QuZWFzaW5nW29wdGlvbnMuZWFzaW5nXTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHR5cGVvZiBlYXNpbmcgIT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRlYXNpbmcgPSBudWxsO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIGR1cmF0aW9uXG4gIFx0ZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uID09PSB1bmRlZmluZWQgPyA0MDAgOiBvcHRpb25zLmR1cmF0aW9uO1xuXG4gIFx0Ly8gVE9ETyBzdG9yZSBrZXlzLCB1c2UgYW4gaW50ZXJuYWwgc2V0IG1ldGhvZFxuICBcdGFuaW1hdGlvbiA9IG5ldyBhbmltYXRlX0FuaW1hdGlvbih7XG4gIFx0XHRrZXlwYXRoOiBrZXlwYXRoLFxuICBcdFx0ZnJvbTogZnJvbSxcbiAgXHRcdHRvOiB0byxcbiAgXHRcdHJvb3Q6IHJvb3QsXG4gIFx0XHRkdXJhdGlvbjogZHVyYXRpb24sXG4gIFx0XHRlYXNpbmc6IGVhc2luZyxcbiAgXHRcdGludGVycG9sYXRvcjogb3B0aW9ucy5pbnRlcnBvbGF0b3IsXG5cbiAgXHRcdC8vIFRPRE8gd3JhcCBjYWxsYmFja3MgaWYgbmVjZXNzYXJ5LCB0byB1c2UgaW5zdGFuY2UgYXMgY29udGV4dFxuICBcdFx0c3RlcDogb3B0aW9ucy5zdGVwLFxuICBcdFx0Y29tcGxldGU6IG9wdGlvbnMuY29tcGxldGVcbiAgXHR9KTtcblxuICBcdHNoYXJlZF9hbmltYXRpb25zLmFkZChhbmltYXRpb24pO1xuICBcdHJvb3QuX2FuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuXG4gIFx0cmV0dXJuIGFuaW1hdGlvbjtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZGV0YWNoID0gUmFjdGl2ZSRkZXRhY2g7XG4gIHZhciBwcm90b3R5cGVfZGV0YWNoX19kZXRhY2hIb29rID0gbmV3IGhvb2tzX0hvb2soXCJkZXRhY2hcIik7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkZGV0YWNoKCkge1xuICBcdGlmICh0aGlzLmRldGFjaGVkKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5kZXRhY2hlZDtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5lbCkge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCB0aGlzKTtcbiAgXHR9XG4gIFx0dGhpcy5kZXRhY2hlZCA9IHRoaXMuZnJhZ21lbnQuZGV0YWNoKCk7XG4gIFx0cHJvdG90eXBlX2RldGFjaF9fZGV0YWNoSG9vay5maXJlKHRoaXMpO1xuICBcdHJldHVybiB0aGlzLmRldGFjaGVkO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9maW5kID0gUmFjdGl2ZSRmaW5kO1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmluZChzZWxlY3Rvcikge1xuICBcdGlmICghdGhpcy5lbCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZChzZWxlY3Rvcik7XG4gIH1cblxuICB2YXIgdGVzdCA9IFF1ZXJ5JHRlc3Q7XG4gIGZ1bmN0aW9uIFF1ZXJ5JHRlc3QoaXRlbSwgbm9EaXJ0eSkge1xuICBcdHZhciBpdGVtTWF0Y2hlcztcblxuICBcdGlmICh0aGlzLl9pc0NvbXBvbmVudFF1ZXJ5KSB7XG4gIFx0XHRpdGVtTWF0Y2hlcyA9ICF0aGlzLnNlbGVjdG9yIHx8IGl0ZW0ubmFtZSA9PT0gdGhpcy5zZWxlY3RvcjtcbiAgXHR9IGVsc2Uge1xuICBcdFx0aXRlbU1hdGNoZXMgPSBpdGVtLm5vZGUgPyBtYXRjaGVzKGl0ZW0ubm9kZSwgdGhpcy5zZWxlY3RvcikgOiBudWxsO1xuICBcdH1cblxuICBcdGlmIChpdGVtTWF0Y2hlcykge1xuICBcdFx0dGhpcy5wdXNoKGl0ZW0ubm9kZSB8fCBpdGVtLmluc3RhbmNlKTtcblxuICBcdFx0aWYgKCFub0RpcnR5KSB7XG4gIFx0XHRcdHRoaXMuX21ha2VEaXJ0eSgpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG4gIH1cblxuICB2YXIgbWFrZVF1ZXJ5X2NhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgXHR2YXIgbGl2ZVF1ZXJpZXMsIHNlbGVjdG9yLCBpbmRleDtcblxuICBcdGxpdmVRdWVyaWVzID0gdGhpcy5fcm9vdFt0aGlzLl9pc0NvbXBvbmVudFF1ZXJ5ID8gXCJsaXZlQ29tcG9uZW50UXVlcmllc1wiIDogXCJsaXZlUXVlcmllc1wiXTtcbiAgXHRzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG5cbiAgXHRpbmRleCA9IGxpdmVRdWVyaWVzLmluZGV4T2Yoc2VsZWN0b3IpO1xuXG4gIFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0bGl2ZVF1ZXJpZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHRcdGxpdmVRdWVyaWVzW3NlbGVjdG9yXSA9IG51bGw7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBzb3J0QnlJdGVtUG9zaXRpb24gPSBmdW5jdGlvbiAoYSwgYikge1xuICBcdHZhciBhbmNlc3RyeUEsIGFuY2VzdHJ5Qiwgb2xkZXN0QSwgb2xkZXN0QiwgbXV0dWFsQW5jZXN0b3IsIGluZGV4QSwgaW5kZXhCLCBmcmFnbWVudHMsIGZyYWdtZW50QSwgZnJhZ21lbnRCO1xuXG4gIFx0YW5jZXN0cnlBID0gZ2V0QW5jZXN0cnkoYS5jb21wb25lbnQgfHwgYS5fcmFjdGl2ZS5wcm94eSk7XG4gIFx0YW5jZXN0cnlCID0gZ2V0QW5jZXN0cnkoYi5jb21wb25lbnQgfHwgYi5fcmFjdGl2ZS5wcm94eSk7XG5cbiAgXHRvbGRlc3RBID0gbGFzdEl0ZW0oYW5jZXN0cnlBKTtcbiAgXHRvbGRlc3RCID0gbGFzdEl0ZW0oYW5jZXN0cnlCKTtcblxuICBcdC8vIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBlbmQgb2YgYm90aCBhbmNlc3RyaWVzIGFzIGxvbmcgYXMgdGhleSBhcmUgaWRlbnRpY2FsXG4gIFx0Ly8gLSB0aGUgZmluYWwgb25lIHJlbW92ZWQgaXMgdGhlIGNsb3Nlc3QgbXV0dWFsIGFuY2VzdG9yXG4gIFx0d2hpbGUgKG9sZGVzdEEgJiYgb2xkZXN0QSA9PT0gb2xkZXN0Qikge1xuICBcdFx0YW5jZXN0cnlBLnBvcCgpO1xuICBcdFx0YW5jZXN0cnlCLnBvcCgpO1xuXG4gIFx0XHRtdXR1YWxBbmNlc3RvciA9IG9sZGVzdEE7XG5cbiAgXHRcdG9sZGVzdEEgPSBsYXN0SXRlbShhbmNlc3RyeUEpO1xuICBcdFx0b2xkZXN0QiA9IGxhc3RJdGVtKGFuY2VzdHJ5Qik7XG4gIFx0fVxuXG4gIFx0Ly8gbm93IHRoYXQgd2UgaGF2ZSB0aGUgbXV0dWFsIGFuY2VzdG9yLCB3ZSBjYW4gZmluZCB3aGljaCBpcyBlYXJsaWVzdFxuICBcdG9sZGVzdEEgPSBvbGRlc3RBLmNvbXBvbmVudCB8fCBvbGRlc3RBO1xuICBcdG9sZGVzdEIgPSBvbGRlc3RCLmNvbXBvbmVudCB8fCBvbGRlc3RCO1xuXG4gIFx0ZnJhZ21lbnRBID0gb2xkZXN0QS5wYXJlbnRGcmFnbWVudDtcbiAgXHRmcmFnbWVudEIgPSBvbGRlc3RCLnBhcmVudEZyYWdtZW50O1xuXG4gIFx0Ly8gaWYgYm90aCBpdGVtcyBzaGFyZSBhIHBhcmVudCBmcmFnbWVudCwgb3VyIGpvYiBpcyBlYXN5XG4gIFx0aWYgKGZyYWdtZW50QSA9PT0gZnJhZ21lbnRCKSB7XG4gIFx0XHRpbmRleEEgPSBmcmFnbWVudEEuaXRlbXMuaW5kZXhPZihvbGRlc3RBKTtcbiAgXHRcdGluZGV4QiA9IGZyYWdtZW50Qi5pdGVtcy5pbmRleE9mKG9sZGVzdEIpO1xuXG4gIFx0XHQvLyBpZiBpdCdzIHRoZSBzYW1lIGluZGV4LCBpdCBtZWFucyBvbmUgY29udGFpbnMgdGhlIG90aGVyLFxuICBcdFx0Ly8gc28gd2Ugc2VlIHdoaWNoIGhhcyB0aGUgbG9uZ2VzdCBhbmNlc3RyeVxuICBcdFx0cmV0dXJuIGluZGV4QSAtIGluZGV4QiB8fCBhbmNlc3RyeUEubGVuZ3RoIC0gYW5jZXN0cnlCLmxlbmd0aDtcbiAgXHR9XG5cbiAgXHQvLyBpZiBtdXR1YWwgYW5jZXN0b3IgaXMgYSBzZWN0aW9uLCB3ZSBmaXJzdCB0ZXN0IHRvIHNlZSB3aGljaCBzZWN0aW9uXG4gIFx0Ly8gZnJhZ21lbnQgY29tZXMgZmlyc3RcbiAgXHRpZiAoZnJhZ21lbnRzID0gbXV0dWFsQW5jZXN0b3IuZnJhZ21lbnRzKSB7XG4gIFx0XHRpbmRleEEgPSBmcmFnbWVudHMuaW5kZXhPZihmcmFnbWVudEEpO1xuICBcdFx0aW5kZXhCID0gZnJhZ21lbnRzLmluZGV4T2YoZnJhZ21lbnRCKTtcblxuICBcdFx0cmV0dXJuIGluZGV4QSAtIGluZGV4QiB8fCBhbmNlc3RyeUEubGVuZ3RoIC0gYW5jZXN0cnlCLmxlbmd0aDtcbiAgXHR9XG5cbiAgXHR0aHJvdyBuZXcgRXJyb3IoXCJBbiB1bmV4cGVjdGVkIGNvbmRpdGlvbiB3YXMgbWV0IHdoaWxlIGNvbXBhcmluZyB0aGUgcG9zaXRpb24gb2YgdHdvIGNvbXBvbmVudHMuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9SYWN0aXZlSlMvUmFjdGl2ZS9pc3N1ZXMgLSB0aGFua3MhXCIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFBhcmVudChpdGVtKSB7XG4gIFx0dmFyIHBhcmVudEZyYWdtZW50O1xuXG4gIFx0aWYgKHBhcmVudEZyYWdtZW50ID0gaXRlbS5wYXJlbnRGcmFnbWVudCkge1xuICBcdFx0cmV0dXJuIHBhcmVudEZyYWdtZW50Lm93bmVyO1xuICBcdH1cblxuICBcdGlmIChpdGVtLmNvbXBvbmVudCAmJiAocGFyZW50RnJhZ21lbnQgPSBpdGVtLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCkpIHtcbiAgXHRcdHJldHVybiBwYXJlbnRGcmFnbWVudC5vd25lcjtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBbmNlc3RyeShpdGVtKSB7XG4gIFx0dmFyIGFuY2VzdHJ5LCBhbmNlc3RvcjtcblxuICBcdGFuY2VzdHJ5ID0gW2l0ZW1dO1xuXG4gIFx0YW5jZXN0b3IgPSBnZXRQYXJlbnQoaXRlbSk7XG5cbiAgXHR3aGlsZSAoYW5jZXN0b3IpIHtcbiAgXHRcdGFuY2VzdHJ5LnB1c2goYW5jZXN0b3IpO1xuICBcdFx0YW5jZXN0b3IgPSBnZXRQYXJlbnQoYW5jZXN0b3IpO1xuICBcdH1cblxuICBcdHJldHVybiBhbmNlc3RyeTtcbiAgfVxuXG4gIHZhciBzb3J0QnlEb2N1bWVudFBvc2l0aW9uID0gZnVuY3Rpb24gKG5vZGUsIG90aGVyTm9kZSkge1xuICBcdHZhciBiaXRtYXNrO1xuXG4gIFx0aWYgKG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgXHRcdGJpdG1hc2sgPSBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG90aGVyTm9kZSk7XG4gIFx0XHRyZXR1cm4gYml0bWFzayAmIDIgPyAxIDogLTE7XG4gIFx0fVxuXG4gIFx0Ly8gSW4gb2xkIElFLCB3ZSBjYW4gcGlnZ3kgYmFjayBvbiB0aGUgbWVjaGFuaXNtIGZvclxuICBcdC8vIGNvbXBhcmluZyBjb21wb25lbnQgcG9zaXRpb25zXG4gIFx0cmV0dXJuIHNvcnRCeUl0ZW1Qb3NpdGlvbihub2RlLCBvdGhlck5vZGUpO1xuICB9O1xuXG4gIHZhciBzb3J0ID0gZnVuY3Rpb24gKCkge1xuICBcdHRoaXMuc29ydCh0aGlzLl9pc0NvbXBvbmVudFF1ZXJ5ID8gc29ydEJ5SXRlbVBvc2l0aW9uIDogc29ydEJ5RG9jdW1lbnRQb3NpdGlvbik7XG4gIFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgbWFrZVF1ZXJ5X2RpcnR5ID0gZnVuY3Rpb24gKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRpZiAoIXRoaXMuX2RpcnR5KSB7XG4gIFx0XHR0aGlzLl9kaXJ0eSA9IHRydWU7XG5cbiAgXHRcdC8vIE9uY2UgdGhlIERPTSBoYXMgYmVlbiB1cGRhdGVkLCBlbnN1cmUgdGhlIHF1ZXJ5XG4gIFx0XHQvLyBpcyBjb3JyZWN0bHkgb3JkZXJlZFxuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0X3RoaXMuX3NvcnQoKTtcbiAgXHRcdH0pO1xuICBcdH1cbiAgfTtcblxuICB2YXIgcmVtb3ZlID0gZnVuY3Rpb24gKG5vZGVPckNvbXBvbmVudCkge1xuICBcdHZhciBpbmRleCA9IHRoaXMuaW5kZXhPZih0aGlzLl9pc0NvbXBvbmVudFF1ZXJ5ID8gbm9kZU9yQ29tcG9uZW50Lmluc3RhbmNlIDogbm9kZU9yQ29tcG9uZW50KTtcblxuICBcdGlmIChpbmRleCAhPT0gLTEpIHtcbiAgXHRcdHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIF9tYWtlUXVlcnkgPSBtYWtlUXVlcnk7XG4gIGZ1bmN0aW9uIG1ha2VRdWVyeShyYWN0aXZlLCBzZWxlY3RvciwgbGl2ZSwgaXNDb21wb25lbnRRdWVyeSkge1xuICBcdHZhciBxdWVyeSA9IFtdO1xuXG4gIFx0ZGVmaW5lUHJvcGVydGllcyhxdWVyeSwge1xuICBcdFx0c2VsZWN0b3I6IHsgdmFsdWU6IHNlbGVjdG9yIH0sXG4gIFx0XHRsaXZlOiB7IHZhbHVlOiBsaXZlIH0sXG5cbiAgXHRcdF9pc0NvbXBvbmVudFF1ZXJ5OiB7IHZhbHVlOiBpc0NvbXBvbmVudFF1ZXJ5IH0sXG4gIFx0XHRfdGVzdDogeyB2YWx1ZTogdGVzdCB9XG4gIFx0fSk7XG5cbiAgXHRpZiAoIWxpdmUpIHtcbiAgXHRcdHJldHVybiBxdWVyeTtcbiAgXHR9XG5cbiAgXHRkZWZpbmVQcm9wZXJ0aWVzKHF1ZXJ5LCB7XG4gIFx0XHRjYW5jZWw6IHsgdmFsdWU6IG1ha2VRdWVyeV9jYW5jZWwgfSxcblxuICBcdFx0X3Jvb3Q6IHsgdmFsdWU6IHJhY3RpdmUgfSxcbiAgXHRcdF9zb3J0OiB7IHZhbHVlOiBzb3J0IH0sXG4gIFx0XHRfbWFrZURpcnR5OiB7IHZhbHVlOiBtYWtlUXVlcnlfZGlydHkgfSxcbiAgXHRcdF9yZW1vdmU6IHsgdmFsdWU6IHJlbW92ZSB9LFxuXG4gIFx0XHRfZGlydHk6IHsgdmFsdWU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSB9XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gcXVlcnk7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2ZpbmRBbGwgPSBSYWN0aXZlJGZpbmRBbGw7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmluZEFsbChzZWxlY3Rvciwgb3B0aW9ucykge1xuICBcdHZhciBsaXZlUXVlcmllcywgcXVlcnk7XG5cbiAgXHRpZiAoIXRoaXMuZWwpIHtcbiAgXHRcdHJldHVybiBbXTtcbiAgXHR9XG5cbiAgXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgXHRsaXZlUXVlcmllcyA9IHRoaXMuX2xpdmVRdWVyaWVzO1xuXG4gIFx0Ly8gU2hvcnRjdXQ6IGlmIHdlJ3JlIG1haW50YWluaW5nIGEgbGl2ZSBxdWVyeSB3aXRoIHRoaXNcbiAgXHQvLyBzZWxlY3Rvciwgd2UgZG9uJ3QgbmVlZCB0byB0cmF2ZXJzZSB0aGUgcGFyYWxsZWwgRE9NXG4gIFx0aWYgKHF1ZXJ5ID0gbGl2ZVF1ZXJpZXNbc2VsZWN0b3JdKSB7XG5cbiAgXHRcdC8vIEVpdGhlciByZXR1cm4gdGhlIGV4YWN0IHNhbWUgcXVlcnksIG9yIChpZiBub3QgbGl2ZSkgYSBzbmFwc2hvdFxuICBcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5saXZlID8gcXVlcnkgOiBxdWVyeS5zbGljZSgpO1xuICBcdH1cblxuICBcdHF1ZXJ5ID0gX21ha2VRdWVyeSh0aGlzLCBzZWxlY3RvciwgISFvcHRpb25zLmxpdmUsIGZhbHNlKTtcblxuICBcdC8vIEFkZCB0aGlzIHRvIHRoZSBsaXN0IG9mIGxpdmUgcXVlcmllcyBSYWN0aXZlIG5lZWRzIHRvIG1haW50YWluLFxuICBcdC8vIGlmIGFwcGxpY2FibGVcbiAgXHRpZiAocXVlcnkubGl2ZSkge1xuICBcdFx0bGl2ZVF1ZXJpZXMucHVzaChzZWxlY3Rvcik7XG4gIFx0XHRsaXZlUXVlcmllc1tcIl9cIiArIHNlbGVjdG9yXSA9IHF1ZXJ5O1xuICBcdH1cblxuICBcdHRoaXMuZnJhZ21lbnQuZmluZEFsbChzZWxlY3RvciwgcXVlcnkpO1xuICBcdHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMgPSBSYWN0aXZlJGZpbmRBbGxDb21wb25lbnRzO1xuICBmdW5jdGlvbiBSYWN0aXZlJGZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBvcHRpb25zKSB7XG4gIFx0dmFyIGxpdmVRdWVyaWVzLCBxdWVyeTtcblxuICBcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBcdGxpdmVRdWVyaWVzID0gdGhpcy5fbGl2ZUNvbXBvbmVudFF1ZXJpZXM7XG5cbiAgXHQvLyBTaG9ydGN1dDogaWYgd2UncmUgbWFpbnRhaW5pbmcgYSBsaXZlIHF1ZXJ5IHdpdGggdGhpc1xuICBcdC8vIHNlbGVjdG9yLCB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIHRoZSBwYXJhbGxlbCBET01cbiAgXHRpZiAocXVlcnkgPSBsaXZlUXVlcmllc1tzZWxlY3Rvcl0pIHtcblxuICBcdFx0Ly8gRWl0aGVyIHJldHVybiB0aGUgZXhhY3Qgc2FtZSBxdWVyeSwgb3IgKGlmIG5vdCBsaXZlKSBhIHNuYXBzaG90XG4gIFx0XHRyZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmxpdmUgPyBxdWVyeSA6IHF1ZXJ5LnNsaWNlKCk7XG4gIFx0fVxuXG4gIFx0cXVlcnkgPSBfbWFrZVF1ZXJ5KHRoaXMsIHNlbGVjdG9yLCAhIW9wdGlvbnMubGl2ZSwgdHJ1ZSk7XG5cbiAgXHQvLyBBZGQgdGhpcyB0byB0aGUgbGlzdCBvZiBsaXZlIHF1ZXJpZXMgUmFjdGl2ZSBuZWVkcyB0byBtYWludGFpbixcbiAgXHQvLyBpZiBhcHBsaWNhYmxlXG4gIFx0aWYgKHF1ZXJ5LmxpdmUpIHtcbiAgXHRcdGxpdmVRdWVyaWVzLnB1c2goc2VsZWN0b3IpO1xuICBcdFx0bGl2ZVF1ZXJpZXNbXCJfXCIgKyBzZWxlY3Rvcl0gPSBxdWVyeTtcbiAgXHR9XG5cbiAgXHR0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0cmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9maW5kQ29tcG9uZW50ID0gUmFjdGl2ZSRmaW5kQ29tcG9uZW50O1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmluZENvbXBvbmVudChzZWxlY3Rvcikge1xuICBcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRDb21wb25lbnQoc2VsZWN0b3IpO1xuICB9XG5cbiAgdmFyIGZpbmRDb250YWluZXIgPSBSYWN0aXZlJGZpbmRDb250YWluZXI7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRmaW5kQ29udGFpbmVyKHNlbGVjdG9yKSB7XG4gIFx0aWYgKHRoaXMuY29udGFpbmVyKSB7XG4gIFx0XHRpZiAodGhpcy5jb250YWluZXIuY29tcG9uZW50ICYmIHRoaXMuY29udGFpbmVyLmNvbXBvbmVudC5uYW1lID09PSBzZWxlY3Rvcikge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5jb250YWluZXIuZmluZENvbnRhaW5lcihzZWxlY3Rvcik7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZmluZFBhcmVudCA9IFJhY3RpdmUkZmluZFBhcmVudDtcblxuICBmdW5jdGlvbiBSYWN0aXZlJGZpbmRQYXJlbnQoc2VsZWN0b3IpIHtcblxuICBcdGlmICh0aGlzLnBhcmVudCkge1xuICBcdFx0aWYgKHRoaXMucGFyZW50LmNvbXBvbmVudCAmJiB0aGlzLnBhcmVudC5jb21wb25lbnQubmFtZSA9PT0gc2VsZWN0b3IpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMucGFyZW50O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMucGFyZW50LmZpbmRQYXJlbnQoc2VsZWN0b3IpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV2ZW50U3RhY2sgPSB7XG4gIFx0ZW5xdWV1ZTogZnVuY3Rpb24gKHJhY3RpdmUsIGV2ZW50KSB7XG4gIFx0XHRpZiAocmFjdGl2ZS5ldmVudCkge1xuICBcdFx0XHRyYWN0aXZlLl9ldmVudFF1ZXVlID0gcmFjdGl2ZS5fZXZlbnRRdWV1ZSB8fCBbXTtcbiAgXHRcdFx0cmFjdGl2ZS5fZXZlbnRRdWV1ZS5wdXNoKHJhY3RpdmUuZXZlbnQpO1xuICBcdFx0fVxuICBcdFx0cmFjdGl2ZS5ldmVudCA9IGV2ZW50O1xuICBcdH0sXG4gIFx0ZGVxdWV1ZTogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdGlmIChyYWN0aXZlLl9ldmVudFF1ZXVlICYmIHJhY3RpdmUuX2V2ZW50UXVldWUubGVuZ3RoKSB7XG4gIFx0XHRcdHJhY3RpdmUuZXZlbnQgPSByYWN0aXZlLl9ldmVudFF1ZXVlLnBvcCgpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZGVsZXRlIHJhY3RpdmUuZXZlbnQ7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBzaGFyZWRfZXZlbnRTdGFjayA9IGV2ZW50U3RhY2s7XG5cbiAgdmFyIHNoYXJlZF9maXJlRXZlbnQgPSBmaXJlRXZlbnQ7XG5cbiAgZnVuY3Rpb24gZmlyZUV2ZW50KHJhY3RpdmUsIGV2ZW50TmFtZSkge1xuICBcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1syXTtcblxuICBcdGlmICghZXZlbnROYW1lKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKCFvcHRpb25zLmV2ZW50KSB7XG4gIFx0XHRvcHRpb25zLmV2ZW50ID0ge1xuICBcdFx0XHRuYW1lOiBldmVudE5hbWUsXG4gIFx0XHRcdC8vIHVudGlsIGV2ZW50IG5vdCBpbmNsdWRlZCBhcyBhcmd1bWVudCBkZWZhdWx0XG4gIFx0XHRcdF9ub0FyZzogdHJ1ZVxuICBcdFx0fTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0b3B0aW9ucy5ldmVudC5uYW1lID0gZXZlbnROYW1lO1xuICBcdH1cblxuICBcdHZhciBldmVudE5hbWVzID0gZ2V0S2V5cGF0aChldmVudE5hbWUpLndpbGRjYXJkTWF0Y2hlcygpO1xuICBcdGZpcmVFdmVudEFzKHJhY3RpdmUsIGV2ZW50TmFtZXMsIG9wdGlvbnMuZXZlbnQsIG9wdGlvbnMuYXJncywgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlRXZlbnRBcyhyYWN0aXZlLCBldmVudE5hbWVzLCBldmVudCwgYXJncykge1xuICBcdHZhciBpbml0aWFsRmlyZSA9IGFyZ3VtZW50c1s0XSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbNF07XG5cbiAgXHR2YXIgc3Vic2NyaWJlcnMsXG4gIFx0ICAgIGksXG4gIFx0ICAgIGJ1YmJsZSA9IHRydWU7XG5cbiAgXHRzaGFyZWRfZXZlbnRTdGFjay5lbnF1ZXVlKHJhY3RpdmUsIGV2ZW50KTtcblxuICBcdGZvciAoaSA9IGV2ZW50TmFtZXMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICBcdFx0c3Vic2NyaWJlcnMgPSByYWN0aXZlLl9zdWJzW2V2ZW50TmFtZXNbaV1dO1xuXG4gIFx0XHRpZiAoc3Vic2NyaWJlcnMpIHtcbiAgXHRcdFx0YnViYmxlID0gbm90aWZ5U3Vic2NyaWJlcnMocmFjdGl2ZSwgc3Vic2NyaWJlcnMsIGV2ZW50LCBhcmdzKSAmJiBidWJibGU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0c2hhcmVkX2V2ZW50U3RhY2suZGVxdWV1ZShyYWN0aXZlKTtcblxuICBcdGlmIChyYWN0aXZlLnBhcmVudCAmJiBidWJibGUpIHtcblxuICBcdFx0aWYgKGluaXRpYWxGaXJlICYmIHJhY3RpdmUuY29tcG9uZW50KSB7XG4gIFx0XHRcdHZhciBmdWxsTmFtZSA9IHJhY3RpdmUuY29tcG9uZW50Lm5hbWUgKyBcIi5cIiArIGV2ZW50TmFtZXNbZXZlbnROYW1lcy5sZW5ndGggLSAxXTtcbiAgXHRcdFx0ZXZlbnROYW1lcyA9IGdldEtleXBhdGgoZnVsbE5hbWUpLndpbGRjYXJkTWF0Y2hlcygpO1xuXG4gIFx0XHRcdGlmIChldmVudCkge1xuICBcdFx0XHRcdGV2ZW50LmNvbXBvbmVudCA9IHJhY3RpdmU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0ZmlyZUV2ZW50QXMocmFjdGl2ZS5wYXJlbnQsIGV2ZW50TmFtZXMsIGV2ZW50LCBhcmdzKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnlTdWJzY3JpYmVycyhyYWN0aXZlLCBzdWJzY3JpYmVycywgZXZlbnQsIGFyZ3MpIHtcbiAgXHR2YXIgb3JpZ2luYWxFdmVudCA9IG51bGwsXG4gIFx0ICAgIHN0b3BFdmVudCA9IGZhbHNlO1xuXG4gIFx0aWYgKGV2ZW50ICYmICFldmVudC5fbm9BcmcpIHtcbiAgXHRcdGFyZ3MgPSBbZXZlbnRdLmNvbmNhdChhcmdzKTtcbiAgXHR9XG5cbiAgXHQvLyBzdWJzY3JpYmVycyBjYW4gYmUgbW9kaWZpZWQgaW5mbGlnaHQsIGUuZy4gXCJvbmNlXCIgZnVuY3Rpb25hbGl0eVxuICBcdC8vIHNvIHdlIG5lZWQgdG8gY29weSB0byBtYWtlIHN1cmUgZXZlcnlvbmUgZ2V0cyBjYWxsZWRcbiAgXHRzdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzLnNsaWNlKCk7XG5cbiAgXHRmb3IgKHZhciBpID0gMCwgbGVuID0gc3Vic2NyaWJlcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdGlmIChzdWJzY3JpYmVyc1tpXS5hcHBseShyYWN0aXZlLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgXHRcdFx0c3RvcEV2ZW50ID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoZXZlbnQgJiYgIWV2ZW50Ll9ub0FyZyAmJiBzdG9wRXZlbnQgJiYgKG9yaWdpbmFsRXZlbnQgPSBldmVudC5vcmlnaW5hbCkpIHtcbiAgXHRcdG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQgJiYgb3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBcdFx0b3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24gJiYgb3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gIXN0b3BFdmVudDtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZmlyZSA9IFJhY3RpdmUkZmlyZTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRmaXJlKGV2ZW50TmFtZSkge1xuXG4gIFx0dmFyIG9wdGlvbnMgPSB7XG4gIFx0XHRhcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gIFx0fTtcblxuICBcdHNoYXJlZF9maXJlRXZlbnQodGhpcywgZXZlbnROYW1lLCBvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZ2V0ID0gUmFjdGl2ZSRnZXQ7XG4gIHZhciBvcHRpb25zID0ge1xuICBcdGNhcHR1cmU6IHRydWUsIC8vIHRvcC1sZXZlbCBjYWxscyBzaG91bGQgYmUgaW50ZXJjZXB0ZWRcbiAgXHRub1Vud3JhcDogdHJ1ZSwgLy8gd3JhcHBlZCB2YWx1ZXMgc2hvdWxkIE5PVCBiZSB1bndyYXBwZWRcbiAgXHRmdWxsUm9vdEdldDogdHJ1ZSAvLyByb290IGdldCBzaG91bGQgcmV0dXJuIG1hcHBpbmdzXG4gIH07XG4gIGZ1bmN0aW9uIFJhY3RpdmUkZ2V0KGtleXBhdGgpIHtcbiAgXHR2YXIgdmFsdWU7XG5cbiAgXHRrZXlwYXRoID0gZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpO1xuICBcdHZhbHVlID0gdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgsIG9wdGlvbnMpO1xuXG4gIFx0Ly8gQ3JlYXRlIGludGVyLWNvbXBvbmVudCBiaW5kaW5nLCBpZiBuZWNlc3NhcnlcbiAgXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnBhcmVudCAmJiAhdGhpcy5pc29sYXRlZCkge1xuICBcdFx0aWYgKHNoYXJlZF9yZXNvbHZlUmVmKHRoaXMsIGtleXBhdGguc3RyLCB0aGlzLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCkpIHtcbiAgXHRcdFx0Ly8gY3JlYXRlcyBiaW5kaW5nIGFzIHNpZGUtZWZmZWN0LCBpZiBhcHByb3ByaWF0ZVxuICBcdFx0XHR2YWx1ZSA9IHRoaXMudmlld21vZGVsLmdldChrZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdmFsdWU7XG4gIH1cblxuICB2YXIgaW5zZXJ0ID0gUmFjdGl2ZSRpbnNlcnQ7XG5cbiAgdmFyIGluc2VydEhvb2sgPSBuZXcgaG9va3NfSG9vayhcImluc2VydFwiKTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRpbnNlcnQodGFyZ2V0LCBhbmNob3IpIHtcbiAgXHRpZiAoIXRoaXMuZnJhZ21lbnQucmVuZGVyZWQpIHtcbiAgXHRcdC8vIFRPRE8gY3JlYXRlLCBhbmQgbGluayB0bywgZG9jdW1lbnRhdGlvbiBleHBsYWluaW5nIHRoaXNcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIlRoZSBBUEkgaGFzIGNoYW5nZWQgLSB5b3UgbXVzdCBjYWxsIGByYWN0aXZlLnJlbmRlcih0YXJnZXRbLCBhbmNob3JdKWAgdG8gcmVuZGVyIHlvdXIgUmFjdGl2ZSBpbnN0YW5jZS4gT25jZSByZW5kZXJlZCB5b3UgY2FuIHVzZSBgcmFjdGl2ZS5pbnNlcnQoKWAuXCIpO1xuICBcdH1cblxuICBcdHRhcmdldCA9IGdldEVsZW1lbnQodGFyZ2V0KTtcbiAgXHRhbmNob3IgPSBnZXRFbGVtZW50KGFuY2hvcikgfHwgbnVsbDtcblxuICBcdGlmICghdGFyZ2V0KSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBzcGVjaWZ5IGEgdmFsaWQgdGFyZ2V0IHRvIGluc2VydCBpbnRvXCIpO1xuICBcdH1cblxuICBcdHRhcmdldC5pbnNlcnRCZWZvcmUodGhpcy5kZXRhY2goKSwgYW5jaG9yKTtcbiAgXHR0aGlzLmVsID0gdGFyZ2V0O1xuXG4gIFx0KHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gfHwgKHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gPSBbXSkpLnB1c2godGhpcyk7XG4gIFx0dGhpcy5kZXRhY2hlZCA9IG51bGw7XG5cbiAgXHRmaXJlSW5zZXJ0SG9vayh0aGlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVJbnNlcnRIb29rKHJhY3RpdmUpIHtcbiAgXHRpbnNlcnRIb29rLmZpcmUocmFjdGl2ZSk7XG5cbiAgXHRyYWN0aXZlLmZpbmRBbGxDb21wb25lbnRzKFwiKlwiKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICBcdFx0ZmlyZUluc2VydEhvb2soY2hpbGQuaW5zdGFuY2UpO1xuICBcdH0pO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9tZXJnZSA9IFJhY3RpdmUkbWVyZ2U7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkbWVyZ2Uoa2V5cGF0aCwgYXJyYXksIG9wdGlvbnMpIHtcbiAgXHR2YXIgY3VycmVudEFycmF5LCBwcm9taXNlO1xuXG4gIFx0a2V5cGF0aCA9IGdldEtleXBhdGgobm9ybWFsaXNlKGtleXBhdGgpKTtcbiAgXHRjdXJyZW50QXJyYXkgPSB0aGlzLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHQvLyBJZiBlaXRoZXIgdGhlIGV4aXN0aW5nIHZhbHVlIG9yIHRoZSBuZXcgdmFsdWUgaXNuJ3QgYW5cbiAgXHQvLyBhcnJheSwganVzdCBkbyBhIHJlZ3VsYXIgc2V0XG4gIFx0aWYgKCFpc0FycmF5KGN1cnJlbnRBcnJheSkgfHwgIWlzQXJyYXkoYXJyYXkpKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5zZXQoa2V5cGF0aCwgYXJyYXksIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wbGV0ZSk7XG4gIFx0fVxuXG4gIFx0Ly8gTWFuYWdlIHRyYW5zaXRpb25zXG4gIFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpO1xuICBcdHRoaXMudmlld21vZGVsLm1lcmdlKGtleXBhdGgsIGN1cnJlbnRBcnJheSwgYXJyYXksIG9wdGlvbnMpO1xuICBcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB2YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiAocmFjdGl2ZSwga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgXHR0aGlzLnJvb3QgPSByYWN0aXZlO1xuICBcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICBcdHRoaXMuZGVmZXIgPSBvcHRpb25zLmRlZmVyO1xuXG4gIFx0Ly8gZGVmYXVsdCB0byByb290IGFzIGNvbnRleHQsIGJ1dCBhbGxvdyBpdCB0byBiZSBvdmVycmlkZGVuXG4gIFx0dGhpcy5jb250ZXh0ID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbnRleHQgPyBvcHRpb25zLmNvbnRleHQgOiByYWN0aXZlO1xuICB9O1xuXG4gIE9ic2VydmVyLnByb3RvdHlwZSA9IHtcbiAgXHRpbml0OiBmdW5jdGlvbiAoaW1tZWRpYXRlKSB7XG4gIFx0XHR0aGlzLnZhbHVlID0gdGhpcy5yb290LmdldCh0aGlzLmtleXBhdGguc3RyKTtcblxuICBcdFx0aWYgKGltbWVkaWF0ZSAhPT0gZmFsc2UpIHtcbiAgXHRcdFx0dGhpcy51cGRhdGUoKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMub2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHRpZiAoIWlzRXF1YWwodmFsdWUsIHRoaXMudmFsdWUpKSB7XG4gIFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICBcdFx0XHRpZiAodGhpcy5kZWZlciAmJiB0aGlzLnJlYWR5KSB7XG4gIFx0XHRcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdHJldHVybiBfdGhpcy51cGRhdGUoKTtcbiAgXHRcdFx0XHR9KTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gUHJldmVudCBpbmZpbml0ZSBsb29wc1xuICBcdFx0aWYgKHRoaXMudXBkYXRpbmcpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblxuICBcdFx0dGhpcy5jYWxsYmFjay5jYWxsKHRoaXMuY29udGV4dCwgdGhpcy52YWx1ZSwgdGhpcy5vbGRWYWx1ZSwgdGhpcy5rZXlwYXRoLnN0cik7XG4gIFx0XHR0aGlzLm9sZFZhbHVlID0gdGhpcy52YWx1ZTtcblxuICBcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuICBcdH1cbiAgfTtcblxuICB2YXIgb2JzZXJ2ZV9PYnNlcnZlciA9IE9ic2VydmVyO1xuXG4gIHZhciBvYnNlcnZlX2dldFBhdHRlcm4gPSBnZXRQYXR0ZXJuO1xuICBmdW5jdGlvbiBnZXRQYXR0ZXJuKHJhY3RpdmUsIHBhdHRlcm4pIHtcbiAgXHR2YXIgbWF0Y2hpbmdLZXlwYXRocywgdmFsdWVzO1xuXG4gIFx0bWF0Y2hpbmdLZXlwYXRocyA9IGdldE1hdGNoaW5nS2V5cGF0aHMocmFjdGl2ZSwgcGF0dGVybik7XG5cbiAgXHR2YWx1ZXMgPSB7fTtcbiAgXHRtYXRjaGluZ0tleXBhdGhzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHZhbHVlc1trZXlwYXRoLnN0cl0gPSByYWN0aXZlLmdldChrZXlwYXRoLnN0cik7XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgdmFyIFBhdHRlcm5PYnNlcnZlcixcbiAgICAgIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIFBhdHRlcm5PYnNlcnZlciA9IGZ1bmN0aW9uIChyYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICBcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG5cbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIFx0dGhpcy5kZWZlciA9IG9wdGlvbnMuZGVmZXI7XG5cbiAgXHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuICBcdHRoaXMucmVnZXggPSBuZXcgUmVnRXhwKFwiXlwiICsga2V5cGF0aC5zdHIucmVwbGFjZSgvXFwuL2csIFwiXFxcXC5cIikucmVwbGFjZSgvXFwqL2csIFwiKFteXFxcXC5dKylcIikgKyBcIiRcIik7XG4gIFx0dGhpcy52YWx1ZXMgPSB7fTtcblxuICBcdGlmICh0aGlzLmRlZmVyKSB7XG4gIFx0XHR0aGlzLnByb3hpZXMgPSBbXTtcbiAgXHR9XG5cbiAgXHQvLyBkZWZhdWx0IHRvIHJvb3QgYXMgY29udGV4dCwgYnV0IGFsbG93IGl0IHRvIGJlIG92ZXJyaWRkZW5cbiAgXHR0aGlzLmNvbnRleHQgPSBvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCA/IG9wdGlvbnMuY29udGV4dCA6IHJhY3RpdmU7XG4gIH07XG5cbiAgUGF0dGVybk9ic2VydmVyLnByb3RvdHlwZSA9IHtcbiAgXHRpbml0OiBmdW5jdGlvbiAoaW1tZWRpYXRlKSB7XG4gIFx0XHR2YXIgdmFsdWVzLCBrZXlwYXRoO1xuXG4gIFx0XHR2YWx1ZXMgPSBvYnNlcnZlX2dldFBhdHRlcm4odGhpcy5yb290LCB0aGlzLmtleXBhdGgpO1xuXG4gIFx0XHRpZiAoaW1tZWRpYXRlICE9PSBmYWxzZSkge1xuICBcdFx0XHRmb3IgKGtleXBhdGggaW4gdmFsdWVzKSB7XG4gIFx0XHRcdFx0aWYgKHZhbHVlcy5oYXNPd25Qcm9wZXJ0eShrZXlwYXRoKSkge1xuICBcdFx0XHRcdFx0dGhpcy51cGRhdGUoZ2V0S2V5cGF0aChrZXlwYXRoKSk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIHZhbHVlcztcblxuICBcdFx0aWYgKGtleXBhdGguaXNQYXR0ZXJuKSB7XG4gIFx0XHRcdHZhbHVlcyA9IG9ic2VydmVfZ2V0UGF0dGVybih0aGlzLnJvb3QsIGtleXBhdGgpO1xuXG4gIFx0XHRcdGZvciAoa2V5cGF0aCBpbiB2YWx1ZXMpIHtcbiAgXHRcdFx0XHRpZiAodmFsdWVzLmhhc093blByb3BlcnR5KGtleXBhdGgpKSB7XG4gIFx0XHRcdFx0XHR0aGlzLnVwZGF0ZShnZXRLZXlwYXRoKGtleXBhdGgpKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIGFycmF5IG11dGF0aW9uIHNob3VsZCBub3QgdHJpZ2dlciBgYXJyYXkuKmBcbiAgXHRcdC8vIHBhdHRlcm4gb2JzZXJ2ZXIgd2l0aCBgYXJyYXkubGVuZ3RoYFxuICBcdFx0aWYgKHRoaXMucm9vdC52aWV3bW9kZWwuaW1wbGljaXRDaGFuZ2VzW2tleXBhdGguc3RyXSkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLmRlZmVyICYmIHRoaXMucmVhZHkpIHtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRyZXR1cm4gX3RoaXMuZ2V0UHJveHkoa2V5cGF0aCkudXBkYXRlKCk7XG4gIFx0XHRcdH0pO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMucmVhbGx5VXBkYXRlKGtleXBhdGgpO1xuICBcdH0sXG5cbiAgXHRyZWFsbHlVcGRhdGU6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHR2YXIga2V5cGF0aFN0ciwgdmFsdWUsIGtleXMsIGFyZ3M7XG5cbiAgXHRcdGtleXBhdGhTdHIgPSBrZXlwYXRoLnN0cjtcbiAgXHRcdHZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRcdC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcHNcbiAgXHRcdGlmICh0aGlzLnVwZGF0aW5nKSB7XG4gIFx0XHRcdHRoaXMudmFsdWVzW2tleXBhdGhTdHJdID0gdmFsdWU7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cbiAgXHRcdGlmICghaXNFcXVhbCh2YWx1ZSwgdGhpcy52YWx1ZXNba2V5cGF0aFN0cl0pIHx8ICF0aGlzLnJlYWR5KSB7XG4gIFx0XHRcdGtleXMgPSBzbGljZS5jYWxsKHRoaXMucmVnZXguZXhlYyhrZXlwYXRoU3RyKSwgMSk7XG4gIFx0XHRcdGFyZ3MgPSBbdmFsdWUsIHRoaXMudmFsdWVzW2tleXBhdGhTdHJdLCBrZXlwYXRoU3RyXS5jb25jYXQoa2V5cyk7XG5cbiAgXHRcdFx0dGhpcy52YWx1ZXNba2V5cGF0aFN0cl0gPSB2YWx1ZTtcbiAgXHRcdFx0dGhpcy5jYWxsYmFjay5hcHBseSh0aGlzLmNvbnRleHQsIGFyZ3MpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG4gIFx0fSxcblxuICBcdGdldFByb3h5OiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0aWYgKCF0aGlzLnByb3hpZXNba2V5cGF0aC5zdHJdKSB7XG4gIFx0XHRcdHRoaXMucHJveGllc1trZXlwYXRoLnN0cl0gPSB7XG4gIFx0XHRcdFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gX3RoaXMucmVhbGx5VXBkYXRlKGtleXBhdGgpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXMucHJveGllc1trZXlwYXRoLnN0cl07XG4gIFx0fVxuICB9O1xuXG4gIHZhciBvYnNlcnZlX1BhdHRlcm5PYnNlcnZlciA9IFBhdHRlcm5PYnNlcnZlcjtcblxuICB2YXIgb2JzZXJ2ZV9nZXRPYnNlcnZlckZhY2FkZSA9IGdldE9ic2VydmVyRmFjYWRlO1xuICB2YXIgZW1wdHlPYmplY3QgPSB7fTtcbiAgZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJGYWNhZGUocmFjdGl2ZSwga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgXHR2YXIgb2JzZXJ2ZXIsIGlzUGF0dGVybk9ic2VydmVyLCBjYW5jZWxsZWQ7XG5cbiAgXHRrZXlwYXRoID0gZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpO1xuICBcdG9wdGlvbnMgPSBvcHRpb25zIHx8IGVtcHR5T2JqZWN0O1xuXG4gIFx0Ly8gcGF0dGVybiBvYnNlcnZlcnMgYXJlIHRyZWF0ZWQgZGlmZmVyZW50bHlcbiAgXHRpZiAoa2V5cGF0aC5pc1BhdHRlcm4pIHtcbiAgXHRcdG9ic2VydmVyID0gbmV3IG9ic2VydmVfUGF0dGVybk9ic2VydmVyKHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgXHRcdHJhY3RpdmUudmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gIFx0XHRpc1BhdHRlcm5PYnNlcnZlciA9IHRydWU7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdG9ic2VydmVyID0gbmV3IG9ic2VydmVfT2JzZXJ2ZXIocmFjdGl2ZSwga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICBcdH1cblxuICBcdG9ic2VydmVyLmluaXQob3B0aW9ucy5pbml0KTtcbiAgXHRyYWN0aXZlLnZpZXdtb2RlbC5yZWdpc3RlcihrZXlwYXRoLCBvYnNlcnZlciwgaXNQYXR0ZXJuT2JzZXJ2ZXIgPyBcInBhdHRlcm5PYnNlcnZlcnNcIiA6IFwib2JzZXJ2ZXJzXCIpO1xuXG4gIFx0Ly8gVGhpcyBmbGFnIGFsbG93cyBvYnNlcnZlcnMgdG8gaW5pdGlhbGlzZSBldmVuIHdpdGggdW5kZWZpbmVkIHZhbHVlc1xuICBcdG9ic2VydmVyLnJlYWR5ID0gdHJ1ZTtcblxuICBcdHZhciBmYWNhZGUgPSB7XG4gIFx0XHRjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dmFyIGluZGV4O1xuXG4gIFx0XHRcdGlmIChjYW5jZWxsZWQpIHtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoaXNQYXR0ZXJuT2JzZXJ2ZXIpIHtcbiAgXHRcdFx0XHRpbmRleCA9IHJhY3RpdmUudmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlcik7XG5cbiAgXHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwudW5yZWdpc3RlcihrZXlwYXRoLCBvYnNlcnZlciwgXCJwYXR0ZXJuT2JzZXJ2ZXJzXCIpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnVucmVnaXN0ZXIoa2V5cGF0aCwgb2JzZXJ2ZXIsIFwib2JzZXJ2ZXJzXCIpO1xuICBcdFx0XHR9XG4gIFx0XHRcdGNhbmNlbGxlZCA9IHRydWU7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdHJhY3RpdmUuX29ic2VydmVycy5wdXNoKGZhY2FkZSk7XG4gIFx0cmV0dXJuIGZhY2FkZTtcbiAgfVxuXG4gIHZhciBvYnNlcnZlID0gUmFjdGl2ZSRvYnNlcnZlO1xuICBmdW5jdGlvbiBSYWN0aXZlJG9ic2VydmUoa2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcblxuICBcdHZhciBvYnNlcnZlcnMsIG1hcCwga2V5cGF0aHMsIGk7XG5cbiAgXHQvLyBBbGxvdyBhIG1hcCBvZiBrZXlwYXRocyB0byBoYW5kbGVyc1xuICBcdGlmIChpc09iamVjdChrZXlwYXRoKSkge1xuICBcdFx0b3B0aW9ucyA9IGNhbGxiYWNrO1xuICBcdFx0bWFwID0ga2V5cGF0aDtcblxuICBcdFx0b2JzZXJ2ZXJzID0gW107XG5cbiAgXHRcdGZvciAoa2V5cGF0aCBpbiBtYXApIHtcbiAgXHRcdFx0aWYgKG1hcC5oYXNPd25Qcm9wZXJ0eShrZXlwYXRoKSkge1xuICBcdFx0XHRcdGNhbGxiYWNrID0gbWFwW2tleXBhdGhdO1xuICBcdFx0XHRcdG9ic2VydmVycy5wdXNoKHRoaXMub2JzZXJ2ZShrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucykpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdHdoaWxlIChvYnNlcnZlcnMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0XHRvYnNlcnZlcnMucG9wKCkuY2FuY2VsKCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9O1xuICBcdH1cblxuICBcdC8vIEFsbG93IGByYWN0aXZlLm9ic2VydmUoIGNhbGxiYWNrIClgIC0gaS5lLiBvYnNlcnZlIGVudGlyZSBtb2RlbFxuICBcdGlmICh0eXBlb2Yga2V5cGF0aCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRvcHRpb25zID0gY2FsbGJhY2s7XG4gIFx0XHRjYWxsYmFjayA9IGtleXBhdGg7XG4gIFx0XHRrZXlwYXRoID0gXCJcIjtcblxuICBcdFx0cmV0dXJuIG9ic2VydmVfZ2V0T2JzZXJ2ZXJGYWNhZGUodGhpcywga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICBcdH1cblxuICBcdGtleXBhdGhzID0ga2V5cGF0aC5zcGxpdChcIiBcIik7XG5cbiAgXHQvLyBTaW5nbGUga2V5cGF0aFxuICBcdGlmIChrZXlwYXRocy5sZW5ndGggPT09IDEpIHtcbiAgXHRcdHJldHVybiBvYnNlcnZlX2dldE9ic2VydmVyRmFjYWRlKHRoaXMsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgXHR9XG5cbiAgXHQvLyBNdWx0aXBsZSBzcGFjZS1zZXBhcmF0ZWQga2V5cGF0aHNcbiAgXHRvYnNlcnZlcnMgPSBbXTtcblxuICBcdGkgPSBrZXlwYXRocy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0a2V5cGF0aCA9IGtleXBhdGhzW2ldO1xuXG4gIFx0XHRpZiAoa2V5cGF0aCkge1xuICBcdFx0XHRvYnNlcnZlcnMucHVzaChvYnNlcnZlX2dldE9ic2VydmVyRmFjYWRlKHRoaXMsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHR3aGlsZSAob2JzZXJ2ZXJzLmxlbmd0aCkge1xuICBcdFx0XHRcdG9ic2VydmVycy5wb3AoKS5jYW5jZWwoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICB2YXIgb2JzZXJ2ZU9uY2UgPSBSYWN0aXZlJG9ic2VydmVPbmNlO1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkb2JzZXJ2ZU9uY2UocHJvcGVydHksIGNhbGxiYWNrLCBvcHRpb25zKSB7XG5cbiAgXHR2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmUocHJvcGVydHksIGZ1bmN0aW9uICgpIHtcbiAgXHRcdGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIFx0XHRvYnNlcnZlci5jYW5jZWwoKTtcbiAgXHR9LCB7IGluaXQ6IGZhbHNlLCBkZWZlcjogb3B0aW9ucyAmJiBvcHRpb25zLmRlZmVyIH0pO1xuXG4gIFx0cmV0dXJuIG9ic2VydmVyO1xuICB9XG5cbiAgdmFyIHNoYXJlZF90cmltID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIudHJpbSgpO1xuICB9O1xuXG4gIHZhciBub3RFbXB0eVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyICE9PSBcIlwiO1xuICB9O1xuXG4gIHZhciBvZmYgPSBSYWN0aXZlJG9mZjtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRvZmYoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgZXZlbnROYW1lcztcblxuICBcdC8vIGlmIG5vIGFyZ3VtZW50cyBzcGVjaWZpZWQsIHJlbW92ZSBhbGwgY2FsbGJhY2tzXG4gIFx0aWYgKCFldmVudE5hbWUpIHtcbiAgXHRcdC8vIFRPRE8gdXNlIHRoaXMgY29kZSBpbnN0ZWFkLCBvbmNlIHRoZSBmb2xsb3dpbmcgaXNzdWUgaGFzIGJlZW4gcmVzb2x2ZWRcbiAgXHRcdC8vIGluIFBoYW50b21KUyAodGVzdHMgYXJlIHVucGFzc2FibGUgb3RoZXJ3aXNlISlcbiAgXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hcml5YS9waGFudG9tanMvaXNzdWVzLzExODU2XG4gIFx0XHQvLyBkZWZpbmVQcm9wZXJ0eSggdGhpcywgJ19zdWJzJywgeyB2YWx1ZTogY3JlYXRlKCBudWxsICksIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgXHRcdGZvciAoZXZlbnROYW1lIGluIHRoaXMuX3N1YnMpIHtcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX3N1YnNbZXZlbnROYW1lXTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0Ly8gSGFuZGxlIG11bHRpcGxlIHNwYWNlLXNlcGFyYXRlZCBldmVudCBuYW1lc1xuICBcdFx0ZXZlbnROYW1lcyA9IGV2ZW50TmFtZS5zcGxpdChcIiBcIikubWFwKHNoYXJlZF90cmltKS5maWx0ZXIobm90RW1wdHlTdHJpbmcpO1xuXG4gIFx0XHRldmVudE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICBcdFx0XHR2YXIgc3Vic2NyaWJlcnMsIGluZGV4O1xuXG4gIFx0XHRcdC8vIElmIHdlIGhhdmUgc3Vic2NyaWJlcnMgZm9yIHRoaXMgZXZlbnQuLi5cbiAgXHRcdFx0aWYgKHN1YnNjcmliZXJzID0gX3RoaXMuX3N1YnNbZXZlbnROYW1lXSkge1xuICBcdFx0XHRcdC8vIC4uLmlmIGEgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgb25seSByZW1vdmUgdGhhdFxuICBcdFx0XHRcdGlmIChjYWxsYmFjaykge1xuICBcdFx0XHRcdFx0aW5kZXggPSBzdWJzY3JpYmVycy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgXHRcdFx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcbiAgXHRcdFx0XHRcdFx0c3Vic2NyaWJlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgcmVtb3ZlIGFsbCBjYWxsYmFja3NcbiAgXHRcdFx0XHRlbHNlIHtcbiAgXHRcdFx0XHRcdF90aGlzLl9zdWJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIG9uID0gUmFjdGl2ZSRvbjtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRvbihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBsaXN0ZW5lcnMsIG4sIGV2ZW50TmFtZXM7XG5cbiAgXHQvLyBhbGxvdyBtdXRsaXBsZSBsaXN0ZW5lcnMgdG8gYmUgYm91bmQgaW4gb25lIGdvXG4gIFx0aWYgKHR5cGVvZiBldmVudE5hbWUgPT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdGxpc3RlbmVycyA9IFtdO1xuXG4gIFx0XHRmb3IgKG4gaW4gZXZlbnROYW1lKSB7XG4gIFx0XHRcdGlmIChldmVudE5hbWUuaGFzT3duUHJvcGVydHkobikpIHtcbiAgXHRcdFx0XHRsaXN0ZW5lcnMucHVzaCh0aGlzLm9uKG4sIGV2ZW50TmFtZVtuXSkpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdHZhciBsaXN0ZW5lcjtcblxuICBcdFx0XHRcdHdoaWxlIChsaXN0ZW5lciA9IGxpc3RlbmVycy5wb3AoKSkge1xuICBcdFx0XHRcdFx0bGlzdGVuZXIuY2FuY2VsKCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9O1xuICBcdH1cblxuICBcdC8vIEhhbmRsZSBtdWx0aXBsZSBzcGFjZS1zZXBhcmF0ZWQgZXZlbnQgbmFtZXNcbiAgXHRldmVudE5hbWVzID0gZXZlbnROYW1lLnNwbGl0KFwiIFwiKS5tYXAoc2hhcmVkX3RyaW0pLmZpbHRlcihub3RFbXB0eVN0cmluZyk7XG5cbiAgXHRldmVudE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICBcdFx0KF90aGlzLl9zdWJzW2V2ZW50TmFtZV0gfHwgKF90aGlzLl9zdWJzW2V2ZW50TmFtZV0gPSBbXSkpLnB1c2goY2FsbGJhY2spO1xuICBcdH0pO1xuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gX3RoaXMub2ZmKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICB2YXIgb25jZSA9IFJhY3RpdmUkb25jZTtcblxuICBmdW5jdGlvbiBSYWN0aXZlJG9uY2UoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG5cbiAgXHR2YXIgbGlzdGVuZXIgPSB0aGlzLm9uKGV2ZW50TmFtZSwgZnVuY3Rpb24gKCkge1xuICBcdFx0aGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBcdFx0bGlzdGVuZXIuY2FuY2VsKCk7XG4gIFx0fSk7XG5cbiAgXHQvLyBzbyB3ZSBjYW4gc3RpbGwgZG8gbGlzdGVuZXIuY2FuY2VsKCkgbWFudWFsbHlcbiAgXHRyZXR1cm4gbGlzdGVuZXI7XG4gIH1cblxuICAvLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIGFycmF5LCB0aGUgbmFtZSBvZiBhIG11dGF0b3IgbWV0aG9kLCBhbmQgdGhlXG4gIC8vIGFyZ3VtZW50cyB0byBjYWxsIHRoYXQgbXV0YXRvciBtZXRob2Qgd2l0aCwgYW5kIHJldHVybnMgYW4gYXJyYXkgdGhhdFxuICAvLyBtYXBzIHRoZSBvbGQgaW5kaWNlcyB0byB0aGVpciBuZXcgaW5kaWNlcy5cblxuICAvLyBTbyBpZiB5b3UgaGFkIHNvbWV0aGluZyBsaWtlIHRoaXMuLi5cbiAgLy9cbiAgLy8gICAgIGFycmF5ID0gWyAnYScsICdiJywgJ2MnLCAnZCcgXTtcbiAgLy8gICAgIGFycmF5LnB1c2goICdlJyApO1xuICAvL1xuICAvLyAuLi55b3UnZCBnZXQgYFsgMCwgMSwgMiwgMyBdYCAtIGluIG90aGVyIHdvcmRzLCBub25lIG9mIHRoZSBvbGQgaW5kaWNlc1xuICAvLyBoYXZlIGNoYW5nZWQuIElmIHlvdSB0aGVuIGRpZCB0aGlzLi4uXG4gIC8vXG4gIC8vICAgICBhcnJheS51bnNoaWZ0KCAneicgKTtcbiAgLy9cbiAgLy8gLi4udGhlIGluZGljZXMgd291bGQgYmUgYFsgMSwgMiwgMywgNCwgNSBdYCAtIGV2ZXJ5IGl0ZW0gaGFzIGJlZW4gbW92ZWRcbiAgLy8gb25lIGhpZ2hlciB0byBtYWtlIHJvb20gZm9yIHRoZSAneicuIElmIHlvdSByZW1vdmVkIGFuIGl0ZW0sIHRoZSBuZXcgaW5kZXhcbiAgLy8gd291bGQgYmUgLTEuLi5cbiAgLy9cbiAgLy8gICAgIGFycmF5LnNwbGljZSggMiwgMiApO1xuICAvL1xuICAvLyAuLi50aGlzIHdvdWxkIHJlc3VsdCBpbiBbIDAsIDEsIC0xLCAtMSwgMiwgMyBdLlxuICAvL1xuICAvLyBUaGlzIGluZm9ybWF0aW9uIGlzIHVzZWQgdG8gZW5hYmxlIGZhc3QsIG5vbi1kZXN0cnVjdGl2ZSBzaHVmZmxpbmcgb2YgbGlzdFxuICAvLyBzZWN0aW9ucyB3aGVuIHlvdSBkbyBlLmcuIGByYWN0aXZlLnNwbGljZSggJ2l0ZW1zJywgMiwgMiApO1xuXG4gIHZhciBzaGFyZWRfZ2V0TmV3SW5kaWNlcyA9IGdldE5ld0luZGljZXM7XG5cbiAgZnVuY3Rpb24gZ2V0TmV3SW5kaWNlcyhhcnJheSwgbWV0aG9kTmFtZSwgYXJncykge1xuICBcdHZhciBzcGxpY2VBcmd1bWVudHMsXG4gIFx0ICAgIGxlbixcbiAgXHQgICAgbmV3SW5kaWNlcyA9IFtdLFxuICBcdCAgICByZW1vdmVTdGFydCxcbiAgXHQgICAgcmVtb3ZlRW5kLFxuICBcdCAgICBiYWxhbmNlLFxuICBcdCAgICBpO1xuXG4gIFx0c3BsaWNlQXJndW1lbnRzID0gZ2V0U3BsaWNlRXF1aXZhbGVudChhcnJheSwgbWV0aG9kTmFtZSwgYXJncyk7XG5cbiAgXHRpZiAoIXNwbGljZUFyZ3VtZW50cykge1xuICBcdFx0cmV0dXJuIG51bGw7IC8vIFRPRE8gc3VwcG9ydCByZXZlcnNlIGFuZCBzb3J0P1xuICBcdH1cblxuICBcdGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgXHRiYWxhbmNlID0gc3BsaWNlQXJndW1lbnRzLmxlbmd0aCAtIDIgLSBzcGxpY2VBcmd1bWVudHNbMV07XG5cbiAgXHRyZW1vdmVTdGFydCA9IE1hdGgubWluKGxlbiwgc3BsaWNlQXJndW1lbnRzWzBdKTtcbiAgXHRyZW1vdmVFbmQgPSByZW1vdmVTdGFydCArIHNwbGljZUFyZ3VtZW50c1sxXTtcblxuICBcdGZvciAoaSA9IDA7IGkgPCByZW1vdmVTdGFydDsgaSArPSAxKSB7XG4gIFx0XHRuZXdJbmRpY2VzLnB1c2goaSk7XG4gIFx0fVxuXG4gIFx0Zm9yICg7IGkgPCByZW1vdmVFbmQ7IGkgKz0gMSkge1xuICBcdFx0bmV3SW5kaWNlcy5wdXNoKC0xKTtcbiAgXHR9XG5cbiAgXHRmb3IgKDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRuZXdJbmRpY2VzLnB1c2goaSArIGJhbGFuY2UpO1xuICBcdH1cblxuICBcdC8vIHRoZXJlIGlzIGEgbmV0IHNoaWZ0IGZvciB0aGUgcmVzdCBvZiB0aGUgYXJyYXkgc3RhcnRpbmcgd2l0aCBpbmRleCArIGJhbGFuY2VcbiAgXHRpZiAoYmFsYW5jZSAhPT0gMCkge1xuICBcdFx0bmV3SW5kaWNlcy50b3VjaGVkRnJvbSA9IHNwbGljZUFyZ3VtZW50c1swXTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0bmV3SW5kaWNlcy50b3VjaGVkRnJvbSA9IGFycmF5Lmxlbmd0aDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbmV3SW5kaWNlcztcbiAgfVxuXG4gIC8vIFRoZSBwb3AsIHB1c2gsIHNoaWZ0IGFuIHVuc2hpZnQgbWV0aG9kcyBjYW4gYWxsIGJlIHJlcHJlc2VudGVkXG4gIC8vIGFzIGFuIGVxdWl2YWxlbnQgc3BsaWNlXG4gIGZ1bmN0aW9uIGdldFNwbGljZUVxdWl2YWxlbnQoYXJyYXksIG1ldGhvZE5hbWUsIGFyZ3MpIHtcbiAgXHRzd2l0Y2ggKG1ldGhvZE5hbWUpIHtcbiAgXHRcdGNhc2UgXCJzcGxpY2VcIjpcbiAgXHRcdFx0aWYgKGFyZ3NbMF0gIT09IHVuZGVmaW5lZCAmJiBhcmdzWzBdIDwgMCkge1xuICBcdFx0XHRcdGFyZ3NbMF0gPSBhcnJheS5sZW5ndGggKyBNYXRoLm1heChhcmdzWzBdLCAtYXJyYXkubGVuZ3RoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHdoaWxlIChhcmdzLmxlbmd0aCA8IDIpIHtcbiAgXHRcdFx0XHRhcmdzLnB1c2goMCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBlbnN1cmUgd2Ugb25seSByZW1vdmUgZWxlbWVudHMgdGhhdCBleGlzdFxuICBcdFx0XHRhcmdzWzFdID0gTWF0aC5taW4oYXJnc1sxXSwgYXJyYXkubGVuZ3RoIC0gYXJnc1swXSk7XG5cbiAgXHRcdFx0cmV0dXJuIGFyZ3M7XG5cbiAgXHRcdGNhc2UgXCJzb3J0XCI6XG4gIFx0XHRjYXNlIFwicmV2ZXJzZVwiOlxuICBcdFx0XHRyZXR1cm4gbnVsbDtcblxuICBcdFx0Y2FzZSBcInBvcFwiOlxuICBcdFx0XHRpZiAoYXJyYXkubGVuZ3RoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIFthcnJheS5sZW5ndGggLSAxLCAxXTtcbiAgXHRcdFx0fVxuICBcdFx0XHRyZXR1cm4gWzAsIDBdO1xuXG4gIFx0XHRjYXNlIFwicHVzaFwiOlxuICBcdFx0XHRyZXR1cm4gW2FycmF5Lmxlbmd0aCwgMF0uY29uY2F0KGFyZ3MpO1xuXG4gIFx0XHRjYXNlIFwic2hpZnRcIjpcbiAgXHRcdFx0cmV0dXJuIFswLCBhcnJheS5sZW5ndGggPyAxIDogMF07XG5cbiAgXHRcdGNhc2UgXCJ1bnNoaWZ0XCI6XG4gIFx0XHRcdHJldHVybiBbMCwgMF0uY29uY2F0KGFyZ3MpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4gIHZhciBtYWtlQXJyYXlNZXRob2QgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICBcdHJldHVybiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRcdGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgYXJyYXksXG4gIFx0XHQgICAgbmV3SW5kaWNlcyA9IFtdLFxuICBcdFx0ICAgIGxlbixcbiAgXHRcdCAgICBwcm9taXNlLFxuICBcdFx0ICAgIHJlc3VsdDtcblxuICBcdFx0a2V5cGF0aCA9IGdldEtleXBhdGgobm9ybWFsaXNlKGtleXBhdGgpKTtcblxuICBcdFx0YXJyYXkgPSB0aGlzLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG4gIFx0XHRsZW4gPSBhcnJheS5sZW5ndGg7XG5cbiAgXHRcdGlmICghaXNBcnJheShhcnJheSkpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2FsbGVkIHJhY3RpdmUuXCIgKyBtZXRob2ROYW1lICsgXCIoJ1wiICsga2V5cGF0aC5zdHIgKyBcIicpLCBidXQgJ1wiICsga2V5cGF0aC5zdHIgKyBcIicgZG9lcyBub3QgcmVmZXIgdG8gYW4gYXJyYXlcIik7XG4gIFx0XHR9XG5cbiAgXHRcdG5ld0luZGljZXMgPSBzaGFyZWRfZ2V0TmV3SW5kaWNlcyhhcnJheSwgbWV0aG9kTmFtZSwgYXJncyk7XG5cbiAgXHRcdHJlc3VsdCA9IGFycmF5UHJvdG9bbWV0aG9kTmFtZV0uYXBwbHkoYXJyYXksIGFyZ3MpO1xuICBcdFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpLnRoZW4oZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdFx0fSk7XG5cbiAgXHRcdGlmICghIW5ld0luZGljZXMpIHtcbiAgXHRcdFx0dGhpcy52aWV3bW9kZWwuc21hcnRVcGRhdGUoa2V5cGF0aCwgYXJyYXksIG5ld0luZGljZXMpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy52aWV3bW9kZWwubWFyayhrZXlwYXRoKTtcbiAgXHRcdH1cblxuICBcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG5cbiAgXHRcdHJldHVybiBwcm9taXNlO1xuICBcdH07XG4gIH07XG5cbiAgdmFyIHBvcCA9IG1ha2VBcnJheU1ldGhvZChcInBvcFwiKTtcblxuICB2YXIgcHVzaCA9IG1ha2VBcnJheU1ldGhvZChcInB1c2hcIik7XG5cbiAgdmFyIGNzcyxcbiAgICAgIHVwZGF0ZSxcbiAgICAgIHN0eWxlRWxlbWVudCxcbiAgICAgIGhlYWQsXG4gICAgICBzdHlsZVNoZWV0LFxuICAgICAgaW5Eb20sXG4gICAgICBnbG9iYWxfY3NzX19wcmVmaXggPSBcIi8qIFJhY3RpdmUuanMgY29tcG9uZW50IHN0eWxlcyAqL1xcblwiLFxuICAgICAgc3R5bGVzID0gW10sXG4gICAgICBkaXJ0eSA9IGZhbHNlO1xuXG4gIGlmICghaXNDbGllbnQpIHtcbiAgXHQvLyBUT0RPIGhhbmRsZSBlbmNhcHN1bGF0ZWQgQ1NTIGluIHNlcnZlci1yZW5kZXJlZCBIVE1MIVxuICBcdGNzcyA9IHtcbiAgXHRcdGFkZDogbm9vcCxcbiAgXHRcdGFwcGx5OiBub29wXG4gIFx0fTtcbiAgfSBlbHNlIHtcbiAgXHRzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIFx0c3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XG5cbiAgXHRoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuXG4gIFx0aW5Eb20gPSBmYWxzZTtcblxuICBcdC8vIEludGVybmV0IEV4cGxvZGVyIHdvbid0IGxldCB5b3UgdXNlIHN0eWxlU2hlZXQuaW5uZXJIVE1MIC0gd2UgaGF2ZSB0b1xuICBcdC8vIHVzZSBzdHlsZVNoZWV0LmNzc1RleHQgaW5zdGVhZFxuICBcdHN0eWxlU2hlZXQgPSBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldDtcblxuICBcdHVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBjc3MgPSBnbG9iYWxfY3NzX19wcmVmaXggKyBzdHlsZXMubWFwKGZ1bmN0aW9uIChzKSB7XG4gIFx0XHRcdHJldHVybiBcIlxcbi8qIHtcIiArIHMuaWQgKyBcIn0gKi9cXG5cIiArIHMuc3R5bGVzO1xuICBcdFx0fSkuam9pbihcIlxcblwiKTtcblxuICBcdFx0aWYgKHN0eWxlU2hlZXQpIHtcbiAgXHRcdFx0c3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0c3R5bGVFbGVtZW50LmlubmVySFRNTCA9IGNzcztcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFpbkRvbSkge1xuICBcdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG4gIFx0XHRcdGluRG9tID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0Y3NzID0ge1xuICBcdFx0YWRkOiBmdW5jdGlvbiAocykge1xuICBcdFx0XHRzdHlsZXMucHVzaChzKTtcbiAgXHRcdFx0ZGlydHkgPSB0cnVlO1xuICBcdFx0fSxcblxuICBcdFx0YXBwbHk6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0aWYgKGRpcnR5KSB7XG4gIFx0XHRcdFx0dXBkYXRlKCk7XG4gIFx0XHRcdFx0ZGlydHkgPSBmYWxzZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICB2YXIgZ2xvYmFsX2NzcyA9IGNzcztcblxuICB2YXIgcHJvdG90eXBlX3JlbmRlciA9IFJhY3RpdmUkcmVuZGVyO1xuXG4gIHZhciByZW5kZXJIb29rID0gbmV3IGhvb2tzX0hvb2soXCJyZW5kZXJcIiksXG4gICAgICBjb21wbGV0ZUhvb2sgPSBuZXcgaG9va3NfSG9vayhcImNvbXBsZXRlXCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJHJlbmRlcih0YXJnZXQsIGFuY2hvcikge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgcHJvbWlzZSwgaW5zdGFuY2VzLCB0cmFuc2l0aW9uc0VuYWJsZWQ7XG5cbiAgXHQvLyBpZiBgbm9JbnRyb2AgaXMgYHRydWVgLCB0ZW1wb3JhcmlseSBkaXNhYmxlIHRyYW5zaXRpb25zXG4gIFx0dHJhbnNpdGlvbnNFbmFibGVkID0gdGhpcy50cmFuc2l0aW9uc0VuYWJsZWQ7XG4gIFx0aWYgKHRoaXMubm9JbnRybykge1xuICBcdFx0dGhpcy50cmFuc2l0aW9uc0VuYWJsZWQgPSBmYWxzZTtcbiAgXHR9XG5cbiAgXHRwcm9taXNlID0gZ2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcywgdHJ1ZSk7XG4gIFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiByZW5kZXJIb29rLmZpcmUoX3RoaXMpO1xuICBcdH0sIHRydWUpO1xuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQucmVuZGVyZWQpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIllvdSBjYW5ub3QgY2FsbCByYWN0aXZlLnJlbmRlcigpIG9uIGFuIGFscmVhZHkgcmVuZGVyZWQgaW5zdGFuY2UhIENhbGwgcmFjdGl2ZS51bnJlbmRlcigpIGZpcnN0XCIpO1xuICBcdH1cblxuICBcdHRhcmdldCA9IGdldEVsZW1lbnQodGFyZ2V0KSB8fCB0aGlzLmVsO1xuICBcdGFuY2hvciA9IGdldEVsZW1lbnQoYW5jaG9yKSB8fCB0aGlzLmFuY2hvcjtcblxuICBcdHRoaXMuZWwgPSB0YXJnZXQ7XG4gIFx0dGhpcy5hbmNob3IgPSBhbmNob3I7XG5cbiAgXHRpZiAoIXRoaXMuYXBwZW5kICYmIHRhcmdldCkge1xuICBcdFx0Ly8gVGVhcmRvd24gYW55IGV4aXN0aW5nIGluc3RhbmNlcyAqYmVmb3JlKiB0cnlpbmcgdG8gc2V0IHVwIHRoZSBuZXcgb25lIC1cbiAgXHRcdC8vIGF2b2lkcyBjZXJ0YWluIHdlaXJkIGJ1Z3NcbiAgXHRcdHZhciBvdGhlcnMgPSB0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fO1xuICBcdFx0aWYgKG90aGVycyAmJiBvdGhlcnMubGVuZ3RoKSB7XG4gIFx0XHRcdHJlbW92ZU90aGVySW5zdGFuY2VzKG90aGVycyk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIG1ha2Ugc3VyZSB3ZSBhcmUgdGhlIG9ubHkgb2NjdXBhbnRzXG4gIFx0XHR0YXJnZXQuaW5uZXJIVE1MID0gXCJcIjsgLy8gVE9ETyBpcyB0aGlzIHF1aWNrZXIgdGhhbiByZW1vdmVDaGlsZD8gSW5pdGlhbCByZXNlYXJjaCBpbmNvbmNsdXNpdmVcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5jc3NJZCkge1xuICBcdFx0Ly8gZW5zdXJlIGVuY2Fwc3VsYXRlZCBDU1MgaXMgdXAtdG8tZGF0ZVxuICBcdFx0Z2xvYmFsX2Nzcy5hcHBseSgpO1xuICBcdH1cblxuICBcdGlmICh0YXJnZXQpIHtcbiAgXHRcdGlmICghKGluc3RhbmNlcyA9IHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18pKSB7XG4gIFx0XHRcdHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gPSBbdGhpc107XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRpbnN0YW5jZXMucHVzaCh0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGFuY2hvcikge1xuICBcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuZnJhZ21lbnQucmVuZGVyKCksIGFuY2hvcik7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQodGhpcy5mcmFnbWVudC5yZW5kZXIoKSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG5cbiAgXHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IHRyYW5zaXRpb25zRW5hYmxlZDtcblxuICBcdHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIGNvbXBsZXRlSG9vay5maXJlKF90aGlzKTtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU90aGVySW5zdGFuY2VzKG90aGVycykge1xuICBcdG90aGVycy5zcGxpY2UoMCwgb3RoZXJzLmxlbmd0aCkuZm9yRWFjaCh0ZWFyZG93bik7XG4gIH1cblxuICB2YXIgYWRhcHRDb25maWd1cmF0b3IgPSB7XG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAoUGFyZW50LCBwcm90bywgb3B0aW9ucykge1xuICBcdFx0cHJvdG8uYWRhcHQgPSBjdXN0b21fYWRhcHRfX2NvbWJpbmUocHJvdG8uYWRhcHQsIGVuc3VyZUFycmF5KG9wdGlvbnMuYWRhcHQpKTtcbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKCkge31cbiAgfTtcblxuICB2YXIgY3VzdG9tX2FkYXB0ID0gYWRhcHRDb25maWd1cmF0b3I7XG5cbiAgZnVuY3Rpb24gY3VzdG9tX2FkYXB0X19jb21iaW5lKGEsIGIpIHtcbiAgXHR2YXIgYyA9IGEuc2xpY2UoKSxcbiAgXHQgICAgaSA9IGIubGVuZ3RoO1xuXG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aWYgKCEgfmMuaW5kZXhPZihiW2ldKSkge1xuICBcdFx0XHRjLnB1c2goYltpXSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGM7XG4gIH1cblxuICB2YXIgdHJhbnNmb3JtID0gdHJhbnNmb3JtQ3NzO1xuXG4gIHZhciBzZWxlY3RvcnNQYXR0ZXJuID0gLyg/Ol58XFx9KT9cXHMqKFteXFx7XFx9XSspXFxzKlxcey9nLFxuICAgICAgY29tbWVudHNQYXR0ZXJuID0gL1xcL1xcKi4qP1xcKlxcLy9nLFxuICAgICAgc2VsZWN0b3JVbml0UGF0dGVybiA9IC8oKD86KD86XFxbW15cXF0rXVxcXSl8KD86W15cXHNcXCtcXD5cXH46XSkpKykoKD86OlteXFxzXFwrXFw+XFx+XFwoXSsoPzpcXChbXlxcKV0rXFwpKT8pP1xccypbXFxzXFwrXFw+XFx+XT8pXFxzKi9nLFxuICAgICAgbWVkaWFRdWVyeVBhdHRlcm4gPSAvXkBtZWRpYS8sXG4gICAgICBkYXRhUnZjR3VpZFBhdHRlcm4gPSAvXFxbZGF0YS1yYWN0aXZlLWNzc349XCJcXHtbYS16MC05LV0rXFx9XCJdL2c7XG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUNzcyhjc3MsIGlkKSB7XG4gIFx0dmFyIHRyYW5zZm9ybWVkLCBkYXRhQXR0ciwgYWRkR3VpZDtcblxuICBcdGRhdGFBdHRyID0gXCJbZGF0YS1yYWN0aXZlLWNzc349XFxcIntcIiArIGlkICsgXCJ9XFxcIl1cIjtcblxuICBcdGFkZEd1aWQgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgXHRcdHZhciBzZWxlY3RvclVuaXRzLFxuICBcdFx0ICAgIG1hdGNoLFxuICBcdFx0ICAgIHVuaXQsXG4gIFx0XHQgICAgYmFzZSxcbiAgXHRcdCAgICBwcmVwZW5kZWQsXG4gIFx0XHQgICAgYXBwZW5kZWQsXG4gIFx0XHQgICAgaSxcbiAgXHRcdCAgICB0cmFuc2Zvcm1lZCA9IFtdO1xuXG4gIFx0XHRzZWxlY3RvclVuaXRzID0gW107XG5cbiAgXHRcdHdoaWxlIChtYXRjaCA9IHNlbGVjdG9yVW5pdFBhdHRlcm4uZXhlYyhzZWxlY3RvcikpIHtcbiAgXHRcdFx0c2VsZWN0b3JVbml0cy5wdXNoKHtcbiAgXHRcdFx0XHRzdHI6IG1hdGNoWzBdLFxuICBcdFx0XHRcdGJhc2U6IG1hdGNoWzFdLFxuICBcdFx0XHRcdG1vZGlmaWVyczogbWF0Y2hbMl1cbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIEZvciBlYWNoIHNpbXBsZSBzZWxlY3RvciB3aXRoaW4gdGhlIHNlbGVjdG9yLCB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHZlcnNpb25cbiAgXHRcdC8vIHRoYXQgYSkgY29tYmluZXMgd2l0aCB0aGUgaWQsIGFuZCBiKSBpcyBpbnNpZGUgdGhlIGlkXG4gIFx0XHRiYXNlID0gc2VsZWN0b3JVbml0cy5tYXAoZXh0cmFjdFN0cmluZyk7XG5cbiAgXHRcdGkgPSBzZWxlY3RvclVuaXRzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0YXBwZW5kZWQgPSBiYXNlLnNsaWNlKCk7XG5cbiAgXHRcdFx0Ly8gUHNldWRvLXNlbGVjdG9ycyBzaG91bGQgZ28gYWZ0ZXIgdGhlIGF0dHJpYnV0ZSBzZWxlY3RvclxuICBcdFx0XHR1bml0ID0gc2VsZWN0b3JVbml0c1tpXTtcbiAgXHRcdFx0YXBwZW5kZWRbaV0gPSB1bml0LmJhc2UgKyBkYXRhQXR0ciArIHVuaXQubW9kaWZpZXJzIHx8IFwiXCI7XG5cbiAgXHRcdFx0cHJlcGVuZGVkID0gYmFzZS5zbGljZSgpO1xuICBcdFx0XHRwcmVwZW5kZWRbaV0gPSBkYXRhQXR0ciArIFwiIFwiICsgcHJlcGVuZGVkW2ldO1xuXG4gIFx0XHRcdHRyYW5zZm9ybWVkLnB1c2goYXBwZW5kZWQuam9pbihcIiBcIiksIHByZXBlbmRlZC5qb2luKFwiIFwiKSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0cmFuc2Zvcm1lZC5qb2luKFwiLCBcIik7XG4gIFx0fTtcblxuICBcdGlmIChkYXRhUnZjR3VpZFBhdHRlcm4udGVzdChjc3MpKSB7XG4gIFx0XHR0cmFuc2Zvcm1lZCA9IGNzcy5yZXBsYWNlKGRhdGFSdmNHdWlkUGF0dGVybiwgZGF0YUF0dHIpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHR0cmFuc2Zvcm1lZCA9IGNzcy5yZXBsYWNlKGNvbW1lbnRzUGF0dGVybiwgXCJcIikucmVwbGFjZShzZWxlY3RvcnNQYXR0ZXJuLCBmdW5jdGlvbiAobWF0Y2gsICQxKSB7XG4gIFx0XHRcdHZhciBzZWxlY3RvcnMsIHRyYW5zZm9ybWVkO1xuXG4gIFx0XHRcdC8vIGRvbid0IHRyYW5zZm9ybSBtZWRpYSBxdWVyaWVzIVxuICBcdFx0XHRpZiAobWVkaWFRdWVyeVBhdHRlcm4udGVzdCgkMSkpIHJldHVybiBtYXRjaDtcblxuICBcdFx0XHRzZWxlY3RvcnMgPSAkMS5zcGxpdChcIixcIikubWFwKHRyaW0pO1xuICBcdFx0XHR0cmFuc2Zvcm1lZCA9IHNlbGVjdG9ycy5tYXAoYWRkR3VpZCkuam9pbihcIiwgXCIpICsgXCIgXCI7XG5cbiAgXHRcdFx0cmV0dXJuIG1hdGNoLnJlcGxhY2UoJDEsIHRyYW5zZm9ybWVkKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIFx0aWYgKHN0ci50cmltKSB7XG4gIFx0XHRyZXR1cm4gc3RyLnRyaW0oKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrLywgXCJcIikucmVwbGFjZSgvXFxzKyQvLCBcIlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3RTdHJpbmcodW5pdCkge1xuICBcdHJldHVybiB1bml0LnN0cjtcbiAgfVxuXG4gIHZhciBjc3NfY3NzX191aWQgPSAxO1xuXG4gIHZhciBjc3NDb25maWd1cmF0b3IgPSB7XG4gIFx0bmFtZTogXCJjc3NcIixcblxuICBcdGV4dGVuZDogZnVuY3Rpb24gKFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpIHtcbiAgXHRcdGlmIChvcHRpb25zLmNzcykge1xuICBcdFx0XHR2YXIgaWQgPSBjc3NfY3NzX191aWQrKztcbiAgXHRcdFx0dmFyIHN0eWxlcyA9IG9wdGlvbnMubm9Dc3NUcmFuc2Zvcm0gPyBvcHRpb25zLmNzcyA6IHRyYW5zZm9ybShvcHRpb25zLmNzcywgaWQpO1xuXG4gIFx0XHRcdHByb3RvLmNzc0lkID0gaWQ7XG4gIFx0XHRcdGdsb2JhbF9jc3MuYWRkKHsgaWQ6IGlkLCBzdHlsZXM6IHN0eWxlcyB9KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKCkge31cbiAgfTtcblxuICB2YXIgY3NzX2NzcyA9IGNzc0NvbmZpZ3VyYXRvcjtcblxuICBmdW5jdGlvbiB2YWxpZGF0ZShkYXRhKSB7XG4gIFx0Ly8gV2FybiBpZiB1c2VyT3B0aW9ucy5kYXRhIGlzIGEgbm9uLVBPSk9cbiAgXHRpZiAoZGF0YSAmJiBkYXRhLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgXHRcdGlmICh0eXBlb2YgZGF0YSA9PT0gXCJmdW5jdGlvblwiKSB7fSBlbHNlIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikge1xuICBcdFx0XHRmYXRhbChcImRhdGEgb3B0aW9uIG11c3QgYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGBcIiArIGRhdGEgKyBcImAgaXMgbm90IHZhbGlkXCIpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0d2FybklmRGVidWcoXCJJZiBzdXBwbGllZCwgb3B0aW9ucy5kYXRhIHNob3VsZCBiZSBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0IC0gdXNpbmcgYSBub24tUE9KTyBhcyB0aGUgcm9vdCBvYmplY3QgbWF5IHdvcmssIGJ1dCBpcyBkaXNjb3VyYWdlZFwiKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgZGF0YUNvbmZpZ3VyYXRvciA9IHtcbiAgXHRuYW1lOiBcImRhdGFcIixcblxuICBcdGV4dGVuZDogZnVuY3Rpb24gKFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpIHtcbiAgXHRcdHZhciBrZXkgPSB1bmRlZmluZWQsXG4gIFx0XHQgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgXHRcdC8vIGNoZWNrIGZvciBub24tcHJpbWl0aXZlcywgd2hpY2ggY291bGQgY2F1c2UgbXV0YXRpb24tcmVsYXRlZCBidWdzXG4gIFx0XHRpZiAob3B0aW9ucy5kYXRhICYmIGlzT2JqZWN0KG9wdGlvbnMuZGF0YSkpIHtcbiAgXHRcdFx0Zm9yIChrZXkgaW4gb3B0aW9ucy5kYXRhKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSBvcHRpb25zLmRhdGFba2V5XTtcblxuICBcdFx0XHRcdGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdFx0XHRcdGlmIChpc09iamVjdCh2YWx1ZSkgfHwgaXNBcnJheSh2YWx1ZSkpIHtcbiAgXHRcdFx0XHRcdFx0d2FybklmRGVidWcoXCJQYXNzaW5nIGEgYGRhdGFgIG9wdGlvbiB3aXRoIG9iamVjdCBhbmQgYXJyYXkgcHJvcGVydGllcyB0byBSYWN0aXZlLmV4dGVuZCgpIGlzIGRpc2NvdXJhZ2VkLCBhcyBtdXRhdGluZyB0aGVtIGlzIGxpa2VseSB0byBjYXVzZSBidWdzLiBDb25zaWRlciB1c2luZyBhIGRhdGEgZnVuY3Rpb24gaW5zdGVhZDpcXG5cXG4gIC8vIHRoaXMuLi5cXG4gIGRhdGE6IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBteU9iamVjdDoge31cXG4gICAgfTtcXG4gIH0pXFxuXFxuICAvLyBpbnN0ZWFkIG9mIHRoaXM6XFxuICBkYXRhOiB7XFxuICAgIG15T2JqZWN0OiB7fVxcbiAgfVwiKTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cHJvdG8uZGF0YSA9IGN1c3RvbV9kYXRhX19jb21iaW5lKHByb3RvLmRhdGEsIG9wdGlvbnMuZGF0YSk7XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uIChQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMpIHtcbiAgXHRcdHZhciByZXN1bHQgPSBjdXN0b21fZGF0YV9fY29tYmluZShQYXJlbnQucHJvdG90eXBlLmRhdGEsIG9wdGlvbnMuZGF0YSk7XG5cbiAgXHRcdGlmICh0eXBlb2YgcmVzdWx0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0cmVzdWx0ID0gcmVzdWx0LmNhbGwocmFjdGl2ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiByZXN1bHQgfHwge307XG4gIFx0fSxcblxuICBcdHJlc2V0OiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuICBcdFx0dmFyIHJlc3VsdCA9IHRoaXMuaW5pdChyYWN0aXZlLmNvbnN0cnVjdG9yLCByYWN0aXZlLCByYWN0aXZlLnZpZXdtb2RlbCk7XG5cbiAgXHRcdHJhY3RpdmUudmlld21vZGVsLnJlc2V0KHJlc3VsdCk7XG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIGN1c3RvbV9kYXRhID0gZGF0YUNvbmZpZ3VyYXRvcjtcblxuICBmdW5jdGlvbiBjdXN0b21fZGF0YV9fY29tYmluZShwYXJlbnRWYWx1ZSwgY2hpbGRWYWx1ZSkge1xuICBcdHZhbGlkYXRlKGNoaWxkVmFsdWUpO1xuXG4gIFx0dmFyIHBhcmVudElzRm4gPSB0eXBlb2YgcGFyZW50VmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbiAgXHR2YXIgY2hpbGRJc0ZuID0gdHlwZW9mIGNoaWxkVmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcblxuICBcdC8vIFZlcnkgaW1wb3J0YW50LCBvdGhlcndpc2UgY2hpbGQgaW5zdGFuY2UgY2FuIGJlY29tZVxuICBcdC8vIHRoZSBkZWZhdWx0IGRhdGEgb2JqZWN0IG9uIFJhY3RpdmUgb3IgYSBjb21wb25lbnQuXG4gIFx0Ly8gdGhlbiByYWN0aXZlLnNldCgpIGVuZHMgdXAgc2V0dGluZyBvbiB0aGUgcHJvdG90eXBlIVxuICBcdGlmICghY2hpbGRWYWx1ZSAmJiAhcGFyZW50SXNGbikge1xuICBcdFx0Y2hpbGRWYWx1ZSA9IHt9O1xuICBcdH1cblxuICBcdC8vIEZhc3QgcGF0aCwgd2hlcmUgd2UganVzdCBuZWVkIHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gIFx0Ly8gcGFyZW50IHRvIGNoaWxkXG4gIFx0aWYgKCFwYXJlbnRJc0ZuICYmICFjaGlsZElzRm4pIHtcbiAgXHRcdHJldHVybiBmcm9tUHJvcGVydGllcyhjaGlsZFZhbHVlLCBwYXJlbnRWYWx1ZSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBjaGlsZCA9IGNoaWxkSXNGbiA/IGNhbGxEYXRhRnVuY3Rpb24oY2hpbGRWYWx1ZSwgdGhpcykgOiBjaGlsZFZhbHVlO1xuICBcdFx0dmFyIHBhcmVudCA9IHBhcmVudElzRm4gPyBjYWxsRGF0YUZ1bmN0aW9uKHBhcmVudFZhbHVlLCB0aGlzKSA6IHBhcmVudFZhbHVlO1xuXG4gIFx0XHRyZXR1cm4gZnJvbVByb3BlcnRpZXMoY2hpbGQsIHBhcmVudCk7XG4gIFx0fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxEYXRhRnVuY3Rpb24oZm4sIGNvbnRleHQpIHtcbiAgXHR2YXIgZGF0YSA9IGZuLmNhbGwoY29udGV4dCk7XG5cbiAgXHRpZiAoIWRhdGEpIHJldHVybjtcblxuICBcdGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikge1xuICBcdFx0ZmF0YWwoXCJEYXRhIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGFuIG9iamVjdFwiKTtcbiAgXHR9XG5cbiAgXHRpZiAoZGF0YS5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gIFx0XHR3YXJuT25jZUlmRGVidWcoXCJEYXRhIGZ1bmN0aW9uIHJldHVybmVkIHNvbWV0aGluZyBvdGhlciB0aGFuIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QuIFRoaXMgbWlnaHQgd29yaywgYnV0IGlzIHN0cm9uZ2x5IGRpc2NvdXJhZ2VkXCIpO1xuICBcdH1cblxuICBcdHJldHVybiBkYXRhO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbVByb3BlcnRpZXMocHJpbWFyeSwgc2Vjb25kYXJ5KSB7XG4gIFx0aWYgKHByaW1hcnkgJiYgc2Vjb25kYXJ5KSB7XG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gc2Vjb25kYXJ5KSB7XG4gIFx0XHRcdGlmICghKGtleSBpbiBwcmltYXJ5KSkge1xuICBcdFx0XHRcdHByaW1hcnlba2V5XSA9IHNlY29uZGFyeVtrZXldO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBwcmltYXJ5O1xuICBcdH1cblxuICBcdHJldHVybiBwcmltYXJ5IHx8IHNlY29uZGFyeTtcbiAgfVxuXG4gIC8vIFRPRE8gZG8gd2UgbmVlZCB0byBzdXBwb3J0IHRoaXMgaW4gdGhlIG5ldyBSYWN0aXZlKCkgY2FzZT9cblxuICB2YXIgUGFyc2VyLFxuICAgICAgUGFyc2VFcnJvcixcbiAgICAgIHBhcnNlX1BhcnNlcl9fbGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccysvO1xuXG4gIFBhcnNlRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICBcdHRoaXMubmFtZSA9IFwiUGFyc2VFcnJvclwiO1xuICBcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIFx0dHJ5IHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgXHR9IGNhdGNoIChlKSB7XG4gIFx0XHR0aGlzLnN0YWNrID0gZS5zdGFjaztcbiAgXHR9XG4gIH07XG5cbiAgUGFyc2VFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgUGFyc2VyID0gZnVuY3Rpb24gKHN0ciwgb3B0aW9ucykge1xuICBcdHZhciBpdGVtcyxcbiAgXHQgICAgaXRlbSxcbiAgXHQgICAgbGluZVN0YXJ0ID0gMDtcblxuICBcdHRoaXMuc3RyID0gc3RyO1xuICBcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIFx0dGhpcy5wb3MgPSAwO1xuXG4gIFx0dGhpcy5saW5lcyA9IHRoaXMuc3RyLnNwbGl0KFwiXFxuXCIpO1xuICBcdHRoaXMubGluZUVuZHMgPSB0aGlzLmxpbmVzLm1hcChmdW5jdGlvbiAobGluZSkge1xuICBcdFx0dmFyIGxpbmVFbmQgPSBsaW5lU3RhcnQgKyBsaW5lLmxlbmd0aCArIDE7IC8vICsxIGZvciB0aGUgbmV3bGluZVxuXG4gIFx0XHRsaW5lU3RhcnQgPSBsaW5lRW5kO1xuICBcdFx0cmV0dXJuIGxpbmVFbmQ7XG4gIFx0fSwgMCk7XG5cbiAgXHQvLyBDdXN0b20gaW5pdCBsb2dpY1xuICBcdGlmICh0aGlzLmluaXQpIHRoaXMuaW5pdChzdHIsIG9wdGlvbnMpO1xuXG4gIFx0aXRlbXMgPSBbXTtcblxuICBcdHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuc3RyLmxlbmd0aCAmJiAoaXRlbSA9IHRoaXMucmVhZCgpKSkge1xuICBcdFx0aXRlbXMucHVzaChpdGVtKTtcbiAgXHR9XG5cbiAgXHR0aGlzLmxlZnRvdmVyID0gdGhpcy5yZW1haW5pbmcoKTtcbiAgXHR0aGlzLnJlc3VsdCA9IHRoaXMucG9zdFByb2Nlc3MgPyB0aGlzLnBvc3RQcm9jZXNzKGl0ZW1zLCBvcHRpb25zKSA6IGl0ZW1zO1xuICB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUgPSB7XG4gIFx0cmVhZDogZnVuY3Rpb24gKGNvbnZlcnRlcnMpIHtcbiAgXHRcdHZhciBwb3MsIGksIGxlbiwgaXRlbTtcblxuICBcdFx0aWYgKCFjb252ZXJ0ZXJzKSBjb252ZXJ0ZXJzID0gdGhpcy5jb252ZXJ0ZXJzO1xuXG4gIFx0XHRwb3MgPSB0aGlzLnBvcztcblxuICBcdFx0bGVuID0gY29udmVydGVycy5sZW5ndGg7XG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0dGhpcy5wb3MgPSBwb3M7IC8vIHJlc2V0IGZvciBlYWNoIGF0dGVtcHRcblxuICBcdFx0XHRpZiAoaXRlbSA9IGNvbnZlcnRlcnNbaV0odGhpcykpIHtcbiAgXHRcdFx0XHRyZXR1cm4gaXRlbTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9LFxuXG4gIFx0Z2V0TGluZVBvczogZnVuY3Rpb24gKGNoYXIpIHtcbiAgXHRcdHZhciBsaW5lTnVtID0gMCxcbiAgXHRcdCAgICBsaW5lU3RhcnQgPSAwLFxuICBcdFx0ICAgIGNvbHVtbk51bTtcblxuICBcdFx0d2hpbGUgKGNoYXIgPj0gdGhpcy5saW5lRW5kc1tsaW5lTnVtXSkge1xuICBcdFx0XHRsaW5lU3RhcnQgPSB0aGlzLmxpbmVFbmRzW2xpbmVOdW1dO1xuICBcdFx0XHRsaW5lTnVtICs9IDE7XG4gIFx0XHR9XG5cbiAgXHRcdGNvbHVtbk51bSA9IGNoYXIgLSBsaW5lU3RhcnQ7XG4gIFx0XHRyZXR1cm4gW2xpbmVOdW0gKyAxLCBjb2x1bW5OdW0gKyAxLCBjaGFyXTsgLy8gbGluZS9jb2wgc2hvdWxkIGJlIG9uZS1iYXNlZCwgbm90IHplcm8tYmFzZWQhXG4gIFx0fSxcblxuICBcdGVycm9yOiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICBcdFx0dmFyIHBvcyA9IHRoaXMuZ2V0TGluZVBvcyh0aGlzLnBvcyk7XG4gIFx0XHR2YXIgbGluZU51bSA9IHBvc1swXTtcbiAgXHRcdHZhciBjb2x1bW5OdW0gPSBwb3NbMV07XG5cbiAgXHRcdHZhciBsaW5lID0gdGhpcy5saW5lc1twb3NbMF0gLSAxXTtcbiAgXHRcdHZhciBudW1UYWJzID0gMDtcbiAgXHRcdHZhciBhbm5vdGF0aW9uID0gbGluZS5yZXBsYWNlKC9cXHQvZywgZnVuY3Rpb24gKG1hdGNoLCBjaGFyKSB7XG4gIFx0XHRcdGlmIChjaGFyIDwgcG9zWzFdKSB7XG4gIFx0XHRcdFx0bnVtVGFicyArPSAxO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIFwiICBcIjtcbiAgXHRcdH0pICsgXCJcXG5cIiArIG5ldyBBcnJheShwb3NbMV0gKyBudW1UYWJzKS5qb2luKFwiIFwiKSArIFwiXi0tLS1cIjtcblxuICBcdFx0dmFyIGVycm9yID0gbmV3IFBhcnNlRXJyb3IoXCJcIiArIG1lc3NhZ2UgKyBcIiBhdCBsaW5lIFwiICsgbGluZU51bSArIFwiIGNoYXJhY3RlciBcIiArIGNvbHVtbk51bSArIFwiOlxcblwiICsgYW5ub3RhdGlvbik7XG5cbiAgXHRcdGVycm9yLmxpbmUgPSBwb3NbMF07XG4gIFx0XHRlcnJvci5jaGFyYWN0ZXIgPSBwb3NbMV07XG4gIFx0XHRlcnJvci5zaG9ydE1lc3NhZ2UgPSBtZXNzYWdlO1xuXG4gIFx0XHR0aHJvdyBlcnJvcjtcbiAgXHR9LFxuXG4gIFx0bWF0Y2hTdHJpbmc6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgXHRcdGlmICh0aGlzLnN0ci5zdWJzdHIodGhpcy5wb3MsIHN0cmluZy5sZW5ndGgpID09PSBzdHJpbmcpIHtcbiAgXHRcdFx0dGhpcy5wb3MgKz0gc3RyaW5nLmxlbmd0aDtcbiAgXHRcdFx0cmV0dXJuIHN0cmluZztcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0bWF0Y2hQYXR0ZXJuOiBmdW5jdGlvbiAocGF0dGVybikge1xuICBcdFx0dmFyIG1hdGNoO1xuXG4gIFx0XHRpZiAobWF0Y2ggPSBwYXR0ZXJuLmV4ZWModGhpcy5yZW1haW5pbmcoKSkpIHtcbiAgXHRcdFx0dGhpcy5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICBcdFx0XHRyZXR1cm4gbWF0Y2hbMV0gfHwgbWF0Y2hbMF07XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGFsbG93V2hpdGVzcGFjZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5tYXRjaFBhdHRlcm4ocGFyc2VfUGFyc2VyX19sZWFkaW5nV2hpdGVzcGFjZSk7XG4gIFx0fSxcblxuICBcdHJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuc3RyLnN1YnN0cmluZyh0aGlzLnBvcyk7XG4gIFx0fSxcblxuICBcdG5leHRDaGFyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5zdHIuY2hhckF0KHRoaXMucG9zKTtcbiAgXHR9XG4gIH07XG5cbiAgUGFyc2VyLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm90bykge1xuICBcdHZhciBQYXJlbnQgPSB0aGlzLFxuICBcdCAgICBDaGlsZCxcbiAgXHQgICAga2V5O1xuXG4gIFx0Q2hpbGQgPSBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG4gIFx0XHRQYXJzZXIuY2FsbCh0aGlzLCBzdHIsIG9wdGlvbnMpO1xuICBcdH07XG5cbiAgXHRDaGlsZC5wcm90b3R5cGUgPSBjcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG5cbiAgXHRmb3IgKGtleSBpbiBwcm90bykge1xuICBcdFx0aWYgKGhhc093bi5jYWxsKHByb3RvLCBrZXkpKSB7XG4gIFx0XHRcdENoaWxkLnByb3RvdHlwZVtrZXldID0gcHJvdG9ba2V5XTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRDaGlsZC5leHRlbmQgPSBQYXJzZXIuZXh0ZW5kO1xuICBcdHJldHVybiBDaGlsZDtcbiAgfTtcblxuICB2YXIgcGFyc2VfUGFyc2VyID0gUGFyc2VyO1xuXG4gIHZhciBURVhUID0gMTtcbiAgdmFyIElOVEVSUE9MQVRPUiA9IDI7XG4gIHZhciBUUklQTEUgPSAzO1xuICB2YXIgU0VDVElPTiA9IDQ7XG4gIHZhciBJTlZFUlRFRCA9IDU7XG4gIHZhciBDTE9TSU5HID0gNjtcbiAgdmFyIEVMRU1FTlQgPSA3O1xuICB2YXIgUEFSVElBTCA9IDg7XG4gIHZhciBDT01NRU5UID0gOTtcbiAgdmFyIERFTElNQ0hBTkdFID0gMTA7XG4gIHZhciBBVFRSSUJVVEUgPSAxMztcbiAgdmFyIENMT1NJTkdfVEFHID0gMTQ7XG4gIHZhciBDT01QT05FTlQgPSAxNTtcbiAgdmFyIFlJRUxERVIgPSAxNjtcbiAgdmFyIElOTElORV9QQVJUSUFMID0gMTc7XG4gIHZhciBET0NUWVBFID0gMTg7XG5cbiAgdmFyIE5VTUJFUl9MSVRFUkFMID0gMjA7XG4gIHZhciBTVFJJTkdfTElURVJBTCA9IDIxO1xuICB2YXIgQVJSQVlfTElURVJBTCA9IDIyO1xuICB2YXIgT0JKRUNUX0xJVEVSQUwgPSAyMztcbiAgdmFyIEJPT0xFQU5fTElURVJBTCA9IDI0O1xuICB2YXIgUkVHRVhQX0xJVEVSQUwgPSAyNTtcblxuICB2YXIgR0xPQkFMID0gMjY7XG4gIHZhciBLRVlfVkFMVUVfUEFJUiA9IDI3O1xuXG4gIHZhciBSRUZFUkVOQ0UgPSAzMDtcbiAgdmFyIFJFRklORU1FTlQgPSAzMTtcbiAgdmFyIE1FTUJFUiA9IDMyO1xuICB2YXIgUFJFRklYX09QRVJBVE9SID0gMzM7XG4gIHZhciBCUkFDS0VURUQgPSAzNDtcbiAgdmFyIENPTkRJVElPTkFMID0gMzU7XG4gIHZhciBJTkZJWF9PUEVSQVRPUiA9IDM2O1xuXG4gIHZhciBJTlZPQ0FUSU9OID0gNDA7XG5cbiAgdmFyIFNFQ1RJT05fSUYgPSA1MDtcbiAgdmFyIFNFQ1RJT05fVU5MRVNTID0gNTE7XG4gIHZhciBTRUNUSU9OX0VBQ0ggPSA1MjtcbiAgdmFyIFNFQ1RJT05fV0lUSCA9IDUzO1xuICB2YXIgU0VDVElPTl9JRl9XSVRIID0gNTQ7XG5cbiAgdmFyIEVMU0UgPSA2MDtcbiAgdmFyIEVMU0VJRiA9IDYxO1xuXG4gIHZhciBtdXN0YWNoZV9yZWFkRGVsaW1pdGVyQ2hhbmdlID0gcmVhZERlbGltaXRlckNoYW5nZTtcbiAgdmFyIGRlbGltaXRlckNoYW5nZVBhdHRlcm4gPSAvXlteXFxzPV0rLyxcbiAgICAgIHdoaXRlc3BhY2VQYXR0ZXJuID0gL15cXHMrLztcbiAgZnVuY3Rpb24gcmVhZERlbGltaXRlckNoYW5nZShwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIG9wZW5pbmcsIGNsb3Npbmc7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIj1cIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIG5ldyBvcGVuaW5nIGRlbGltaXRlclxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdG9wZW5pbmcgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGRlbGltaXRlckNoYW5nZVBhdHRlcm4pO1xuICBcdGlmICghb3BlbmluZykge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSAoaW4gZmFjdCwgaXQncyBuZWNlc3NhcnkuLi4pXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hQYXR0ZXJuKHdoaXRlc3BhY2VQYXR0ZXJuKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Y2xvc2luZyA9IHBhcnNlci5tYXRjaFBhdHRlcm4oZGVsaW1pdGVyQ2hhbmdlUGF0dGVybik7XG4gIFx0aWYgKCFjbG9zaW5nKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSBjbG9zaW5nICc9J1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiPVwiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIFtvcGVuaW5nLCBjbG9zaW5nXTtcbiAgfVxuXG4gIHZhciByZWFkUmVnZXhwTGl0ZXJhbCA9IHJlYWRSZWdleHBMaXRlcmFsX19yZWFkTnVtYmVyTGl0ZXJhbDtcbiAgdmFyIHJlZ2V4cFBhdHRlcm4gPSAvXihcXC8oPzpbXlxcblxcclxcdTIwMjhcXHUyMDI5L1xcXFxbXXxcXFxcLnxcXFsoPzpbXlxcblxcclxcdTIwMjhcXHUyMDI5XFxdXFxcXF18XFxcXC4pKl0pK1xcLyg/OihbZ2ltdXldKSg/IVthLXpdKlxcMikpKig/IVthLXpBLVpfJDAtOV0pKS87XG4gIGZ1bmN0aW9uIHJlYWRSZWdleHBMaXRlcmFsX19yZWFkTnVtYmVyTGl0ZXJhbChwYXJzZXIpIHtcbiAgXHR2YXIgcmVzdWx0O1xuXG4gIFx0aWYgKHJlc3VsdCA9IHBhcnNlci5tYXRjaFBhdHRlcm4ocmVnZXhwUGF0dGVybikpIHtcbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IFJFR0VYUF9MSVRFUkFMLFxuICBcdFx0XHR2OiByZXN1bHRcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkTXVzdGFjaGUgPSByZWFkTXVzdGFjaGU7XG5cbiAgdmFyIGRlbGltaXRlckNoYW5nZVRva2VuID0geyB0OiBERUxJTUNIQU5HRSwgZXhjbHVkZTogdHJ1ZSB9O1xuICBmdW5jdGlvbiByZWFkTXVzdGFjaGUocGFyc2VyKSB7XG4gIFx0dmFyIG11c3RhY2hlLCBpO1xuXG4gIFx0Ly8gSWYgd2UncmUgaW5zaWRlIGEgPHNjcmlwdD4gb3IgPHN0eWxlPiB0YWcsIGFuZCB3ZSdyZSBub3RcbiAgXHQvLyBpbnRlcnBvbGF0aW5nLCBidWcgb3V0XG4gIFx0aWYgKHBhcnNlci5pbnRlcnBvbGF0ZVtwYXJzZXIuaW5zaWRlXSA9PT0gZmFsc2UpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGZvciAoaSA9IDA7IGkgPCBwYXJzZXIudGFncy5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0aWYgKG11c3RhY2hlID0gcmVhZE11c3RhY2hlT2ZUeXBlKHBhcnNlciwgcGFyc2VyLnRhZ3NbaV0pKSB7XG4gIFx0XHRcdHJldHVybiBtdXN0YWNoZTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkTXVzdGFjaGVPZlR5cGUocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQsIG11c3RhY2hlLCByZWFkZXIsIGk7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiXFxcXFwiICsgdGFnLm9wZW4pKSB7XG4gIFx0XHRpZiAoc3RhcnQgPT09IDAgfHwgcGFyc2VyLnN0cltzdGFydCAtIDFdICE9PSBcIlxcXFxcIikge1xuICBcdFx0XHRyZXR1cm4gdGFnLm9wZW47XG4gIFx0XHR9XG4gIFx0fSBlbHNlIGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5vcGVuKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gZGVsaW1pdGVyIGNoYW5nZT9cbiAgXHRpZiAobXVzdGFjaGUgPSBtdXN0YWNoZV9yZWFkRGVsaW1pdGVyQ2hhbmdlKHBhcnNlcikpIHtcbiAgXHRcdC8vIGZpbmQgY2xvc2luZyBkZWxpbWl0ZXIgb3IgYWJvcnQuLi5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIC4uLnRoZW4gbWFrZSB0aGUgc3dpdGNoXG4gIFx0XHR0YWcub3BlbiA9IG11c3RhY2hlWzBdO1xuICBcdFx0dGFnLmNsb3NlID0gbXVzdGFjaGVbMV07XG4gIFx0XHRwYXJzZXIuc29ydE11c3RhY2hlVGFncygpO1xuXG4gIFx0XHRyZXR1cm4gZGVsaW1pdGVyQ2hhbmdlVG9rZW47XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gaWxsZWdhbCBzZWN0aW9uIGNsb3NlclxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIvXCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zIC09IDE7XG4gIFx0XHR2YXIgcmV3aW5kID0gcGFyc2VyLnBvcztcbiAgXHRcdGlmICghcmVhZFJlZ2V4cExpdGVyYWwocGFyc2VyKSkge1xuICBcdFx0XHRwYXJzZXIucG9zID0gcmV3aW5kIC0gdGFnLmNsb3NlLmxlbmd0aDtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiQXR0ZW1wdGVkIHRvIGNsb3NlIGEgc2VjdGlvbiB0aGF0IHdhc24ndCBvcGVuXCIpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHJld2luZDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRmb3IgKGkgPSAwOyBpIDwgdGFnLnJlYWRlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdHJlYWRlciA9IHRhZy5yZWFkZXJzW2ldO1xuXG4gIFx0XHRpZiAobXVzdGFjaGUgPSByZWFkZXIocGFyc2VyLCB0YWcpKSB7XG4gIFx0XHRcdGlmICh0YWcuaXNTdGF0aWMpIHtcbiAgXHRcdFx0XHRtdXN0YWNoZS5zID0gdHJ1ZTsgLy8gVE9ETyBtYWtlIHRoaXMgYDFgIGluc3RlYWQgLSBtb3JlIGNvbXBhY3RcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChwYXJzZXIuaW5jbHVkZUxpbmVQb3NpdGlvbnMpIHtcbiAgXHRcdFx0XHRtdXN0YWNoZS5wID0gcGFyc2VyLmdldExpbmVQb3Moc3RhcnQpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIG11c3RhY2hlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBleHBlY3RlZEV4cHJlc3Npb24gPSBcIkV4cGVjdGVkIGEgSmF2YVNjcmlwdCBleHByZXNzaW9uXCI7XG4gIHZhciBleHBlY3RlZFBhcmVuID0gXCJFeHBlY3RlZCBjbG9zaW5nIHBhcmVuXCI7XG5cbiAgdmFyIGxpdGVyYWxfcmVhZE51bWJlckxpdGVyYWwgPSBsaXRlcmFsX3JlYWROdW1iZXJMaXRlcmFsX19yZWFkTnVtYmVyTGl0ZXJhbDtcbiAgdmFyIGxpdGVyYWxfcmVhZE51bWJlckxpdGVyYWxfX251bWJlclBhdHRlcm4gPSAvXig/OlsrLV0/KTAqKD86KD86KD86WzEtOV1cXGQqKT9cXC5cXGQrKXwoPzooPzowfFsxLTldXFxkKilcXC4pfCg/OjB8WzEtOV1cXGQqKSkoPzpbZUVdWystXT9cXGQrKT8vO1xuICBmdW5jdGlvbiBsaXRlcmFsX3JlYWROdW1iZXJMaXRlcmFsX19yZWFkTnVtYmVyTGl0ZXJhbChwYXJzZXIpIHtcbiAgXHR2YXIgcmVzdWx0O1xuXG4gIFx0aWYgKHJlc3VsdCA9IHBhcnNlci5tYXRjaFBhdHRlcm4obGl0ZXJhbF9yZWFkTnVtYmVyTGl0ZXJhbF9fbnVtYmVyUGF0dGVybikpIHtcbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IE5VTUJFUl9MSVRFUkFMLFxuICBcdFx0XHR2OiByZXN1bHRcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbGl0ZXJhbF9yZWFkQm9vbGVhbkxpdGVyYWwgPSByZWFkQm9vbGVhbkxpdGVyYWw7XG4gIGZ1bmN0aW9uIHJlYWRCb29sZWFuTGl0ZXJhbChwYXJzZXIpIHtcbiAgXHR2YXIgcmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXG4gIFx0aWYgKHJlbWFpbmluZy5zdWJzdHIoMCwgNCkgPT09IFwidHJ1ZVwiKSB7XG4gIFx0XHRwYXJzZXIucG9zICs9IDQ7XG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBCT09MRUFOX0xJVEVSQUwsXG4gIFx0XHRcdHY6IFwidHJ1ZVwiXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdGlmIChyZW1haW5pbmcuc3Vic3RyKDAsIDUpID09PSBcImZhbHNlXCIpIHtcbiAgXHRcdHBhcnNlci5wb3MgKz0gNTtcbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IEJPT0xFQU5fTElURVJBTCxcbiAgXHRcdFx0djogXCJmYWxzZVwiXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHN0cmluZ01pZGRsZVBhdHRlcm4sIGVzY2FwZVNlcXVlbmNlUGF0dGVybiwgbGluZUNvbnRpbnVhdGlvblBhdHRlcm47XG5cbiAgLy8gTWF0Y2ggb25lIG9yIG1vcmUgY2hhcmFjdGVycyB1bnRpbDogXCIsICcsIFxcLCBvciBFT0wvRU9GLlxuICAvLyBFT0wvRU9GIGlzIHdyaXR0ZW4gYXMgKD8hLikgKG1lYW5pbmcgdGhlcmUncyBubyBub24tbmV3bGluZSBjaGFyIG5leHQpLlxuICBzdHJpbmdNaWRkbGVQYXR0ZXJuID0gL14oPz0uKVteXCInXFxcXF0rPyg/Oig/IS4pfCg/PVtcIidcXFxcXSkpLztcblxuICAvLyBNYXRjaCBvbmUgZXNjYXBlIHNlcXVlbmNlLCBpbmNsdWRpbmcgdGhlIGJhY2tzbGFzaC5cbiAgZXNjYXBlU2VxdWVuY2VQYXR0ZXJuID0gL15cXFxcKD86WydcIlxcXFxiZm5ydF18MCg/IVswLTldKXx4WzAtOWEtZkEtRl17Mn18dVswLTlhLWZBLUZdezR9fCg/PS4pW151eDAtOV0pLztcblxuICAvLyBNYXRjaCBvbmUgRVM1IGxpbmUgY29udGludWF0aW9uIChiYWNrc2xhc2ggKyBsaW5lIHRlcm1pbmF0b3IpLlxuICBsaW5lQ29udGludWF0aW9uUGF0dGVybiA9IC9eXFxcXCg/OlxcclxcbnxbXFx1MDAwQVxcdTAwMERcXHUyMDI4XFx1MjAyOV0pLztcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIGdldERvdWJsZVF1b3RlZFN0cmluZyBhbmQgZ2V0U2luZ2xlUXVvdGVkU3RyaW5nLlxuICB2YXIgbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIgPSBmdW5jdGlvbiAob2tRdW90ZSkge1xuICBcdHJldHVybiBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0XHR2YXIgc3RhcnQsIGxpdGVyYWwsIGRvbmUsIG5leHQ7XG5cbiAgXHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcbiAgXHRcdGxpdGVyYWwgPSBcIlxcXCJcIjtcbiAgXHRcdGRvbmUgPSBmYWxzZTtcblxuICBcdFx0d2hpbGUgKCFkb25lKSB7XG4gIFx0XHRcdG5leHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHN0cmluZ01pZGRsZVBhdHRlcm4pIHx8IHBhcnNlci5tYXRjaFBhdHRlcm4oZXNjYXBlU2VxdWVuY2VQYXR0ZXJuKSB8fCBwYXJzZXIubWF0Y2hTdHJpbmcob2tRdW90ZSk7XG4gIFx0XHRcdGlmIChuZXh0KSB7XG4gIFx0XHRcdFx0aWYgKG5leHQgPT09IFwiXFxcIlwiKSB7XG4gIFx0XHRcdFx0XHRsaXRlcmFsICs9IFwiXFxcXFxcXCJcIjtcbiAgXHRcdFx0XHR9IGVsc2UgaWYgKG5leHQgPT09IFwiXFxcXCdcIikge1xuICBcdFx0XHRcdFx0bGl0ZXJhbCArPSBcIidcIjtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0bGl0ZXJhbCArPSBuZXh0O1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRuZXh0ID0gcGFyc2VyLm1hdGNoUGF0dGVybihsaW5lQ29udGludWF0aW9uUGF0dGVybik7XG4gIFx0XHRcdFx0aWYgKG5leHQpIHtcbiAgXHRcdFx0XHRcdC8vIGNvbnZlcnQgXFwobmV3bGluZS1saWtlKSBpbnRvIGEgXFx1IGVzY2FwZSwgd2hpY2ggaXMgYWxsb3dlZCBpbiBKU09OXG4gIFx0XHRcdFx0XHRsaXRlcmFsICs9IFwiXFxcXHVcIiArIChcIjAwMFwiICsgbmV4dC5jaGFyQ29kZUF0KDEpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRkb25lID0gdHJ1ZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0bGl0ZXJhbCArPSBcIlxcXCJcIjtcblxuICBcdFx0Ly8gdXNlIEpTT04ucGFyc2UgdG8gaW50ZXJwcmV0IGVzY2FwZXNcbiAgXHRcdHJldHVybiBKU09OLnBhcnNlKGxpdGVyYWwpO1xuICBcdH07XG4gIH07XG5cbiAgdmFyIGdldFNpbmdsZVF1b3RlZFN0cmluZyA9IG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyKFwiXFxcIlwiKTtcbiAgdmFyIGdldERvdWJsZVF1b3RlZFN0cmluZyA9IG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyKFwiJ1wiKTtcblxuICB2YXIgcmVhZFN0cmluZ0xpdGVyYWwgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBzdHJpbmc7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiXFxcIlwiKSkge1xuICBcdFx0c3RyaW5nID0gZ2V0RG91YmxlUXVvdGVkU3RyaW5nKHBhcnNlcik7XG5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiXFxcIlwiKSkge1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBTVFJJTkdfTElURVJBTCxcbiAgXHRcdFx0djogc3RyaW5nXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCInXCIpKSB7XG4gIFx0XHRzdHJpbmcgPSBnZXRTaW5nbGVRdW90ZWRTdHJpbmcocGFyc2VyKTtcblxuICBcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCInXCIpKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IFNUUklOR19MSVRFUkFMLFxuICBcdFx0XHR2OiBzdHJpbmdcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIHBhdHRlcm5zX19uYW1lID0gL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSovO1xuXG4gIC8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtcHJvcGVydGllc1xuICAvLyBjYW4gYmUgYW55IG5hbWUsIHN0cmluZyBsaXRlcmFsLCBvciBudW1iZXIgbGl0ZXJhbFxuICB2YXIgc2hhcmVkX3JlYWRLZXkgPSByZWFkS2V5O1xuICB2YXIgaWRlbnRpZmllciA9IC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qJC87XG4gIGZ1bmN0aW9uIHJlYWRLZXkocGFyc2VyKSB7XG4gIFx0dmFyIHRva2VuO1xuXG4gIFx0aWYgKHRva2VuID0gcmVhZFN0cmluZ0xpdGVyYWwocGFyc2VyKSkge1xuICBcdFx0cmV0dXJuIGlkZW50aWZpZXIudGVzdCh0b2tlbi52KSA/IHRva2VuLnYgOiBcIlxcXCJcIiArIHRva2VuLnYucmVwbGFjZSgvXCIvZywgXCJcXFxcXFxcIlwiKSArIFwiXFxcIlwiO1xuICBcdH1cblxuICBcdGlmICh0b2tlbiA9IGxpdGVyYWxfcmVhZE51bWJlckxpdGVyYWwocGFyc2VyKSkge1xuICBcdFx0cmV0dXJuIHRva2VuLnY7XG4gIFx0fVxuXG4gIFx0aWYgKHRva2VuID0gcGFyc2VyLm1hdGNoUGF0dGVybihwYXR0ZXJuc19fbmFtZSkpIHtcbiAgXHRcdHJldHVybiB0b2tlbjtcbiAgXHR9XG4gIH1cblxuICB2YXIga2V5VmFsdWVQYWlyID0gcmVhZEtleVZhbHVlUGFpcjtcbiAgZnVuY3Rpb24gcmVhZEtleVZhbHVlUGFpcihwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGtleSwgdmFsdWU7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gJ3snIGFuZCBrZXlcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRrZXkgPSBzaGFyZWRfcmVhZEtleShwYXJzZXIpO1xuICBcdGlmIChrZXkgPT09IG51bGwpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBrZXkgYW5kICc6J1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIG5leHQgY2hhcmFjdGVyIG11c3QgYmUgJzonXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI6XCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gJzonIGFuZCB2YWx1ZVxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIG5leHQgZXhwcmVzc2lvbiBtdXN0IGJlIGEsIHdlbGwuLi4gZXhwcmVzc2lvblxuICBcdHZhbHVlID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuICBcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IEtFWV9WQUxVRV9QQUlSLFxuICBcdFx0azoga2V5LFxuICBcdFx0djogdmFsdWVcbiAgXHR9O1xuICB9XG5cbiAgdmFyIG9iamVjdExpdGVyYWxfa2V5VmFsdWVQYWlycyA9IHJlYWRLZXlWYWx1ZVBhaXJzO1xuICBmdW5jdGlvbiByZWFkS2V5VmFsdWVQYWlycyhwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIHBhaXJzLCBwYWlyLCBrZXlWYWx1ZVBhaXJzO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0cGFpciA9IGtleVZhbHVlUGFpcihwYXJzZXIpO1xuICBcdGlmIChwYWlyID09PSBudWxsKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYWlycyA9IFtwYWlyXTtcblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIsXCIpKSB7XG4gIFx0XHRrZXlWYWx1ZVBhaXJzID0gcmVhZEtleVZhbHVlUGFpcnMocGFyc2VyKTtcblxuICBcdFx0aWYgKCFrZXlWYWx1ZVBhaXJzKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBwYWlycy5jb25jYXQoa2V5VmFsdWVQYWlycyk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHBhaXJzO1xuICB9XG5cbiAgdmFyIHJlYWRPYmplY3RMaXRlcmFsID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwga2V5VmFsdWVQYWlycztcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2VcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIntcIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGtleVZhbHVlUGFpcnMgPSBvYmplY3RMaXRlcmFsX2tleVZhbHVlUGFpcnMocGFyc2VyKTtcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBmaW5hbCB2YWx1ZSBhbmQgJ30nXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCJ9XCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogT0JKRUNUX0xJVEVSQUwsXG4gIFx0XHRtOiBrZXlWYWx1ZVBhaXJzXG4gIFx0fTtcbiAgfTtcblxuICB2YXIgc2hhcmVkX3JlYWRFeHByZXNzaW9uTGlzdCA9IHJlYWRFeHByZXNzaW9uTGlzdDtcbiAgZnVuY3Rpb24gcmVhZEV4cHJlc3Npb25MaXN0KHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgZXhwcmVzc2lvbnMsIGV4cHIsIG5leHQ7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRleHByID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuXG4gIFx0aWYgKGV4cHIgPT09IG51bGwpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGV4cHJlc3Npb25zID0gW2V4cHJdO1xuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuIGV4cHJlc3Npb24gYW5kICcsJ1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIsXCIpKSB7XG4gIFx0XHRuZXh0ID0gcmVhZEV4cHJlc3Npb25MaXN0KHBhcnNlcik7XG4gIFx0XHRpZiAobmV4dCA9PT0gbnVsbCkge1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRFeHByZXNzaW9uKTtcbiAgXHRcdH1cblxuICBcdFx0bmV4dC5mb3JFYWNoKGFwcGVuZCk7XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gYXBwZW5kKGV4cHJlc3Npb24pIHtcbiAgXHRcdGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGV4cHJlc3Npb25zO1xuICB9XG5cbiAgdmFyIHJlYWRBcnJheUxpdGVyYWwgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBleHByZXNzaW9uTGlzdDtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlICdbJ1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiW1wiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0ZXhwcmVzc2lvbkxpc3QgPSBzaGFyZWRfcmVhZEV4cHJlc3Npb25MaXN0KHBhcnNlcik7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIl1cIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBBUlJBWV9MSVRFUkFMLFxuICBcdFx0bTogZXhwcmVzc2lvbkxpc3RcbiAgXHR9O1xuICB9O1xuXG4gIHZhciBwcmltYXJ5X3JlYWRMaXRlcmFsID0gcmVhZExpdGVyYWw7XG4gIGZ1bmN0aW9uIHJlYWRMaXRlcmFsKHBhcnNlcikge1xuICBcdHJldHVybiBsaXRlcmFsX3JlYWROdW1iZXJMaXRlcmFsKHBhcnNlcikgfHwgbGl0ZXJhbF9yZWFkQm9vbGVhbkxpdGVyYWwocGFyc2VyKSB8fCByZWFkU3RyaW5nTGl0ZXJhbChwYXJzZXIpIHx8IHJlYWRPYmplY3RMaXRlcmFsKHBhcnNlcikgfHwgcmVhZEFycmF5TGl0ZXJhbChwYXJzZXIpIHx8IHJlYWRSZWdleHBMaXRlcmFsKHBhcnNlcik7XG4gIH1cblxuICB2YXIgcHJpbWFyeV9yZWFkUmVmZXJlbmNlID0gcmVhZFJlZmVyZW5jZTtcbiAgdmFyIHByZWZpeFBhdHRlcm4gPSAvXig/On5cXC98KD86XFwuXFwuXFwvKSt8XFwuXFwvKD86XFwuXFwuXFwvKSp8XFwuKS8sXG4gICAgICBnbG9iYWxzLFxuICAgICAga2V5d29yZHM7XG5cbiAgLy8gaWYgYSByZWZlcmVuY2UgaXMgYSBicm93c2VyIGdsb2JhbCwgd2UgZG9uJ3QgZGVmZXJlbmNlIGl0IGxhdGVyLCBzbyBpdCBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudFxuICBnbG9iYWxzID0gL14oPzpBcnJheXxjb25zb2xlfERhdGV8UmVnRXhwfGRlY29kZVVSSUNvbXBvbmVudHxkZWNvZGVVUkl8ZW5jb2RlVVJJQ29tcG9uZW50fGVuY29kZVVSSXxpc0Zpbml0ZXxpc05hTnxwYXJzZUZsb2F0fHBhcnNlSW50fEpTT058TWF0aHxOYU58dW5kZWZpbmVkfG51bGwpXFxiLztcblxuICAvLyBrZXl3b3JkcyBhcmUgbm90IHZhbGlkIHJlZmVyZW5jZXMsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBgdGhpc2BcbiAga2V5d29yZHMgPSAvXig/OmJyZWFrfGNhc2V8Y2F0Y2h8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxmaW5hbGx5fGZvcnxmdW5jdGlvbnxpZnxpbnxpbnN0YW5jZW9mfG5ld3xyZXR1cm58c3dpdGNofHRocm93fHRyeXx0eXBlb2Z8dmFyfHZvaWR8d2hpbGV8d2l0aCkkLztcblxuICB2YXIgbGVnYWxSZWZlcmVuY2UgPSAvXlthLXpBLVokXzAtOV0rKD86KD86XFwuW2EtekEtWiRfMC05XSspfCg/OlxcW1swLTldK1xcXSkpKi87XG4gIHZhciByZWxheGVkTmFtZSA9IC9eW2EtekEtWl8kXVstYS16QS1aXyQwLTldKi87XG4gIGZ1bmN0aW9uIHJlYWRSZWZlcmVuY2UocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0UG9zLCBwcmVmaXgsIG5hbWUsIGdsb2JhbCwgcmVmZXJlbmNlLCBsYXN0RG90SW5kZXg7XG5cbiAgXHRzdGFydFBvcyA9IHBhcnNlci5wb3M7XG5cbiAgXHRuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybigvXkAoPzprZXlwYXRofGluZGV4fGtleSkvKTtcblxuICBcdGlmICghbmFtZSkge1xuICBcdFx0cHJlZml4ID0gcGFyc2VyLm1hdGNoUGF0dGVybihwcmVmaXhQYXR0ZXJuKSB8fCBcIlwiO1xuICBcdFx0bmFtZSA9ICFwcmVmaXggJiYgcGFyc2VyLnJlbGF4ZWROYW1lcyAmJiBwYXJzZXIubWF0Y2hQYXR0ZXJuKHJlbGF4ZWROYW1lKSB8fCBwYXJzZXIubWF0Y2hQYXR0ZXJuKGxlZ2FsUmVmZXJlbmNlKTtcblxuICBcdFx0aWYgKCFuYW1lICYmIHByZWZpeCA9PT0gXCIuXCIpIHtcbiAgXHRcdFx0cHJlZml4ID0gXCJcIjtcbiAgXHRcdFx0bmFtZSA9IFwiLlwiO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICghbmFtZSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gYnVnIG91dCBpZiBpdCdzIGEga2V5d29yZCAoZXhjZXB0aW9uIGZvciBhbmNlc3Rvci9yZXN0cmljdGVkIHJlZnMgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3Vlcy8xNDk3KVxuICBcdGlmICghcHJlZml4ICYmICFwYXJzZXIucmVsYXhlZE5hbWVzICYmIGtleXdvcmRzLnRlc3QobmFtZSkpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydFBvcztcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGlmIHRoaXMgaXMgYSBicm93c2VyIGdsb2JhbCwgc3RvcCBoZXJlXG4gIFx0aWYgKCFwcmVmaXggJiYgZ2xvYmFscy50ZXN0KG5hbWUpKSB7XG4gIFx0XHRnbG9iYWwgPSBnbG9iYWxzLmV4ZWMobmFtZSlbMF07XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnRQb3MgKyBnbG9iYWwubGVuZ3RoO1xuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBHTE9CQUwsXG4gIFx0XHRcdHY6IGdsb2JhbFxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZWZlcmVuY2UgPSAocHJlZml4IHx8IFwiXCIpICsgbm9ybWFsaXNlKG5hbWUpO1xuXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIihcIikpIHtcbiAgXHRcdC8vIGlmIHRoaXMgaXMgYSBtZXRob2QgaW52b2NhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIGZ1bmN0aW9uKSB3ZSBuZWVkXG4gIFx0XHQvLyB0byBzdHJpcCB0aGUgbWV0aG9kIG5hbWUgZnJvbSB0aGUgcmVmZXJlbmNlIGNvbWJvLCBlbHNlIHRoZSBjb250ZXh0XG4gIFx0XHQvLyB3aWxsIGJlIHdyb25nXG4gIFx0XHRsYXN0RG90SW5kZXggPSByZWZlcmVuY2UubGFzdEluZGV4T2YoXCIuXCIpO1xuICBcdFx0aWYgKGxhc3REb3RJbmRleCAhPT0gLTEpIHtcbiAgXHRcdFx0cmVmZXJlbmNlID0gcmVmZXJlbmNlLnN1YnN0cigwLCBsYXN0RG90SW5kZXgpO1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnRQb3MgKyByZWZlcmVuY2UubGVuZ3RoO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyAtPSAxO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBSRUZFUkVOQ0UsXG4gIFx0XHRuOiByZWZlcmVuY2UucmVwbGFjZSgvXnRoaXNcXC4vLCBcIi4vXCIpLnJlcGxhY2UoL150aGlzJC8sIFwiLlwiKVxuICBcdH07XG4gIH1cblxuICB2YXIgcHJpbWFyeV9yZWFkQnJhY2tldGVkRXhwcmVzc2lvbiA9IHJlYWRCcmFja2V0ZWRFeHByZXNzaW9uO1xuICBmdW5jdGlvbiByZWFkQnJhY2tldGVkRXhwcmVzc2lvbihwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHI7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIihcIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGV4cHIgPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0aWYgKCFleHByKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRFeHByZXNzaW9uKTtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIilcIikpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihleHBlY3RlZFBhcmVuKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogQlJBQ0tFVEVELFxuICBcdFx0eDogZXhwclxuICBcdH07XG4gIH1cblxuICB2YXIgcmVhZFByaW1hcnkgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0cmV0dXJuIHByaW1hcnlfcmVhZExpdGVyYWwocGFyc2VyKSB8fCBwcmltYXJ5X3JlYWRSZWZlcmVuY2UocGFyc2VyKSB8fCBwcmltYXJ5X3JlYWRCcmFja2V0ZWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIH07XG5cbiAgdmFyIHNoYXJlZF9yZWFkUmVmaW5lbWVudCA9IHJlYWRSZWZpbmVtZW50O1xuICBmdW5jdGlvbiByZWFkUmVmaW5lbWVudChwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIG5hbWUsIGV4cHI7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHQvLyBcIi5cIiBuYW1lXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIi5cIikpIHtcbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0aWYgKG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHBhdHRlcm5zX19uYW1lKSkge1xuICBcdFx0XHRyZXR1cm4ge1xuICBcdFx0XHRcdHQ6IFJFRklORU1FTlQsXG4gIFx0XHRcdFx0bjogbmFtZVxuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBhIHByb3BlcnR5IG5hbWVcIik7XG4gIFx0fVxuXG4gIFx0Ly8gXCJbXCIgZXhwcmVzc2lvbiBcIl1cIlxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJbXCIpKSB7XG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdGV4cHIgPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0XHRpZiAoIWV4cHIpIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkRXhwcmVzc2lvbik7XG4gIFx0XHR9XG5cbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCJdXCIpKSB7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkICddJ1wiKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogUkVGSU5FTUVOVCxcbiAgXHRcdFx0eDogZXhwclxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciByZWFkTWVtYmVyT3JJbnZvY2F0aW9uID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdHZhciBjdXJyZW50LCBleHByZXNzaW9uLCByZWZpbmVtZW50LCBleHByZXNzaW9uTGlzdDtcblxuICBcdGV4cHJlc3Npb24gPSByZWFkUHJpbWFyeShwYXJzZXIpO1xuXG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHR3aGlsZSAoZXhwcmVzc2lvbikge1xuICBcdFx0Y3VycmVudCA9IHBhcnNlci5wb3M7XG5cbiAgXHRcdGlmIChyZWZpbmVtZW50ID0gc2hhcmVkX3JlYWRSZWZpbmVtZW50KHBhcnNlcikpIHtcbiAgXHRcdFx0ZXhwcmVzc2lvbiA9IHtcbiAgXHRcdFx0XHR0OiBNRU1CRVIsXG4gIFx0XHRcdFx0eDogZXhwcmVzc2lvbixcbiAgXHRcdFx0XHRyOiByZWZpbmVtZW50XG4gIFx0XHRcdH07XG4gIFx0XHR9IGVsc2UgaWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIihcIikpIHtcbiAgXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdFx0XHRleHByZXNzaW9uTGlzdCA9IHNoYXJlZF9yZWFkRXhwcmVzc2lvbkxpc3QocGFyc2VyKTtcblxuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCIpXCIpKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkUGFyZW4pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0ZXhwcmVzc2lvbiA9IHtcbiAgXHRcdFx0XHR0OiBJTlZPQ0FUSU9OLFxuICBcdFx0XHRcdHg6IGV4cHJlc3Npb25cbiAgXHRcdFx0fTtcblxuICBcdFx0XHRpZiAoZXhwcmVzc2lvbkxpc3QpIHtcbiAgXHRcdFx0XHRleHByZXNzaW9uLm8gPSBleHByZXNzaW9uTGlzdDtcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0YnJlYWs7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGV4cHJlc3Npb247XG4gIH07XG5cbiAgdmFyIHJlYWRUeXBlT2YsIG1ha2VQcmVmaXhTZXF1ZW5jZU1hdGNoZXI7XG5cbiAgbWFrZVByZWZpeFNlcXVlbmNlTWF0Y2hlciA9IGZ1bmN0aW9uIChzeW1ib2wsIGZhbGx0aHJvdWdoKSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgXHRcdHZhciBleHByZXNzaW9uO1xuXG4gIFx0XHRpZiAoZXhwcmVzc2lvbiA9IGZhbGx0aHJvdWdoKHBhcnNlcikpIHtcbiAgXHRcdFx0cmV0dXJuIGV4cHJlc3Npb247XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHN5bWJvbCkpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0ZXhwcmVzc2lvbiA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRFeHByZXNzaW9uKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0czogc3ltYm9sLFxuICBcdFx0XHRvOiBleHByZXNzaW9uLFxuICBcdFx0XHR0OiBQUkVGSVhfT1BFUkFUT1JcbiAgXHRcdH07XG4gIFx0fTtcbiAgfTtcblxuICAvLyBjcmVhdGUgYWxsIHByZWZpeCBzZXF1ZW5jZSBtYXRjaGVycywgcmV0dXJuIHJlYWRUeXBlT2ZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgXHR2YXIgaSwgbGVuLCBtYXRjaGVyLCBwcmVmaXhPcGVyYXRvcnMsIGZhbGx0aHJvdWdoO1xuXG4gIFx0cHJlZml4T3BlcmF0b3JzID0gXCIhIH4gKyAtIHR5cGVvZlwiLnNwbGl0KFwiIFwiKTtcblxuICBcdGZhbGx0aHJvdWdoID0gcmVhZE1lbWJlck9ySW52b2NhdGlvbjtcbiAgXHRmb3IgKGkgPSAwLCBsZW4gPSBwcmVmaXhPcGVyYXRvcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdG1hdGNoZXIgPSBtYWtlUHJlZml4U2VxdWVuY2VNYXRjaGVyKHByZWZpeE9wZXJhdG9yc1tpXSwgZmFsbHRocm91Z2gpO1xuICBcdFx0ZmFsbHRocm91Z2ggPSBtYXRjaGVyO1xuICBcdH1cblxuICBcdC8vIHR5cGVvZiBvcGVyYXRvciBpcyBoaWdoZXIgcHJlY2VkZW5jZSB0aGFuIG11bHRpcGxpY2F0aW9uLCBzbyBwcm92aWRlcyB0aGVcbiAgXHQvLyBmYWxsdGhyb3VnaCBmb3IgdGhlIG11bHRpcGxpY2F0aW9uIHNlcXVlbmNlIG1hdGNoZXIgd2UncmUgYWJvdXQgdG8gY3JlYXRlXG4gIFx0Ly8gKHdlJ3JlIHNraXBwaW5nIHZvaWQgYW5kIGRlbGV0ZSlcbiAgXHRyZWFkVHlwZU9mID0gZmFsbHRocm91Z2g7XG4gIH0pKCk7XG5cbiAgdmFyIHJlYWRUeXBlb2YgPSByZWFkVHlwZU9mO1xuXG4gIHZhciByZWFkTG9naWNhbE9yLCBtYWtlSW5maXhTZXF1ZW5jZU1hdGNoZXI7XG5cbiAgbWFrZUluZml4U2VxdWVuY2VNYXRjaGVyID0gZnVuY3Rpb24gKHN5bWJvbCwgZmFsbHRocm91Z2gpIHtcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdFx0dmFyIHN0YXJ0LCBsZWZ0LCByaWdodDtcblxuICBcdFx0bGVmdCA9IGZhbGx0aHJvdWdoKHBhcnNlcik7XG4gIFx0XHRpZiAoIWxlZnQpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIExvb3AgdG8gaGFuZGxlIGxlZnQtcmVjdXJzaW9uIGluIGEgY2FzZSBsaWtlIGBhICogYiAqIGNgIGFuZCBwcm9kdWNlXG4gIFx0XHQvLyBsZWZ0IGFzc29jaWF0aW9uLCBpLmUuIGAoYSAqIGIpICogY2AuICBUaGUgbWF0Y2hlciBjYW4ndCBjYWxsIGl0c2VsZlxuICBcdFx0Ly8gdG8gcGFyc2UgYGxlZnRgIGJlY2F1c2UgdGhhdCB3b3VsZCBiZSBpbmZpbml0ZSByZWdyZXNzLlxuICBcdFx0d2hpbGUgKHRydWUpIHtcbiAgXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhzeW1ib2wpKSB7XG4gIFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRcdHJldHVybiBsZWZ0O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gaW4gb3BlcmF0b3IgbXVzdCBub3QgYmUgZm9sbG93ZWQgYnkgW2EtekEtWl8kMC05XVxuICBcdFx0XHRpZiAoc3ltYm9sID09PSBcImluXCIgJiYgL1thLXpBLVpfJDAtOV0vLnRlc3QocGFyc2VyLnJlbWFpbmluZygpLmNoYXJBdCgwKSkpIHtcbiAgXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdFx0cmV0dXJuIGxlZnQ7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdFx0Ly8gcmlnaHQgb3BlcmFuZCBtdXN0IGFsc28gY29uc2lzdCBvZiBvbmx5IGhpZ2hlci1wcmVjZWRlbmNlIG9wZXJhdG9yc1xuICBcdFx0XHRyaWdodCA9IGZhbGx0aHJvdWdoKHBhcnNlcik7XG4gIFx0XHRcdGlmICghcmlnaHQpIHtcbiAgXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdFx0cmV0dXJuIGxlZnQ7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRsZWZ0ID0ge1xuICBcdFx0XHRcdHQ6IElORklYX09QRVJBVE9SLFxuICBcdFx0XHRcdHM6IHN5bWJvbCxcbiAgXHRcdFx0XHRvOiBbbGVmdCwgcmlnaHRdXG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0Ly8gTG9vcCBiYWNrIGFyb3VuZC4gIElmIHdlIGRvbid0IHNlZSBhbm90aGVyIG9jY3VycmVuY2Ugb2YgdGhlIHN5bWJvbCxcbiAgXHRcdFx0Ly8gd2UnbGwgcmV0dXJuIGxlZnQuXG4gIFx0XHR9XG4gIFx0fTtcbiAgfTtcblxuICAvLyBjcmVhdGUgYWxsIGluZml4IHNlcXVlbmNlIG1hdGNoZXJzLCBhbmQgcmV0dXJuIHJlYWRMb2dpY2FsT3JcbiAgKGZ1bmN0aW9uICgpIHtcbiAgXHR2YXIgaSwgbGVuLCBtYXRjaGVyLCBpbmZpeE9wZXJhdG9ycywgZmFsbHRocm91Z2g7XG5cbiAgXHQvLyBBbGwgdGhlIGluZml4IG9wZXJhdG9ycyBvbiBvcmRlciBvZiBwcmVjZWRlbmNlIChzb3VyY2U6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL09wZXJhdG9yX1ByZWNlZGVuY2UpXG4gIFx0Ly8gRWFjaCBzZXF1ZW5jZSBtYXRjaGVyIHdpbGwgaW5pdGlhbGx5IGZhbGwgdGhyb3VnaCB0byBpdHMgaGlnaGVyIHByZWNlZGVuY2VcbiAgXHQvLyBuZWlnaGJvdXIsIGFuZCBvbmx5IGF0dGVtcHQgdG8gbWF0Y2ggaWYgb25lIG9mIHRoZSBoaWdoZXIgcHJlY2VkZW5jZSBvcGVyYXRvcnNcbiAgXHQvLyAob3IsIHVsdGltYXRlbHksIGEgbGl0ZXJhbCwgcmVmZXJlbmNlLCBvciBicmFja2V0ZWQgZXhwcmVzc2lvbikgYWxyZWFkeSBtYXRjaGVkXG4gIFx0aW5maXhPcGVyYXRvcnMgPSBcIiogLyAlICsgLSA8PCA+PiA+Pj4gPCA8PSA+ID49IGluIGluc3RhbmNlb2YgPT0gIT0gPT09ICE9PSAmIF4gfCAmJiB8fFwiLnNwbGl0KFwiIFwiKTtcblxuICBcdC8vIEEgdHlwZW9mIG9wZXJhdG9yIGlzIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gbXVsdGlwbGljYXRpb25cbiAgXHRmYWxsdGhyb3VnaCA9IHJlYWRUeXBlb2Y7XG4gIFx0Zm9yIChpID0gMCwgbGVuID0gaW5maXhPcGVyYXRvcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdG1hdGNoZXIgPSBtYWtlSW5maXhTZXF1ZW5jZU1hdGNoZXIoaW5maXhPcGVyYXRvcnNbaV0sIGZhbGx0aHJvdWdoKTtcbiAgXHRcdGZhbGx0aHJvdWdoID0gbWF0Y2hlcjtcbiAgXHR9XG5cbiAgXHQvLyBMb2dpY2FsIE9SIGlzIHRoZSBmYWxsdGhyb3VnaCBmb3IgdGhlIGNvbmRpdGlvbmFsIG1hdGNoZXJcbiAgXHRyZWFkTG9naWNhbE9yID0gZmFsbHRocm91Z2g7XG4gIH0pKCk7XG5cbiAgdmFyIGV4cHJlc3Npb25zX3JlYWRMb2dpY2FsT3IgPSByZWFkTG9naWNhbE9yO1xuXG4gIC8vIFRoZSBjb25kaXRpb25hbCBvcGVyYXRvciBpcyB0aGUgbG93ZXN0IHByZWNlZGVuY2Ugb3BlcmF0b3IsIHNvIHdlIHN0YXJ0IGhlcmVcbiAgdmFyIHJlYWRDb25kaXRpb25hbCA9IGdldENvbmRpdGlvbmFsO1xuICBmdW5jdGlvbiBnZXRDb25kaXRpb25hbChwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHJlc3Npb24sIGlmVHJ1ZSwgaWZGYWxzZTtcblxuICBcdGV4cHJlc3Npb24gPSBleHByZXNzaW9uc19yZWFkTG9naWNhbE9yKHBhcnNlcik7XG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIj9cIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBleHByZXNzaW9uO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmVHJ1ZSA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRpZiAoIWlmVHJ1ZSkge1xuICBcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkRXhwcmVzc2lvbik7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI6XCIpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBcXFwiOlxcXCJcIik7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWZGYWxzZSA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRpZiAoIWlmRmFsc2UpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihleHBlY3RlZEV4cHJlc3Npb24pO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBDT05ESVRJT05BTCxcbiAgXHRcdG86IFtleHByZXNzaW9uLCBpZlRydWUsIGlmRmFsc2VdXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uID0gcmVhZEV4cHJlc3Npb247XG4gIGZ1bmN0aW9uIHJlYWRFeHByZXNzaW9uKHBhcnNlcikge1xuICBcdC8vIFRoZSBjb25kaXRpb25hbCBvcGVyYXRvciBpcyB0aGUgbG93ZXN0IHByZWNlZGVuY2Ugb3BlcmF0b3IgKGV4Y2VwdCB5aWVsZCxcbiAgXHQvLyBhc3NpZ25tZW50IG9wZXJhdG9ycywgYW5kIGNvbW1hcywgbm9uZSBvZiB3aGljaCBhcmUgc3VwcG9ydGVkKSwgc28gd2VcbiAgXHQvLyBzdGFydCB0aGVyZS4gSWYgaXQgZG9lc24ndCBtYXRjaCwgaXQgJ2ZhbGxzIHRocm91Z2gnIHRvIHByb2dyZXNzaXZlbHlcbiAgXHQvLyBoaWdoZXIgcHJlY2VkZW5jZSBvcGVyYXRvcnMsIHVudGlsIGl0IGV2ZW50dWFsbHkgbWF0Y2hlcyAob3IgZmFpbHMgdG9cbiAgXHQvLyBtYXRjaCkgYSAncHJpbWFyeScgLSBhIGxpdGVyYWwgb3IgYSByZWZlcmVuY2UuIFRoaXMgd2F5LCB0aGUgYWJzdHJhY3Qgc3ludGF4XG4gIFx0Ly8gdHJlZSBoYXMgZXZlcnl0aGluZyBpbiBpdHMgcHJvcGVyIHBsYWNlLCBpLmUuIDIgKyAzICogNCA9PT0gMTQsIG5vdCAyMC5cbiAgXHRyZXR1cm4gcmVhZENvbmRpdGlvbmFsKHBhcnNlcik7XG4gIH1cblxuICB2YXIgdXRpbHNfZmxhdHRlbkV4cHJlc3Npb24gPSBmbGF0dGVuRXhwcmVzc2lvbjtcblxuICBmdW5jdGlvbiBmbGF0dGVuRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gIFx0dmFyIHJlZnM7XG5cbiAgXHRleHRyYWN0UmVmcyhleHByZXNzaW9uLCByZWZzID0gW10pO1xuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHI6IHJlZnMsXG4gIFx0XHRzOiBzdHJpbmdpZnkoZXhwcmVzc2lvbilcbiAgXHR9O1xuXG4gIFx0ZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUpIHtcbiAgXHRcdHN3aXRjaCAobm9kZS50KSB7XG4gIFx0XHRcdGNhc2UgQk9PTEVBTl9MSVRFUkFMOlxuICBcdFx0XHRjYXNlIEdMT0JBTDpcbiAgXHRcdFx0Y2FzZSBOVU1CRVJfTElURVJBTDpcbiAgXHRcdFx0Y2FzZSBSRUdFWFBfTElURVJBTDpcbiAgXHRcdFx0XHRyZXR1cm4gbm9kZS52O1xuXG4gIFx0XHRcdGNhc2UgU1RSSU5HX0xJVEVSQUw6XG4gIFx0XHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KFN0cmluZyhub2RlLnYpKTtcblxuICBcdFx0XHRjYXNlIEFSUkFZX0xJVEVSQUw6XG4gIFx0XHRcdFx0cmV0dXJuIFwiW1wiICsgKG5vZGUubSA/IG5vZGUubS5tYXAoc3RyaW5naWZ5KS5qb2luKFwiLFwiKSA6IFwiXCIpICsgXCJdXCI7XG5cbiAgXHRcdFx0Y2FzZSBPQkpFQ1RfTElURVJBTDpcbiAgXHRcdFx0XHRyZXR1cm4gXCJ7XCIgKyAobm9kZS5tID8gbm9kZS5tLm1hcChzdHJpbmdpZnkpLmpvaW4oXCIsXCIpIDogXCJcIikgKyBcIn1cIjtcblxuICBcdFx0XHRjYXNlIEtFWV9WQUxVRV9QQUlSOlxuICBcdFx0XHRcdHJldHVybiBub2RlLmsgKyBcIjpcIiArIHN0cmluZ2lmeShub2RlLnYpO1xuXG4gIFx0XHRcdGNhc2UgUFJFRklYX09QRVJBVE9SOlxuICBcdFx0XHRcdHJldHVybiAobm9kZS5zID09PSBcInR5cGVvZlwiID8gXCJ0eXBlb2YgXCIgOiBub2RlLnMpICsgc3RyaW5naWZ5KG5vZGUubyk7XG5cbiAgXHRcdFx0Y2FzZSBJTkZJWF9PUEVSQVRPUjpcbiAgXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KG5vZGUub1swXSkgKyAobm9kZS5zLnN1YnN0cigwLCAyKSA9PT0gXCJpblwiID8gXCIgXCIgKyBub2RlLnMgKyBcIiBcIiA6IG5vZGUucykgKyBzdHJpbmdpZnkobm9kZS5vWzFdKTtcblxuICBcdFx0XHRjYXNlIElOVk9DQVRJT046XG4gIFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeShub2RlLngpICsgXCIoXCIgKyAobm9kZS5vID8gbm9kZS5vLm1hcChzdHJpbmdpZnkpLmpvaW4oXCIsXCIpIDogXCJcIikgKyBcIilcIjtcblxuICBcdFx0XHRjYXNlIEJSQUNLRVRFRDpcbiAgXHRcdFx0XHRyZXR1cm4gXCIoXCIgKyBzdHJpbmdpZnkobm9kZS54KSArIFwiKVwiO1xuXG4gIFx0XHRcdGNhc2UgTUVNQkVSOlxuICBcdFx0XHRcdHJldHVybiBzdHJpbmdpZnkobm9kZS54KSArIHN0cmluZ2lmeShub2RlLnIpO1xuXG4gIFx0XHRcdGNhc2UgUkVGSU5FTUVOVDpcbiAgXHRcdFx0XHRyZXR1cm4gbm9kZS5uID8gXCIuXCIgKyBub2RlLm4gOiBcIltcIiArIHN0cmluZ2lmeShub2RlLngpICsgXCJdXCI7XG5cbiAgXHRcdFx0Y2FzZSBDT05ESVRJT05BTDpcbiAgXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KG5vZGUub1swXSkgKyBcIj9cIiArIHN0cmluZ2lmeShub2RlLm9bMV0pICsgXCI6XCIgKyBzdHJpbmdpZnkobm9kZS5vWzJdKTtcblxuICBcdFx0XHRjYXNlIFJFRkVSRU5DRTpcbiAgXHRcdFx0XHRyZXR1cm4gXCJfXCIgKyByZWZzLmluZGV4T2Yobm9kZS5uKTtcblxuICBcdFx0XHRkZWZhdWx0OlxuICBcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGxlZ2FsIEphdmFTY3JpcHRcIik7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgLy8gVE9ETyBtYXliZSByZWZhY3RvciB0aGlzP1xuICBmdW5jdGlvbiBleHRyYWN0UmVmcyhub2RlLCByZWZzKSB7XG4gIFx0dmFyIGksIGxpc3Q7XG5cbiAgXHRpZiAobm9kZS50ID09PSBSRUZFUkVOQ0UpIHtcbiAgXHRcdGlmIChyZWZzLmluZGV4T2Yobm9kZS5uKSA9PT0gLTEpIHtcbiAgXHRcdFx0cmVmcy51bnNoaWZ0KG5vZGUubik7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0bGlzdCA9IG5vZGUubyB8fCBub2RlLm07XG4gIFx0aWYgKGxpc3QpIHtcbiAgXHRcdGlmIChpc09iamVjdChsaXN0KSkge1xuICBcdFx0XHRleHRyYWN0UmVmcyhsaXN0LCByZWZzKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdGV4dHJhY3RSZWZzKGxpc3RbaV0sIHJlZnMpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKG5vZGUueCkge1xuICBcdFx0ZXh0cmFjdFJlZnMobm9kZS54LCByZWZzKTtcbiAgXHR9XG5cbiAgXHRpZiAobm9kZS5yKSB7XG4gIFx0XHRleHRyYWN0UmVmcyhub2RlLnIsIHJlZnMpO1xuICBcdH1cblxuICBcdGlmIChub2RlLnYpIHtcbiAgXHRcdGV4dHJhY3RSZWZzKG5vZGUudiwgcmVmcyk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHV0aWxzX3JlZmluZUV4cHJlc3Npb24gPSByZWZpbmVFeHByZXNzaW9uO1xuXG4gIHZhciBhcnJheU1lbWJlclBhdHRlcm4gPSAvXlswLTldWzEtOV0qJC87XG4gIGZ1bmN0aW9uIHJlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgbXVzdGFjaGUpIHtcbiAgXHR2YXIgcmVmZXJlbmNlRXhwcmVzc2lvbjtcblxuICBcdGlmIChleHByZXNzaW9uKSB7XG4gIFx0XHR3aGlsZSAoZXhwcmVzc2lvbi50ID09PSBCUkFDS0VURUQgJiYgZXhwcmVzc2lvbi54KSB7XG4gIFx0XHRcdGV4cHJlc3Npb24gPSBleHByZXNzaW9uLng7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIGludGVnZXJzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGFycmF5IG1lbWJlcnMgcmVmZXJlbmNlcyxcbiAgXHRcdC8vIHJhdGhlciB0aGFuIGFzIGV4cHJlc3Npb25zIGluIHRoZWlyIG93biByaWdodFxuICBcdFx0aWYgKGV4cHJlc3Npb24udCA9PT0gUkVGRVJFTkNFKSB7XG4gIFx0XHRcdG11c3RhY2hlLnIgPSBleHByZXNzaW9uLm47XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRpZiAoZXhwcmVzc2lvbi50ID09PSBOVU1CRVJfTElURVJBTCAmJiBhcnJheU1lbWJlclBhdHRlcm4udGVzdChleHByZXNzaW9uLnYpKSB7XG4gIFx0XHRcdFx0bXVzdGFjaGUuciA9IGV4cHJlc3Npb24udjtcbiAgXHRcdFx0fSBlbHNlIGlmIChyZWZlcmVuY2VFeHByZXNzaW9uID0gZ2V0UmVmZXJlbmNlRXhwcmVzc2lvbihleHByZXNzaW9uKSkge1xuICBcdFx0XHRcdG11c3RhY2hlLnJ4ID0gcmVmZXJlbmNlRXhwcmVzc2lvbjtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRtdXN0YWNoZS54ID0gdXRpbHNfZmxhdHRlbkV4cHJlc3Npb24oZXhwcmVzc2lvbik7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG11c3RhY2hlO1xuICBcdH1cbiAgfVxuXG4gIC8vIFRPRE8gcmVmYWN0b3IgdGhpcyEgaXQncyBiZXdpbGRlcmluZ1xuICBmdW5jdGlvbiBnZXRSZWZlcmVuY2VFeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgXHR2YXIgbWVtYmVycyA9IFtdLFxuICBcdCAgICByZWZpbmVtZW50O1xuXG4gIFx0d2hpbGUgKGV4cHJlc3Npb24udCA9PT0gTUVNQkVSICYmIGV4cHJlc3Npb24uci50ID09PSBSRUZJTkVNRU5UKSB7XG4gIFx0XHRyZWZpbmVtZW50ID0gZXhwcmVzc2lvbi5yO1xuXG4gIFx0XHRpZiAocmVmaW5lbWVudC54KSB7XG4gIFx0XHRcdGlmIChyZWZpbmVtZW50LngudCA9PT0gUkVGRVJFTkNFKSB7XG4gIFx0XHRcdFx0bWVtYmVycy51bnNoaWZ0KHJlZmluZW1lbnQueCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0bWVtYmVycy51bnNoaWZ0KHV0aWxzX2ZsYXR0ZW5FeHByZXNzaW9uKHJlZmluZW1lbnQueCkpO1xuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRtZW1iZXJzLnVuc2hpZnQocmVmaW5lbWVudC5uKTtcbiAgXHRcdH1cblxuICBcdFx0ZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ueDtcbiAgXHR9XG5cbiAgXHRpZiAoZXhwcmVzc2lvbi50ICE9PSBSRUZFUkVOQ0UpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHRyOiBleHByZXNzaW9uLm4sXG4gIFx0XHRtOiBtZW1iZXJzXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBtdXN0YWNoZV9yZWFkVHJpcGxlID0gcmVhZFRyaXBsZTtcbiAgZnVuY3Rpb24gcmVhZFRyaXBsZShwYXJzZXIsIHRhZykge1xuICBcdHZhciBleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpLFxuICBcdCAgICB0cmlwbGU7XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHR9XG5cbiAgXHR0cmlwbGUgPSB7IHQ6IFRSSVBMRSB9O1xuICBcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgdHJpcGxlKTsgLy8gVE9ETyBoYW5kbGUgdGhpcyBkaWZmZXJlbnRseSAtIGl0J3MgbXlzdGVyaW91c1xuXG4gIFx0cmV0dXJuIHRyaXBsZTtcbiAgfVxuXG4gIHZhciBtdXN0YWNoZV9yZWFkVW5lc2NhcGVkID0gcmVhZFVuZXNjYXBlZDtcbiAgZnVuY3Rpb24gcmVhZFVuZXNjYXBlZChwYXJzZXIsIHRhZykge1xuICBcdHZhciBleHByZXNzaW9uLCB0cmlwbGU7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIiZcIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHR9XG5cbiAgXHR0cmlwbGUgPSB7IHQ6IFRSSVBMRSB9O1xuICBcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgdHJpcGxlKTsgLy8gVE9ETyBoYW5kbGUgdGhpcyBkaWZmZXJlbnRseSAtIGl0J3MgbXlzdGVyaW91c1xuXG4gIFx0cmV0dXJuIHRyaXBsZTtcbiAgfVxuXG4gIHZhciBtdXN0YWNoZV9yZWFkUGFydGlhbCA9IHJlYWRQYXJ0aWFsO1xuICBmdW5jdGlvbiByZWFkUGFydGlhbChwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCwgbmFtZVN0YXJ0LCBleHByZXNzaW9uLCBjb250ZXh0LCBwYXJ0aWFsO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI+XCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gIFx0bmFtZVN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIFBhcnRpYWwgbmFtZXMgY2FuIGluY2x1ZGUgaHlwaGVucywgc28gd2UgY2FuJ3QgdXNlIHJlYWRFeHByZXNzaW9uXG4gIFx0Ly8gYmxpbmRseS4gSW5zdGVhZCwgd2UgdXNlIHRoZSBgcmVsYXhlZE5hbWVzYCBmbGFnIHRvIGluZGljYXRlIHRoYXRcbiAgXHQvLyBgZm9vLWJhcmAgc2hvdWxkIGJlIHJlYWQgYXMgYSBzaW5nbGUgbmFtZSwgcmF0aGVyIHRoYW4gJ3N1YnRyYWN0XG4gIFx0Ly8gYmFyIGZyb20gZm9vJ1xuICBcdHBhcnNlci5yZWxheGVkTmFtZXMgPSB0cnVlO1xuICBcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0cGFyc2VyLnJlbGF4ZWROYW1lcyA9IGZhbHNlO1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdGNvbnRleHQgPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJ0aWFsID0geyB0OiBQQVJUSUFMIH07XG4gIFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihleHByZXNzaW9uLCBwYXJ0aWFsKTsgLy8gVE9ETy4uLlxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gaWYgd2UgaGF2ZSBhbm90aGVyIGV4cHJlc3Npb24gLSBlLmcuIGB7ez5mb28gYmFyfX1gIC0gdGhlblxuICBcdC8vIHdlIHR1cm4gaXQgaW50byBge3sjd2l0aCBiYXJ9fXt7PmZvb319e3svd2l0aH19YFxuICBcdGlmIChjb250ZXh0KSB7XG4gIFx0XHRwYXJ0aWFsID0ge1xuICBcdFx0XHR0OiBTRUNUSU9OLFxuICBcdFx0XHRuOiBTRUNUSU9OX1dJVEgsXG4gIFx0XHRcdGY6IFtwYXJ0aWFsXVxuICBcdFx0fTtcblxuICBcdFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihjb250ZXh0LCBwYXJ0aWFsKTtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyB0YWcuY2xvc2UgKyBcIidcIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHBhcnRpYWw7XG4gIH1cblxuICB2YXIgcmVhZE11c3RhY2hlQ29tbWVudCA9IHJlYWRDb21tZW50O1xuICBmdW5jdGlvbiByZWFkQ29tbWVudChwYXJzZXIsIHRhZykge1xuICBcdHZhciBpbmRleDtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiIVwiKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aW5kZXggPSBwYXJzZXIucmVtYWluaW5nKCkuaW5kZXhPZih0YWcuY2xvc2UpO1xuXG4gIFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0cGFyc2VyLnBvcyArPSBpbmRleCArIHRhZy5jbG9zZS5sZW5ndGg7XG4gIFx0XHRyZXR1cm4geyB0OiBDT01NRU5UIH07XG4gIFx0fVxuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb25PclJlZmVyZW5jZSA9IHJlYWRFeHByZXNzaW9uT3JSZWZlcmVuY2U7XG4gIGZ1bmN0aW9uIHJlYWRFeHByZXNzaW9uT3JSZWZlcmVuY2UocGFyc2VyLCBleHBlY3RlZEZvbGxvd2Vycykge1xuICBcdHZhciBzdGFydCwgZXhwcmVzc2lvbiwgaTtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcbiAgXHRleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuXG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRmb3IgKGkgPSAwOyBpIDwgZXhwZWN0ZWRGb2xsb3dlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdGlmIChwYXJzZXIucmVtYWluaW5nKCkuc3Vic3RyKDAsIGV4cGVjdGVkRm9sbG93ZXJzW2ldLmxlbmd0aCkgPT09IGV4cGVjdGVkRm9sbG93ZXJzW2ldKSB7XG4gIFx0XHRcdHJldHVybiBleHByZXNzaW9uO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRyZXR1cm4gcHJpbWFyeV9yZWFkUmVmZXJlbmNlKHBhcnNlcik7XG4gIH1cblxuICB2YXIgbXVzdGFjaGVfcmVhZEludGVycG9sYXRvciA9IHJlYWRJbnRlcnBvbGF0b3I7XG4gIGZ1bmN0aW9uIHJlYWRJbnRlcnBvbGF0b3IocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHJlc3Npb24sIGludGVycG9sYXRvciwgZXJyO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gVE9ETyB3b3VsZCBiZSBnb29kIGZvciBwZXJmIGlmIHdlIGNvdWxkIGRvIGF3YXkgd2l0aCB0aGUgdHJ5LWNhdGNoXG4gIFx0dHJ5IHtcbiAgXHRcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uT3JSZWZlcmVuY2UocGFyc2VyLCBbdGFnLmNsb3NlXSk7XG4gIFx0fSBjYXRjaCAoZSkge1xuICBcdFx0ZXJyID0gZTtcbiAgXHR9XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdGlmIChwYXJzZXIuc3RyLmNoYXJBdChzdGFydCkgPT09IFwiIVwiKSB7XG4gIFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIGNvbW1lbnRcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGVycikge1xuICBcdFx0XHR0aHJvdyBlcnI7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgdGFnLmNsb3NlICsgXCInIGFmdGVyIHJlZmVyZW5jZVwiKTtcblxuICBcdFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIGNvbW1lbnRcbiAgXHRcdFx0aWYgKHBhcnNlci5uZXh0Q2hhcigpID09PSBcIiFcIikge1xuICBcdFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgZXhwcmVzc2lvbiBvciBsZWdhbCByZWZlcmVuY2VcIik7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aW50ZXJwb2xhdG9yID0geyB0OiBJTlRFUlBPTEFUT1IgfTtcbiAgXHR1dGlsc19yZWZpbmVFeHByZXNzaW9uKGV4cHJlc3Npb24sIGludGVycG9sYXRvcik7IC8vIFRPRE8gaGFuZGxlIHRoaXMgZGlmZmVyZW50bHkgLSBpdCdzIG15c3RlcmlvdXNcblxuICBcdHJldHVybiBpbnRlcnBvbGF0b3I7XG4gIH1cblxuICB2YXIgbXVzdGFjaGVfcmVhZFlpZWxkZXIgPSByZWFkWWllbGRlcjtcbiAgdmFyIHlpZWxkUGF0dGVybiA9IC9eeWllbGRcXHMqLztcbiAgZnVuY3Rpb24gcmVhZFlpZWxkZXIocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQsIG5hbWUsIHlpZWxkZXI7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFBhdHRlcm4oeWllbGRQYXR0ZXJuKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuICBcdG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOVxcLV0qLyk7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJleHBlY3RlZCBsZWdhbCBwYXJ0aWFsIG5hbWVcIik7XG4gIFx0fVxuXG4gIFx0eWllbGRlciA9IHsgdDogWUlFTERFUiB9O1xuXG4gIFx0aWYgKG5hbWUpIHtcbiAgXHRcdHlpZWxkZXIubiA9IG5hbWU7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHlpZWxkZXI7XG4gIH1cblxuICB2YXIgc2VjdGlvbl9yZWFkQ2xvc2luZyA9IHJlYWRDbG9zaW5nO1xuICBmdW5jdGlvbiByZWFkQ2xvc2luZyhwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCwgcmVtYWluaW5nLCBpbmRleCwgY2xvc2luZztcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5vcGVuKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCIvXCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG4gIFx0aW5kZXggPSByZW1haW5pbmcuaW5kZXhPZih0YWcuY2xvc2UpO1xuXG4gIFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0Y2xvc2luZyA9IHtcbiAgXHRcdFx0dDogQ0xPU0lORyxcbiAgXHRcdFx0cjogcmVtYWluaW5nLnN1YnN0cigwLCBpbmRleCkuc3BsaXQoXCIgXCIpWzBdXG4gIFx0XHR9O1xuXG4gIFx0XHRwYXJzZXIucG9zICs9IGluZGV4O1xuXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGNsb3Npbmc7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHNlY3Rpb25fcmVhZEVsc2UgPSBzZWN0aW9uX3JlYWRFbHNlX19yZWFkRWxzZTtcbiAgdmFyIHNlY3Rpb25fcmVhZEVsc2VfX2Vsc2VQYXR0ZXJuID0gL15cXHMqZWxzZVxccyovO1xuICBmdW5jdGlvbiBzZWN0aW9uX3JlYWRFbHNlX19yZWFkRWxzZShwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcub3BlbikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoUGF0dGVybihzZWN0aW9uX3JlYWRFbHNlX19lbHNlUGF0dGVybikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogRUxTRVxuICBcdH07XG4gIH1cblxuICB2YXIgcmVhZEVsc2VJZiA9IHJlYWRFbHNlSWZfX3JlYWRFbHNlO1xuICB2YXIgcmVhZEVsc2VJZl9fZWxzZVBhdHRlcm4gPSAvXlxccyplbHNlaWZcXHMrLztcbiAgZnVuY3Rpb24gcmVhZEVsc2VJZl9fcmVhZEVsc2UocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQgPSBwYXJzZXIucG9zLFxuICBcdCAgICBleHByZXNzaW9uO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLm9wZW4pKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFBhdHRlcm4ocmVhZEVsc2VJZl9fZWxzZVBhdHRlcm4pKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgdGFnLmNsb3NlICsgXCInXCIpO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBFTFNFSUYsXG4gIFx0XHR4OiBleHByZXNzaW9uXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBoYW5kbGViYXJzQmxvY2tDb2RlcyA9IHtcbiAgXHRlYWNoOiBTRUNUSU9OX0VBQ0gsXG4gIFx0XCJpZlwiOiBTRUNUSU9OX0lGLFxuICBcdFwiaWYtd2l0aFwiOiBTRUNUSU9OX0lGX1dJVEgsXG4gIFx0XCJ3aXRoXCI6IFNFQ1RJT05fV0lUSCxcbiAgXHR1bmxlc3M6IFNFQ1RJT05fVU5MRVNTXG4gIH07XG5cbiAgdmFyIG11c3RhY2hlX3JlYWRTZWN0aW9uID0gcmVhZFNlY3Rpb247XG5cbiAgdmFyIGluZGV4UmVmUGF0dGVybiA9IC9eXFxzKjpcXHMqKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKikvLFxuICAgICAga2V5SW5kZXhSZWZQYXR0ZXJuID0gL15cXHMqLFxccyooW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKS8sXG4gICAgICBoYW5kbGViYXJzQmxvY2tQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl4oXCIgKyBPYmplY3Qua2V5cyhoYW5kbGViYXJzQmxvY2tDb2Rlcykuam9pbihcInxcIikgKyBcIilcXFxcYlwiKTtcbiAgZnVuY3Rpb24gcmVhZFNlY3Rpb24ocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHJlc3Npb24sIHNlY3Rpb24sIGNoaWxkLCBjaGlsZHJlbiwgaGFzRWxzZSwgYmxvY2ssIHVubGVzc0Jsb2NrLCBjb25kaXRpb25zLCBjbG9zZWQsIGksIGV4cGVjdGVkQ2xvc2U7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiXlwiKSkge1xuICBcdFx0c2VjdGlvbiA9IHsgdDogU0VDVElPTiwgZjogW10sIG46IFNFQ1RJT05fVU5MRVNTIH07XG4gIFx0fSBlbHNlIGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIjXCIpKSB7XG4gIFx0XHRzZWN0aW9uID0geyB0OiBTRUNUSU9OLCBmOiBbXSB9O1xuXG4gIFx0XHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwicGFydGlhbFwiKSkge1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQgLSBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzBdLmxlbmd0aDtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiUGFydGlhbCBkZWZpbml0aW9ucyBjYW4gb25seSBiZSBhdCB0aGUgdG9wIGxldmVsIG9mIHRoZSB0ZW1wbGF0ZSwgb3IgaW1tZWRpYXRlbHkgaW5zaWRlIGNvbXBvbmVudHNcIik7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChibG9jayA9IHBhcnNlci5tYXRjaFBhdHRlcm4oaGFuZGxlYmFyc0Jsb2NrUGF0dGVybikpIHtcbiAgXHRcdFx0ZXhwZWN0ZWRDbG9zZSA9IGJsb2NrO1xuICBcdFx0XHRzZWN0aW9uLm4gPSBoYW5kbGViYXJzQmxvY2tDb2Rlc1tibG9ja107XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGV4cHJlc3Npb25cIik7XG4gIFx0fVxuXG4gIFx0Ly8gb3B0aW9uYWwgaW5kZXggYW5kIGtleSByZWZlcmVuY2VzXG4gIFx0aWYgKGkgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGluZGV4UmVmUGF0dGVybikpIHtcbiAgXHRcdHZhciBleHRyYSA9IHVuZGVmaW5lZDtcblxuICBcdFx0aWYgKGV4dHJhID0gcGFyc2VyLm1hdGNoUGF0dGVybihrZXlJbmRleFJlZlBhdHRlcm4pKSB7XG4gIFx0XHRcdHNlY3Rpb24uaSA9IGkgKyBcIixcIiArIGV4dHJhO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0c2VjdGlvbi5pID0gaTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyB0YWcuY2xvc2UgKyBcIidcIik7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLnNlY3Rpb25EZXB0aCArPSAxO1xuICBcdGNoaWxkcmVuID0gc2VjdGlvbi5mO1xuXG4gIFx0Y29uZGl0aW9ucyA9IFtdO1xuXG4gIFx0ZG8ge1xuICBcdFx0aWYgKGNoaWxkID0gc2VjdGlvbl9yZWFkQ2xvc2luZyhwYXJzZXIsIHRhZykpIHtcbiAgXHRcdFx0aWYgKGV4cGVjdGVkQ2xvc2UgJiYgY2hpbGQuciAhPT0gZXhwZWN0ZWRDbG9zZSkge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIFwiICsgdGFnLm9wZW4gKyBcIi9cIiArIGV4cGVjdGVkQ2xvc2UgKyBcIlwiICsgdGFnLmNsb3NlKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHBhcnNlci5zZWN0aW9uRGVwdGggLT0gMTtcbiAgXHRcdFx0Y2xvc2VkID0gdHJ1ZTtcbiAgXHRcdH0gZWxzZSBpZiAoY2hpbGQgPSByZWFkRWxzZUlmKHBhcnNlciwgdGFnKSkge1xuICBcdFx0XHRpZiAoc2VjdGlvbi5uID09PSBTRUNUSU9OX1VOTEVTUykge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcInt7ZWxzZX19IG5vdCBhbGxvd2VkIGluIHt7I3VubGVzc319XCIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGhhc0Vsc2UpIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJpbGxlZ2FsIHt7ZWxzZWlmLi4ufX0gYWZ0ZXIge3tlbHNlfX1cIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIXVubGVzc0Jsb2NrKSB7XG4gIFx0XHRcdFx0dW5sZXNzQmxvY2sgPSBjcmVhdGVVbmxlc3NCbG9jayhleHByZXNzaW9uLCBzZWN0aW9uLm4pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dW5sZXNzQmxvY2suZi5wdXNoKHtcbiAgXHRcdFx0XHR0OiBTRUNUSU9OLFxuICBcdFx0XHRcdG46IFNFQ1RJT05fSUYsXG4gIFx0XHRcdFx0eDogdXRpbHNfZmxhdHRlbkV4cHJlc3Npb24obXVzdGFjaGVfcmVhZFNlY3Rpb25fX2NvbWJpbmUoY29uZGl0aW9ucy5jb25jYXQoY2hpbGQueCkpKSxcbiAgXHRcdFx0XHRmOiBjaGlsZHJlbiA9IFtdXG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdGNvbmRpdGlvbnMucHVzaChpbnZlcnQoY2hpbGQueCkpO1xuICBcdFx0fSBlbHNlIGlmIChjaGlsZCA9IHNlY3Rpb25fcmVhZEVsc2UocGFyc2VyLCB0YWcpKSB7XG4gIFx0XHRcdGlmIChzZWN0aW9uLm4gPT09IFNFQ1RJT05fVU5MRVNTKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwie3tlbHNlfX0gbm90IGFsbG93ZWQgaW4ge3sjdW5sZXNzfX1cIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoaGFzRWxzZSkge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcInRoZXJlIGNhbiBvbmx5IGJlIG9uZSB7e2Vsc2V9fSBibG9jaywgYXQgdGhlIGVuZCBvZiBhIHNlY3Rpb25cIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRoYXNFbHNlID0gdHJ1ZTtcblxuICBcdFx0XHQvLyB1c2UgYW4gdW5sZXNzIGJsb2NrIGlmIHRoZXJlJ3Mgbm8gZWxzZWlmXG4gIFx0XHRcdGlmICghdW5sZXNzQmxvY2spIHtcbiAgXHRcdFx0XHR1bmxlc3NCbG9jayA9IGNyZWF0ZVVubGVzc0Jsb2NrKGV4cHJlc3Npb24sIHNlY3Rpb24ubik7XG4gIFx0XHRcdFx0Y2hpbGRyZW4gPSB1bmxlc3NCbG9jay5mO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHVubGVzc0Jsb2NrLmYucHVzaCh7XG4gIFx0XHRcdFx0XHR0OiBTRUNUSU9OLFxuICBcdFx0XHRcdFx0bjogU0VDVElPTl9JRixcbiAgXHRcdFx0XHRcdHg6IHV0aWxzX2ZsYXR0ZW5FeHByZXNzaW9uKG11c3RhY2hlX3JlYWRTZWN0aW9uX19jb21iaW5lKGNvbmRpdGlvbnMpKSxcbiAgXHRcdFx0XHRcdGY6IGNoaWxkcmVuID0gW11cbiAgXHRcdFx0XHR9KTtcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Y2hpbGQgPSBwYXJzZXIucmVhZChSRUFERVJTKTtcblxuICBcdFx0XHRpZiAoIWNoaWxkKSB7XG4gIFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgXHRcdH1cbiAgXHR9IHdoaWxlICghY2xvc2VkKTtcblxuICBcdGlmICh1bmxlc3NCbG9jaykge1xuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gYHdpdGhgIHNob3VsZCBiZWNvbWUgYGlmLXdpdGhgIChUT0RPIGlzIHRoaXMgcmlnaHQ/XG4gIFx0XHQvLyBzZWVtcyB0byBtZSB0aGF0IGB3aXRoYCBvdWdodCB0byBiZWhhdmUgY29uc2lzdGVudGx5LCByZWdhcmRsZXNzXG4gIFx0XHQvLyBvZiB0aGUgcHJlc2VuY2UvYWJzZW5jZSBvZiBgZWxzZWAuIEluIG90aGVyIHdvcmRzIHNob3VsZCBhbHdheXNcbiAgXHRcdC8vIGJlIGBpZi13aXRoYFxuICBcdFx0aWYgKHNlY3Rpb24ubiA9PT0gU0VDVElPTl9XSVRIKSB7XG4gIFx0XHRcdHNlY3Rpb24ubiA9IFNFQ1RJT05fSUZfV0lUSDtcbiAgXHRcdH1cblxuICBcdFx0c2VjdGlvbi5sID0gdW5sZXNzQmxvY2s7XG4gIFx0fVxuXG4gIFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihleHByZXNzaW9uLCBzZWN0aW9uKTtcblxuICBcdC8vIFRPRE8gaWYgYSBzZWN0aW9uIGlzIGVtcHR5IGl0IHNob3VsZCBiZSBkaXNjYXJkZWQuIERvbid0IGRvXG4gIFx0Ly8gdGhhdCBoZXJlIHRob3VnaCAtIHdlIG5lZWQgdG8gY2xlYW4gZXZlcnl0aGluZyB1cCBmaXJzdCwgYXNcbiAgXHQvLyBpdCBtYXkgY29udGFpbiByZW1vdmVhYmxlIHdoaXRlc3BhY2UuIEFzIGEgdGVtcG9yYXJ5IG1lYXN1cmUsXG4gIFx0Ly8gdG8gcGFzcyB0aGUgZXhpc3RpbmcgdGVzdHMsIHJlbW92ZSBlbXB0eSBgZmAgYXJyYXlzXG4gIFx0aWYgKCFzZWN0aW9uLmYubGVuZ3RoKSB7XG4gIFx0XHRkZWxldGUgc2VjdGlvbi5mO1xuICBcdH1cblxuICBcdHJldHVybiBzZWN0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5sZXNzQmxvY2soZXhwcmVzc2lvbiwgc2VjdGlvblR5cGUpIHtcbiAgXHR2YXIgdW5sZXNzQmxvY2s7XG5cbiAgXHRpZiAoc2VjdGlvblR5cGUgPT09IFNFQ1RJT05fV0lUSCkge1xuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gYSBge3sjd2l0aCBmb299fWAgc2VjdGlvbiB3aWxsIHJlbmRlciBpZiBgZm9vYCBpc1xuICBcdFx0Ly8gdHJ1dGh5LCBzbyB0aGUgYHt7ZWxzZX19YCBzZWN0aW9uIG5lZWRzIHRvIHJlbmRlciBpZiBgZm9vYCBpcyBmYWxzeSxcbiAgXHRcdC8vIHJhdGhlciB0aGFuIGFkaGVyaW5nIHRvIHRoZSBub3JtYWwgYHt7I3VubGVzcyBmb299fWAgbG9naWMgKHdoaWNoXG4gIFx0XHQvLyB0cmVhdHMgZW1wdHkgYXJyYXlzL29iamVjdHMgYXMgZmFsc3kpXG4gIFx0XHR1bmxlc3NCbG9jayA9IHtcbiAgXHRcdFx0dDogU0VDVElPTixcbiAgXHRcdFx0bjogU0VDVElPTl9JRixcbiAgXHRcdFx0ZjogW11cbiAgXHRcdH07XG5cbiAgXHRcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oaW52ZXJ0KGV4cHJlc3Npb24pLCB1bmxlc3NCbG9jayk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHVubGVzc0Jsb2NrID0ge1xuICBcdFx0XHR0OiBTRUNUSU9OLFxuICBcdFx0XHRuOiBTRUNUSU9OX1VOTEVTUyxcbiAgXHRcdFx0ZjogW11cbiAgXHRcdH07XG5cbiAgXHRcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgdW5sZXNzQmxvY2spO1xuICBcdH1cblxuICBcdHJldHVybiB1bmxlc3NCbG9jaztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmVydChleHByZXNzaW9uKSB7XG4gIFx0aWYgKGV4cHJlc3Npb24udCA9PT0gUFJFRklYX09QRVJBVE9SICYmIGV4cHJlc3Npb24ucyA9PT0gXCIhXCIpIHtcbiAgXHRcdHJldHVybiBleHByZXNzaW9uLm87XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IFBSRUZJWF9PUEVSQVRPUixcbiAgXHRcdHM6IFwiIVwiLFxuICBcdFx0bzogcGFyZW5zSWZOZWNlc3NhcnkoZXhwcmVzc2lvbilcbiAgXHR9O1xuICB9XG5cbiAgZnVuY3Rpb24gbXVzdGFjaGVfcmVhZFNlY3Rpb25fX2NvbWJpbmUoZXhwcmVzc2lvbnMpIHtcbiAgXHRpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID09PSAxKSB7XG4gIFx0XHRyZXR1cm4gZXhwcmVzc2lvbnNbMF07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IElORklYX09QRVJBVE9SLFxuICBcdFx0czogXCImJlwiLFxuICBcdFx0bzogW3BhcmVuc0lmTmVjZXNzYXJ5KGV4cHJlc3Npb25zWzBdKSwgcGFyZW5zSWZOZWNlc3NhcnkobXVzdGFjaGVfcmVhZFNlY3Rpb25fX2NvbWJpbmUoZXhwcmVzc2lvbnMuc2xpY2UoMSkpKV1cbiAgXHR9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyZW5zSWZOZWNlc3NhcnkoZXhwcmVzc2lvbikge1xuICBcdC8vIFRPRE8gb25seSB3cmFwIGlmIG5lY2Vzc2FyeVxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBCUkFDS0VURUQsXG4gIFx0XHR4OiBleHByZXNzaW9uXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBjb252ZXJ0ZXJzX3JlYWRIdG1sQ29tbWVudCA9IHJlYWRIdG1sQ29tbWVudDtcbiAgdmFyIE9QRU5fQ09NTUVOVCA9IFwiPCEtLVwiLFxuICAgICAgQ0xPU0VfQ09NTUVOVCA9IFwiLS0+XCI7XG4gIGZ1bmN0aW9uIHJlYWRIdG1sQ29tbWVudChwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGNvbnRlbnQsIHJlbWFpbmluZywgZW5kSW5kZXgsIGNvbW1lbnQ7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhPUEVOX0NPTU1FTlQpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG4gIFx0ZW5kSW5kZXggPSByZW1haW5pbmcuaW5kZXhPZihDTE9TRV9DT01NRU5UKTtcblxuICBcdGlmIChlbmRJbmRleCA9PT0gLTEpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIklsbGVnYWwgSFRNTCAtIGV4cGVjdGVkIGNsb3NpbmcgY29tbWVudCBzZXF1ZW5jZSAoJy0tPicpXCIpO1xuICBcdH1cblxuICBcdGNvbnRlbnQgPSByZW1haW5pbmcuc3Vic3RyKDAsIGVuZEluZGV4KTtcbiAgXHRwYXJzZXIucG9zICs9IGVuZEluZGV4ICsgMztcblxuICBcdGNvbW1lbnQgPSB7XG4gIFx0XHR0OiBDT01NRU5ULFxuICBcdFx0YzogY29udGVudFxuICBcdH07XG5cbiAgXHRpZiAocGFyc2VyLmluY2x1ZGVMaW5lUG9zaXRpb25zKSB7XG4gIFx0XHRjb21tZW50LnAgPSBwYXJzZXIuZ2V0TGluZVBvcyhzdGFydCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGNvbW1lbnQ7XG4gIH1cblxuICB2YXIgYm9vbGVhbkF0dHJpYnV0ZXMsIHZvaWRFbGVtZW50TmFtZXMsIGh0bWxFbnRpdGllcywgY29udHJvbENoYXJhY3RlcnMsIGVudGl0eVBhdHRlcm4sIGxlc3NUaGFuLCBncmVhdGVyVGhhbiwgYW1wO1xuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5nYXgvaHRtbC1taW5pZmllci9pc3N1ZXMvNjMjaXNzdWVjb21tZW50LTM3NzYzMzE2XG4gIGJvb2xlYW5BdHRyaWJ1dGVzID0gL14oYWxsb3dGdWxsc2NyZWVufGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjaGVja2VkfGNvbXBhY3R8Y29udHJvbHN8ZGVjbGFyZXxkZWZhdWx0fGRlZmF1bHRDaGVja2VkfGRlZmF1bHRNdXRlZHxkZWZhdWx0U2VsZWN0ZWR8ZGVmZXJ8ZGlzYWJsZWR8ZW5hYmxlZHxmb3JtTm9WYWxpZGF0ZXxoaWRkZW58aW5kZXRlcm1pbmF0ZXxpbmVydHxpc01hcHxpdGVtU2NvcGV8bG9vcHxtdWx0aXBsZXxtdXRlZHxub0hyZWZ8bm9SZXNpemV8bm9TaGFkZXxub1ZhbGlkYXRlfG5vV3JhcHxvcGVufHBhdXNlT25FeGl0fHJlYWRPbmx5fHJlcXVpcmVkfHJldmVyc2VkfHNjb3BlZHxzZWFtbGVzc3xzZWxlY3RlZHxzb3J0YWJsZXx0cmFuc2xhdGV8dHJ1ZVNwZWVkfHR5cGVNdXN0TWF0Y2h8dmlzaWJsZSkkL2k7XG4gIHZvaWRFbGVtZW50TmFtZXMgPSAvXig/OmFyZWF8YmFzZXxicnxjb2x8Y29tbWFuZHxkb2N0eXBlfGVtYmVkfGhyfGltZ3xpbnB1dHxrZXlnZW58bGlua3xtZXRhfHBhcmFtfHNvdXJjZXx0cmFja3x3YnIpJC9pO1xuXG4gIGh0bWxFbnRpdGllcyA9IHsgcXVvdDogMzQsIGFtcDogMzgsIGFwb3M6IDM5LCBsdDogNjAsIGd0OiA2MiwgbmJzcDogMTYwLCBpZXhjbDogMTYxLCBjZW50OiAxNjIsIHBvdW5kOiAxNjMsIGN1cnJlbjogMTY0LCB5ZW46IDE2NSwgYnJ2YmFyOiAxNjYsIHNlY3Q6IDE2NywgdW1sOiAxNjgsIGNvcHk6IDE2OSwgb3JkZjogMTcwLCBsYXF1bzogMTcxLCBub3Q6IDE3Miwgc2h5OiAxNzMsIHJlZzogMTc0LCBtYWNyOiAxNzUsIGRlZzogMTc2LCBwbHVzbW46IDE3Nywgc3VwMjogMTc4LCBzdXAzOiAxNzksIGFjdXRlOiAxODAsIG1pY3JvOiAxODEsIHBhcmE6IDE4MiwgbWlkZG90OiAxODMsIGNlZGlsOiAxODQsIHN1cDE6IDE4NSwgb3JkbTogMTg2LCByYXF1bzogMTg3LCBmcmFjMTQ6IDE4OCwgZnJhYzEyOiAxODksIGZyYWMzNDogMTkwLCBpcXVlc3Q6IDE5MSwgQWdyYXZlOiAxOTIsIEFhY3V0ZTogMTkzLCBBY2lyYzogMTk0LCBBdGlsZGU6IDE5NSwgQXVtbDogMTk2LCBBcmluZzogMTk3LCBBRWxpZzogMTk4LCBDY2VkaWw6IDE5OSwgRWdyYXZlOiAyMDAsIEVhY3V0ZTogMjAxLCBFY2lyYzogMjAyLCBFdW1sOiAyMDMsIElncmF2ZTogMjA0LCBJYWN1dGU6IDIwNSwgSWNpcmM6IDIwNiwgSXVtbDogMjA3LCBFVEg6IDIwOCwgTnRpbGRlOiAyMDksIE9ncmF2ZTogMjEwLCBPYWN1dGU6IDIxMSwgT2NpcmM6IDIxMiwgT3RpbGRlOiAyMTMsIE91bWw6IDIxNCwgdGltZXM6IDIxNSwgT3NsYXNoOiAyMTYsIFVncmF2ZTogMjE3LCBVYWN1dGU6IDIxOCwgVWNpcmM6IDIxOSwgVXVtbDogMjIwLCBZYWN1dGU6IDIyMSwgVEhPUk46IDIyMiwgc3psaWc6IDIyMywgYWdyYXZlOiAyMjQsIGFhY3V0ZTogMjI1LCBhY2lyYzogMjI2LCBhdGlsZGU6IDIyNywgYXVtbDogMjI4LCBhcmluZzogMjI5LCBhZWxpZzogMjMwLCBjY2VkaWw6IDIzMSwgZWdyYXZlOiAyMzIsIGVhY3V0ZTogMjMzLCBlY2lyYzogMjM0LCBldW1sOiAyMzUsIGlncmF2ZTogMjM2LCBpYWN1dGU6IDIzNywgaWNpcmM6IDIzOCwgaXVtbDogMjM5LCBldGg6IDI0MCwgbnRpbGRlOiAyNDEsIG9ncmF2ZTogMjQyLCBvYWN1dGU6IDI0Mywgb2NpcmM6IDI0NCwgb3RpbGRlOiAyNDUsIG91bWw6IDI0NiwgZGl2aWRlOiAyNDcsIG9zbGFzaDogMjQ4LCB1Z3JhdmU6IDI0OSwgdWFjdXRlOiAyNTAsIHVjaXJjOiAyNTEsIHV1bWw6IDI1MiwgeWFjdXRlOiAyNTMsIHRob3JuOiAyNTQsIHl1bWw6IDI1NSwgT0VsaWc6IDMzOCwgb2VsaWc6IDMzOSwgU2Nhcm9uOiAzNTIsIHNjYXJvbjogMzUzLCBZdW1sOiAzNzYsIGZub2Y6IDQwMiwgY2lyYzogNzEwLCB0aWxkZTogNzMyLCBBbHBoYTogOTEzLCBCZXRhOiA5MTQsIEdhbW1hOiA5MTUsIERlbHRhOiA5MTYsIEVwc2lsb246IDkxNywgWmV0YTogOTE4LCBFdGE6IDkxOSwgVGhldGE6IDkyMCwgSW90YTogOTIxLCBLYXBwYTogOTIyLCBMYW1iZGE6IDkyMywgTXU6IDkyNCwgTnU6IDkyNSwgWGk6IDkyNiwgT21pY3JvbjogOTI3LCBQaTogOTI4LCBSaG86IDkyOSwgU2lnbWE6IDkzMSwgVGF1OiA5MzIsIFVwc2lsb246IDkzMywgUGhpOiA5MzQsIENoaTogOTM1LCBQc2k6IDkzNiwgT21lZ2E6IDkzNywgYWxwaGE6IDk0NSwgYmV0YTogOTQ2LCBnYW1tYTogOTQ3LCBkZWx0YTogOTQ4LCBlcHNpbG9uOiA5NDksIHpldGE6IDk1MCwgZXRhOiA5NTEsIHRoZXRhOiA5NTIsIGlvdGE6IDk1Mywga2FwcGE6IDk1NCwgbGFtYmRhOiA5NTUsIG11OiA5NTYsIG51OiA5NTcsIHhpOiA5NTgsIG9taWNyb246IDk1OSwgcGk6IDk2MCwgcmhvOiA5NjEsIHNpZ21hZjogOTYyLCBzaWdtYTogOTYzLCB0YXU6IDk2NCwgdXBzaWxvbjogOTY1LCBwaGk6IDk2NiwgY2hpOiA5NjcsIHBzaTogOTY4LCBvbWVnYTogOTY5LCB0aGV0YXN5bTogOTc3LCB1cHNpaDogOTc4LCBwaXY6IDk4MiwgZW5zcDogODE5NCwgZW1zcDogODE5NSwgdGhpbnNwOiA4MjAxLCB6d25qOiA4MjA0LCB6d2o6IDgyMDUsIGxybTogODIwNiwgcmxtOiA4MjA3LCBuZGFzaDogODIxMSwgbWRhc2g6IDgyMTIsIGxzcXVvOiA4MjE2LCByc3F1bzogODIxNywgc2JxdW86IDgyMTgsIGxkcXVvOiA4MjIwLCByZHF1bzogODIyMSwgYmRxdW86IDgyMjIsIGRhZ2dlcjogODIyNCwgRGFnZ2VyOiA4MjI1LCBidWxsOiA4MjI2LCBoZWxsaXA6IDgyMzAsIHBlcm1pbDogODI0MCwgcHJpbWU6IDgyNDIsIFByaW1lOiA4MjQzLCBsc2FxdW86IDgyNDksIHJzYXF1bzogODI1MCwgb2xpbmU6IDgyNTQsIGZyYXNsOiA4MjYwLCBldXJvOiA4MzY0LCBpbWFnZTogODQ2NSwgd2VpZXJwOiA4NDcyLCByZWFsOiA4NDc2LCB0cmFkZTogODQ4MiwgYWxlZnN5bTogODUwMSwgbGFycjogODU5MiwgdWFycjogODU5MywgcmFycjogODU5NCwgZGFycjogODU5NSwgaGFycjogODU5NiwgY3JhcnI6IDg2MjksIGxBcnI6IDg2NTYsIHVBcnI6IDg2NTcsIHJBcnI6IDg2NTgsIGRBcnI6IDg2NTksIGhBcnI6IDg2NjAsIGZvcmFsbDogODcwNCwgcGFydDogODcwNiwgZXhpc3Q6IDg3MDcsIGVtcHR5OiA4NzA5LCBuYWJsYTogODcxMSwgaXNpbjogODcxMiwgbm90aW46IDg3MTMsIG5pOiA4NzE1LCBwcm9kOiA4NzE5LCBzdW06IDg3MjEsIG1pbnVzOiA4NzIyLCBsb3dhc3Q6IDg3MjcsIHJhZGljOiA4NzMwLCBwcm9wOiA4NzMzLCBpbmZpbjogODczNCwgYW5nOiA4NzM2LCBhbmQ6IDg3NDMsIG9yOiA4NzQ0LCBjYXA6IDg3NDUsIGN1cDogODc0NiwgaW50OiA4NzQ3LCB0aGVyZTQ6IDg3NTYsIHNpbTogODc2NCwgY29uZzogODc3MywgYXN5bXA6IDg3NzYsIG5lOiA4ODAwLCBlcXVpdjogODgwMSwgbGU6IDg4MDQsIGdlOiA4ODA1LCBzdWI6IDg4MzQsIHN1cDogODgzNSwgbnN1YjogODgzNiwgc3ViZTogODgzOCwgc3VwZTogODgzOSwgb3BsdXM6IDg4NTMsIG90aW1lczogODg1NSwgcGVycDogODg2OSwgc2RvdDogODkwMSwgbGNlaWw6IDg5NjgsIHJjZWlsOiA4OTY5LCBsZmxvb3I6IDg5NzAsIHJmbG9vcjogODk3MSwgbGFuZzogOTAwMSwgcmFuZzogOTAwMiwgbG96OiA5Njc0LCBzcGFkZXM6IDk4MjQsIGNsdWJzOiA5ODI3LCBoZWFydHM6IDk4MjksIGRpYW1zOiA5ODMwIH07XG4gIGNvbnRyb2xDaGFyYWN0ZXJzID0gWzgzNjQsIDEyOSwgODIxOCwgNDAyLCA4MjIyLCA4MjMwLCA4MjI0LCA4MjI1LCA3MTAsIDgyNDAsIDM1MiwgODI0OSwgMzM4LCAxNDEsIDM4MSwgMTQzLCAxNDQsIDgyMTYsIDgyMTcsIDgyMjAsIDgyMjEsIDgyMjYsIDgyMTEsIDgyMTIsIDczMiwgODQ4MiwgMzUzLCA4MjUwLCAzMzksIDE1NywgMzgyLCAzNzZdO1xuICBlbnRpdHlQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIiYoIz8oPzp4W1xcXFx3XFxcXGRdK3xcXFxcZCt8XCIgKyBPYmplY3Qua2V5cyhodG1sRW50aXRpZXMpLmpvaW4oXCJ8XCIpICsgXCIpKTs/XCIsIFwiZ1wiKTtcblxuICBmdW5jdGlvbiBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKGh0bWwpIHtcbiAgXHRyZXR1cm4gaHRtbC5yZXBsYWNlKGVudGl0eVBhdHRlcm4sIGZ1bmN0aW9uIChtYXRjaCwgZW50aXR5KSB7XG4gIFx0XHR2YXIgY29kZTtcblxuICBcdFx0Ly8gSGFuZGxlIG5hbWVkIGVudGl0aWVzXG4gIFx0XHRpZiAoZW50aXR5WzBdICE9PSBcIiNcIikge1xuICBcdFx0XHRjb2RlID0gaHRtbEVudGl0aWVzW2VudGl0eV07XG4gIFx0XHR9IGVsc2UgaWYgKGVudGl0eVsxXSA9PT0gXCJ4XCIpIHtcbiAgXHRcdFx0Y29kZSA9IHBhcnNlSW50KGVudGl0eS5zdWJzdHJpbmcoMiksIDE2KTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGNvZGUgPSBwYXJzZUludChlbnRpdHkuc3Vic3RyaW5nKDEpLCAxMCk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghY29kZSkge1xuICBcdFx0XHRyZXR1cm4gbWF0Y2g7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbGlkYXRlQ29kZShjb2RlKSk7XG4gIFx0fSk7XG4gIH1cblxuICAvLyBzb21lIGNvZGUgcG9pbnRzIGFyZSB2ZXJib3Rlbi4gSWYgd2Ugd2VyZSBpbnNlcnRpbmcgSFRNTCwgdGhlIGJyb3dzZXIgd291bGQgcmVwbGFjZSB0aGUgaWxsZWdhbFxuICAvLyBjb2RlIHBvaW50cyB3aXRoIGFsdGVybmF0aXZlcyBpbiBzb21lIGNhc2VzIC0gc2luY2Ugd2UncmUgYnlwYXNzaW5nIHRoYXQgbWVjaGFuaXNtLCB3ZSBuZWVkXG4gIC8vIHRvIHJlcGxhY2UgdGhlbSBvdXJzZWx2ZXNcbiAgLy9cbiAgLy8gU291cmNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NoYXJhY3Rlcl9lbmNvZGluZ3NfaW5fSFRNTCNJbGxlZ2FsX2NoYXJhY3RlcnNcbiAgZnVuY3Rpb24gdmFsaWRhdGVDb2RlKGNvZGUpIHtcbiAgXHRpZiAoIWNvZGUpIHtcbiAgXHRcdHJldHVybiA2NTUzMztcbiAgXHR9XG5cbiAgXHQvLyBsaW5lIGZlZWQgYmVjb21lcyBnZW5lcmljIHdoaXRlc3BhY2VcbiAgXHRpZiAoY29kZSA9PT0gMTApIHtcbiAgXHRcdHJldHVybiAzMjtcbiAgXHR9XG5cbiAgXHQvLyBBU0NJSSByYW5nZS4gKFdoeSBzb21lb25lIHdvdWxkIHVzZSBIVE1MIGVudGl0aWVzIGZvciBBU0NJSSBjaGFyYWN0ZXJzIEkgZG9uJ3Qga25vdywgYnV0Li4uKVxuICBcdGlmIChjb2RlIDwgMTI4KSB7XG4gIFx0XHRyZXR1cm4gY29kZTtcbiAgXHR9XG5cbiAgXHQvLyBjb2RlIHBvaW50cyAxMjgtMTU5IGFyZSBkZWFsdCB3aXRoIGxlbmllbnRseSBieSBicm93c2VycywgYnV0IHRoZXkncmUgaW5jb3JyZWN0LiBXZSBuZWVkXG4gIFx0Ly8gdG8gY29ycmVjdCB0aGUgbWlzdGFrZSBvciB3ZSdsbCBlbmQgdXAgd2l0aCBtaXNzaW5nIOKCrCBzaWducyBhbmQgc28gb25cbiAgXHRpZiAoY29kZSA8PSAxNTkpIHtcbiAgXHRcdHJldHVybiBjb250cm9sQ2hhcmFjdGVyc1tjb2RlIC0gMTI4XTtcbiAgXHR9XG5cbiAgXHQvLyBiYXNpYyBtdWx0aWxpbmd1YWwgcGxhbmVcbiAgXHRpZiAoY29kZSA8IDU1Mjk2KSB7XG4gIFx0XHRyZXR1cm4gY29kZTtcbiAgXHR9XG5cbiAgXHQvLyBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuICBcdGlmIChjb2RlIDw9IDU3MzQzKSB7XG4gIFx0XHRyZXR1cm4gNjU1MzM7XG4gIFx0fVxuXG4gIFx0Ly8gcmVzdCBvZiB0aGUgYmFzaWMgbXVsdGlsaW5ndWFsIHBsYW5lXG4gIFx0aWYgKGNvZGUgPD0gNjU1MzUpIHtcbiAgXHRcdHJldHVybiBjb2RlO1xuICBcdH1cblxuICBcdHJldHVybiA2NTUzMztcbiAgfVxuXG4gIGxlc3NUaGFuID0gLzwvZztcbiAgZ3JlYXRlclRoYW4gPSAvPi9nO1xuICBhbXAgPSAvJi9nO1xuXG4gIGZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyKSB7XG4gIFx0cmV0dXJuIHN0ci5yZXBsYWNlKGFtcCwgXCImYW1wO1wiKS5yZXBsYWNlKGxlc3NUaGFuLCBcIiZsdDtcIikucmVwbGFjZShncmVhdGVyVGhhbiwgXCImZ3Q7XCIpO1xuICB9XG5cbiAgdmFyIGxlYWRpbmdMaW5lYnJlYWsgPSAvXlxccypcXHI/XFxuLyxcbiAgICAgIHRyYWlsaW5nTGluZWJyZWFrID0gL1xccj9cXG5cXHMqJC87XG5cbiAgdmFyIHN0cmlwU3RhbmRhbG9uZXMgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgXHR2YXIgaSwgY3VycmVudCwgYmFja09uZSwgYmFja1R3bywgbGFzdFNlY3Rpb25JdGVtO1xuXG4gIFx0Zm9yIChpID0gMTsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRjdXJyZW50ID0gaXRlbXNbaV07XG4gIFx0XHRiYWNrT25lID0gaXRlbXNbaSAtIDFdO1xuICBcdFx0YmFja1R3byA9IGl0ZW1zW2kgLSAyXTtcblxuICBcdFx0Ly8gaWYgd2UncmUgYXQgdGhlIGVuZCBvZiBhIFt0ZXh0XVtjb21tZW50XVt0ZXh0XSBzZXF1ZW5jZS4uLlxuICBcdFx0aWYgKGlzU3RyaW5nKGN1cnJlbnQpICYmIGlzQ29tbWVudChiYWNrT25lKSAmJiBpc1N0cmluZyhiYWNrVHdvKSkge1xuXG4gIFx0XHRcdC8vIC4uLiBhbmQgdGhlIGNvbW1lbnQgaXMgYSBzdGFuZGFsb25lIChpLmUuIGxpbmUgYnJlYWtzIGVpdGhlciBzaWRlKS4uLlxuICBcdFx0XHRpZiAodHJhaWxpbmdMaW5lYnJlYWsudGVzdChiYWNrVHdvKSAmJiBsZWFkaW5nTGluZWJyZWFrLnRlc3QoY3VycmVudCkpIHtcblxuICBcdFx0XHRcdC8vIC4uLiB0aGVuIHdlIHdhbnQgdG8gcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlIGFmdGVyIHRoZSBmaXJzdCBsaW5lIGJyZWFrXG4gIFx0XHRcdFx0aXRlbXNbaSAtIDJdID0gYmFja1R3by5yZXBsYWNlKHRyYWlsaW5nTGluZWJyZWFrLCBcIlxcblwiKTtcblxuICBcdFx0XHRcdC8vIGFuZCB0aGUgbGVhZGluZyBsaW5lIGJyZWFrIG9mIHRoZSBzZWNvbmQgdGV4dCB0b2tlblxuICBcdFx0XHRcdGl0ZW1zW2ldID0gY3VycmVudC5yZXBsYWNlKGxlYWRpbmdMaW5lYnJlYWssIFwiXCIpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGlmIHRoZSBjdXJyZW50IGl0ZW0gaXMgYSBzZWN0aW9uLCBhbmQgaXQgaXMgcHJlY2VkZWQgYnkgYSBsaW5lYnJlYWssIGFuZFxuICBcdFx0Ly8gaXRzIGZpcnN0IGl0ZW0gaXMgYSBsaW5lYnJlYWsuLi5cbiAgXHRcdGlmIChpc1NlY3Rpb24oY3VycmVudCkgJiYgaXNTdHJpbmcoYmFja09uZSkpIHtcbiAgXHRcdFx0aWYgKHRyYWlsaW5nTGluZWJyZWFrLnRlc3QoYmFja09uZSkgJiYgaXNTdHJpbmcoY3VycmVudC5mWzBdKSAmJiBsZWFkaW5nTGluZWJyZWFrLnRlc3QoY3VycmVudC5mWzBdKSkge1xuICBcdFx0XHRcdGl0ZW1zW2kgLSAxXSA9IGJhY2tPbmUucmVwbGFjZSh0cmFpbGluZ0xpbmVicmVhaywgXCJcXG5cIik7XG4gIFx0XHRcdFx0Y3VycmVudC5mWzBdID0gY3VycmVudC5mWzBdLnJlcGxhY2UobGVhZGluZ0xpbmVicmVhaywgXCJcIik7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gaWYgdGhlIGxhc3QgaXRlbSB3YXMgYSBzZWN0aW9uLCBhbmQgaXQgaXMgZm9sbG93ZWQgYnkgYSBsaW5lYnJlYWssIGFuZFxuICBcdFx0Ly8gaXRzIGxhc3QgaXRlbSBpcyBhIGxpbmVicmVhay4uLlxuICBcdFx0aWYgKGlzU3RyaW5nKGN1cnJlbnQpICYmIGlzU2VjdGlvbihiYWNrT25lKSkge1xuICBcdFx0XHRsYXN0U2VjdGlvbkl0ZW0gPSBsYXN0SXRlbShiYWNrT25lLmYpO1xuXG4gIFx0XHRcdGlmIChpc1N0cmluZyhsYXN0U2VjdGlvbkl0ZW0pICYmIHRyYWlsaW5nTGluZWJyZWFrLnRlc3QobGFzdFNlY3Rpb25JdGVtKSAmJiBsZWFkaW5nTGluZWJyZWFrLnRlc3QoY3VycmVudCkpIHtcbiAgXHRcdFx0XHRiYWNrT25lLmZbYmFja09uZS5mLmxlbmd0aCAtIDFdID0gbGFzdFNlY3Rpb25JdGVtLnJlcGxhY2UodHJhaWxpbmdMaW5lYnJlYWssIFwiXFxuXCIpO1xuICBcdFx0XHRcdGl0ZW1zW2ldID0gY3VycmVudC5yZXBsYWNlKGxlYWRpbmdMaW5lYnJlYWssIFwiXCIpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGl0ZW1zO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGlzU3RyaW5nKGl0ZW0pIHtcbiAgXHRyZXR1cm4gdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc0NvbW1lbnQoaXRlbSkge1xuICBcdHJldHVybiBpdGVtLnQgPT09IENPTU1FTlQgfHwgaXRlbS50ID09PSBERUxJTUNIQU5HRTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU2VjdGlvbihpdGVtKSB7XG4gIFx0cmV0dXJuIChpdGVtLnQgPT09IFNFQ1RJT04gfHwgaXRlbS50ID09PSBJTlZFUlRFRCkgJiYgaXRlbS5mO1xuICB9XG5cbiAgdmFyIHRyaW1XaGl0ZXNwYWNlID0gZnVuY3Rpb24gKGl0ZW1zLCBsZWFkaW5nUGF0dGVybiwgdHJhaWxpbmdQYXR0ZXJuKSB7XG4gIFx0dmFyIGl0ZW07XG5cbiAgXHRpZiAobGVhZGluZ1BhdHRlcm4pIHtcbiAgXHRcdGl0ZW0gPSBpdGVtc1swXTtcbiAgXHRcdGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRpdGVtID0gaXRlbS5yZXBsYWNlKGxlYWRpbmdQYXR0ZXJuLCBcIlwiKTtcblxuICBcdFx0XHRpZiAoIWl0ZW0pIHtcbiAgXHRcdFx0XHRpdGVtcy5zaGlmdCgpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdGl0ZW1zWzBdID0gaXRlbTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICh0cmFpbGluZ1BhdHRlcm4pIHtcbiAgXHRcdGl0ZW0gPSBsYXN0SXRlbShpdGVtcyk7XG4gIFx0XHRpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0aXRlbSA9IGl0ZW0ucmVwbGFjZSh0cmFpbGluZ1BhdHRlcm4sIFwiXCIpO1xuXG4gIFx0XHRcdGlmICghaXRlbSkge1xuICBcdFx0XHRcdGl0ZW1zLnBvcCgpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdID0gaXRlbTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgdXRpbHNfY2xlYW51cCA9IGNsZWFudXA7XG4gIHZhciBjb250aWd1b3VzV2hpdGVzcGFjZSA9IC9bIFxcdFxcZlxcclxcbl0rL2c7XG4gIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2VFbGVtZW50cyA9IC9eKD86cHJlfHNjcmlwdHxzdHlsZXx0ZXh0YXJlYSkkL2k7XG4gIHZhciB1dGlsc19jbGVhbnVwX19sZWFkaW5nV2hpdGVzcGFjZSA9IC9eWyBcXHRcXGZcXHJcXG5dKy87XG4gIHZhciB0cmFpbGluZ1doaXRlc3BhY2UgPSAvWyBcXHRcXGZcXHJcXG5dKyQvO1xuICB2YXIgbGVhZGluZ05ld0xpbmUgPSAvXig/OlxcclxcbnxcXHJ8XFxuKS87XG4gIHZhciB0cmFpbGluZ05ld0xpbmUgPSAvKD86XFxyXFxufFxccnxcXG4pJC87XG4gIGZ1bmN0aW9uIGNsZWFudXAoaXRlbXMsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2UsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZSkge1xuICBcdHZhciBpLCBpdGVtLCBwcmV2aW91c0l0ZW0sIG5leHRJdGVtLCBwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIGtleTtcblxuICBcdC8vIEZpcnN0IHBhc3MgLSByZW1vdmUgc3RhbmRhbG9uZXMgYW5kIGNvbW1lbnRzIGV0Y1xuICBcdHN0cmlwU3RhbmRhbG9uZXMoaXRlbXMpO1xuXG4gIFx0aSA9IGl0ZW1zLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpdGVtID0gaXRlbXNbaV07XG5cbiAgXHRcdC8vIFJlbW92ZSBkZWxpbWl0ZXIgY2hhbmdlcywgdW5zYWZlIGVsZW1lbnRzIGV0Y1xuICBcdFx0aWYgKGl0ZW0uZXhjbHVkZSkge1xuICBcdFx0XHRpdGVtcy5zcGxpY2UoaSwgMSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFJlbW92ZSBjb21tZW50cywgdW5sZXNzIHdlIHdhbnQgdG8ga2VlcCB0aGVtXG4gIFx0XHRlbHNlIGlmIChzdHJpcENvbW1lbnRzICYmIGl0ZW0udCA9PT0gQ09NTUVOVCkge1xuICBcdFx0XHRpdGVtcy5zcGxpY2UoaSwgMSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gSWYgbmVjZXNzYXJ5LCByZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICBcdHRyaW1XaGl0ZXNwYWNlKGl0ZW1zLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZSA/IHV0aWxzX2NsZWFudXBfX2xlYWRpbmdXaGl0ZXNwYWNlIDogbnVsbCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlID8gdHJhaWxpbmdXaGl0ZXNwYWNlIDogbnVsbCk7XG5cbiAgXHRpID0gaXRlbXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGl0ZW0gPSBpdGVtc1tpXTtcblxuICBcdFx0Ly8gUmVjdXJzZVxuICBcdFx0aWYgKGl0ZW0uZikge1xuICBcdFx0XHR2YXIgaXNQcmVzZXJ2ZVdoaXRlc3BhY2VFbGVtZW50ID0gaXRlbS50ID09PSBFTEVNRU5UICYmIHByZXNlcnZlV2hpdGVzcGFjZUVsZW1lbnRzLnRlc3QoaXRlbS5lKTtcbiAgXHRcdFx0cHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgPSBwcmVzZXJ2ZVdoaXRlc3BhY2UgfHwgaXNQcmVzZXJ2ZVdoaXRlc3BhY2VFbGVtZW50O1xuXG4gIFx0XHRcdGlmICghcHJlc2VydmVXaGl0ZXNwYWNlICYmIGlzUHJlc2VydmVXaGl0ZXNwYWNlRWxlbWVudCkge1xuICBcdFx0XHRcdHRyaW1XaGl0ZXNwYWNlKGl0ZW0uZiwgbGVhZGluZ05ld0xpbmUsIHRyYWlsaW5nTmV3TGluZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIXByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KSB7XG4gIFx0XHRcdFx0cHJldmlvdXNJdGVtID0gaXRlbXNbaSAtIDFdO1xuICBcdFx0XHRcdG5leHRJdGVtID0gaXRlbXNbaSArIDFdO1xuXG4gIFx0XHRcdFx0Ly8gaWYgdGhlIHByZXZpb3VzIGl0ZW0gd2FzIGEgdGV4dCBpdGVtIHdpdGggdHJhaWxpbmcgd2hpdGVzcGFjZSxcbiAgXHRcdFx0XHQvLyByZW1vdmUgbGVhZGluZyB3aGl0ZXNwYWNlIGluc2lkZSB0aGUgZnJhZ21lbnRcbiAgXHRcdFx0XHRpZiAoIXByZXZpb3VzSXRlbSB8fCB0eXBlb2YgcHJldmlvdXNJdGVtID09PSBcInN0cmluZ1wiICYmIHRyYWlsaW5nV2hpdGVzcGFjZS50ZXN0KHByZXZpb3VzSXRlbSkpIHtcbiAgXHRcdFx0XHRcdHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgPSB0cnVlO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdC8vIGFuZCB2aWNlIHZlcnNhXG4gIFx0XHRcdFx0aWYgKCFuZXh0SXRlbSB8fCB0eXBlb2YgbmV4dEl0ZW0gPT09IFwic3RyaW5nXCIgJiYgdXRpbHNfY2xlYW51cF9fbGVhZGluZ1doaXRlc3BhY2UudGVzdChuZXh0SXRlbSkpIHtcbiAgXHRcdFx0XHRcdHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50ID0gdHJ1ZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjbGVhbnVwKGl0ZW0uZiwgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gU3BsaXQgaWYtZWxzZSBibG9ja3MgaW50byB0d28gKGFuIGlmLCBhbmQgYW4gdW5sZXNzKVxuICBcdFx0aWYgKGl0ZW0ubCkge1xuICBcdFx0XHRjbGVhbnVwKGl0ZW0ubC5mLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KTtcblxuICBcdFx0XHRpdGVtcy5zcGxpY2UoaSArIDEsIDAsIGl0ZW0ubCk7XG4gIFx0XHRcdGRlbGV0ZSBpdGVtLmw7IC8vIFRPRE8gd291bGQgYmUgbmljZSBpZiB0aGVyZSB3YXMgYSB3YXkgYXJvdW5kIHRoaXNcbiAgXHRcdH1cblxuICBcdFx0Ly8gQ2xlYW4gdXAgZWxlbWVudCBhdHRyaWJ1dGVzXG4gIFx0XHRpZiAoaXRlbS5hKSB7XG4gIFx0XHRcdGZvciAoa2V5IGluIGl0ZW0uYSkge1xuICBcdFx0XHRcdGlmIChpdGVtLmEuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0eXBlb2YgaXRlbS5hW2tleV0gIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0XHRcdGNsZWFudXAoaXRlbS5hW2tleV0sIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBDbGVhbiB1cCBjb25kaXRpb25hbCBhdHRyaWJ1dGVzXG4gIFx0XHRpZiAoaXRlbS5tKSB7XG4gIFx0XHRcdGNsZWFudXAoaXRlbS5tLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gQ2xlYW4gdXAgZXZlbnQgaGFuZGxlcnNcbiAgXHRcdGlmIChpdGVtLnYpIHtcbiAgXHRcdFx0Zm9yIChrZXkgaW4gaXRlbS52KSB7XG4gIFx0XHRcdFx0aWYgKGl0ZW0udi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gIFx0XHRcdFx0XHQvLyBjbGVhbiB1cCBuYW1lc1xuICBcdFx0XHRcdFx0aWYgKGlzQXJyYXkoaXRlbS52W2tleV0ubikpIHtcbiAgXHRcdFx0XHRcdFx0Y2xlYW51cChpdGVtLnZba2V5XS5uLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KTtcbiAgXHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0Ly8gY2xlYW4gdXAgcGFyYW1zXG4gIFx0XHRcdFx0XHRpZiAoaXNBcnJheShpdGVtLnZba2V5XS5kKSkge1xuICBcdFx0XHRcdFx0XHRjbGVhbnVwKGl0ZW0udltrZXldLmQsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIGZpbmFsIHBhc3MgLSBmdXNlIHRleHQgbm9kZXMgdG9nZXRoZXJcbiAgXHRpID0gaXRlbXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGlmICh0eXBlb2YgaXRlbXNbaV0gPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0aWYgKHR5cGVvZiBpdGVtc1tpICsgMV0gPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0XHRpdGVtc1tpXSA9IGl0ZW1zW2ldICsgaXRlbXNbaSArIDFdO1xuICBcdFx0XHRcdGl0ZW1zLnNwbGljZShpICsgMSwgMSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIXByZXNlcnZlV2hpdGVzcGFjZSkge1xuICBcdFx0XHRcdGl0ZW1zW2ldID0gaXRlbXNbaV0ucmVwbGFjZShjb250aWd1b3VzV2hpdGVzcGFjZSwgXCIgXCIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGl0ZW1zW2ldID09PSBcIlwiKSB7XG4gIFx0XHRcdFx0aXRlbXMuc3BsaWNlKGksIDEpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIGVsZW1lbnRfcmVhZENsb3NpbmdUYWcgPSByZWFkQ2xvc2luZ1RhZztcbiAgdmFyIGNsb3NpbmdUYWdQYXR0ZXJuID0gL14oW2EtekEtWl17MSx9Oj9bYS16QS1aMC05XFwtXSopXFxzKlxcPi87XG4gIGZ1bmN0aW9uIHJlYWRDbG9zaW5nVGFnKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgdGFnO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gYXJlIHdlIGxvb2tpbmcgYXQgYSBjbG9zaW5nIHRhZz9cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIjwvXCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAodGFnID0gcGFyc2VyLm1hdGNoUGF0dGVybihjbG9zaW5nVGFnUGF0dGVybikpIHtcbiAgXHRcdGlmIChwYXJzZXIuaW5zaWRlICYmIHRhZyAhPT0gcGFyc2VyLmluc2lkZSkge1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBDTE9TSU5HX1RBRyxcbiAgXHRcdFx0ZTogdGFnXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdC8vIFdlIGhhdmUgYW4gaWxsZWdhbCBjbG9zaW5nIHRhZywgcmVwb3J0IGl0XG4gIFx0cGFyc2VyLnBvcyAtPSAyO1xuICBcdHBhcnNlci5lcnJvcihcIklsbGVnYWwgY2xvc2luZyB0YWdcIik7XG4gIH1cblxuICB2YXIgZ2V0TG93ZXN0SW5kZXggPSBmdW5jdGlvbiAoaGF5c3RhY2ssIG5lZWRsZXMpIHtcbiAgXHR2YXIgaSwgaW5kZXgsIGxvd2VzdDtcblxuICBcdGkgPSBuZWVkbGVzLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpbmRleCA9IGhheXN0YWNrLmluZGV4T2YobmVlZGxlc1tpXSk7XG5cbiAgXHRcdC8vIHNob3J0IGNpcmN1aXRcbiAgXHRcdGlmICghaW5kZXgpIHtcbiAgXHRcdFx0cmV0dXJuIDA7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0Y29udGludWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghbG93ZXN0IHx8IGluZGV4IDwgbG93ZXN0KSB7XG4gIFx0XHRcdGxvd2VzdCA9IGluZGV4O1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBsb3dlc3QgfHwgLTE7XG4gIH07XG5cbiAgdmFyIGVsZW1lbnRfcmVhZEF0dHJpYnV0ZSA9IHJlYWRBdHRyaWJ1dGU7XG5cbiAgdmFyIGF0dHJpYnV0ZU5hbWVQYXR0ZXJuID0gL15bXlxcc1wiJz5cXC89XSsvLFxuICAgICAgdW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRleHRQYXR0ZXJuID0gL15bXlxcc1wiJz08PmBdKy87XG4gIGZ1bmN0aW9uIHJlYWRBdHRyaWJ1dGUocGFyc2VyKSB7XG4gIFx0dmFyIGF0dHIsIG5hbWUsIHZhbHVlO1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0bmFtZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oYXR0cmlidXRlTmFtZVBhdHRlcm4pO1xuICBcdGlmICghbmFtZSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0YXR0ciA9IHsgbmFtZTogbmFtZSB9O1xuXG4gIFx0dmFsdWUgPSByZWFkQXR0cmlidXRlVmFsdWUocGFyc2VyKTtcbiAgXHRpZiAodmFsdWUgIT0gbnVsbCkge1xuICBcdFx0Ly8gbm90IG51bGwvdW5kZWZpbmVkXG4gIFx0XHRhdHRyLnZhbHVlID0gdmFsdWU7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGF0dHI7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkQXR0cmlidXRlVmFsdWUocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCB2YWx1ZVN0YXJ0LCBzdGFydERlcHRoLCB2YWx1ZTtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIG5leHQgY2hhcmFjdGVyIG11c3QgYmUgYD1gLCBgL2AsIGA+YCBvciB3aGl0ZXNwYWNlXG4gIFx0aWYgKCEvWz1cXC8+XFxzXS8udGVzdChwYXJzZXIubmV4dENoYXIoKSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGA9YCwgYC9gLCBgPmAgb3Igd2hpdGVzcGFjZVwiKTtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIj1cIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdHZhbHVlU3RhcnQgPSBwYXJzZXIucG9zO1xuICBcdHN0YXJ0RGVwdGggPSBwYXJzZXIuc2VjdGlvbkRlcHRoO1xuXG4gIFx0dmFsdWUgPSByZWFkUXVvdGVkQXR0cmlidXRlVmFsdWUocGFyc2VyLCBcIidcIikgfHwgcmVhZFF1b3RlZEF0dHJpYnV0ZVZhbHVlKHBhcnNlciwgXCJcXFwiXCIpIHx8IHJlYWRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlKHBhcnNlcik7XG5cbiAgXHRpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIHZhbGlkIGF0dHJpYnV0ZSB2YWx1ZVwiKTtcbiAgXHR9XG5cbiAgXHRpZiAocGFyc2VyLnNlY3Rpb25EZXB0aCAhPT0gc3RhcnREZXB0aCkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHZhbHVlU3RhcnQ7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJBbiBhdHRyaWJ1dGUgdmFsdWUgbXVzdCBjb250YWluIGFzIG1hbnkgb3BlbmluZyBzZWN0aW9uIHRhZ3MgYXMgY2xvc2luZyBzZWN0aW9uIHRhZ3NcIik7XG4gIFx0fVxuXG4gIFx0aWYgKCF2YWx1ZS5sZW5ndGgpIHtcbiAgXHRcdHJldHVybiBcIlwiO1xuICBcdH1cblxuICBcdGlmICh2YWx1ZS5sZW5ndGggPT09IDEgJiYgdHlwZW9mIHZhbHVlWzBdID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRyZXR1cm4gZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyh2YWx1ZVswXSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFVucXVvdGVkQXR0cmlidXRlVmFsdWVUb2tlbihwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIHRleHQsIGhheXN0YWNrLCBuZWVkbGVzLCBpbmRleDtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdHRleHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHVucXVvdGVkQXR0cmlidXRlVmFsdWVUZXh0UGF0dGVybik7XG5cbiAgXHRpZiAoIXRleHQpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGhheXN0YWNrID0gdGV4dDtcbiAgXHRuZWVkbGVzID0gcGFyc2VyLnRhZ3MubWFwKGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRyZXR1cm4gdC5vcGVuO1xuICBcdH0pOyAvLyBUT0RPIHJlZmFjdG9yLi4uIHdlIGRvIHRoaXMgaW4gcmVhZFRleHQuanMgYXMgd2VsbFxuXG4gIFx0aWYgKChpbmRleCA9IGdldExvd2VzdEluZGV4KGhheXN0YWNrLCBuZWVkbGVzKSkgIT09IC0xKSB7XG4gIFx0XHR0ZXh0ID0gdGV4dC5zdWJzdHIoMCwgaW5kZXgpO1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0ICsgdGV4dC5sZW5ndGg7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRleHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZShwYXJzZXIpIHtcbiAgXHR2YXIgdG9rZW5zLCB0b2tlbjtcblxuICBcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IHRydWU7XG5cbiAgXHR0b2tlbnMgPSBbXTtcblxuICBcdHRva2VuID0gY29udmVydGVyc19yZWFkTXVzdGFjaGUocGFyc2VyKSB8fCByZWFkVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRva2VuKHBhcnNlcik7XG4gIFx0d2hpbGUgKHRva2VuICE9PSBudWxsKSB7XG4gIFx0XHR0b2tlbnMucHVzaCh0b2tlbik7XG4gIFx0XHR0b2tlbiA9IGNvbnZlcnRlcnNfcmVhZE11c3RhY2hlKHBhcnNlcikgfHwgcmVhZFVucXVvdGVkQXR0cmlidXRlVmFsdWVUb2tlbihwYXJzZXIpO1xuICBcdH1cblxuICBcdGlmICghdG9rZW5zLmxlbmd0aCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmluQXR0cmlidXRlID0gZmFsc2U7XG4gIFx0cmV0dXJuIHRva2VucztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRRdW90ZWRBdHRyaWJ1dGVWYWx1ZShwYXJzZXIsIHF1b3RlTWFyaykge1xuICBcdHZhciBzdGFydCwgdG9rZW5zLCB0b2tlbjtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHF1b3RlTWFyaykpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IHF1b3RlTWFyaztcblxuICBcdHRva2VucyA9IFtdO1xuXG4gIFx0dG9rZW4gPSBjb252ZXJ0ZXJzX3JlYWRNdXN0YWNoZShwYXJzZXIpIHx8IHJlYWRRdW90ZWRTdHJpbmdUb2tlbihwYXJzZXIsIHF1b3RlTWFyayk7XG4gIFx0d2hpbGUgKHRva2VuICE9PSBudWxsKSB7XG4gIFx0XHR0b2tlbnMucHVzaCh0b2tlbik7XG4gIFx0XHR0b2tlbiA9IGNvbnZlcnRlcnNfcmVhZE11c3RhY2hlKHBhcnNlcikgfHwgcmVhZFF1b3RlZFN0cmluZ1Rva2VuKHBhcnNlciwgcXVvdGVNYXJrKTtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhxdW90ZU1hcmspKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuaW5BdHRyaWJ1dGUgPSBmYWxzZTtcblxuICBcdHJldHVybiB0b2tlbnM7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkUXVvdGVkU3RyaW5nVG9rZW4ocGFyc2VyLCBxdW90ZU1hcmspIHtcbiAgXHR2YXIgc3RhcnQsIGluZGV4LCBoYXlzdGFjaywgbmVlZGxlcztcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcbiAgXHRoYXlzdGFjayA9IHBhcnNlci5yZW1haW5pbmcoKTtcblxuICBcdG5lZWRsZXMgPSBwYXJzZXIudGFncy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgXHRcdHJldHVybiB0Lm9wZW47XG4gIFx0fSk7IC8vIFRPRE8gcmVmYWN0b3IuLi4gd2UgZG8gdGhpcyBpbiByZWFkVGV4dC5qcyBhcyB3ZWxsXG4gIFx0bmVlZGxlcy5wdXNoKHF1b3RlTWFyayk7XG5cbiAgXHRpbmRleCA9IGdldExvd2VzdEluZGV4KGhheXN0YWNrLCBuZWVkbGVzKTtcblxuICBcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIlF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUgbXVzdCBoYXZlIGEgY2xvc2luZyBxdW90ZVwiKTtcbiAgXHR9XG5cbiAgXHRpZiAoIWluZGV4KSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIucG9zICs9IGluZGV4O1xuICBcdHJldHVybiBoYXlzdGFjay5zdWJzdHIoMCwgaW5kZXgpO1xuICB9XG5cbiAgdmFyIEpzb25QYXJzZXIsIHNwZWNpYWxzLCBzcGVjaWFsc1BhdHRlcm4sIHBhcnNlSlNPTl9fbnVtYmVyUGF0dGVybiwgcGxhY2Vob2xkZXJQYXR0ZXJuLCBwbGFjZWhvbGRlckF0U3RhcnRQYXR0ZXJuLCBvbmx5V2hpdGVzcGFjZTtcblxuICBzcGVjaWFscyA9IHtcbiAgXHRcInRydWVcIjogdHJ1ZSxcbiAgXHRcImZhbHNlXCI6IGZhbHNlLFxuICBcdHVuZGVmaW5lZDogdW5kZWZpbmVkLFxuICBcdFwibnVsbFwiOiBudWxsXG4gIH07XG5cbiAgc3BlY2lhbHNQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl4oPzpcIiArIE9iamVjdC5rZXlzKHNwZWNpYWxzKS5qb2luKFwifFwiKSArIFwiKVwiKTtcbiAgcGFyc2VKU09OX19udW1iZXJQYXR0ZXJuID0gL14oPzpbKy1dPykoPzooPzooPzowfFsxLTldXFxkKik/XFwuXFxkKyl8KD86KD86MHxbMS05XVxcZCopXFwuKXwoPzowfFsxLTldXFxkKikpKD86W2VFXVsrLV0/XFxkKyk/LztcbiAgcGxhY2Vob2xkZXJQYXR0ZXJuID0gL1xcJFxceyhbXlxcfV0rKVxcfS9nO1xuICBwbGFjZWhvbGRlckF0U3RhcnRQYXR0ZXJuID0gL15cXCRcXHsoW15cXH1dKylcXH0vO1xuICBvbmx5V2hpdGVzcGFjZSA9IC9eXFxzKiQvO1xuXG4gIEpzb25QYXJzZXIgPSBwYXJzZV9QYXJzZXIuZXh0ZW5kKHtcbiAgXHRpbml0OiBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG4gIFx0XHR0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICBcdFx0dGhpcy5hbGxvd1doaXRlc3BhY2UoKTtcbiAgXHR9LFxuXG4gIFx0cG9zdFByb2Nlc3M6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgXHRcdGlmIChyZXN1bHQubGVuZ3RoICE9PSAxIHx8ICFvbmx5V2hpdGVzcGFjZS50ZXN0KHRoaXMubGVmdG92ZXIpKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4geyB2YWx1ZTogcmVzdWx0WzBdLnYgfTtcbiAgXHR9LFxuXG4gIFx0Y29udmVydGVyczogW2Z1bmN0aW9uIGdldFBsYWNlaG9sZGVyKHBhcnNlcikge1xuICBcdFx0dmFyIHBsYWNlaG9sZGVyO1xuXG4gIFx0XHRpZiAoIXBhcnNlci52YWx1ZXMpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHBsYWNlaG9sZGVyID0gcGFyc2VyLm1hdGNoUGF0dGVybihwbGFjZWhvbGRlckF0U3RhcnRQYXR0ZXJuKTtcblxuICBcdFx0aWYgKHBsYWNlaG9sZGVyICYmIHBhcnNlci52YWx1ZXMuaGFzT3duUHJvcGVydHkocGxhY2Vob2xkZXIpKSB7XG4gIFx0XHRcdHJldHVybiB7IHY6IHBhcnNlci52YWx1ZXNbcGxhY2Vob2xkZXJdIH07XG4gIFx0XHR9XG4gIFx0fSwgZnVuY3Rpb24gZ2V0U3BlY2lhbChwYXJzZXIpIHtcbiAgXHRcdHZhciBzcGVjaWFsO1xuXG4gIFx0XHRpZiAoc3BlY2lhbCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oc3BlY2lhbHNQYXR0ZXJuKSkge1xuICBcdFx0XHRyZXR1cm4geyB2OiBzcGVjaWFsc1tzcGVjaWFsXSB9O1xuICBcdFx0fVxuICBcdH0sIGZ1bmN0aW9uIGdldE51bWJlcihwYXJzZXIpIHtcbiAgXHRcdHZhciBudW1iZXI7XG5cbiAgXHRcdGlmIChudW1iZXIgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHBhcnNlSlNPTl9fbnVtYmVyUGF0dGVybikpIHtcbiAgXHRcdFx0cmV0dXJuIHsgdjogK251bWJlciB9O1xuICBcdFx0fVxuICBcdH0sIGZ1bmN0aW9uIGdldFN0cmluZyhwYXJzZXIpIHtcbiAgXHRcdHZhciBzdHJpbmdMaXRlcmFsID0gcmVhZFN0cmluZ0xpdGVyYWwocGFyc2VyKSxcbiAgXHRcdCAgICB2YWx1ZXM7XG5cbiAgXHRcdGlmIChzdHJpbmdMaXRlcmFsICYmICh2YWx1ZXMgPSBwYXJzZXIudmFsdWVzKSkge1xuICBcdFx0XHRyZXR1cm4ge1xuICBcdFx0XHRcdHY6IHN0cmluZ0xpdGVyYWwudi5yZXBsYWNlKHBsYWNlaG9sZGVyUGF0dGVybiwgZnVuY3Rpb24gKG1hdGNoLCAkMSkge1xuICBcdFx0XHRcdFx0cmV0dXJuICQxIGluIHZhbHVlcyA/IHZhbHVlc1skMV0gOiAkMTtcbiAgXHRcdFx0XHR9KVxuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gc3RyaW5nTGl0ZXJhbDtcbiAgXHR9LCBmdW5jdGlvbiBnZXRPYmplY3QocGFyc2VyKSB7XG4gIFx0XHR2YXIgcmVzdWx0LCBwYWlyO1xuXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIntcIikpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJlc3VsdCA9IHt9O1xuXG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJ9XCIpKSB7XG4gIFx0XHRcdHJldHVybiB7IHY6IHJlc3VsdCB9O1xuICBcdFx0fVxuXG4gIFx0XHR3aGlsZSAocGFpciA9IGdldEtleVZhbHVlUGFpcihwYXJzZXIpKSB7XG4gIFx0XHRcdHJlc3VsdFtwYWlyLmtleV0gPSBwYWlyLnZhbHVlO1xuXG4gIFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0XHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwifVwiKSkge1xuICBcdFx0XHRcdHJldHVybiB7IHY6IHJlc3VsdCB9O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCIsXCIpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fSwgZnVuY3Rpb24gZ2V0QXJyYXkocGFyc2VyKSB7XG4gIFx0XHR2YXIgcmVzdWx0LCB2YWx1ZVRva2VuO1xuXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIltcIikpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJlc3VsdCA9IFtdO1xuXG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJdXCIpKSB7XG4gIFx0XHRcdHJldHVybiB7IHY6IHJlc3VsdCB9O1xuICBcdFx0fVxuXG4gIFx0XHR3aGlsZSAodmFsdWVUb2tlbiA9IHBhcnNlci5yZWFkKCkpIHtcbiAgXHRcdFx0cmVzdWx0LnB1c2godmFsdWVUb2tlbi52KTtcblxuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIl1cIikpIHtcbiAgXHRcdFx0XHRyZXR1cm4geyB2OiByZXN1bHQgfTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiLFwiKSkge1xuICBcdFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XVxuICB9KTtcblxuICBmdW5jdGlvbiBnZXRLZXlWYWx1ZVBhaXIocGFyc2VyKSB7XG4gIFx0dmFyIGtleSwgdmFsdWVUb2tlbiwgcGFpcjtcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGtleSA9IHNoYXJlZF9yZWFkS2V5KHBhcnNlcik7XG5cbiAgXHRpZiAoIWtleSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFpciA9IHsga2V5OiBrZXkgfTtcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIjpcIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHR2YWx1ZVRva2VuID0gcGFyc2VyLnJlYWQoKTtcbiAgXHRpZiAoIXZhbHVlVG9rZW4pIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhaXIudmFsdWUgPSB2YWx1ZVRva2VuLnY7XG5cbiAgXHRyZXR1cm4gcGFpcjtcbiAgfVxuXG4gIHZhciBwYXJzZUpTT04gPSBmdW5jdGlvbiAoc3RyLCB2YWx1ZXMpIHtcbiAgXHR2YXIgcGFyc2VyID0gbmV3IEpzb25QYXJzZXIoc3RyLCB7XG4gIFx0XHR2YWx1ZXM6IHZhbHVlc1xuICBcdH0pO1xuXG4gIFx0cmV0dXJuIHBhcnNlci5yZXN1bHQ7XG4gIH07XG5cbiAgLy8gVE9ETyBjbGVhbiB0aGlzIHVwLCBpdCdzIHNob2NraW5nXG4gIHZhciBlbGVtZW50X3Byb2Nlc3NEaXJlY3RpdmUgPSBwcm9jZXNzRGlyZWN0aXZlO1xuICB2YXIgbWV0aG9kQ2FsbFBhdHRlcm4gPSAvXihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopXFwoLyxcbiAgICAgIG1ldGhvZENhbGxFeGNlc3NQYXR0ZXJuID0gL1xcKVxccyokLyxcbiAgICAgIEV4cHJlc3Npb25QYXJzZXI7XG5cbiAgRXhwcmVzc2lvblBhcnNlciA9IHBhcnNlX1BhcnNlci5leHRlbmQoe1xuICBcdGNvbnZlcnRlcnM6IFtjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uXVxuICB9KTtcbiAgZnVuY3Rpb24gcHJvY2Vzc0RpcmVjdGl2ZSh0b2tlbnMsIHBhcmVudFBhcnNlcikge1xuICBcdHZhciByZXN1bHQsIG1hdGNoLCBwYXJzZXIsIGFyZ3MsIHRva2VuLCBjb2xvbkluZGV4LCBkaXJlY3RpdmVOYW1lLCBkaXJlY3RpdmVBcmdzLCBwYXJzZWQ7XG5cbiAgXHRpZiAodHlwZW9mIHRva2VucyA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0aWYgKG1hdGNoID0gbWV0aG9kQ2FsbFBhdHRlcm4uZXhlYyh0b2tlbnMpKSB7XG4gIFx0XHRcdHZhciBlbmQgPSB0b2tlbnMubGFzdEluZGV4T2YoXCIpXCIpO1xuXG4gIFx0XHRcdC8vIGNoZWNrIGZvciBpbnZhbGlkIG1ldGhvZCBjYWxsc1xuICBcdFx0XHRpZiAoIW1ldGhvZENhbGxFeGNlc3NQYXR0ZXJuLnRlc3QodG9rZW5zKSkge1xuICBcdFx0XHRcdHBhcmVudFBhcnNlci5lcnJvcihcIkludmFsaWQgaW5wdXQgYWZ0ZXIgbWV0aG9kIGNhbGwgZXhwcmVzc2lvbiAnXCIgKyB0b2tlbnMuc2xpY2UoZW5kICsgMSkgKyBcIidcIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXN1bHQgPSB7IG06IG1hdGNoWzFdIH07XG4gIFx0XHRcdGFyZ3MgPSBcIltcIiArIHRva2Vucy5zbGljZShyZXN1bHQubS5sZW5ndGggKyAxLCBlbmQpICsgXCJdXCI7XG5cbiAgXHRcdFx0cGFyc2VyID0gbmV3IEV4cHJlc3Npb25QYXJzZXIoYXJncyk7XG4gIFx0XHRcdHJlc3VsdC5hID0gdXRpbHNfZmxhdHRlbkV4cHJlc3Npb24ocGFyc2VyLnJlc3VsdFswXSk7XG5cbiAgXHRcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRva2Vucy5pbmRleE9mKFwiOlwiKSA9PT0gLTEpIHtcbiAgXHRcdFx0cmV0dXJuIHRva2Vucy50cmltKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRva2VucyA9IFt0b2tlbnNdO1xuICBcdH1cblxuICBcdHJlc3VsdCA9IHt9O1xuXG4gIFx0ZGlyZWN0aXZlTmFtZSA9IFtdO1xuICBcdGRpcmVjdGl2ZUFyZ3MgPSBbXTtcblxuICBcdGlmICh0b2tlbnMpIHtcbiAgXHRcdHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gIFx0XHRcdHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG5cbiAgXHRcdFx0aWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRcdGNvbG9uSW5kZXggPSB0b2tlbi5pbmRleE9mKFwiOlwiKTtcblxuICBcdFx0XHRcdGlmIChjb2xvbkluZGV4ID09PSAtMSkge1xuICBcdFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKHRva2VuKTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gIFx0XHRcdFx0XHQvLyBpcyB0aGUgY29sb24gdGhlIGZpcnN0IGNoYXJhY3Rlcj9cbiAgXHRcdFx0XHRcdGlmIChjb2xvbkluZGV4KSB7XG4gIFx0XHRcdFx0XHRcdC8vIG5vXG4gIFx0XHRcdFx0XHRcdGRpcmVjdGl2ZU5hbWUucHVzaCh0b2tlbi5zdWJzdHIoMCwgY29sb25JbmRleCkpO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHQvLyBpZiB0aGVyZSBpcyBhbnl0aGluZyBhZnRlciB0aGUgY29sb24gaW4gdGhpcyB0b2tlbiwgdHJlYXRcbiAgXHRcdFx0XHRcdC8vIGl0IGFzIHRoZSBmaXJzdCB0b2tlbiBvZiB0aGUgZGlyZWN0aXZlQXJncyBmcmFnbWVudFxuICBcdFx0XHRcdFx0aWYgKHRva2VuLmxlbmd0aCA+IGNvbG9uSW5kZXggKyAxKSB7XG4gIFx0XHRcdFx0XHRcdGRpcmVjdGl2ZUFyZ3NbMF0gPSB0b2tlbi5zdWJzdHJpbmcoY29sb25JbmRleCArIDEpO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHRicmVhaztcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKHRva2VuKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRkaXJlY3RpdmVBcmdzID0gZGlyZWN0aXZlQXJncy5jb25jYXQodG9rZW5zKTtcbiAgXHR9XG5cbiAgXHRpZiAoIWRpcmVjdGl2ZU5hbWUubGVuZ3RoKSB7XG4gIFx0XHRyZXN1bHQgPSBcIlwiO1xuICBcdH0gZWxzZSBpZiAoZGlyZWN0aXZlQXJncy5sZW5ndGggfHwgdHlwZW9mIGRpcmVjdGl2ZU5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHJlc3VsdCA9IHtcbiAgXHRcdFx0Ly8gVE9ETyBpcyB0aGlzIHJlYWxseSBuZWNlc3Nhcnk/IGp1c3QgdXNlIHRoZSBhcnJheVxuICBcdFx0XHRuOiBkaXJlY3RpdmVOYW1lLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZGlyZWN0aXZlTmFtZVswXSA9PT0gXCJzdHJpbmdcIiA/IGRpcmVjdGl2ZU5hbWVbMF0gOiBkaXJlY3RpdmVOYW1lXG4gIFx0XHR9O1xuXG4gIFx0XHRpZiAoZGlyZWN0aXZlQXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGRpcmVjdGl2ZUFyZ3NbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0cGFyc2VkID0gcGFyc2VKU09OKFwiW1wiICsgZGlyZWN0aXZlQXJnc1swXSArIFwiXVwiKTtcbiAgXHRcdFx0cmVzdWx0LmEgPSBwYXJzZWQgPyBwYXJzZWQudmFsdWUgOiBkaXJlY3RpdmVBcmdzWzBdLnRyaW0oKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJlc3VsdC5kID0gZGlyZWN0aXZlQXJncztcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0cmVzdWx0ID0gZGlyZWN0aXZlTmFtZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIHRhZ05hbWVQYXR0ZXJuID0gL15bYS16QS1aXXsxLH06P1thLXpBLVowLTlcXC1dKi8sXG4gICAgICB2YWxpZFRhZ05hbWVGb2xsb3dlciA9IC9eW1xcc1xcblxcLz5dLyxcbiAgICAgIG9uUGF0dGVybiA9IC9eb24vLFxuICAgICAgcHJveHlFdmVudFBhdHRlcm4gPSAvXm9uLShbYS16QS1aXFxcXCpcXFxcLiRfXVthLXpBLVpcXFxcKlxcXFwuJF8wLTlcXC1dKykkLyxcbiAgICAgIHJlc2VydmVkRXZlbnROYW1lcyA9IC9eKD86Y2hhbmdlfHJlc2V0fHRlYXJkb3dufHVwZGF0ZXxjb25zdHJ1Y3R8Y29uZmlnfGluaXR8cmVuZGVyfHVucmVuZGVyfGRldGFjaHxpbnNlcnQpJC8sXG4gICAgICBkaXJlY3RpdmVzID0geyBcImludHJvLW91dHJvXCI6IFwidDBcIiwgaW50cm86IFwidDFcIiwgb3V0cm86IFwidDJcIiwgZGVjb3JhdG9yOiBcIm9cIiB9LFxuICAgICAgZXhjbHVkZSA9IHsgZXhjbHVkZTogdHJ1ZSB9LFxuICAgICAgZGlzYWxsb3dlZENvbnRlbnRzO1xuXG4gIC8vIGJhc2VkIG9uIGh0dHA6Ly9kZXZlbG9wZXJzLndoYXR3Zy5vcmcvc3ludGF4Lmh0bWwjc3ludGF4LXRhZy1vbWlzc2lvblxuICBkaXNhbGxvd2VkQ29udGVudHMgPSB7XG4gIFx0bGk6IFtcImxpXCJdLFxuICBcdGR0OiBbXCJkdFwiLCBcImRkXCJdLFxuICBcdGRkOiBbXCJkdFwiLCBcImRkXCJdLFxuICBcdHA6IFwiYWRkcmVzcyBhcnRpY2xlIGFzaWRlIGJsb2NrcXVvdGUgZGl2IGRsIGZpZWxkc2V0IGZvb3RlciBmb3JtIGgxIGgyIGgzIGg0IGg1IGg2IGhlYWRlciBoZ3JvdXAgaHIgbWFpbiBtZW51IG5hdiBvbCBwIHByZSBzZWN0aW9uIHRhYmxlIHVsXCIuc3BsaXQoXCIgXCIpLFxuICBcdHJ0OiBbXCJydFwiLCBcInJwXCJdLFxuICBcdHJwOiBbXCJydFwiLCBcInJwXCJdLFxuICBcdG9wdGdyb3VwOiBbXCJvcHRncm91cFwiXSxcbiAgXHRvcHRpb246IFtcIm9wdGlvblwiLCBcIm9wdGdyb3VwXCJdLFxuICBcdHRoZWFkOiBbXCJ0Ym9keVwiLCBcInRmb290XCJdLFxuICBcdHRib2R5OiBbXCJ0Ym9keVwiLCBcInRmb290XCJdLFxuICBcdHRmb290OiBbXCJ0Ym9keVwiXSxcbiAgXHR0cjogW1widHJcIiwgXCJ0Ym9keVwiXSxcbiAgXHR0ZDogW1widGRcIiwgXCJ0aFwiLCBcInRyXCJdLFxuICBcdHRoOiBbXCJ0ZFwiLCBcInRoXCIsIFwidHJcIl1cbiAgfTtcblxuICB2YXIgY29udmVydGVyc19yZWFkRWxlbWVudCA9IHJlYWRFbGVtZW50O1xuXG4gIGZ1bmN0aW9uIHJlYWRFbGVtZW50KHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgZWxlbWVudCwgZGlyZWN0aXZlTmFtZSwgbWF0Y2gsIGFkZFByb3h5RXZlbnQsIGF0dHJpYnV0ZSwgZGlyZWN0aXZlLCBzZWxmQ2xvc2luZywgY2hpbGRyZW4sIHBhcnRpYWxzLCBoYXNQYXJ0aWFscywgY2hpbGQsIGNsb3NlZCwgcG9zLCByZW1haW5pbmcsIGNsb3NpbmdUYWc7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAocGFyc2VyLmluc2lkZSB8fCBwYXJzZXIuaW5BdHRyaWJ1dGUpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiPFwiKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gaWYgdGhpcyBpcyBhIGNsb3NpbmcgdGFnLCBhYm9ydCBzdHJhaWdodCBhd2F5XG4gIFx0aWYgKHBhcnNlci5uZXh0Q2hhcigpID09PSBcIi9cIikge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0ZWxlbWVudCA9IHt9O1xuICBcdGlmIChwYXJzZXIuaW5jbHVkZUxpbmVQb3NpdGlvbnMpIHtcbiAgXHRcdGVsZW1lbnQucCA9IHBhcnNlci5nZXRMaW5lUG9zKHN0YXJ0KTtcbiAgXHR9XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiIVwiKSkge1xuICBcdFx0ZWxlbWVudC50ID0gRE9DVFlQRTtcbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoUGF0dGVybigvXmRvY3R5cGUvaSkpIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgRE9DVFlQRSBkZWNsYXJhdGlvblwiKTtcbiAgXHRcdH1cblxuICBcdFx0ZWxlbWVudC5hID0gcGFyc2VyLm1hdGNoUGF0dGVybigvXiguKz8pPi8pO1xuICBcdFx0cmV0dXJuIGVsZW1lbnQ7XG4gIFx0fVxuXG4gIFx0ZWxlbWVudC50ID0gRUxFTUVOVDtcblxuICBcdC8vIGVsZW1lbnQgbmFtZVxuICBcdGVsZW1lbnQuZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4odGFnTmFtZVBhdHRlcm4pO1xuICBcdGlmICghZWxlbWVudC5lKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBuZXh0IGNoYXJhY3RlciBtdXN0IGJlIHdoaXRlc3BhY2UsIGNsb3Npbmcgc29saWR1cyBvciAnPidcbiAgXHRpZiAoIXZhbGlkVGFnTmFtZUZvbGxvd2VyLnRlc3QocGFyc2VyLm5leHRDaGFyKCkpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJJbGxlZ2FsIHRhZyBuYW1lXCIpO1xuICBcdH1cblxuICBcdGFkZFByb3h5RXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZGlyZWN0aXZlKSB7XG4gIFx0XHR2YXIgZGlyZWN0aXZlTmFtZSA9IGRpcmVjdGl2ZS5uIHx8IGRpcmVjdGl2ZTtcblxuICBcdFx0aWYgKHJlc2VydmVkRXZlbnROYW1lcy50ZXN0KGRpcmVjdGl2ZU5hbWUpKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgLT0gZGlyZWN0aXZlTmFtZS5sZW5ndGg7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIkNhbm5vdCB1c2UgcmVzZXJ2ZWQgZXZlbnQgbmFtZXMgKGNoYW5nZSwgcmVzZXQsIHRlYXJkb3duLCB1cGRhdGUsIGNvbnN0cnVjdCwgY29uZmlnLCBpbml0LCByZW5kZXIsIHVucmVuZGVyLCBkZXRhY2gsIGluc2VydClcIik7XG4gIFx0XHR9XG5cbiAgXHRcdGVsZW1lbnQudltuYW1lXSA9IGRpcmVjdGl2ZTtcbiAgXHR9O1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gZGlyZWN0aXZlcyBhbmQgYXR0cmlidXRlc1xuICBcdHdoaWxlIChhdHRyaWJ1dGUgPSBjb252ZXJ0ZXJzX3JlYWRNdXN0YWNoZShwYXJzZXIpIHx8IGVsZW1lbnRfcmVhZEF0dHJpYnV0ZShwYXJzZXIpKSB7XG4gIFx0XHQvLyByZWd1bGFyIGF0dHJpYnV0ZXNcbiAgXHRcdGlmIChhdHRyaWJ1dGUubmFtZSkge1xuICBcdFx0XHQvLyBpbnRybywgb3V0cm8sIGRlY29yYXRvclxuICBcdFx0XHRpZiAoZGlyZWN0aXZlTmFtZSA9IGRpcmVjdGl2ZXNbYXR0cmlidXRlLm5hbWVdKSB7XG4gIFx0XHRcdFx0ZWxlbWVudFtkaXJlY3RpdmVOYW1lXSA9IGVsZW1lbnRfcHJvY2Vzc0RpcmVjdGl2ZShhdHRyaWJ1dGUudmFsdWUsIHBhcnNlcik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBvbi1jbGljayBldGNcbiAgXHRcdFx0ZWxzZSBpZiAobWF0Y2ggPSBwcm94eUV2ZW50UGF0dGVybi5leGVjKGF0dHJpYnV0ZS5uYW1lKSkge1xuICBcdFx0XHRcdGlmICghZWxlbWVudC52KSBlbGVtZW50LnYgPSB7fTtcbiAgXHRcdFx0XHRkaXJlY3RpdmUgPSBlbGVtZW50X3Byb2Nlc3NEaXJlY3RpdmUoYXR0cmlidXRlLnZhbHVlLCBwYXJzZXIpO1xuICBcdFx0XHRcdGFkZFByb3h5RXZlbnQobWF0Y2hbMV0sIGRpcmVjdGl2ZSk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0aWYgKCFwYXJzZXIuc2FuaXRpemVFdmVudEF0dHJpYnV0ZXMgfHwgIW9uUGF0dGVybi50ZXN0KGF0dHJpYnV0ZS5uYW1lKSkge1xuICBcdFx0XHRcdFx0aWYgKCFlbGVtZW50LmEpIGVsZW1lbnQuYSA9IHt9O1xuICBcdFx0XHRcdFx0ZWxlbWVudC5hW2F0dHJpYnV0ZS5uYW1lXSA9IGF0dHJpYnV0ZS52YWx1ZSB8fCAoYXR0cmlidXRlLnZhbHVlID09PSBcIlwiID8gXCJcIiA6IDApO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyB7eyNpZiBmb299fWNsYXNzPSdmb28ne3svaWZ9fVxuICBcdFx0ZWxzZSB7XG4gIFx0XHRcdGlmICghZWxlbWVudC5tKSBlbGVtZW50Lm0gPSBbXTtcbiAgXHRcdFx0ZWxlbWVudC5tLnB1c2goYXR0cmlidXRlKTtcbiAgXHRcdH1cblxuICBcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdH1cblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIGNsb3Npbmcgc29saWR1c1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIHNlbGYtY2xvc2luZyBzb2xpZHVzP1xuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIvXCIpKSB7XG4gIFx0XHRzZWxmQ2xvc2luZyA9IHRydWU7XG4gIFx0fVxuXG4gIFx0Ly8gY2xvc2luZyBhbmdsZSBicmFja2V0XG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI+XCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHR2YXIgbG93ZXJDYXNlTmFtZSA9IGVsZW1lbnQuZS50b0xvd2VyQ2FzZSgpO1xuICBcdHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBwYXJzZXIucHJlc2VydmVXaGl0ZXNwYWNlO1xuXG4gIFx0aWYgKCFzZWxmQ2xvc2luZyAmJiAhdm9pZEVsZW1lbnROYW1lcy50ZXN0KGVsZW1lbnQuZSkpIHtcbiAgXHRcdHBhcnNlci5lbGVtZW50U3RhY2sucHVzaChsb3dlckNhc2VOYW1lKTtcblxuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gaWYgd2Ugb3BlbiBhIHNjcmlwdCBlbGVtZW50LCBmdXJ0aGVyIHRhZ3Mgc2hvdWxkXG4gIFx0XHQvLyBiZSBpZ25vcmVkIHVubGVzcyB0aGV5J3JlIGEgY2xvc2luZyBzY3JpcHQgZWxlbWVudFxuICBcdFx0aWYgKGxvd2VyQ2FzZU5hbWUgPT09IFwic2NyaXB0XCIgfHwgbG93ZXJDYXNlTmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gIFx0XHRcdHBhcnNlci5pbnNpZGUgPSBsb3dlckNhc2VOYW1lO1xuICBcdFx0fVxuXG4gIFx0XHRjaGlsZHJlbiA9IFtdO1xuICBcdFx0cGFydGlhbHMgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHRcdGRvIHtcbiAgXHRcdFx0cG9zID0gcGFyc2VyLnBvcztcbiAgXHRcdFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXG4gIFx0XHRcdC8vIGlmIGZvciBleGFtcGxlIHdlJ3JlIGluIGFuIDxsaT4gZWxlbWVudCwgYW5kIHdlIHNlZSBhbm90aGVyXG4gIFx0XHRcdC8vIDxsaT4gdGFnLCBjbG9zZSB0aGUgZmlyc3Qgc28gdGhleSBiZWNvbWUgc2libGluZ3NcbiAgXHRcdFx0aWYgKCFjYW5Db250YWluKGxvd2VyQ2FzZU5hbWUsIHJlbWFpbmluZykpIHtcbiAgXHRcdFx0XHRjbG9zZWQgPSB0cnVlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gY2xvc2luZyB0YWdcbiAgXHRcdFx0ZWxzZSBpZiAoY2xvc2luZ1RhZyA9IGVsZW1lbnRfcmVhZENsb3NpbmdUYWcocGFyc2VyKSkge1xuICBcdFx0XHRcdGNsb3NlZCA9IHRydWU7XG5cbiAgXHRcdFx0XHR2YXIgY2xvc2luZ1RhZ05hbWUgPSBjbG9zaW5nVGFnLmUudG9Mb3dlckNhc2UoKTtcblxuICBcdFx0XHRcdC8vIGlmIHRoaXMgKmlzbid0KiB0aGUgY2xvc2luZyB0YWcgZm9yIHRoZSBjdXJyZW50IGVsZW1lbnQuLi5cbiAgXHRcdFx0XHRpZiAoY2xvc2luZ1RhZ05hbWUgIT09IGxvd2VyQ2FzZU5hbWUpIHtcbiAgXHRcdFx0XHRcdC8vIHJld2luZCBwYXJzZXJcbiAgXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBwb3M7XG5cbiAgXHRcdFx0XHRcdC8vIGlmIGl0IGRvZXNuJ3QgY2xvc2UgYSBwYXJlbnQgdGFnLCBlcnJvclxuICBcdFx0XHRcdFx0aWYgKCEgfnBhcnNlci5lbGVtZW50U3RhY2suaW5kZXhPZihjbG9zaW5nVGFnTmFtZSkpIHtcbiAgXHRcdFx0XHRcdFx0dmFyIGVycm9yTWVzc2FnZSA9IFwiVW5leHBlY3RlZCBjbG9zaW5nIHRhZ1wiO1xuXG4gIFx0XHRcdFx0XHRcdC8vIGFkZCBhZGRpdGlvbmFsIGhlbHAgZm9yIHZvaWQgZWxlbWVudHMsIHNpbmNlIGNvbXBvbmVudCBuYW1lc1xuICBcdFx0XHRcdFx0XHQvLyBtaWdodCBjbGFzaCB3aXRoIHRoZW1cbiAgXHRcdFx0XHRcdFx0aWYgKHZvaWRFbGVtZW50TmFtZXMudGVzdChjbG9zaW5nVGFnTmFtZSkpIHtcbiAgXHRcdFx0XHRcdFx0XHRlcnJvck1lc3NhZ2UgKz0gXCIgKDxcIiArIGNsb3NpbmdUYWdOYW1lICsgXCI+IGlzIGEgdm9pZCBlbGVtZW50IC0gaXQgY2Fubm90IGNvbnRhaW4gY2hpbGRyZW4pXCI7XG4gIFx0XHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBpbXBsaWNpdCBjbG9zZSBieSBjbG9zaW5nIHNlY3Rpb24gdGFnLiBUT0RPIGNsZWFuIHRoaXMgdXBcbiAgXHRcdFx0ZWxzZSBpZiAoY2hpbGQgPSBzZWN0aW9uX3JlYWRDbG9zaW5nKHBhcnNlciwgeyBvcGVuOiBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzBdLCBjbG9zZTogcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVyc1sxXSB9KSkge1xuICBcdFx0XHRcdGNsb3NlZCA9IHRydWU7XG4gIFx0XHRcdFx0cGFyc2VyLnBvcyA9IHBvcztcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRpZiAoY2hpbGQgPSBwYXJzZXIucmVhZChQQVJUSUFMX1JFQURFUlMpKSB7XG4gIFx0XHRcdFx0XHRpZiAocGFydGlhbHNbY2hpbGQubl0pIHtcbiAgXHRcdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHBvcztcbiAgXHRcdFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiRHVwbGljYXRlIHBhcnRpYWwgZGVmaW5pdGlvblwiKTtcbiAgXHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0dXRpbHNfY2xlYW51cChjaGlsZC5mLCBwYXJzZXIuc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCAhcHJlc2VydmVXaGl0ZXNwYWNlLCAhcHJlc2VydmVXaGl0ZXNwYWNlKTtcblxuICBcdFx0XHRcdFx0cGFydGlhbHNbY2hpbGQubl0gPSBjaGlsZC5mO1xuICBcdFx0XHRcdFx0aGFzUGFydGlhbHMgPSB0cnVlO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRpZiAoY2hpbGQgPSBwYXJzZXIucmVhZChSRUFERVJTKSkge1xuICBcdFx0XHRcdFx0XHRjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgXHRcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRcdGNsb3NlZCA9IHRydWU7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9IHdoaWxlICghY2xvc2VkKTtcblxuICBcdFx0aWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICBcdFx0XHRlbGVtZW50LmYgPSBjaGlsZHJlbjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGhhc1BhcnRpYWxzKSB7XG4gIFx0XHRcdGVsZW1lbnQucCA9IHBhcnRpYWxzO1xuICBcdFx0fVxuXG4gIFx0XHRwYXJzZXIuZWxlbWVudFN0YWNrLnBvcCgpO1xuICBcdH1cblxuICBcdHBhcnNlci5pbnNpZGUgPSBudWxsO1xuXG4gIFx0aWYgKHBhcnNlci5zYW5pdGl6ZUVsZW1lbnRzICYmIHBhcnNlci5zYW5pdGl6ZUVsZW1lbnRzLmluZGV4T2YobG93ZXJDYXNlTmFtZSkgIT09IC0xKSB7XG4gIFx0XHRyZXR1cm4gZXhjbHVkZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbkNvbnRhaW4obmFtZSwgcmVtYWluaW5nKSB7XG4gIFx0dmFyIG1hdGNoLCBkaXNhbGxvd2VkO1xuXG4gIFx0bWF0Y2ggPSAvXjwoW2EtekEtWl1bYS16QS1aMC05XSopLy5leGVjKHJlbWFpbmluZyk7XG4gIFx0ZGlzYWxsb3dlZCA9IGRpc2FsbG93ZWRDb250ZW50c1tuYW1lXTtcblxuICBcdGlmICghbWF0Y2ggfHwgIWRpc2FsbG93ZWQpIHtcbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cblxuICBcdHJldHVybiAhIH5kaXNhbGxvd2VkLmluZGV4T2YobWF0Y2hbMV0udG9Mb3dlckNhc2UoKSk7XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkVGV4dCA9IHJlYWRUZXh0O1xuICBmdW5jdGlvbiByZWFkVGV4dChwYXJzZXIpIHtcbiAgXHR2YXIgaW5kZXgsIHJlbWFpbmluZywgZGlzYWxsb3dlZCwgYmFycmllcjtcblxuICBcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblxuICBcdGJhcnJpZXIgPSBwYXJzZXIuaW5zaWRlID8gXCI8L1wiICsgcGFyc2VyLmluc2lkZSA6IFwiPFwiO1xuXG4gIFx0aWYgKHBhcnNlci5pbnNpZGUgJiYgIXBhcnNlci5pbnRlcnBvbGF0ZVtwYXJzZXIuaW5zaWRlXSkge1xuICBcdFx0aW5kZXggPSByZW1haW5pbmcuaW5kZXhPZihiYXJyaWVyKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0ZGlzYWxsb3dlZCA9IHBhcnNlci50YWdzLm1hcChmdW5jdGlvbiAodCkge1xuICBcdFx0XHRyZXR1cm4gdC5vcGVuO1xuICBcdFx0fSk7XG4gIFx0XHRkaXNhbGxvd2VkID0gZGlzYWxsb3dlZC5jb25jYXQocGFyc2VyLnRhZ3MubWFwKGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRcdHJldHVybiBcIlxcXFxcIiArIHQub3BlbjtcbiAgXHRcdH0pKTtcblxuICBcdFx0Ly8gaHR0cDovL2RldmVsb3BlcnMud2hhdHdnLm9yZy9zeW50YXguaHRtbCNzeW50YXgtYXR0cmlidXRlc1xuICBcdFx0aWYgKHBhcnNlci5pbkF0dHJpYnV0ZSA9PT0gdHJ1ZSkge1xuICBcdFx0XHQvLyB3ZSdyZSBpbnNpZGUgYW4gdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlXG4gIFx0XHRcdGRpc2FsbG93ZWQucHVzaChcIlxcXCJcIiwgXCInXCIsIFwiPVwiLCBcIjxcIiwgXCI+XCIsIFwiYFwiKTtcbiAgXHRcdH0gZWxzZSBpZiAocGFyc2VyLmluQXR0cmlidXRlKSB7XG4gIFx0XHRcdC8vIHF1b3RlZCBhdHRyaWJ1dGUgdmFsdWVcbiAgXHRcdFx0ZGlzYWxsb3dlZC5wdXNoKHBhcnNlci5pbkF0dHJpYnV0ZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRkaXNhbGxvd2VkLnB1c2goYmFycmllcik7XG4gIFx0XHR9XG5cbiAgXHRcdGluZGV4ID0gZ2V0TG93ZXN0SW5kZXgocmVtYWluaW5nLCBkaXNhbGxvd2VkKTtcbiAgXHR9XG5cbiAgXHRpZiAoIWluZGV4KSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRpbmRleCA9IHJlbWFpbmluZy5sZW5ndGg7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLnBvcyArPSBpbmRleDtcblxuICBcdHJldHVybiBwYXJzZXIuaW5zaWRlID8gcmVtYWluaW5nLnN1YnN0cigwLCBpbmRleCkgOiBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKHJlbWFpbmluZy5zdWJzdHIoMCwgaW5kZXgpKTtcbiAgfVxuXG4gIHZhciB1dGlsc19lc2NhcGVSZWdFeHAgPSBlc2NhcGVSZWdFeHA7XG4gIHZhciB1dGlsc19lc2NhcGVSZWdFeHBfX3BhdHRlcm4gPSAvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZztcbiAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICBcdHJldHVybiBzdHIucmVwbGFjZSh1dGlsc19lc2NhcGVSZWdFeHBfX3BhdHRlcm4sIFwiXFxcXCQmXCIpO1xuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZFBhcnRpYWxEZWZpbml0aW9uQ29tbWVudCA9IHJlYWRQYXJ0aWFsRGVmaW5pdGlvbkNvbW1lbnQ7XG5cbiAgdmFyIHN0YXJ0UGF0dGVybiA9IC9ePCEtLVxccyovLFxuICAgICAgbmFtZVBhdHRlcm4gPSAvcyo+XFxzKihbYS16QS1aXyRdWy1hLXpBLVpfJDAtOV0qKVxccyovLFxuICAgICAgZmluaXNoUGF0dGVybiA9IC9cXHMqLS0+LyxcbiAgICAgIGNoaWxkO1xuXG4gIGZ1bmN0aW9uIHJlYWRQYXJ0aWFsRGVmaW5pdGlvbkNvbW1lbnQocGFyc2VyKSB7XG4gIFx0dmFyIGZpcnN0UG9zID0gcGFyc2VyLnBvcyxcbiAgXHQgICAgb3BlbiA9IHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnNbMF0sXG4gIFx0ICAgIGNsb3NlID0gcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVyc1sxXSxcbiAgXHQgICAgY29udGVudCA9IHVuZGVmaW5lZCxcbiAgXHQgICAgY2xvc2VkID0gdW5kZWZpbmVkO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hQYXR0ZXJuKHN0YXJ0UGF0dGVybikgfHwgIXBhcnNlci5tYXRjaFN0cmluZyhvcGVuKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IGZpcnN0UG9zO1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0dmFyIG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKG5hbWVQYXR0ZXJuKTtcblxuICBcdHdhcm5PbmNlSWZEZWJ1ZyhcIklubGluZSBwYXJ0aWFsIGNvbW1lbnRzIGFyZSBkZXByZWNhdGVkLlxcblVzZSB0aGlzLi4uXFxuICB7eyNwYXJ0aWFsIFwiICsgbmFtZSArIFwifX0gLi4uIHt7L3BhcnRpYWx9fVxcblxcbi4uLmluc3RlYWQgb2YgdGhpczpcXG4gIDwhLS0ge3s+XCIgKyBuYW1lICsgXCJ9fSAtLT4gLi4uIDwhLS0ge3svXCIgKyBuYW1lICsgXCJ9fSAtLT4nXCIpO1xuXG4gIFx0Ly8gbWFrZSBzdXJlIHRoZSByZXN0IG9mIHRoZSBjb21tZW50IGlzIGluIHRoZSBjb3JyZWN0IHBsYWNlXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoY2xvc2UpIHx8ICFwYXJzZXIubWF0Y2hQYXR0ZXJuKGZpbmlzaFBhdHRlcm4pKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gZmlyc3RQb3M7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRjb250ZW50ID0gW107XG5cbiAgXHR2YXIgZW5kUGF0dGVybiA9IG5ldyBSZWdFeHAoXCJePCEtLVxcXFxzKlwiICsgdXRpbHNfZXNjYXBlUmVnRXhwKG9wZW4pICsgXCJcXFxccypcXFxcL1xcXFxzKlwiICsgbmFtZSArIFwiXFxcXHMqXCIgKyB1dGlsc19lc2NhcGVSZWdFeHAoY2xvc2UpICsgXCJcXFxccyotLT5cIik7XG5cbiAgXHRkbyB7XG4gIFx0XHRpZiAocGFyc2VyLm1hdGNoUGF0dGVybihlbmRQYXR0ZXJuKSkge1xuICBcdFx0XHRjbG9zZWQgPSB0cnVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Y2hpbGQgPSBwYXJzZXIucmVhZChSRUFERVJTKTtcbiAgXHRcdFx0aWYgKCFjaGlsZCkge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcImV4cGVjdGVkIGNsb3NpbmcgY29tbWVudCAoJzwhLS0gXCIgKyBvcGVuICsgXCIvXCIgKyBuYW1lICsgXCJcIiArIGNsb3NlICsgXCIgLS0+JylcIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjb250ZW50LnB1c2goY2hpbGQpO1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKCFjbG9zZWQpO1xuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IElOTElORV9QQVJUSUFMLFxuICBcdFx0ZjogY29udGVudCxcbiAgXHRcdG46IG5hbWVcbiAgXHR9O1xuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZFBhcnRpYWxEZWZpbml0aW9uU2VjdGlvbiA9IHJlYWRQYXJ0aWFsRGVmaW5pdGlvblNlY3Rpb247XG4gIHZhciBwYXJ0aWFsRGVmaW5pdGlvblNlY3Rpb25QYXR0ZXJuID0gL14jXFxzKnBhcnRpYWxcXHMrLztcbiAgZnVuY3Rpb24gcmVhZFBhcnRpYWxEZWZpbml0aW9uU2VjdGlvbihwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIG5hbWUsIGNvbnRlbnQsIGNoaWxkLCBjbG9zZWQ7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHR2YXIgZGVsaW1pdGVycyA9IHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnM7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhkZWxpbWl0ZXJzWzBdKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hQYXR0ZXJuKHBhcnRpYWxEZWZpbml0aW9uU2VjdGlvblBhdHRlcm4pKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybigvXlthLXpBLVpfJF1bYS16QS1aXyQwLTlcXC1dKi8pO1xuXG4gIFx0aWYgKCFuYW1lKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJleHBlY3RlZCBsZWdhbCBwYXJ0aWFsIG5hbWVcIik7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoZGVsaW1pdGVyc1sxXSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIGRlbGltaXRlcnNbMV0gKyBcIidcIik7XG4gIFx0fVxuXG4gIFx0Y29udGVudCA9IFtdO1xuXG4gIFx0ZG8ge1xuICBcdFx0Ly8gVE9ETyBjbGVhbiB0aGlzIHVwXG4gIFx0XHRpZiAoY2hpbGQgPSBzZWN0aW9uX3JlYWRDbG9zaW5nKHBhcnNlciwgeyBvcGVuOiBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzBdLCBjbG9zZTogcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVyc1sxXSB9KSkge1xuICBcdFx0XHRpZiAoIWNoaWxkLnIgPT09IFwicGFydGlhbFwiKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgXCIgKyBkZWxpbWl0ZXJzWzBdICsgXCIvcGFydGlhbFwiICsgZGVsaW1pdGVyc1sxXSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjbG9zZWQgPSB0cnVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Y2hpbGQgPSBwYXJzZXIucmVhZChSRUFERVJTKTtcblxuICBcdFx0XHRpZiAoIWNoaWxkKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgXCIgKyBkZWxpbWl0ZXJzWzBdICsgXCIvcGFydGlhbFwiICsgZGVsaW1pdGVyc1sxXSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjb250ZW50LnB1c2goY2hpbGQpO1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKCFjbG9zZWQpO1xuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IElOTElORV9QQVJUSUFMLFxuICBcdFx0bjogbmFtZSxcbiAgXHRcdGY6IGNvbnRlbnRcbiAgXHR9O1xuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZFRlbXBsYXRlID0gcmVhZFRlbXBsYXRlO1xuICBmdW5jdGlvbiByZWFkVGVtcGxhdGUocGFyc2VyKSB7XG4gIFx0dmFyIGZyYWdtZW50ID0gW107XG4gIFx0dmFyIHBhcnRpYWxzID0gY3JlYXRlKG51bGwpO1xuICBcdHZhciBoYXNQYXJ0aWFscyA9IGZhbHNlO1xuXG4gIFx0dmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IHBhcnNlci5wcmVzZXJ2ZVdoaXRlc3BhY2U7XG5cbiAgXHR3aGlsZSAocGFyc2VyLnBvcyA8IHBhcnNlci5zdHIubGVuZ3RoKSB7XG4gIFx0XHR2YXIgcG9zID0gcGFyc2VyLnBvcyxcbiAgXHRcdCAgICBpdGVtID0gdW5kZWZpbmVkLFxuICBcdFx0ICAgIHBhcnRpYWwgPSB1bmRlZmluZWQ7XG5cbiAgXHRcdGlmIChwYXJ0aWFsID0gcGFyc2VyLnJlYWQoUEFSVElBTF9SRUFERVJTKSkge1xuICBcdFx0XHRpZiAocGFydGlhbHNbcGFydGlhbC5uXSkge1xuICBcdFx0XHRcdHBhcnNlci5wb3MgPSBwb3M7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiRHVwbGljYXRlZCBwYXJ0aWFsIGRlZmluaXRpb25cIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR1dGlsc19jbGVhbnVwKHBhcnRpYWwuZiwgcGFyc2VyLnN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgIXByZXNlcnZlV2hpdGVzcGFjZSwgIXByZXNlcnZlV2hpdGVzcGFjZSk7XG5cbiAgXHRcdFx0cGFydGlhbHNbcGFydGlhbC5uXSA9IHBhcnRpYWwuZjtcbiAgXHRcdFx0aGFzUGFydGlhbHMgPSB0cnVlO1xuICBcdFx0fSBlbHNlIGlmIChpdGVtID0gcGFyc2VyLnJlYWQoUkVBREVSUykpIHtcbiAgXHRcdFx0ZnJhZ21lbnQucHVzaChpdGVtKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIlVuZXhwZWN0ZWQgdGVtcGxhdGUgY29udGVudFwiKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR2YXIgcmVzdWx0ID0ge1xuICBcdFx0djogVEVNUExBVEVfVkVSU0lPTixcbiAgXHRcdHQ6IGZyYWdtZW50XG4gIFx0fTtcblxuICBcdGlmIChoYXNQYXJ0aWFscykge1xuICBcdFx0cmVzdWx0LnAgPSBwYXJ0aWFscztcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIF9wYXJzZSA9IHBhcnNlO1xuXG4gIHZhciBTVEFOREFSRF9SRUFERVJTID0gW211c3RhY2hlX3JlYWRQYXJ0aWFsLCBtdXN0YWNoZV9yZWFkVW5lc2NhcGVkLCBtdXN0YWNoZV9yZWFkU2VjdGlvbiwgbXVzdGFjaGVfcmVhZFlpZWxkZXIsIG11c3RhY2hlX3JlYWRJbnRlcnBvbGF0b3IsIHJlYWRNdXN0YWNoZUNvbW1lbnRdO1xuICB2YXIgVFJJUExFX1JFQURFUlMgPSBbbXVzdGFjaGVfcmVhZFRyaXBsZV07XG4gIHZhciBTVEFUSUNfUkVBREVSUyA9IFttdXN0YWNoZV9yZWFkVW5lc2NhcGVkLCBtdXN0YWNoZV9yZWFkU2VjdGlvbiwgbXVzdGFjaGVfcmVhZEludGVycG9sYXRvcl07IC8vIFRPRE8gZG9lcyBpdCBtYWtlIHNlbnNlIHRvIGhhdmUgYSBzdGF0aWMgc2VjdGlvbj9cblxuICB2YXIgU3RhbmRhcmRQYXJzZXIgPSB1bmRlZmluZWQ7XG4gIGZ1bmN0aW9uIHBhcnNlKHRlbXBsYXRlLCBvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBTdGFuZGFyZFBhcnNlcih0ZW1wbGF0ZSwgb3B0aW9ucyB8fCB7fSkucmVzdWx0O1xuICB9XG5cbiAgdmFyIFJFQURFUlMgPSBbY29udmVydGVyc19yZWFkTXVzdGFjaGUsIGNvbnZlcnRlcnNfcmVhZEh0bWxDb21tZW50LCBjb252ZXJ0ZXJzX3JlYWRFbGVtZW50LCBjb252ZXJ0ZXJzX3JlYWRUZXh0XTtcbiAgdmFyIFBBUlRJQUxfUkVBREVSUyA9IFtjb252ZXJ0ZXJzX3JlYWRQYXJ0aWFsRGVmaW5pdGlvbkNvbW1lbnQsIGNvbnZlcnRlcnNfcmVhZFBhcnRpYWxEZWZpbml0aW9uU2VjdGlvbl07XG5cbiAgU3RhbmRhcmRQYXJzZXIgPSBwYXJzZV9QYXJzZXIuZXh0ZW5kKHtcbiAgXHRpbml0OiBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG4gIFx0XHR2YXIgdHJpcGxlRGVsaW1pdGVycyA9IG9wdGlvbnMudHJpcGxlRGVsaW1pdGVycyB8fCBbXCJ7e3tcIiwgXCJ9fX1cIl0sXG4gIFx0XHQgICAgc3RhdGljRGVsaW1pdGVycyA9IG9wdGlvbnMuc3RhdGljRGVsaW1pdGVycyB8fCBbXCJbW1wiLCBcIl1dXCJdLFxuICBcdFx0ICAgIHN0YXRpY1RyaXBsZURlbGltaXRlcnMgPSBvcHRpb25zLnN0YXRpY1RyaXBsZURlbGltaXRlcnMgfHwgW1wiW1tbXCIsIFwiXV1dXCJdO1xuXG4gIFx0XHR0aGlzLnN0YW5kYXJkRGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycyB8fCBbXCJ7e1wiLCBcIn19XCJdO1xuXG4gIFx0XHR0aGlzLnRhZ3MgPSBbeyBpc1N0YXRpYzogZmFsc2UsIGlzVHJpcGxlOiBmYWxzZSwgb3BlbjogdGhpcy5zdGFuZGFyZERlbGltaXRlcnNbMF0sIGNsb3NlOiB0aGlzLnN0YW5kYXJkRGVsaW1pdGVyc1sxXSwgcmVhZGVyczogU1RBTkRBUkRfUkVBREVSUyB9LCB7IGlzU3RhdGljOiBmYWxzZSwgaXNUcmlwbGU6IHRydWUsIG9wZW46IHRyaXBsZURlbGltaXRlcnNbMF0sIGNsb3NlOiB0cmlwbGVEZWxpbWl0ZXJzWzFdLCByZWFkZXJzOiBUUklQTEVfUkVBREVSUyB9LCB7IGlzU3RhdGljOiB0cnVlLCBpc1RyaXBsZTogZmFsc2UsIG9wZW46IHN0YXRpY0RlbGltaXRlcnNbMF0sIGNsb3NlOiBzdGF0aWNEZWxpbWl0ZXJzWzFdLCByZWFkZXJzOiBTVEFUSUNfUkVBREVSUyB9LCB7IGlzU3RhdGljOiB0cnVlLCBpc1RyaXBsZTogdHJ1ZSwgb3Blbjogc3RhdGljVHJpcGxlRGVsaW1pdGVyc1swXSwgY2xvc2U6IHN0YXRpY1RyaXBsZURlbGltaXRlcnNbMV0sIHJlYWRlcnM6IFRSSVBMRV9SRUFERVJTIH1dO1xuXG4gIFx0XHR0aGlzLnNvcnRNdXN0YWNoZVRhZ3MoKTtcblxuICBcdFx0dGhpcy5zZWN0aW9uRGVwdGggPSAwO1xuICBcdFx0dGhpcy5lbGVtZW50U3RhY2sgPSBbXTtcblxuICBcdFx0dGhpcy5pbnRlcnBvbGF0ZSA9IHtcbiAgXHRcdFx0c2NyaXB0OiAhb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCBvcHRpb25zLmludGVycG9sYXRlLnNjcmlwdCAhPT0gZmFsc2UsXG4gIFx0XHRcdHN0eWxlOiAhb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCBvcHRpb25zLmludGVycG9sYXRlLnN0eWxlICE9PSBmYWxzZVxuICBcdFx0fTtcblxuICBcdFx0aWYgKG9wdGlvbnMuc2FuaXRpemUgPT09IHRydWUpIHtcbiAgXHRcdFx0b3B0aW9ucy5zYW5pdGl6ZSA9IHtcbiAgXHRcdFx0XHQvLyBibGFja2xpc3QgZnJvbSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1jYWphL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvY2FqYS9sYW5nL2h0bWwvaHRtbDQtZWxlbWVudHMtd2hpdGVsaXN0Lmpzb25cbiAgXHRcdFx0XHRlbGVtZW50czogXCJhcHBsZXQgYmFzZSBiYXNlZm9udCBib2R5IGZyYW1lIGZyYW1lc2V0IGhlYWQgaHRtbCBpc2luZGV4IGxpbmsgbWV0YSBub2ZyYW1lcyBub3NjcmlwdCBvYmplY3QgcGFyYW0gc2NyaXB0IHN0eWxlIHRpdGxlXCIuc3BsaXQoXCIgXCIpLFxuICBcdFx0XHRcdGV2ZW50QXR0cmlidXRlczogdHJ1ZVxuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnN0cmlwQ29tbWVudHMgPSBvcHRpb25zLnN0cmlwQ29tbWVudHMgIT09IGZhbHNlO1xuICBcdFx0dGhpcy5wcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZTtcbiAgXHRcdHRoaXMuc2FuaXRpemVFbGVtZW50cyA9IG9wdGlvbnMuc2FuaXRpemUgJiYgb3B0aW9ucy5zYW5pdGl6ZS5lbGVtZW50cztcbiAgXHRcdHRoaXMuc2FuaXRpemVFdmVudEF0dHJpYnV0ZXMgPSBvcHRpb25zLnNhbml0aXplICYmIG9wdGlvbnMuc2FuaXRpemUuZXZlbnRBdHRyaWJ1dGVzO1xuICBcdFx0dGhpcy5pbmNsdWRlTGluZVBvc2l0aW9ucyA9IG9wdGlvbnMuaW5jbHVkZUxpbmVQb3NpdGlvbnM7XG4gIFx0fSxcblxuICBcdHBvc3RQcm9jZXNzOiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBlbXB0eSBzdHJpbmdcbiAgXHRcdGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICBcdFx0XHRyZXR1cm4geyB0OiBbXSwgdjogVEVNUExBVEVfVkVSU0lPTiB9O1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5zZWN0aW9uRGVwdGggPiAwKSB7XG4gIFx0XHRcdHRoaXMuZXJyb3IoXCJBIHNlY3Rpb24gd2FzIGxlZnQgb3BlblwiKTtcbiAgXHRcdH1cblxuICBcdFx0dXRpbHNfY2xlYW51cChyZXN1bHRbMF0udCwgdGhpcy5zdHJpcENvbW1lbnRzLCB0aGlzLnByZXNlcnZlV2hpdGVzcGFjZSwgIXRoaXMucHJlc2VydmVXaGl0ZXNwYWNlLCAhdGhpcy5wcmVzZXJ2ZVdoaXRlc3BhY2UpO1xuXG4gIFx0XHRyZXR1cm4gcmVzdWx0WzBdO1xuICBcdH0sXG5cbiAgXHRjb252ZXJ0ZXJzOiBbY29udmVydGVyc19yZWFkVGVtcGxhdGVdLFxuXG4gIFx0c29ydE11c3RhY2hlVGFnczogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gU29ydCBpbiBvcmRlciBvZiBkZXNjZW5kaW5nIG9wZW5pbmcgZGVsaW1pdGVyIGxlbmd0aCAobG9uZ2VyIGZpcnN0KSxcbiAgXHRcdC8vIHRvIHByb3RlY3QgYWdhaW5zdCBvcGVuaW5nIGRlbGltaXRlcnMgYmVpbmcgc3Vic3RyaW5ncyBvZiBlYWNoIG90aGVyXG4gIFx0XHR0aGlzLnRhZ3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICBcdFx0XHRyZXR1cm4gYi5vcGVuLmxlbmd0aCAtIGEub3Blbi5sZW5ndGg7XG4gIFx0XHR9KTtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBwYXJzZU9wdGlvbnMgPSBbXCJwcmVzZXJ2ZVdoaXRlc3BhY2VcIiwgXCJzYW5pdGl6ZVwiLCBcInN0cmlwQ29tbWVudHNcIiwgXCJkZWxpbWl0ZXJzXCIsIFwidHJpcGxlRGVsaW1pdGVyc1wiLCBcImludGVycG9sYXRlXCJdO1xuXG4gIHZhciBwYXJzZXIgPSB7XG4gIFx0ZnJvbUlkOiBmcm9tSWQsIGlzSGFzaGVkSWQ6IGlzSGFzaGVkSWQsIGlzUGFyc2VkOiBpc1BhcnNlZCwgZ2V0UGFyc2VPcHRpb25zOiBnZXRQYXJzZU9wdGlvbnMsIGNyZWF0ZUhlbHBlcjogdGVtcGxhdGVfcGFyc2VyX19jcmVhdGVIZWxwZXIsXG4gIFx0cGFyc2U6IGRvUGFyc2VcbiAgfTtcblxuICBmdW5jdGlvbiB0ZW1wbGF0ZV9wYXJzZXJfX2NyZWF0ZUhlbHBlcihwYXJzZU9wdGlvbnMpIHtcbiAgXHR2YXIgaGVscGVyID0gY3JlYXRlKHBhcnNlcik7XG4gIFx0aGVscGVyLnBhcnNlID0gZnVuY3Rpb24gKHRlbXBsYXRlLCBvcHRpb25zKSB7XG4gIFx0XHRyZXR1cm4gZG9QYXJzZSh0ZW1wbGF0ZSwgb3B0aW9ucyB8fCBwYXJzZU9wdGlvbnMpO1xuICBcdH07XG4gIFx0cmV0dXJuIGhlbHBlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvUGFyc2UodGVtcGxhdGUsIHBhcnNlT3B0aW9ucykge1xuICBcdGlmICghX3BhcnNlKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIFJhY3RpdmUucGFyc2UgLSBjYW5ub3QgcGFyc2UgdGVtcGxhdGUuIEVpdGhlciBwcmVwYXJzZSBvciB1c2UgdGhlIHZlcnNpb24gdGhhdCBpbmNsdWRlcyB0aGUgcGFyc2VyXCIpO1xuICBcdH1cblxuICBcdHJldHVybiBfcGFyc2UodGVtcGxhdGUsIHBhcnNlT3B0aW9ucyB8fCB0aGlzLm9wdGlvbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbUlkKGlkLCBvcHRpb25zKSB7XG4gIFx0dmFyIHRlbXBsYXRlO1xuXG4gIFx0aWYgKCFpc0NsaWVudCkge1xuICBcdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Rocm93KSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXRyaWV2ZSB0ZW1wbGF0ZSAjXCIgKyBpZCArIFwiIGFzIFJhY3RpdmUgaXMgbm90IHJ1bm5pbmcgaW4gYSBicm93c2VyLlwiKTtcbiAgXHR9XG5cbiAgXHRpZiAoaXNIYXNoZWRJZChpZCkpIHtcbiAgXHRcdGlkID0gaWQuc3Vic3RyaW5nKDEpO1xuICBcdH1cblxuICBcdGlmICghKHRlbXBsYXRlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpKSkge1xuICBcdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Rocm93KSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHRlbXBsYXRlIGVsZW1lbnQgd2l0aCBpZCAjXCIgKyBpZCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRlbXBsYXRlLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gXCJTQ1JJUFRcIikge1xuICBcdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Rocm93KSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIlRlbXBsYXRlIGVsZW1lbnQgd2l0aCBpZCAjXCIgKyBpZCArIFwiLCBtdXN0IGJlIGEgPHNjcmlwdD4gZWxlbWVudFwiKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gXCJ0ZXh0Q29udGVudFwiIGluIHRlbXBsYXRlID8gdGVtcGxhdGUudGV4dENvbnRlbnQgOiB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hhc2hlZElkKGlkKSB7XG4gIFx0cmV0dXJuIGlkICYmIGlkWzBdID09PSBcIiNcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGFyc2VkKHRlbXBsYXRlKSB7XG4gIFx0cmV0dXJuICEodHlwZW9mIHRlbXBsYXRlID09PSBcInN0cmluZ1wiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhcnNlT3B0aW9ucyhyYWN0aXZlKSB7XG4gIFx0Ly8gQ291bGQgYmUgUmFjdGl2ZSBvciBhIENvbXBvbmVudFxuICBcdGlmIChyYWN0aXZlLmRlZmF1bHRzKSB7XG4gIFx0XHRyYWN0aXZlID0gcmFjdGl2ZS5kZWZhdWx0cztcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcGFyc2VPcHRpb25zLnJlZHVjZShmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgXHRcdHZhbFtrZXldID0gcmFjdGl2ZVtrZXldO1xuICBcdFx0cmV0dXJuIHZhbDtcbiAgXHR9LCB7fSk7XG4gIH1cblxuICB2YXIgdGVtcGxhdGVfcGFyc2VyID0gcGFyc2VyO1xuXG4gIHZhciB0ZW1wbGF0ZUNvbmZpZ3VyYXRvciA9IHtcbiAgXHRuYW1lOiBcInRlbXBsYXRlXCIsXG5cbiAgXHRleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChQYXJlbnQsIHByb3RvLCBvcHRpb25zKSB7XG4gIFx0XHR2YXIgdGVtcGxhdGU7XG5cbiAgXHRcdC8vIG9ubHkgYXNzaWduIGlmIGV4aXN0c1xuICBcdFx0aWYgKFwidGVtcGxhdGVcIiBpbiBvcHRpb25zKSB7XG4gIFx0XHRcdHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcblxuICBcdFx0XHRpZiAodHlwZW9mIHRlbXBsYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0XHRwcm90by50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHByb3RvLnRlbXBsYXRlID0gcGFyc2VJZlN0cmluZyh0ZW1wbGF0ZSwgcHJvdG8pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uIGluaXQoUGFyZW50LCByYWN0aXZlLCBvcHRpb25zKSB7XG4gIFx0XHR2YXIgdGVtcGxhdGUsIGZuO1xuXG4gIFx0XHQvLyBUT0RPIGJlY2F1c2Ugb2YgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgd2UgbWlnaHQganVzdCBiZSBhYmxlIHRvIHVzZVxuICBcdFx0Ly8gcmFjdGl2ZS50ZW1wbGF0ZSwgYW5kIG5vdCBib3RoZXIgcGFzc2luZyB0aHJvdWdoIHRoZSBQYXJlbnQgb2JqZWN0LlxuICBcdFx0Ly8gQXQgcHJlc2VudCB0aGF0IGJyZWFrcyB0aGUgdGVzdCBtb2NrcycgZXhwZWN0YXRpb25zXG4gIFx0XHR0ZW1wbGF0ZSA9IFwidGVtcGxhdGVcIiBpbiBvcHRpb25zID8gb3B0aW9ucy50ZW1wbGF0ZSA6IFBhcmVudC5wcm90b3R5cGUudGVtcGxhdGU7XG5cbiAgXHRcdGlmICh0eXBlb2YgdGVtcGxhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRmbiA9IHRlbXBsYXRlO1xuICBcdFx0XHR0ZW1wbGF0ZSA9IGdldER5bmFtaWNUZW1wbGF0ZShyYWN0aXZlLCBmbik7XG5cbiAgXHRcdFx0cmFjdGl2ZS5fY29uZmlnLnRlbXBsYXRlID0ge1xuICBcdFx0XHRcdGZuOiBmbixcbiAgXHRcdFx0XHRyZXN1bHQ6IHRlbXBsYXRlXG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHRlbXBsYXRlID0gcGFyc2VJZlN0cmluZyh0ZW1wbGF0ZSwgcmFjdGl2ZSk7XG5cbiAgXHRcdC8vIFRPRE8gdGhlIG5hbWluZyBvZiB0aGlzIGlzIGNvbmZ1c2luZyAtIHJhY3RpdmUudGVtcGxhdGUgcmVmZXJzIHRvIFsuLi5dLFxuICBcdFx0Ly8gYnV0IENvbXBvbmVudC5wcm90b3R5cGUudGVtcGxhdGUgcmVmZXJzIHRvIHt2OjEsdDpbXSxwOltdfS4uLlxuICBcdFx0Ly8gaXQncyB1bm5lY2Vzc2FyeSwgYmVjYXVzZSB0aGUgZGV2ZWxvcGVyIG5ldmVyIG5lZWRzIHRvIGFjY2Vzc1xuICBcdFx0Ly8gcmFjdGl2ZS50ZW1wbGF0ZVxuICBcdFx0cmFjdGl2ZS50ZW1wbGF0ZSA9IHRlbXBsYXRlLnQ7XG5cbiAgXHRcdGlmICh0ZW1wbGF0ZS5wKSB7XG4gIFx0XHRcdGV4dGVuZFBhcnRpYWxzKHJhY3RpdmUucGFydGlhbHMsIHRlbXBsYXRlLnApO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZXNldDogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdHZhciByZXN1bHQgPSByZXNldFZhbHVlKHJhY3RpdmUpLFxuICBcdFx0ICAgIHBhcnNlZDtcblxuICBcdFx0aWYgKHJlc3VsdCkge1xuICBcdFx0XHRwYXJzZWQgPSBwYXJzZUlmU3RyaW5nKHJlc3VsdCwgcmFjdGl2ZSk7XG5cbiAgXHRcdFx0cmFjdGl2ZS50ZW1wbGF0ZSA9IHBhcnNlZC50O1xuICBcdFx0XHRleHRlbmRQYXJ0aWFscyhyYWN0aXZlLnBhcnRpYWxzLCBwYXJzZWQucCwgdHJ1ZSk7XG5cbiAgXHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIGZ1bmN0aW9uIHJlc2V0VmFsdWUocmFjdGl2ZSkge1xuICBcdHZhciBpbml0aWFsID0gcmFjdGl2ZS5fY29uZmlnLnRlbXBsYXRlLFxuICBcdCAgICByZXN1bHQ7XG5cbiAgXHQvLyBJZiB0aGlzIGlzbid0IGEgZHluYW1pYyB0ZW1wbGF0ZSwgdGhlcmUncyBub3RoaW5nIHRvIGRvXG4gIFx0aWYgKCFpbml0aWFsIHx8ICFpbml0aWFsLmZuKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0cmVzdWx0ID0gZ2V0RHluYW1pY1RlbXBsYXRlKHJhY3RpdmUsIGluaXRpYWwuZm4pO1xuXG4gIFx0Ly8gVE9ETyBkZWVwIGVxdWFsaXR5IGNoZWNrIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmUtcmVuZGVyaW5nXG4gIFx0Ly8gaW4gdGhlIGNhc2Ugb2YgYWxyZWFkeS1wYXJzZWQgdGVtcGxhdGVzXG4gIFx0aWYgKHJlc3VsdCAhPT0gaW5pdGlhbC5yZXN1bHQpIHtcbiAgXHRcdGluaXRpYWwucmVzdWx0ID0gcmVzdWx0O1xuICBcdFx0cmVzdWx0ID0gcGFyc2VJZlN0cmluZyhyZXN1bHQsIHJhY3RpdmUpO1xuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBnZXREeW5hbWljVGVtcGxhdGUocmFjdGl2ZSwgZm4pIHtcbiAgXHR2YXIgaGVscGVyID0gdGVtcGxhdGVfdGVtcGxhdGVfX2NyZWF0ZUhlbHBlcih0ZW1wbGF0ZV9wYXJzZXIuZ2V0UGFyc2VPcHRpb25zKHJhY3RpdmUpKTtcbiAgXHRyZXR1cm4gZm4uY2FsbChyYWN0aXZlLCBoZWxwZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGVtcGxhdGVfdGVtcGxhdGVfX2NyZWF0ZUhlbHBlcihwYXJzZU9wdGlvbnMpIHtcbiAgXHR2YXIgaGVscGVyID0gY3JlYXRlKHRlbXBsYXRlX3BhcnNlcik7XG4gIFx0aGVscGVyLnBhcnNlID0gZnVuY3Rpb24gKHRlbXBsYXRlLCBvcHRpb25zKSB7XG4gIFx0XHRyZXR1cm4gdGVtcGxhdGVfcGFyc2VyLnBhcnNlKHRlbXBsYXRlLCBvcHRpb25zIHx8IHBhcnNlT3B0aW9ucyk7XG4gIFx0fTtcbiAgXHRyZXR1cm4gaGVscGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VJZlN0cmluZyh0ZW1wbGF0ZSwgcmFjdGl2ZSkge1xuICBcdGlmICh0eXBlb2YgdGVtcGxhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdC8vIElEIG9mIGFuIGVsZW1lbnQgY29udGFpbmluZyB0aGUgdGVtcGxhdGU/XG4gIFx0XHRpZiAodGVtcGxhdGVbMF0gPT09IFwiI1wiKSB7XG4gIFx0XHRcdHRlbXBsYXRlID0gdGVtcGxhdGVfcGFyc2VyLmZyb21JZCh0ZW1wbGF0ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRlbXBsYXRlID0gX3BhcnNlKHRlbXBsYXRlLCB0ZW1wbGF0ZV9wYXJzZXIuZ2V0UGFyc2VPcHRpb25zKHJhY3RpdmUpKTtcbiAgXHR9XG5cbiAgXHQvLyBDaGVjayB0aGF0IHRoZSB0ZW1wbGF0ZSBldmVuIGV4aXN0c1xuICBcdGVsc2UgaWYgKHRlbXBsYXRlID09IHVuZGVmaW5lZCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIHRlbXBsYXRlIGNhbm5vdCBiZSBcIiArIHRlbXBsYXRlICsgXCIuXCIpO1xuICBcdH1cblxuICBcdC8vIENoZWNrIHRoZSBwYXJzZWQgdGVtcGxhdGUgaGFzIGEgdmVyc2lvbiBhdCBhbGxcbiAgXHRlbHNlIGlmICh0eXBlb2YgdGVtcGxhdGUudiAhPT0gXCJudW1iZXJcIikge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIHRlbXBsYXRlIHBhcnNlciB3YXMgcGFzc2VkIGEgbm9uLXN0cmluZyB0ZW1wbGF0ZSwgYnV0IHRoZSB0ZW1wbGF0ZSBkb2Vzbid0IGhhdmUgYSB2ZXJzaW9uLiAgTWFrZSBzdXJlIHlvdSdyZSBwYXNzaW5nIGluIHRoZSB0ZW1wbGF0ZSB5b3UgdGhpbmsgeW91IGFyZS5cIik7XG4gIFx0fVxuXG4gIFx0Ly8gQ2hlY2sgd2UncmUgdXNpbmcgdGhlIGNvcnJlY3QgdmVyc2lvblxuICBcdGVsc2UgaWYgKHRlbXBsYXRlLnYgIT09IFRFTVBMQVRFX1ZFUlNJT04pIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgdGVtcGxhdGUgdmVyc2lvbiAoZXhwZWN0ZWQgXCIgKyBURU1QTEFURV9WRVJTSU9OICsgXCIsIGdvdCBcIiArIHRlbXBsYXRlLnYgKyBcIikgUGxlYXNlIGVuc3VyZSB5b3UgYXJlIHVzaW5nIHRoZSBsYXRlc3QgdmVyc2lvbiBvZiBSYWN0aXZlLmpzIGluIHlvdXIgYnVpbGQgcHJvY2VzcyBhcyB3ZWxsIGFzIGluIHlvdXIgYXBwXCIpO1xuICBcdH1cblxuICBcdHJldHVybiB0ZW1wbGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZFBhcnRpYWxzKGV4aXN0aW5nUGFydGlhbHMsIG5ld1BhcnRpYWxzLCBvdmVyd3JpdGUpIHtcbiAgXHRpZiAoIW5ld1BhcnRpYWxzKSByZXR1cm47XG5cbiAgXHQvLyBUT0RPIHRoZXJlJ3MgYW4gYW1iaWd1aXR5IGhlcmUgLSB3ZSBuZWVkIHRvIG92ZXJ3cml0ZSBpbiB0aGUgYHJlc2V0KClgXG4gIFx0Ly8gY2FzZSwgYnV0IG5vdCBpbml0aWFsbHkuLi5cblxuICBcdGZvciAodmFyIGtleSBpbiBuZXdQYXJ0aWFscykge1xuICBcdFx0aWYgKG92ZXJ3cml0ZSB8fCAhZXhpc3RpbmdQYXJ0aWFscy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gIFx0XHRcdGV4aXN0aW5nUGFydGlhbHNba2V5XSA9IG5ld1BhcnRpYWxzW2tleV07XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIHRlbXBsYXRlX3RlbXBsYXRlID0gdGVtcGxhdGVDb25maWd1cmF0b3I7XG5cbiAgdmFyIGNvbmZpZ19yZWdpc3RyaWVzX19yZWdpc3RyeU5hbWVzLCBSZWdpc3RyeSwgcmVnaXN0cmllcztcblxuICBjb25maWdfcmVnaXN0cmllc19fcmVnaXN0cnlOYW1lcyA9IFtcImFkYXB0b3JzXCIsIFwiY29tcG9uZW50c1wiLCBcImNvbXB1dGVkXCIsIFwiZGVjb3JhdG9yc1wiLCBcImVhc2luZ1wiLCBcImV2ZW50c1wiLCBcImludGVycG9sYXRvcnNcIiwgXCJwYXJ0aWFsc1wiLCBcInRyYW5zaXRpb25zXCJdO1xuXG4gIFJlZ2lzdHJ5ID0gZnVuY3Rpb24gKG5hbWUsIHVzZURlZmF1bHRzKSB7XG4gIFx0dGhpcy5uYW1lID0gbmFtZTtcbiAgXHR0aGlzLnVzZURlZmF1bHRzID0gdXNlRGVmYXVsdHM7XG4gIH07XG5cbiAgUmVnaXN0cnkucHJvdG90eXBlID0ge1xuICBcdGNvbnN0cnVjdG9yOiBSZWdpc3RyeSxcblxuICBcdGV4dGVuZDogZnVuY3Rpb24gKFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpIHtcbiAgXHRcdHRoaXMuY29uZmlndXJlKHRoaXMudXNlRGVmYXVsdHMgPyBQYXJlbnQuZGVmYXVsdHMgOiBQYXJlbnQsIHRoaXMudXNlRGVmYXVsdHMgPyBwcm90byA6IHByb3RvLmNvbnN0cnVjdG9yLCBvcHRpb25zKTtcbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKCkge30sXG5cbiAgXHRjb25maWd1cmU6IGZ1bmN0aW9uIChQYXJlbnQsIHRhcmdldCwgb3B0aW9ucykge1xuICBcdFx0dmFyIG5hbWUgPSB0aGlzLm5hbWUsXG4gIFx0XHQgICAgb3B0aW9uID0gb3B0aW9uc1tuYW1lXSxcbiAgXHRcdCAgICByZWdpc3RyeTtcblxuICBcdFx0cmVnaXN0cnkgPSBjcmVhdGUoUGFyZW50W25hbWVdKTtcblxuICBcdFx0Zm9yICh2YXIga2V5IGluIG9wdGlvbikge1xuICBcdFx0XHRyZWdpc3RyeVtrZXldID0gb3B0aW9uW2tleV07XG4gIFx0XHR9XG5cbiAgXHRcdHRhcmdldFtuYW1lXSA9IHJlZ2lzdHJ5O1xuICBcdH0sXG5cbiAgXHRyZXNldDogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdHZhciByZWdpc3RyeSA9IHJhY3RpdmVbdGhpcy5uYW1lXTtcbiAgXHRcdHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gIFx0XHRPYmplY3Qua2V5cyhyZWdpc3RyeSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFx0XHRcdHZhciBpdGVtID0gcmVnaXN0cnlba2V5XTtcbiAgXHRcdFx0aWYgKGl0ZW0uX2ZuKSB7XG4gIFx0XHRcdFx0aWYgKGl0ZW0uX2ZuLmlzT3duZXIpIHtcbiAgXHRcdFx0XHRcdHJlZ2lzdHJ5W2tleV0gPSBpdGVtLl9mbjtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0ZGVsZXRlIHJlZ2lzdHJ5W2tleV07XG4gIFx0XHRcdFx0fVxuICBcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcbiAgXHRcdHJldHVybiBjaGFuZ2VkO1xuICBcdH1cbiAgfTtcblxuICByZWdpc3RyaWVzID0gY29uZmlnX3JlZ2lzdHJpZXNfX3JlZ2lzdHJ5TmFtZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0cmV0dXJuIG5ldyBSZWdpc3RyeShuYW1lLCBuYW1lID09PSBcImNvbXB1dGVkXCIpO1xuICB9KTtcblxuICB2YXIgY29uZmlnX3JlZ2lzdHJpZXMgPSByZWdpc3RyaWVzO1xuXG4gIC8qdGhpcy5jb25maWd1cmUoXG4gIFx0dGhpcy51c2VEZWZhdWx0cyA/IFBhcmVudC5kZWZhdWx0cyA6IFBhcmVudCxcbiAgXHRyYWN0aXZlLFxuICBcdG9wdGlvbnMgKTsqL1xuXG4gIHZhciB3cmFwUHJvdG90eXBlID0gd3JhcDtcblxuICBmdW5jdGlvbiB3cmFwKHBhcmVudCwgbmFtZSwgbWV0aG9kKSB7XG4gIFx0aWYgKCEvX3N1cGVyLy50ZXN0KG1ldGhvZCkpIHtcbiAgXHRcdHJldHVybiBtZXRob2Q7XG4gIFx0fVxuXG4gIFx0dmFyIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwU3VwZXIoKSB7XG4gIFx0XHR2YXIgc3VwZXJNZXRob2QgPSBnZXRTdXBlck1ldGhvZCh3cmFwcGVyLl9wYXJlbnQsIG5hbWUpLFxuICBcdFx0ICAgIGhhc1N1cGVyID0gKFwiX3N1cGVyXCIgaW4gdGhpcyksXG4gIFx0XHQgICAgb2xkU3VwZXIgPSB0aGlzLl9zdXBlcixcbiAgXHRcdCAgICByZXN1bHQ7XG5cbiAgXHRcdHRoaXMuX3N1cGVyID0gc3VwZXJNZXRob2Q7XG5cbiAgXHRcdHJlc3VsdCA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIFx0XHRpZiAoaGFzU3VwZXIpIHtcbiAgXHRcdFx0dGhpcy5fc3VwZXIgPSBvbGRTdXBlcjtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9zdXBlcjtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9O1xuXG4gIFx0d3JhcHBlci5fcGFyZW50ID0gcGFyZW50O1xuICBcdHdyYXBwZXIuX21ldGhvZCA9IG1ldGhvZDtcblxuICBcdHJldHVybiB3cmFwcGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U3VwZXJNZXRob2QocGFyZW50LCBuYW1lKSB7XG4gIFx0dmFyIHZhbHVlLCBtZXRob2Q7XG5cbiAgXHRpZiAobmFtZSBpbiBwYXJlbnQpIHtcbiAgXHRcdHZhbHVlID0gcGFyZW50W25hbWVdO1xuXG4gIFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0bWV0aG9kID0gdmFsdWU7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRtZXRob2QgPSBmdW5jdGlvbiByZXR1cm5WYWx1ZSgpIHtcbiAgXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0XHRcdH07XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdG1ldGhvZCA9IG5vb3A7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG1ldGhvZDtcbiAgfVxuXG4gIHZhciBjb25maWdfZGVwcmVjYXRlID0gZGVwcmVjYXRlO1xuICBmdW5jdGlvbiBnZXRNZXNzYWdlKGRlcHJlY2F0ZWQsIGNvcnJlY3QsIGlzRXJyb3IpIHtcbiAgXHRyZXR1cm4gXCJvcHRpb25zLlwiICsgZGVwcmVjYXRlZCArIFwiIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIG9wdGlvbnMuXCIgKyBjb3JyZWN0ICsgXCIuXCIgKyAoaXNFcnJvciA/IFwiIFlvdSBjYW5ub3Qgc3BlY2lmeSBib3RoIG9wdGlvbnMsIHBsZWFzZSB1c2Ugb3B0aW9ucy5cIiArIGNvcnJlY3QgKyBcIi5cIiA6IFwiXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVwcmVjYXRlT3B0aW9uKG9wdGlvbnMsIGRlcHJlY2F0ZWRPcHRpb24sIGNvcnJlY3QpIHtcbiAgXHRpZiAoZGVwcmVjYXRlZE9wdGlvbiBpbiBvcHRpb25zKSB7XG4gIFx0XHRpZiAoIShjb3JyZWN0IGluIG9wdGlvbnMpKSB7XG4gIFx0XHRcdHdhcm5JZkRlYnVnKGdldE1lc3NhZ2UoZGVwcmVjYXRlZE9wdGlvbiwgY29ycmVjdCkpO1xuICBcdFx0XHRvcHRpb25zW2NvcnJlY3RdID0gb3B0aW9uc1tkZXByZWNhdGVkT3B0aW9uXTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihnZXRNZXNzYWdlKGRlcHJlY2F0ZWRPcHRpb24sIGNvcnJlY3QsIHRydWUpKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cbiAgZnVuY3Rpb24gZGVwcmVjYXRlKG9wdGlvbnMpIHtcbiAgXHRkZXByZWNhdGVPcHRpb24ob3B0aW9ucywgXCJiZWZvcmVJbml0XCIsIFwib25jb25zdHJ1Y3RcIik7XG4gIFx0ZGVwcmVjYXRlT3B0aW9uKG9wdGlvbnMsIFwiaW5pdFwiLCBcIm9ucmVuZGVyXCIpO1xuICBcdGRlcHJlY2F0ZU9wdGlvbihvcHRpb25zLCBcImNvbXBsZXRlXCIsIFwib25jb21wbGV0ZVwiKTtcbiAgXHRkZXByZWNhdGVPcHRpb24ob3B0aW9ucywgXCJldmVudERlZmluaXRpb25zXCIsIFwiZXZlbnRzXCIpO1xuXG4gIFx0Ly8gVXNpbmcgZXh0ZW5kIHdpdGggQ29tcG9uZW50IGluc3RlYWQgb2Ygb3B0aW9ucyxcbiAgXHQvLyBsaWtlIEh1bWFuLmV4dGVuZCggU3BpZGVyICkgbWVhbnMgYWRhcHRvcnMgYXMgYSByZWdpc3RyeVxuICBcdC8vIGdldHMgY29waWVkIHRvIG9wdGlvbnMuIFNvIHdlIGhhdmUgdG8gY2hlY2sgaWYgYWN0dWFsbHkgYW4gYXJyYXlcbiAgXHRpZiAoaXNBcnJheShvcHRpb25zLmFkYXB0b3JzKSkge1xuICBcdFx0ZGVwcmVjYXRlT3B0aW9uKG9wdGlvbnMsIFwiYWRhcHRvcnNcIiwgXCJhZGFwdFwiKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgY29uZmlnLCBvcmRlciwgZGVmYXVsdEtleXMsIGN1c3RvbSwgaXNCbGFja2xpc3RlZCwgaXNTdGFuZGFyZEtleTtcblxuICBjdXN0b20gPSB7XG4gIFx0YWRhcHQ6IGN1c3RvbV9hZGFwdCxcbiAgXHRjc3M6IGNzc19jc3MsXG4gIFx0ZGF0YTogY3VzdG9tX2RhdGEsXG4gIFx0dGVtcGxhdGU6IHRlbXBsYXRlX3RlbXBsYXRlXG4gIH07XG5cbiAgZGVmYXVsdEtleXMgPSBPYmplY3Qua2V5cyhjb25maWdfZGVmYXVsdHMpO1xuXG4gIGlzU3RhbmRhcmRLZXkgPSBtYWtlT2JqKGRlZmF1bHRLZXlzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gIFx0cmV0dXJuICFjdXN0b21ba2V5XTtcbiAgfSkpO1xuXG4gIC8vIGJsYWNrbGlzdGVkIGtleXMgdGhhdCB3ZSBkb24ndCBkb3VibGUgZXh0ZW5kXG4gIGlzQmxhY2tsaXN0ZWQgPSBtYWtlT2JqKGRlZmF1bHRLZXlzLmNvbmNhdChjb25maWdfcmVnaXN0cmllcy5tYXAoZnVuY3Rpb24gKHIpIHtcbiAgXHRyZXR1cm4gci5uYW1lO1xuICB9KSkpO1xuXG4gIG9yZGVyID0gW10uY29uY2F0KGRlZmF1bHRLZXlzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gIFx0cmV0dXJuICFjb25maWdfcmVnaXN0cmllc1trZXldICYmICFjdXN0b21ba2V5XTtcbiAgfSksIGNvbmZpZ19yZWdpc3RyaWVzLCBjdXN0b20uZGF0YSwgY3VzdG9tLnRlbXBsYXRlLCBjdXN0b20uY3NzKTtcblxuICBjb25maWcgPSB7XG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAoUGFyZW50LCBwcm90bywgb3B0aW9ucykge1xuICBcdFx0cmV0dXJuIGNvbmZpZ3VyZShcImV4dGVuZFwiLCBQYXJlbnQsIHByb3RvLCBvcHRpb25zKTtcbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucykge1xuICBcdFx0cmV0dXJuIGNvbmZpZ3VyZShcImluaXRcIiwgUGFyZW50LCByYWN0aXZlLCBvcHRpb25zKTtcbiAgXHR9LFxuXG4gIFx0cmVzZXQ6IGZ1bmN0aW9uIChyYWN0aXZlKSB7XG4gIFx0XHRyZXR1cm4gb3JkZXIuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gIFx0XHRcdHJldHVybiBjLnJlc2V0ICYmIGMucmVzZXQocmFjdGl2ZSk7XG4gIFx0XHR9KS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgXHRcdFx0cmV0dXJuIGMubmFtZTtcbiAgXHRcdH0pO1xuICBcdH0sXG5cbiAgXHQvLyB0aGlzIGRlZmluZXMgdGhlIG9yZGVyLiBUT0RPIHRoaXMgaXNuJ3QgdXNlZCBhbnl3aGVyZSBpbiB0aGUgY29kZWJhc2UsXG4gIFx0Ly8gb25seSBpbiB0aGUgdGVzdCBzdWl0ZSAtIHNob3VsZCBnZXQgcmlkIG9mIGl0XG4gIFx0b3JkZXI6IG9yZGVyIH07XG5cbiAgZnVuY3Rpb24gY29uZmlndXJlKG1ldGhvZCwgUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgXHRjb25maWdfZGVwcmVjYXRlKG9wdGlvbnMpO1xuXG4gIFx0Zm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgXHRcdGlmIChpc1N0YW5kYXJkS2V5Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgXHRcdFx0dmFyIHZhbHVlID0gb3B0aW9uc1trZXldO1xuXG4gIFx0XHRcdC8vIHdhcm4gdGhlIGRldmVsb3BlciBpZiB0aGV5IHBhc3NlZCBhIGZ1bmN0aW9uIGFuZCBpZ25vcmUgaXRzIHZhbHVlXG5cbiAgXHRcdFx0Ly8gTk9URTogd2UgYWxsb3cgc29tZSBmdW5jdGlvbnMgb24gXCJlbFwiIGJlY2F1c2Ugd2UgZHVjayB0eXBlIGVsZW1lbnQgbGlzdHNcbiAgXHRcdFx0Ly8gYW5kIHNvbWUgbGlicmFyaWVzIG9yIGVmJ2VkLXVwIHZpcnR1YWwgYnJvd3NlcnMgKHBoYW50b21KUykgcmV0dXJuIGFcbiAgXHRcdFx0Ly8gZnVuY3Rpb24gb2JqZWN0IGFzIHRoZSByZXN1bHQgb2YgcXVlcnlTZWxlY3RvciBtZXRob2RzXG4gIFx0XHRcdGlmIChrZXkgIT09IFwiZWxcIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRcdHdhcm5JZkRlYnVnKFwiXCIgKyBrZXkgKyBcIiBpcyBhIFJhY3RpdmUgb3B0aW9uIHRoYXQgZG9lcyBub3QgZXhwZWN0IGEgZnVuY3Rpb24gYW5kIHdpbGwgYmUgaWdub3JlZFwiLCBtZXRob2QgPT09IFwiaW5pdFwiID8gdGFyZ2V0IDogbnVsbCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0dGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdGNvbmZpZ19yZWdpc3RyaWVzLmZvckVhY2goZnVuY3Rpb24gKHJlZ2lzdHJ5KSB7XG4gIFx0XHRyZWdpc3RyeVttZXRob2RdKFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgXHR9KTtcblxuICBcdGN1c3RvbV9hZGFwdFttZXRob2RdKFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgXHR0ZW1wbGF0ZV90ZW1wbGF0ZVttZXRob2RdKFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgXHRjc3NfY3NzW21ldGhvZF0oUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMpO1xuXG4gIFx0ZXh0ZW5kT3RoZXJNZXRob2RzKFBhcmVudC5wcm90b3R5cGUsIHRhcmdldCwgb3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmRPdGhlck1ldGhvZHMocGFyZW50LCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgXHRmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICBcdFx0aWYgKCFpc0JsYWNrbGlzdGVkW2tleV0gJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gIFx0XHRcdHZhciBtZW1iZXIgPSBvcHRpb25zW2tleV07XG5cbiAgXHRcdFx0Ly8gaWYgdGhpcyBpcyBhIG1ldGhvZCB0aGF0IG92ZXJ3cml0ZXMgYSBtZXRob2QsIHdyYXAgaXQ6XG4gIFx0XHRcdGlmICh0eXBlb2YgbWVtYmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0XHRtZW1iZXIgPSB3cmFwUHJvdG90eXBlKHBhcmVudCwga2V5LCBtZW1iZXIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGFyZ2V0W2tleV0gPSBtZW1iZXI7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gbWFrZU9iaihhcnJheSkge1xuICBcdHZhciBvYmogPSB7fTtcbiAgXHRhcnJheS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gIFx0XHRyZXR1cm4gb2JqW3hdID0gdHJ1ZTtcbiAgXHR9KTtcbiAgXHRyZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIGNvbmZpZ19jb25maWcgPSBjb25maWc7XG5cbiAgdmFyIHByb3RvdHlwZV9idWJibGUgPSBGcmFnbWVudCRidWJibGU7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkYnViYmxlKCkge1xuICBcdHRoaXMuZGlydHlWYWx1ZSA9IHRoaXMuZGlydHlBcmdzID0gdHJ1ZTtcblxuICBcdGlmICh0aGlzLmJvdW5kICYmIHR5cGVvZiB0aGlzLm93bmVyLmJ1YmJsZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHR0aGlzLm93bmVyLmJ1YmJsZSgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfZGV0YWNoID0gRnJhZ21lbnQkZGV0YWNoO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGRldGFjaCgpIHtcbiAgXHR2YXIgZG9jRnJhZztcblxuICBcdGlmICh0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMSkge1xuICBcdFx0cmV0dXJuIHRoaXMuaXRlbXNbMF0uZGV0YWNoKCk7XG4gIFx0fVxuXG4gIFx0ZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICBcdHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0dmFyIG5vZGUgPSBpdGVtLmRldGFjaCgpO1xuXG4gIFx0XHQvLyBUT0RPIFRoZSBpZiB7Li4ufSB3YXNuJ3QgcHJldmlvdXNseSByZXF1aXJlZCAtIGl0IGlzIG5vdywgYmVjYXVzZSB3ZSdyZVxuICBcdFx0Ly8gZm9yY2libHkgZGV0YWNoaW5nIGV2ZXJ5dGhpbmcgdG8gcmVvcmRlciBzZWN0aW9ucyBhZnRlciBhbiB1cGRhdGUuIFRoYXQnc1xuICBcdFx0Ly8gYSBub24taWRlYWwgYnJ1dGUgZm9yY2UgYXBwcm9hY2gsIGltcGxlbWVudGVkIHRvIGdldCBhbGwgdGhlIHRlc3RzIHRvIHBhc3NcbiAgXHRcdC8vIC0gYXMgc29vbiBhcyBpdCdzIHJlcGxhY2VkIHdpdGggc29tZXRoaW5nIG1vcmUgZWxlZ2FudCwgdGhpcyBzaG91bGRcbiAgXHRcdC8vIHJldmVydCB0byBgZG9jRnJhZy5hcHBlbmRDaGlsZCggaXRlbS5kZXRhY2goKSApYFxuICBcdFx0aWYgKG5vZGUpIHtcbiAgXHRcdFx0ZG9jRnJhZy5hcHBlbmRDaGlsZChub2RlKTtcbiAgXHRcdH1cbiAgXHR9KTtcblxuICBcdHJldHVybiBkb2NGcmFnO1xuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9maW5kID0gRnJhZ21lbnQkZmluZDtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRmaW5kKHNlbGVjdG9yKSB7XG4gIFx0dmFyIGksIGxlbiwgaXRlbSwgcXVlcnlSZXN1bHQ7XG5cbiAgXHRpZiAodGhpcy5pdGVtcykge1xuICBcdFx0bGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbaV07XG5cbiAgXHRcdFx0aWYgKGl0ZW0uZmluZCAmJiAocXVlcnlSZXN1bHQgPSBpdGVtLmZpbmQoc2VsZWN0b3IpKSkge1xuICBcdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX2ZpbmRBbGwgPSBGcmFnbWVudCRmaW5kQWxsO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0dmFyIGksIGxlbiwgaXRlbTtcblxuICBcdGlmICh0aGlzLml0ZW1zKSB7XG4gIFx0XHRsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRpdGVtID0gdGhpcy5pdGVtc1tpXTtcblxuICBcdFx0XHRpZiAoaXRlbS5maW5kQWxsKSB7XG4gIFx0XHRcdFx0aXRlbS5maW5kQWxsKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gcXVlcnk7XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX2ZpbmRBbGxDb21wb25lbnRzID0gRnJhZ21lbnQkZmluZEFsbENvbXBvbmVudHM7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0dmFyIGksIGxlbiwgaXRlbTtcblxuICBcdGlmICh0aGlzLml0ZW1zKSB7XG4gIFx0XHRsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRpdGVtID0gdGhpcy5pdGVtc1tpXTtcblxuICBcdFx0XHRpZiAoaXRlbS5maW5kQWxsQ29tcG9uZW50cykge1xuICBcdFx0XHRcdGl0ZW0uZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfZmluZENvbXBvbmVudCA9IEZyYWdtZW50JGZpbmRDb21wb25lbnQ7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZmluZENvbXBvbmVudChzZWxlY3Rvcikge1xuICBcdHZhciBsZW4sIGksIGl0ZW0sIHF1ZXJ5UmVzdWx0O1xuXG4gIFx0aWYgKHRoaXMuaXRlbXMpIHtcbiAgXHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zW2ldO1xuXG4gIFx0XHRcdGlmIChpdGVtLmZpbmRDb21wb25lbnQgJiYgKHF1ZXJ5UmVzdWx0ID0gaXRlbS5maW5kQ29tcG9uZW50KHNlbGVjdG9yKSkpIHtcbiAgXHRcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9maW5kTmV4dE5vZGUgPSBGcmFnbWVudCRmaW5kTmV4dE5vZGU7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZmluZE5leHROb2RlKGl0ZW0pIHtcbiAgXHR2YXIgaW5kZXggPSBpdGVtLmluZGV4LFxuICBcdCAgICBub2RlO1xuXG4gIFx0aWYgKHRoaXMuaXRlbXNbaW5kZXggKyAxXSkge1xuICBcdFx0bm9kZSA9IHRoaXMuaXRlbXNbaW5kZXggKyAxXS5maXJzdE5vZGUoKTtcbiAgXHR9XG5cbiAgXHQvLyBpZiB0aGlzIGlzIHRoZSByb290IGZyYWdtZW50LCBhbmQgdGhlcmUgYXJlIG5vIG1vcmUgaXRlbXMsXG4gIFx0Ly8gaXQgbWVhbnMgd2UncmUgYXQgdGhlIGVuZC4uLlxuICBcdGVsc2UgaWYgKHRoaXMub3duZXIgPT09IHRoaXMucm9vdCkge1xuICBcdFx0aWYgKCF0aGlzLm93bmVyLmNvbXBvbmVudCkge1xuICBcdFx0XHQvLyBUT0RPIGJ1dCBzb21ldGhpbmcgZWxzZSBjb3VsZCBoYXZlIGJlZW4gYXBwZW5kZWQgdG9cbiAgXHRcdFx0Ly8gdGhpcy5yb290LmVsLCBubz9cbiAgXHRcdFx0bm9kZSA9IG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIC4uLnVubGVzcyB0aGlzIGlzIGEgY29tcG9uZW50XG4gIFx0XHRlbHNlIHtcbiAgXHRcdFx0bm9kZSA9IHRoaXMub3duZXIuY29tcG9uZW50LmZpbmROZXh0Tm9kZSgpO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRub2RlID0gdGhpcy5vd25lci5maW5kTmV4dE5vZGUodGhpcyk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG5vZGU7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2ZpcnN0Tm9kZSA9IEZyYWdtZW50JGZpcnN0Tm9kZTtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRmaXJzdE5vZGUoKSB7XG4gIFx0aWYgKHRoaXMuaXRlbXMgJiYgdGhpcy5pdGVtc1swXSkge1xuICBcdFx0cmV0dXJuIHRoaXMuaXRlbXNbMF0uZmlyc3ROb2RlKCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc2hhcmVkX3Byb2Nlc3NJdGVtcyA9IHByb2Nlc3NJdGVtcztcblxuICBmdW5jdGlvbiBwcm9jZXNzSXRlbXMoaXRlbXMsIHZhbHVlcywgZ3VpZCwgY291bnRlcikge1xuICBcdGNvdW50ZXIgPSBjb3VudGVyIHx8IDA7XG5cbiAgXHRyZXR1cm4gaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHR2YXIgcGxhY2Vob2xkZXJJZCwgd3JhcHBlZCwgdmFsdWU7XG5cbiAgXHRcdGlmIChpdGVtLnRleHQpIHtcbiAgXHRcdFx0cmV0dXJuIGl0ZW0udGV4dDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGl0ZW0uZnJhZ21lbnRzKSB7XG4gIFx0XHRcdHJldHVybiBpdGVtLmZyYWdtZW50cy5tYXAoZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gIFx0XHRcdFx0cmV0dXJuIHByb2Nlc3NJdGVtcyhmcmFnbWVudC5pdGVtcywgdmFsdWVzLCBndWlkLCBjb3VudGVyKTtcbiAgXHRcdFx0fSkuam9pbihcIlwiKTtcbiAgXHRcdH1cblxuICBcdFx0cGxhY2Vob2xkZXJJZCA9IGd1aWQgKyBcIi1cIiArIGNvdW50ZXIrKztcblxuICBcdFx0aWYgKGl0ZW0ua2V5cGF0aCAmJiAod3JhcHBlZCA9IGl0ZW0ucm9vdC52aWV3bW9kZWwud3JhcHBlZFtpdGVtLmtleXBhdGguc3RyXSkpIHtcbiAgXHRcdFx0dmFsdWUgPSB3cmFwcGVkLnZhbHVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dmFsdWUgPSBpdGVtLmdldFZhbHVlKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHZhbHVlc1twbGFjZWhvbGRlcklkXSA9IHZhbHVlO1xuXG4gIFx0XHRyZXR1cm4gXCIke1wiICsgcGxhY2Vob2xkZXJJZCArIFwifVwiO1xuICBcdH0pLmpvaW4oXCJcIik7XG4gIH1cblxuICB2YXIgZ2V0QXJnc0xpc3QgPSBGcmFnbWVudCRnZXRBcmdzTGlzdDtcbiAgZnVuY3Rpb24gRnJhZ21lbnQkZ2V0QXJnc0xpc3QoKSB7XG4gIFx0dmFyIHZhbHVlcywgc291cmNlLCBwYXJzZWQsIHJlc3VsdDtcblxuICBcdGlmICh0aGlzLmRpcnR5QXJncykge1xuICBcdFx0c291cmNlID0gc2hhcmVkX3Byb2Nlc3NJdGVtcyh0aGlzLml0ZW1zLCB2YWx1ZXMgPSB7fSwgdGhpcy5yb290Ll9ndWlkKTtcbiAgXHRcdHBhcnNlZCA9IHBhcnNlSlNPTihcIltcIiArIHNvdXJjZSArIFwiXVwiLCB2YWx1ZXMpO1xuXG4gIFx0XHRpZiAoIXBhcnNlZCkge1xuICBcdFx0XHRyZXN1bHQgPSBbdGhpcy50b1N0cmluZygpXTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJlc3VsdCA9IHBhcnNlZC52YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5hcmdzTGlzdCA9IHJlc3VsdDtcbiAgXHRcdHRoaXMuZGlydHlBcmdzID0gZmFsc2U7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMuYXJnc0xpc3Q7XG4gIH1cblxuICB2YXIgZ2V0Tm9kZSA9IEZyYWdtZW50JGdldE5vZGU7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZ2V0Tm9kZSgpIHtcbiAgXHR2YXIgZnJhZ21lbnQgPSB0aGlzO1xuXG4gIFx0ZG8ge1xuICBcdFx0aWYgKGZyYWdtZW50LnBFbGVtZW50KSB7XG4gIFx0XHRcdHJldHVybiBmcmFnbWVudC5wRWxlbWVudC5ub2RlO1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50KTtcblxuICBcdHJldHVybiB0aGlzLnJvb3QuZGV0YWNoZWQgfHwgdGhpcy5yb290LmVsO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9nZXRWYWx1ZSA9IEZyYWdtZW50JGdldFZhbHVlO1xuICBmdW5jdGlvbiBGcmFnbWVudCRnZXRWYWx1ZSgpIHtcbiAgXHR2YXIgdmFsdWVzLCBzb3VyY2UsIHBhcnNlZCwgcmVzdWx0O1xuXG4gIFx0aWYgKHRoaXMuZGlydHlWYWx1ZSkge1xuICBcdFx0c291cmNlID0gc2hhcmVkX3Byb2Nlc3NJdGVtcyh0aGlzLml0ZW1zLCB2YWx1ZXMgPSB7fSwgdGhpcy5yb290Ll9ndWlkKTtcbiAgXHRcdHBhcnNlZCA9IHBhcnNlSlNPTihzb3VyY2UsIHZhbHVlcyk7XG5cbiAgXHRcdGlmICghcGFyc2VkKSB7XG4gIFx0XHRcdHJlc3VsdCA9IHRoaXMudG9TdHJpbmcoKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJlc3VsdCA9IHBhcnNlZC52YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy52YWx1ZSA9IHJlc3VsdDtcbiAgXHRcdHRoaXMuZGlydHlWYWx1ZSA9IGZhbHNlO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG5cbiAgdmFyIHNoYXJlZF9kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIFx0cmV0dXJuIGRldGFjaE5vZGUodGhpcy5ub2RlKTtcbiAgfTtcblxuICB2YXIgVGV4dCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy50eXBlID0gVEVYVDtcbiAgXHR0aGlzLnRleHQgPSBvcHRpb25zLnRlbXBsYXRlO1xuICB9O1xuXG4gIFRleHQucHJvdG90eXBlID0ge1xuICBcdGRldGFjaDogc2hhcmVkX2RldGFjaCxcblxuICBcdGZpcnN0Tm9kZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMubm9kZSkge1xuICBcdFx0XHR0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH0sXG5cbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKGVzY2FwZSkge1xuICBcdFx0cmV0dXJuIGVzY2FwZSA/IGVzY2FwZUh0bWwodGhpcy50ZXh0KSA6IHRoaXMudGV4dDtcbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRpZiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5kZXRhY2goKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIGl0ZW1zX1RleHQgPSBUZXh0O1xuXG4gIHZhciBzaGFyZWRfdW5iaW5kID0gc2hhcmVkX3VuYmluZF9fdW5iaW5kO1xuXG4gIGZ1bmN0aW9uIHNoYXJlZF91bmJpbmRfX3VuYmluZCgpIHtcbiAgXHRpZiAodGhpcy5yZWdpc3RlcmVkKSB7XG4gIFx0XHQvLyB0aGlzIHdhcyByZWdpc3RlcmVkIGFzIGEgZGVwZW5kYW50XG4gIFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnVucmVnaXN0ZXIodGhpcy5rZXlwYXRoLCB0aGlzKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5yZXNvbHZlcikge1xuICBcdFx0dGhpcy5yZXNvbHZlci51bmJpbmQoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgTXVzdGFjaGVfZ2V0VmFsdWUgPSBNdXN0YWNoZSRnZXRWYWx1ZTtcblxuICBmdW5jdGlvbiBNdXN0YWNoZSRnZXRWYWx1ZSgpIHtcbiAgXHRyZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuXG4gIHZhciBSZWZlcmVuY2VSZXNvbHZlciA9IGZ1bmN0aW9uIChvd25lciwgcmVmLCBjYWxsYmFjaykge1xuICBcdHZhciBrZXlwYXRoO1xuXG4gIFx0dGhpcy5yZWYgPSByZWY7XG4gIFx0dGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xuXG4gIFx0dGhpcy5yb290ID0gb3duZXIucm9vdDtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gb3duZXIucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gIFx0a2V5cGF0aCA9IHNoYXJlZF9yZXNvbHZlUmVmKG93bmVyLnJvb3QsIHJlZiwgb3duZXIucGFyZW50RnJhZ21lbnQpO1xuICBcdGlmIChrZXlwYXRoICE9IHVuZGVmaW5lZCkge1xuICBcdFx0dGhpcy5yZXNvbHZlKGtleXBhdGgpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5hZGRVbnJlc29sdmVkKHRoaXMpO1xuICBcdH1cbiAgfTtcblxuICBSZWZlcmVuY2VSZXNvbHZlci5wcm90b3R5cGUgPSB7XG4gIFx0cmVzb2x2ZTogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdGlmICh0aGlzLmtleXBhdGggJiYgIWtleXBhdGgpIHtcbiAgXHRcdFx0Ly8gaXQgd2FzIHJlc29sdmVkLCBhbmQgbm93IGl0J3Mgbm90LiBDYW4gaGFwcGVuIGlmIGUuZy4gYGJhcmAgaW5cbiAgXHRcdFx0Ly8gYHt7Zm9vW2Jhcl19fWAgYmVjb21lcyB1bmRlZmluZWRcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVW5yZXNvbHZlZCh0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5yZXNvbHZlZCA9IHRydWU7XG5cbiAgXHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0XHR0aGlzLmNhbGxiYWNrKGtleXBhdGgpO1xuICBcdH0sXG5cbiAgXHRmb3JjZVJlc29sdXRpb246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMucmVzb2x2ZShnZXRLZXlwYXRoKHRoaXMucmVmKSk7XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdHZhciBrZXlwYXRoO1xuXG4gIFx0XHRpZiAodGhpcy5rZXlwYXRoICE9IHVuZGVmaW5lZCkge1xuICBcdFx0XHRrZXlwYXRoID0gdGhpcy5rZXlwYXRoLnJlcGxhY2Uob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHRcdC8vIHdhcyBhIG5ldyBrZXlwYXRoIGNyZWF0ZWQ/XG4gIFx0XHRcdGlmIChrZXlwYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHQvLyByZXNvbHZlIGl0XG4gIFx0XHRcdFx0dGhpcy5yZXNvbHZlKGtleXBhdGgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLnJlc29sdmVkKSB7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLnJlbW92ZVVucmVzb2x2ZWQodGhpcyk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBSZXNvbHZlcnNfUmVmZXJlbmNlUmVzb2x2ZXIgPSBSZWZlcmVuY2VSZXNvbHZlcjtcblxuICB2YXIgU3BlY2lhbFJlc29sdmVyID0gZnVuY3Rpb24gKG93bmVyLCByZWYsIGNhbGxiYWNrKSB7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IG93bmVyLnBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMucmVmID0gcmVmO1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBcdHRoaXMucmViaW5kKCk7XG4gIH07XG5cbiAgdmFyIHByb3BzID0ge1xuICBcdFwiQGtleXBhdGhcIjogeyBwcmVmaXg6IFwiY1wiLCBwcm9wOiBbXCJjb250ZXh0XCJdIH0sXG4gIFx0XCJAaW5kZXhcIjogeyBwcmVmaXg6IFwiaVwiLCBwcm9wOiBbXCJpbmRleFwiXSB9LFxuICBcdFwiQGtleVwiOiB7IHByZWZpeDogXCJrXCIsIHByb3A6IFtcImtleVwiLCBcImluZGV4XCJdIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRQcm9wKHRhcmdldCwgcHJvcCkge1xuICBcdHZhciB2YWx1ZTtcbiAgXHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3AucHJvcC5sZW5ndGg7IGkrKykge1xuICBcdFx0aWYgKCh2YWx1ZSA9IHRhcmdldFtwcm9wLnByb3BbaV1dKSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHJldHVybiB2YWx1ZTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBTcGVjaWFsUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuICBcdHJlYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHJlZiA9IHRoaXMucmVmLFxuICBcdFx0ICAgIGZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudCxcbiAgXHRcdCAgICBwcm9wID0gcHJvcHNbcmVmXSxcbiAgXHRcdCAgICB2YWx1ZTtcblxuICBcdFx0aWYgKCFwcm9wKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVua25vd24gc3BlY2lhbCByZWZlcmVuY2UgXFxcIlwiICsgcmVmICsgXCJcXFwiIC0gdmFsaWQgcmVmZXJlbmNlcyBhcmUgQGluZGV4LCBAa2V5IGFuZCBAa2V5cGF0aFwiKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gaGF2ZSB3ZSBhbHJlYWR5IGZvdW5kIHRoZSBuZWFyZXN0IHBhcmVudD9cbiAgXHRcdGlmICh0aGlzLmNhY2hlZCkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5jYWxsYmFjayhnZXRLZXlwYXRoKFwiQFwiICsgcHJvcC5wcmVmaXggKyBnZXRQcm9wKHRoaXMuY2FjaGVkLCBwcm9wKSkpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgZm9yIGluZGljZXMsIHdoaWNoIG1heSBjcm9zcyBjb21wb25lbnQgYm91bmRhcmllc1xuICBcdFx0aWYgKHByb3AucHJvcC5pbmRleE9mKFwiaW5kZXhcIikgIT09IC0xIHx8IHByb3AucHJvcC5pbmRleE9mKFwia2V5XCIpICE9PSAtMSkge1xuICBcdFx0XHR3aGlsZSAoZnJhZ21lbnQpIHtcbiAgXHRcdFx0XHRpZiAoZnJhZ21lbnQub3duZXIuY3VycmVudFN1YnR5cGUgPT09IFNFQ1RJT05fRUFDSCAmJiAodmFsdWUgPSBnZXRQcm9wKGZyYWdtZW50LCBwcm9wKSkgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdFx0dGhpcy5jYWNoZWQgPSBmcmFnbWVudDtcblxuICBcdFx0XHRcdFx0ZnJhZ21lbnQucmVnaXN0ZXJJbmRleFJlZih0aGlzKTtcblxuICBcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY2FsbGJhY2soZ2V0S2V5cGF0aChcIkBcIiArIHByb3AucHJlZml4ICsgdmFsdWUpKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHQvLyB3YXRjaCBmb3IgY29tcG9uZW50IGJvdW5kYXJpZXNcbiAgXHRcdFx0XHRpZiAoIWZyYWdtZW50LnBhcmVudCAmJiBmcmFnbWVudC5vd25lciAmJiBmcmFnbWVudC5vd25lci5jb21wb25lbnQgJiYgZnJhZ21lbnQub3duZXIuY29tcG9uZW50LnBhcmVudEZyYWdtZW50ICYmICFmcmFnbWVudC5vd25lci5jb21wb25lbnQuaW5zdGFuY2UuaXNvbGF0ZWQpIHtcbiAgXHRcdFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQub3duZXIuY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudDtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHdoaWxlIChmcmFnbWVudCkge1xuICBcdFx0XHRcdGlmICgodmFsdWUgPSBnZXRQcm9wKGZyYWdtZW50LCBwcm9wKSkgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY2FsbGJhY2soZ2V0S2V5cGF0aChcIkBcIiArIHByb3AucHJlZml4ICsgdmFsdWUuc3RyKSk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQ7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5jYWNoZWQpIHtcbiAgXHRcdFx0dGhpcy5jYWNoZWQudW5yZWdpc3RlckluZGV4UmVmKHRoaXMpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgUmVzb2x2ZXJzX1NwZWNpYWxSZXNvbHZlciA9IFNwZWNpYWxSZXNvbHZlcjtcblxuICB2YXIgSW5kZXhSZXNvbHZlciA9IGZ1bmN0aW9uIChvd25lciwgcmVmLCBjYWxsYmFjaykge1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBvd25lci5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLnJlZiA9IHJlZjtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgXHRyZWYucmVmLmZyYWdtZW50LnJlZ2lzdGVySW5kZXhSZWYodGhpcyk7XG5cbiAgXHR0aGlzLnJlYmluZCgpO1xuICB9O1xuXG4gIEluZGV4UmVzb2x2ZXIucHJvdG90eXBlID0ge1xuICBcdHJlYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGluZGV4LFxuICBcdFx0ICAgIHJlZiA9IHRoaXMucmVmLnJlZjtcblxuICBcdFx0aWYgKHJlZi5yZWYudCA9PT0gXCJrXCIpIHtcbiAgXHRcdFx0aW5kZXggPSBcImtcIiArIHJlZi5mcmFnbWVudC5rZXk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRpbmRleCA9IFwiaVwiICsgcmVmLmZyYWdtZW50LmluZGV4O1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0aGlzLmNhbGxiYWNrKGdldEtleXBhdGgoXCJAXCIgKyBpbmRleCkpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMucmVmLnJlZi5mcmFnbWVudC51bnJlZ2lzdGVySW5kZXhSZWYodGhpcyk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBSZXNvbHZlcnNfSW5kZXhSZXNvbHZlciA9IEluZGV4UmVzb2x2ZXI7XG5cbiAgdmFyIFJlc29sdmVyc19maW5kSW5kZXhSZWZzID0gZmluZEluZGV4UmVmcztcblxuICBmdW5jdGlvbiBmaW5kSW5kZXhSZWZzKGZyYWdtZW50LCByZWZOYW1lKSB7XG4gIFx0dmFyIHJlc3VsdCA9IHt9LFxuICBcdCAgICByZWZzLFxuICBcdCAgICBmcmFnUmVmcyxcbiAgXHQgICAgcmVmLFxuICBcdCAgICBpLFxuICBcdCAgICBvd25lcixcbiAgXHQgICAgaGl0ID0gZmFsc2U7XG5cbiAgXHRpZiAoIXJlZk5hbWUpIHtcbiAgXHRcdHJlc3VsdC5yZWZzID0gcmVmcyA9IHt9O1xuICBcdH1cblxuICBcdHdoaWxlIChmcmFnbWVudCkge1xuICBcdFx0aWYgKChvd25lciA9IGZyYWdtZW50Lm93bmVyKSAmJiAoZnJhZ1JlZnMgPSBvd25lci5pbmRleFJlZnMpKSB7XG5cbiAgXHRcdFx0Ly8gd2UncmUgbG9va2luZyBmb3IgYSBwYXJ0aWN1bGFyIHJlZiwgYW5kIGl0J3MgaGVyZVxuICBcdFx0XHRpZiAocmVmTmFtZSAmJiAocmVmID0gb3duZXIuZ2V0SW5kZXhSZWYocmVmTmFtZSkpKSB7XG4gIFx0XHRcdFx0cmVzdWx0LnJlZiA9IHtcbiAgXHRcdFx0XHRcdGZyYWdtZW50OiBmcmFnbWVudCxcbiAgXHRcdFx0XHRcdHJlZjogcmVmXG4gIFx0XHRcdFx0fTtcbiAgXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gd2UncmUgY29sbGVjdGluZyByZWZzIHVwLXRyZWVcbiAgXHRcdFx0ZWxzZSBpZiAoIXJlZk5hbWUpIHtcbiAgXHRcdFx0XHRmb3IgKGkgaW4gZnJhZ1JlZnMpIHtcbiAgXHRcdFx0XHRcdHJlZiA9IGZyYWdSZWZzW2ldO1xuXG4gIFx0XHRcdFx0XHQvLyBkb24ndCBvdmVyd3JpdGUgZXhpc3RpbmcgcmVmcyAtIHRoZXkgc2hvdWxkIHNoYWRvdyBwYXJlbnRzXG4gIFx0XHRcdFx0XHRpZiAoIXJlZnNbcmVmLm5dKSB7XG4gIFx0XHRcdFx0XHRcdGhpdCA9IHRydWU7XG4gIFx0XHRcdFx0XHRcdHJlZnNbcmVmLm5dID0ge1xuICBcdFx0XHRcdFx0XHRcdGZyYWdtZW50OiBmcmFnbWVudCxcbiAgXHRcdFx0XHRcdFx0XHRyZWY6IHJlZlxuICBcdFx0XHRcdFx0XHR9O1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyB3YXRjaCBmb3IgY29tcG9uZW50IGJvdW5kYXJpZXNcbiAgXHRcdGlmICghZnJhZ21lbnQucGFyZW50ICYmIGZyYWdtZW50Lm93bmVyICYmIGZyYWdtZW50Lm93bmVyLmNvbXBvbmVudCAmJiBmcmFnbWVudC5vd25lci5jb21wb25lbnQucGFyZW50RnJhZ21lbnQgJiYgIWZyYWdtZW50Lm93bmVyLmNvbXBvbmVudC5pbnN0YW5jZS5pc29sYXRlZCkge1xuICBcdFx0XHRyZXN1bHQuY29tcG9uZW50Qm91bmRhcnkgPSB0cnVlO1xuICBcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50Lm93bmVyLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50O1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICghaGl0KSB7XG4gIFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdH1cbiAgfVxuXG4gIGZpbmRJbmRleFJlZnMucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoaW5kaWNlcykge1xuICBcdHZhciByZWZzID0ge30sXG4gIFx0ICAgIGssXG4gIFx0ICAgIHJlZjtcblxuICBcdGZvciAoayBpbiBpbmRpY2VzLnJlZnMpIHtcbiAgXHRcdHJlZiA9IGluZGljZXMucmVmc1trXTtcbiAgXHRcdHJlZnNbcmVmLnJlZi5uXSA9IHJlZi5yZWYudCA9PT0gXCJrXCIgPyByZWYuZnJhZ21lbnQua2V5IDogcmVmLmZyYWdtZW50LmluZGV4O1xuICBcdH1cblxuICBcdHJldHVybiByZWZzO1xuICB9O1xuXG4gIHZhciBSZXNvbHZlcnNfY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIgPSBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlcjtcbiAgZnVuY3Rpb24gY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIob3duZXIsIHJlZiwgY2FsbGJhY2spIHtcbiAgXHR2YXIgaW5kZXhSZWY7XG5cbiAgXHRpZiAocmVmLmNoYXJBdCgwKSA9PT0gXCJAXCIpIHtcbiAgXHRcdHJldHVybiBuZXcgUmVzb2x2ZXJzX1NwZWNpYWxSZXNvbHZlcihvd25lciwgcmVmLCBjYWxsYmFjayk7XG4gIFx0fVxuXG4gIFx0aWYgKGluZGV4UmVmID0gUmVzb2x2ZXJzX2ZpbmRJbmRleFJlZnMob3duZXIucGFyZW50RnJhZ21lbnQsIHJlZikpIHtcbiAgXHRcdHJldHVybiBuZXcgUmVzb2x2ZXJzX0luZGV4UmVzb2x2ZXIob3duZXIsIGluZGV4UmVmLCBjYWxsYmFjayk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG5ldyBSZXNvbHZlcnNfUmVmZXJlbmNlUmVzb2x2ZXIob3duZXIsIHJlZiwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIHNoYXJlZF9nZXRGdW5jdGlvbkZyb21TdHJpbmcgPSBnZXRGdW5jdGlvbkZyb21TdHJpbmc7XG4gIHZhciBjYWNoZSA9IHt9O1xuICBmdW5jdGlvbiBnZXRGdW5jdGlvbkZyb21TdHJpbmcoc3RyLCBpKSB7XG4gIFx0dmFyIGZuLCBhcmdzO1xuXG4gIFx0aWYgKGNhY2hlW3N0cl0pIHtcbiAgXHRcdHJldHVybiBjYWNoZVtzdHJdO1xuICBcdH1cblxuICBcdGFyZ3MgPSBbXTtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRhcmdzW2ldID0gXCJfXCIgKyBpO1xuICBcdH1cblxuICBcdGZuID0gbmV3IEZ1bmN0aW9uKGFyZ3Muam9pbihcIixcIiksIFwicmV0dXJuKFwiICsgc3RyICsgXCIpXCIpO1xuXG4gIFx0Y2FjaGVbc3RyXSA9IGZuO1xuICBcdHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciBFeHByZXNzaW9uUmVzb2x2ZXIsXG4gICAgICBSZXNvbHZlcnNfRXhwcmVzc2lvblJlc29sdmVyX19iaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ7XG5cbiAgRXhwcmVzc2lvblJlc29sdmVyID0gZnVuY3Rpb24gKG93bmVyLCBwYXJlbnRGcmFnbWVudCwgZXhwcmVzc2lvbiwgY2FsbGJhY2spIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIHJhY3RpdmU7XG5cbiAgXHRyYWN0aXZlID0gb3duZXIucm9vdDtcblxuICBcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IHBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgXHR0aGlzLm93bmVyID0gb3duZXI7XG4gIFx0dGhpcy5zdHIgPSBleHByZXNzaW9uLnM7XG4gIFx0dGhpcy5rZXlwYXRocyA9IFtdO1xuXG4gIFx0Ly8gQ3JlYXRlIHJlc29sdmVycyBmb3IgZWFjaCByZWZlcmVuY2VcbiAgXHR0aGlzLnBlbmRpbmcgPSBleHByZXNzaW9uLnIubGVuZ3RoO1xuICBcdHRoaXMucmVmUmVzb2x2ZXJzID0gZXhwcmVzc2lvbi5yLm1hcChmdW5jdGlvbiAocmVmLCBpKSB7XG4gIFx0XHRyZXR1cm4gUmVzb2x2ZXJzX2NyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKF90aGlzLCByZWYsIGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdF90aGlzLnJlc29sdmUoaSwga2V5cGF0aCk7XG4gIFx0XHR9KTtcbiAgXHR9KTtcblxuICBcdHRoaXMucmVhZHkgPSB0cnVlO1xuICBcdHRoaXMuYnViYmxlKCk7XG4gIH07XG5cbiAgRXhwcmVzc2lvblJlc29sdmVyLnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5yZWFkeSkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMudW5pcXVlU3RyaW5nID0gZ2V0VW5pcXVlU3RyaW5nKHRoaXMuc3RyLCB0aGlzLmtleXBhdGhzKTtcbiAgXHRcdHRoaXMua2V5cGF0aCA9IGNyZWF0ZUV4cHJlc3Npb25LZXlwYXRoKHRoaXMudW5pcXVlU3RyaW5nKTtcblxuICBcdFx0dGhpcy5jcmVhdGVFdmFsdWF0b3IoKTtcbiAgXHRcdHRoaXMuY2FsbGJhY2sodGhpcy5rZXlwYXRoKTtcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcmVzb2x2ZXI7XG5cbiAgXHRcdHdoaWxlIChyZXNvbHZlciA9IHRoaXMucmVmUmVzb2x2ZXJzLnBvcCgpKSB7XG4gIFx0XHRcdHJlc29sdmVyLnVuYmluZCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZXNvbHZlOiBmdW5jdGlvbiAoaW5kZXgsIGtleXBhdGgpIHtcbiAgXHRcdHRoaXMua2V5cGF0aHNbaW5kZXhdID0ga2V5cGF0aDtcbiAgXHRcdHRoaXMuYnViYmxlKCk7XG4gIFx0fSxcblxuICBcdGNyZWF0ZUV2YWx1YXRvcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIGNvbXB1dGF0aW9uLCB2YWx1ZUdldHRlcnMsIHNpZ25hdHVyZSwga2V5cGF0aCwgZm47XG5cbiAgXHRcdGtleXBhdGggPSB0aGlzLmtleXBhdGg7XG4gIFx0XHRjb21wdXRhdGlvbiA9IHRoaXMucm9vdC52aWV3bW9kZWwuY29tcHV0YXRpb25zW2tleXBhdGguc3RyXTtcblxuICBcdFx0Ly8gb25seSBpZiBpdCBkb2Vzbid0IGV4aXN0IHlldCFcbiAgXHRcdGlmICghY29tcHV0YXRpb24pIHtcbiAgXHRcdFx0Zm4gPSBzaGFyZWRfZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nKHRoaXMuc3RyLCB0aGlzLnJlZlJlc29sdmVycy5sZW5ndGgpO1xuXG4gIFx0XHRcdHZhbHVlR2V0dGVycyA9IHRoaXMua2V5cGF0aHMubWFwKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdFx0dmFyIHZhbHVlO1xuXG4gIFx0XHRcdFx0aWYgKGtleXBhdGggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG4gIFx0XHRcdFx0XHR9O1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdC8vICdzcGVjaWFsJyBrZXlwYXRocyBlbmNvZGUgYSB2YWx1ZVxuICBcdFx0XHRcdGlmIChrZXlwYXRoLmlzU3BlY2lhbCkge1xuICBcdFx0XHRcdFx0dmFsdWUgPSBrZXlwYXRoLnZhbHVlO1xuICBcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuICBcdFx0XHRcdFx0fTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0dmFyIHZhbHVlID0gX3RoaXMucm9vdC52aWV3bW9kZWwuZ2V0KGtleXBhdGgsIHsgbm9VbndyYXA6IHRydWUsIGZ1bGxSb290R2V0OiB0cnVlIH0pO1xuICBcdFx0XHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdFx0XHRcdHZhbHVlID0gd3JhcEZ1bmN0aW9uKHZhbHVlLCBfdGhpcy5yb290KTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcbiAgXHRcdFx0XHR9O1xuICBcdFx0XHR9KTtcblxuICBcdFx0XHRzaWduYXR1cmUgPSB7XG4gIFx0XHRcdFx0ZGVwczogdGhpcy5rZXlwYXRocy5maWx0ZXIoaXNWYWxpZERlcGVuZGVuY3kpLFxuICBcdFx0XHRcdGdldHRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0dmFyIGFyZ3MgPSB2YWx1ZUdldHRlcnMubWFwKGNhbGwpO1xuICBcdFx0XHRcdFx0cmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fTtcblxuICBcdFx0XHRjb21wdXRhdGlvbiA9IHRoaXMucm9vdC52aWV3bW9kZWwuY29tcHV0ZShrZXlwYXRoLCBzaWduYXR1cmUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5tYXJrKGtleXBhdGgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHQvLyBUT0RPIG9ubHkgYnViYmxlIG9uY2UsIG5vIG1hdHRlciBob3cgbWFueSByZWZlcmVuY2VzIGFyZSBhZmZlY3RlZCBieSB0aGUgcmViaW5kXG4gIFx0XHR0aGlzLnJlZlJlc29sdmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gIFx0XHRcdHJldHVybiByLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdH0pO1xuICBcdH1cbiAgfTtcblxuICB2YXIgUmVzb2x2ZXJzX0V4cHJlc3Npb25SZXNvbHZlciA9IEV4cHJlc3Npb25SZXNvbHZlcjtcblxuICBmdW5jdGlvbiBjYWxsKHZhbHVlKSB7XG4gIFx0cmV0dXJuIHZhbHVlLmNhbGwoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFVuaXF1ZVN0cmluZyhzdHIsIGtleXBhdGhzKSB7XG4gIFx0Ly8gZ2V0IHN0cmluZyB0aGF0IGlzIHVuaXF1ZSB0byB0aGlzIGV4cHJlc3Npb25cbiAgXHRyZXR1cm4gc3RyLnJlcGxhY2UoL18oWzAtOV0rKS9nLCBmdW5jdGlvbiAobWF0Y2gsICQxKSB7XG4gIFx0XHR2YXIga2V5cGF0aCwgdmFsdWU7XG5cbiAgXHRcdC8vIG1ha2Ugc3VyZSB3ZSdyZSBub3QgcmVwbGFjaW5nIGEgbm9uLWtleXBhdGggX1swLTldXG4gIFx0XHRpZiAoKyQxID49IGtleXBhdGhzLmxlbmd0aCkge1xuICBcdFx0XHRyZXR1cm4gXCJfXCIgKyAkMTtcbiAgXHRcdH1cblxuICBcdFx0a2V5cGF0aCA9IGtleXBhdGhzWyQxXTtcblxuICBcdFx0aWYgKGtleXBhdGggPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGtleXBhdGguaXNTcGVjaWFsKSB7XG4gIFx0XHRcdHZhbHVlID0ga2V5cGF0aC52YWx1ZTtcbiAgXHRcdFx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiA/IHZhbHVlIDogXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ga2V5cGF0aC5zdHI7XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFeHByZXNzaW9uS2V5cGF0aCh1bmlxdWVTdHJpbmcpIHtcbiAgXHQvLyBTYW5pdGl6ZSBieSByZW1vdmluZyBhbnkgcGVyaW9kcyBvciBzcXVhcmUgYnJhY2tldHMuIE90aGVyd2lzZVxuICBcdC8vIHdlIGNhbid0IHNwbGl0IHRoZSBrZXlwYXRoIGludG8ga2V5cyFcbiAgXHQvLyBSZW1vdmUgYXN0ZXJpc2tzIHRvbywgc2luY2UgdGhleSBtZXNzIHdpdGggcGF0dGVybiBvYnNlcnZlcnNcbiAgXHRyZXR1cm4gZ2V0S2V5cGF0aChcIiR7XCIgKyB1bmlxdWVTdHJpbmcucmVwbGFjZSgvW1xcLlxcW1xcXV0vZywgXCItXCIpLnJlcGxhY2UoL1xcKi8sIFwiI01VTCNcIikgKyBcIn1cIik7XG4gIH1cblxuICBmdW5jdGlvbiBpc1ZhbGlkRGVwZW5kZW5jeShrZXlwYXRoKSB7XG4gIFx0cmV0dXJuIGtleXBhdGggIT09IHVuZGVmaW5lZCAmJiBrZXlwYXRoWzBdICE9PSBcIkBcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBGdW5jdGlvbihmbiwgcmFjdGl2ZSkge1xuICBcdHZhciB3cmFwcGVkLCBwcm9wLCBrZXk7XG5cbiAgXHRpZiAoZm4uX19yYWN0aXZlX25vd3JhcCkge1xuICBcdFx0cmV0dXJuIGZuO1xuICBcdH1cblxuICBcdHByb3AgPSBcIl9fcmFjdGl2ZV9cIiArIHJhY3RpdmUuX2d1aWQ7XG4gIFx0d3JhcHBlZCA9IGZuW3Byb3BdO1xuXG4gIFx0aWYgKHdyYXBwZWQpIHtcbiAgXHRcdHJldHVybiB3cmFwcGVkO1xuICBcdH0gZWxzZSBpZiAoL3RoaXMvLnRlc3QoZm4udG9TdHJpbmcoKSkpIHtcbiAgXHRcdGRlZmluZVByb3BlcnR5KGZuLCBwcm9wLCB7XG4gIFx0XHRcdHZhbHVlOiBSZXNvbHZlcnNfRXhwcmVzc2lvblJlc29sdmVyX19iaW5kLmNhbGwoZm4sIHJhY3RpdmUpLFxuICBcdFx0XHRjb25maWd1cmFibGU6IHRydWVcbiAgXHRcdH0pO1xuXG4gIFx0XHQvLyBBZGQgcHJvcGVydGllcy9tZXRob2RzIHRvIHdyYXBwZWQgZnVuY3Rpb25cbiAgXHRcdGZvciAoa2V5IGluIGZuKSB7XG4gIFx0XHRcdGlmIChmbi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gIFx0XHRcdFx0Zm5bcHJvcF1ba2V5XSA9IGZuW2tleV07XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmFjdGl2ZS5fYm91bmRGdW5jdGlvbnMucHVzaCh7XG4gIFx0XHRcdGZuOiBmbixcbiAgXHRcdFx0cHJvcDogcHJvcFxuICBcdFx0fSk7XG5cbiAgXHRcdHJldHVybiBmbltwcm9wXTtcbiAgXHR9XG5cbiAgXHRkZWZpbmVQcm9wZXJ0eShmbiwgXCJfX3JhY3RpdmVfbm93cmFwXCIsIHtcbiAgXHRcdHZhbHVlOiBmblxuICBcdH0pO1xuXG4gIFx0cmV0dXJuIGZuLl9fcmFjdGl2ZV9ub3dyYXA7XG4gIH1cblxuICB2YXIgTWVtYmVyUmVzb2x2ZXIgPSBmdW5jdGlvbiAodGVtcGxhdGUsIHJlc29sdmVyLCBwYXJlbnRGcmFnbWVudCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR0aGlzLnJlc29sdmVyID0gcmVzb2x2ZXI7XG4gIFx0dGhpcy5yb290ID0gcmVzb2x2ZXIucm9vdDtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gcGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy52aWV3bW9kZWwgPSByZXNvbHZlci5yb290LnZpZXdtb2RlbDtcblxuICBcdGlmICh0eXBlb2YgdGVtcGxhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHRoaXMudmFsdWUgPSB0ZW1wbGF0ZTtcbiAgXHR9XG5cbiAgXHQvLyBTaW1wbGUgcmVmZXJlbmNlP1xuICBcdGVsc2UgaWYgKHRlbXBsYXRlLnQgPT09IFJFRkVSRU5DRSkge1xuICBcdFx0dGhpcy5yZWZSZXNvbHZlciA9IFJlc29sdmVyc19jcmVhdGVSZWZlcmVuY2VSZXNvbHZlcih0aGlzLCB0ZW1wbGF0ZS5uLCBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRfdGhpcy5yZXNvbHZlKGtleXBhdGgpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0Ly8gT3RoZXJ3aXNlIHdlIGhhdmUgYW4gZXhwcmVzc2lvbiBpbiBpdHMgb3duIHJpZ2h0XG4gIFx0ZWxzZSB7XG4gIFx0XHRuZXcgUmVzb2x2ZXJzX0V4cHJlc3Npb25SZXNvbHZlcihyZXNvbHZlciwgcGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlLCBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRfdGhpcy5yZXNvbHZlKGtleXBhdGgpO1xuICBcdFx0fSk7XG4gIFx0fVxuICB9O1xuXG4gIE1lbWJlclJlc29sdmVyLnByb3RvdHlwZSA9IHtcbiAgXHRyZXNvbHZlOiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0aWYgKHRoaXMua2V5cGF0aCkge1xuICBcdFx0XHR0aGlzLnZpZXdtb2RlbC51bnJlZ2lzdGVyKHRoaXMua2V5cGF0aCwgdGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0XHR0aGlzLnZhbHVlID0gdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuXG4gIFx0XHR0aGlzLmJpbmQoKTtcblxuICBcdFx0dGhpcy5yZXNvbHZlci5idWJibGUoKTtcbiAgXHR9LFxuXG4gIFx0YmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy52aWV3bW9kZWwucmVnaXN0ZXIodGhpcy5rZXlwYXRoLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0aWYgKHRoaXMucmVmUmVzb2x2ZXIpIHtcbiAgXHRcdFx0dGhpcy5yZWZSZXNvbHZlci5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgXHRcdHRoaXMucmVzb2x2ZXIuYnViYmxlKCk7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMua2V5cGF0aCkge1xuICBcdFx0XHR0aGlzLnZpZXdtb2RlbC51bnJlZ2lzdGVyKHRoaXMua2V5cGF0aCwgdGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLnJlZlJlc29sdmVyKSB7XG4gIFx0XHRcdHRoaXMucmVmUmVzb2x2ZXIudW5iaW5kKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGZvcmNlUmVzb2x1dGlvbjogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMucmVmUmVzb2x2ZXIpIHtcbiAgXHRcdFx0dGhpcy5yZWZSZXNvbHZlci5mb3JjZVJlc29sdXRpb24oKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9NZW1iZXJSZXNvbHZlciA9IE1lbWJlclJlc29sdmVyO1xuXG4gIHZhciBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIgPSBmdW5jdGlvbiAobXVzdGFjaGUsIHRlbXBsYXRlLCBjYWxsYmFjaykge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgcmFjdGl2ZSwgcmVmLCBrZXlwYXRoLCBwYXJlbnRGcmFnbWVudDtcblxuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudCA9IG11c3RhY2hlLnBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMucm9vdCA9IHJhY3RpdmUgPSBtdXN0YWNoZS5yb290O1xuICBcdHRoaXMubXVzdGFjaGUgPSBtdXN0YWNoZTtcblxuICBcdHRoaXMucmVmID0gcmVmID0gdGVtcGxhdGUucjtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgXHR0aGlzLnVucmVzb2x2ZWQgPSBbXTtcblxuICBcdC8vIEZpbmQgYmFzZSBrZXlwYXRoXG4gIFx0aWYgKGtleXBhdGggPSBzaGFyZWRfcmVzb2x2ZVJlZihyYWN0aXZlLCByZWYsIHBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0dGhpcy5iYXNlID0ga2V5cGF0aDtcbiAgXHR9IGVsc2Uge1xuICBcdFx0dGhpcy5iYXNlUmVzb2x2ZXIgPSBuZXcgUmVzb2x2ZXJzX1JlZmVyZW5jZVJlc29sdmVyKHRoaXMsIHJlZiwgZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0X3RoaXMuYmFzZSA9IGtleXBhdGg7XG4gIFx0XHRcdF90aGlzLmJhc2VSZXNvbHZlciA9IG51bGw7XG4gIFx0XHRcdF90aGlzLmJ1YmJsZSgpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0Ly8gRmluZCB2YWx1ZXMgZm9yIG1lbWJlcnMsIG9yIG1hcmsgdGhlbSBhcyB1bnJlc29sdmVkXG4gIFx0dGhpcy5tZW1iZXJzID0gdGVtcGxhdGUubS5tYXAoZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gIFx0XHRyZXR1cm4gbmV3IFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9NZW1iZXJSZXNvbHZlcih0ZW1wbGF0ZSwgX3RoaXMsIHBhcmVudEZyYWdtZW50KTtcbiAgXHR9KTtcblxuICBcdHRoaXMucmVhZHkgPSB0cnVlO1xuICBcdHRoaXMuYnViYmxlKCk7IC8vIHRyaWdnZXIgaW5pdGlhbCByZXNvbHV0aW9uIGlmIHBvc3NpYmxlXG4gIH07XG5cbiAgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyLnByb3RvdHlwZSA9IHtcbiAgXHRnZXRLZXlwYXRoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgdmFsdWVzID0gdGhpcy5tZW1iZXJzLm1hcChSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXJfUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX19nZXRWYWx1ZSk7XG5cbiAgXHRcdGlmICghdmFsdWVzLmV2ZXJ5KGlzRGVmaW5lZCkgfHwgdGhpcy5iYXNlUmVzb2x2ZXIpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzLmJhc2Uuam9pbih2YWx1ZXMuam9pbihcIi5cIikpO1xuICBcdH0sXG5cbiAgXHRidWJibGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5yZWFkeSB8fCB0aGlzLmJhc2VSZXNvbHZlcikge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuY2FsbGJhY2sodGhpcy5nZXRLZXlwYXRoKCkpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMubWVtYmVycy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdHZhciBjaGFuZ2VkO1xuXG4gIFx0XHRpZiAodGhpcy5iYXNlKSB7XG4gIFx0XHRcdHZhciBuZXdCYXNlID0gdGhpcy5iYXNlLnJlcGxhY2Uob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHRcdGlmIChuZXdCYXNlICYmIG5ld0Jhc2UgIT09IHRoaXMuYmFzZSkge1xuICBcdFx0XHRcdHRoaXMuYmFzZSA9IG5ld0Jhc2U7XG4gIFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0dGhpcy5tZW1iZXJzLmZvckVhY2goZnVuY3Rpb24gKG1lbWJlcnMpIHtcbiAgXHRcdFx0aWYgKG1lbWJlcnMucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpKSB7XG4gIFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuXG4gIFx0XHRpZiAoY2hhbmdlZCkge1xuICBcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRmb3JjZVJlc29sdXRpb246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmJhc2VSZXNvbHZlcikge1xuICBcdFx0XHR0aGlzLmJhc2UgPSBnZXRLZXlwYXRoKHRoaXMucmVmKTtcblxuICBcdFx0XHR0aGlzLmJhc2VSZXNvbHZlci51bmJpbmQoKTtcbiAgXHRcdFx0dGhpcy5iYXNlUmVzb2x2ZXIgPSBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLm1lbWJlcnMuZm9yRWFjaChmb3JjZVJlc29sdXRpb24pO1xuICBcdFx0dGhpcy5idWJibGUoKTtcbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9fZ2V0VmFsdWUobWVtYmVyKSB7XG4gIFx0cmV0dXJuIG1lbWJlci52YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICBcdHJldHVybiB2YWx1ZSAhPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JjZVJlc29sdXRpb24obWVtYmVyKSB7XG4gIFx0bWVtYmVyLmZvcmNlUmVzb2x1dGlvbigpO1xuICB9XG5cbiAgdmFyIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9SZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIgPSBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXI7XG5cbiAgdmFyIE11c3RhY2hlX2luaXRpYWxpc2UgPSBNdXN0YWNoZSRpbml0O1xuICBmdW5jdGlvbiBNdXN0YWNoZSRpbml0KG11c3RhY2hlLCBvcHRpb25zKSB7XG5cbiAgXHR2YXIgcmVmLCBwYXJlbnRGcmFnbWVudCwgdGVtcGxhdGU7XG5cbiAgXHRwYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuXG4gIFx0bXVzdGFjaGUucm9vdCA9IHBhcmVudEZyYWdtZW50LnJvb3Q7XG4gIFx0bXVzdGFjaGUucGFyZW50RnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudDtcbiAgXHRtdXN0YWNoZS5wRWxlbWVudCA9IHBhcmVudEZyYWdtZW50LnBFbGVtZW50O1xuXG4gIFx0bXVzdGFjaGUudGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICBcdG11c3RhY2hlLmluZGV4ID0gb3B0aW9ucy5pbmRleCB8fCAwO1xuICBcdG11c3RhY2hlLmlzU3RhdGljID0gb3B0aW9ucy50ZW1wbGF0ZS5zO1xuXG4gIFx0bXVzdGFjaGUudHlwZSA9IG9wdGlvbnMudGVtcGxhdGUudDtcblxuICBcdG11c3RhY2hlLnJlZ2lzdGVyZWQgPSBmYWxzZTtcblxuICBcdC8vIGlmIHRoaXMgaXMgYSBzaW1wbGUgbXVzdGFjaGUsIHdpdGggYSByZWZlcmVuY2UsIHdlIGp1c3QgbmVlZCB0byByZXNvbHZlXG4gIFx0Ly8gdGhlIHJlZmVyZW5jZSB0byBhIGtleXBhdGhcbiAgXHRpZiAocmVmID0gdGVtcGxhdGUucikge1xuICBcdFx0bXVzdGFjaGUucmVzb2x2ZXIgPSBSZXNvbHZlcnNfY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIobXVzdGFjaGUsIHJlZiwgcmVzb2x2ZSk7XG4gIFx0fVxuXG4gIFx0Ly8gaWYgaXQncyBhbiBleHByZXNzaW9uLCB3ZSBoYXZlIGEgYml0IG1vcmUgd29yayB0byBkb1xuICBcdGlmIChvcHRpb25zLnRlbXBsYXRlLngpIHtcbiAgXHRcdG11c3RhY2hlLnJlc29sdmVyID0gbmV3IFJlc29sdmVyc19FeHByZXNzaW9uUmVzb2x2ZXIobXVzdGFjaGUsIHBhcmVudEZyYWdtZW50LCBvcHRpb25zLnRlbXBsYXRlLngsIHJlc29sdmVBbmRSZWJpbmRDaGlsZHJlbik7XG4gIFx0fVxuXG4gIFx0aWYgKG9wdGlvbnMudGVtcGxhdGUucngpIHtcbiAgXHRcdG11c3RhY2hlLnJlc29sdmVyID0gbmV3IFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9SZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIobXVzdGFjaGUsIG9wdGlvbnMudGVtcGxhdGUucngsIHJlc29sdmVBbmRSZWJpbmRDaGlsZHJlbik7XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gaW52ZXJ0ZWQgc2VjdGlvbnNcbiAgXHRpZiAobXVzdGFjaGUudGVtcGxhdGUubiA9PT0gU0VDVElPTl9VTkxFU1MgJiYgIW11c3RhY2hlLmhhc093blByb3BlcnR5KFwidmFsdWVcIikpIHtcbiAgXHRcdG11c3RhY2hlLnNldFZhbHVlKHVuZGVmaW5lZCk7XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gcmVzb2x2ZShrZXlwYXRoKSB7XG4gIFx0XHRtdXN0YWNoZS5yZXNvbHZlKGtleXBhdGgpO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIHJlc29sdmVBbmRSZWJpbmRDaGlsZHJlbihuZXdLZXlwYXRoKSB7XG4gIFx0XHR2YXIgb2xkS2V5cGF0aCA9IG11c3RhY2hlLmtleXBhdGg7XG5cbiAgXHRcdGlmIChuZXdLZXlwYXRoICE9IG9sZEtleXBhdGgpIHtcbiAgXHRcdFx0bXVzdGFjaGUucmVzb2x2ZShuZXdLZXlwYXRoKTtcblxuICBcdFx0XHRpZiAob2xkS2V5cGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0bXVzdGFjaGUuZnJhZ21lbnRzICYmIG11c3RhY2hlLmZyYWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gIFx0XHRcdFx0XHRmLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdFx0XHR9KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBNdXN0YWNoZV9yZXNvbHZlID0gTXVzdGFjaGUkcmVzb2x2ZTtcblxuICBmdW5jdGlvbiBNdXN0YWNoZSRyZXNvbHZlKGtleXBhdGgpIHtcbiAgXHR2YXIgd2FzUmVzb2x2ZWQsIHZhbHVlLCB0d293YXlCaW5kaW5nO1xuXG4gIFx0Ly8gJ1NwZWNpYWwnIGtleXBhdGhzLCBlLmcuIEBmb28gb3IgQDcsIGVuY29kZSBhIHZhbHVlXG4gIFx0aWYgKGtleXBhdGggJiYga2V5cGF0aC5pc1NwZWNpYWwpIHtcbiAgXHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0XHR0aGlzLnNldFZhbHVlKGtleXBhdGgudmFsdWUpO1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIElmIHdlIHJlc29sdmVkIHByZXZpb3VzbHksIHdlIG5lZWQgdG8gdW5yZWdpc3RlclxuICBcdGlmICh0aGlzLnJlZ2lzdGVyZWQpIHtcbiAgXHRcdC8vIHVuZGVmaW5lZCBvciBudWxsXG4gIFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnVucmVnaXN0ZXIodGhpcy5rZXlwYXRoLCB0aGlzKTtcbiAgXHRcdHRoaXMucmVnaXN0ZXJlZCA9IGZhbHNlO1xuXG4gIFx0XHR3YXNSZXNvbHZlZCA9IHRydWU7XG4gIFx0fVxuXG4gIFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblxuICBcdC8vIElmIHRoZSBuZXcga2V5cGF0aCBleGlzdHMsIHdlIG5lZWQgdG8gcmVnaXN0ZXJcbiAgXHQvLyB3aXRoIHRoZSB2aWV3bW9kZWxcbiAgXHRpZiAoa2V5cGF0aCAhPSB1bmRlZmluZWQpIHtcbiAgXHRcdC8vIHVuZGVmaW5lZCBvciBudWxsXG4gIFx0XHR2YWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5yZWdpc3RlcihrZXlwYXRoLCB0aGlzKTtcblxuICBcdFx0dGhpcy5yZWdpc3RlcmVkID0gdHJ1ZTtcbiAgXHR9XG5cbiAgXHQvLyBFaXRoZXIgd2F5IHdlIG5lZWQgdG8gcXVldWUgdXAgYSByZW5kZXIgKGB2YWx1ZWBcbiAgXHQvLyB3aWxsIGJlIGB1bmRlZmluZWRgIGlmIHRoZXJlJ3Mgbm8ga2V5cGF0aClcbiAgXHR0aGlzLnNldFZhbHVlKHZhbHVlKTtcblxuICBcdC8vIFR3by13YXkgYmluZGluZ3MgbmVlZCB0byBwb2ludCB0byB0aGVpciBuZXcgdGFyZ2V0IGtleXBhdGhcbiAgXHRpZiAod2FzUmVzb2x2ZWQgJiYgKHR3b3dheUJpbmRpbmcgPSB0aGlzLnR3b3dheUJpbmRpbmcpKSB7XG4gIFx0XHR0d293YXlCaW5kaW5nLnJlYm91bmQoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgTXVzdGFjaGVfcmViaW5kID0gTXVzdGFjaGUkcmViaW5kO1xuXG4gIGZ1bmN0aW9uIE11c3RhY2hlJHJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0Ly8gQ2hpbGRyZW4gZmlyc3RcbiAgXHRpZiAodGhpcy5mcmFnbWVudHMpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgXHRcdFx0cmV0dXJuIGYucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0Ly8gRXhwcmVzc2lvbiBtdXN0YWNoZT9cbiAgXHRpZiAodGhpcy5yZXNvbHZlcikge1xuICBcdFx0dGhpcy5yZXNvbHZlci5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIE11c3RhY2hlID0ge1xuICBcdGdldFZhbHVlOiBNdXN0YWNoZV9nZXRWYWx1ZSxcbiAgXHRpbml0OiBNdXN0YWNoZV9pbml0aWFsaXNlLFxuICBcdHJlc29sdmU6IE11c3RhY2hlX3Jlc29sdmUsXG4gIFx0cmViaW5kOiBNdXN0YWNoZV9yZWJpbmRcbiAgfTtcblxuICB2YXIgSW50ZXJwb2xhdG9yID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLnR5cGUgPSBJTlRFUlBPTEFUT1I7XG4gIFx0TXVzdGFjaGUuaW5pdCh0aGlzLCBvcHRpb25zKTtcbiAgfTtcblxuICBJbnRlcnBvbGF0b3IucHJvdG90eXBlID0ge1xuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5ub2RlLmRhdGEgPSB0aGlzLnZhbHVlID09IHVuZGVmaW5lZCA/IFwiXCIgOiB0aGlzLnZhbHVlO1xuICBcdH0sXG4gIFx0cmVzb2x2ZTogTXVzdGFjaGUucmVzb2x2ZSxcbiAgXHRyZWJpbmQ6IE11c3RhY2hlLnJlYmluZCxcbiAgXHRkZXRhY2g6IHNoYXJlZF9kZXRhY2gsXG5cbiAgXHR1bmJpbmQ6IHNoYXJlZF91bmJpbmQsXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5ub2RlKSB7XG4gIFx0XHRcdHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHNhZmVUb1N0cmluZ1ZhbHVlKHRoaXMudmFsdWUpKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRpZiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0XHRkZXRhY2hOb2RlKHRoaXMubm9kZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBNdXN0YWNoZS5nZXRWYWx1ZSxcblxuICBcdC8vIFRFTVBcbiAgXHRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHR2YXIgd3JhcHBlcjtcblxuICBcdFx0Ly8gVE9ETyBpcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gYXBwcm9hY2ggdGhpcz9cbiAgXHRcdGlmICh0aGlzLmtleXBhdGggJiYgKHdyYXBwZXIgPSB0aGlzLnJvb3Qudmlld21vZGVsLndyYXBwZWRbdGhpcy5rZXlwYXRoLnN0cl0pKSB7XG4gIFx0XHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFpc0VxdWFsKHZhbHVlLCB0aGlzLnZhbHVlKSkge1xuICBcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG4gIFx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG5cbiAgXHRcdFx0aWYgKHRoaXMubm9kZSkge1xuICBcdFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFZpZXcodGhpcyk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Zmlyc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH0sXG5cbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKGVzY2FwZSkge1xuICBcdFx0dmFyIHN0cmluZyA9IFwiXCIgKyBzYWZlVG9TdHJpbmdWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgXHRcdHJldHVybiBlc2NhcGUgPyBlc2NhcGVIdG1sKHN0cmluZykgOiBzdHJpbmc7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBpdGVtc19JbnRlcnBvbGF0b3IgPSBJbnRlcnBvbGF0b3I7XG5cbiAgdmFyIFNlY3Rpb25fcHJvdG90eXBlX2J1YmJsZSA9IFNlY3Rpb24kYnViYmxlO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kYnViYmxlKCkge1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG4gIH1cblxuICB2YXIgU2VjdGlvbl9wcm90b3R5cGVfZGV0YWNoID0gU2VjdGlvbiRkZXRhY2g7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRkZXRhY2goKSB7XG4gIFx0dmFyIGRvY0ZyYWc7XG5cbiAgXHRpZiAodGhpcy5mcmFnbWVudHMubGVuZ3RoID09PSAxKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudHNbMF0uZGV0YWNoKCk7XG4gIFx0fVxuXG4gIFx0ZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICBcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgXHRcdGRvY0ZyYWcuYXBwZW5kQ2hpbGQoaXRlbS5kZXRhY2goKSk7XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gZG9jRnJhZztcbiAgfVxuXG4gIHZhciBmaW5kID0gU2VjdGlvbiRmaW5kO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kZmluZChzZWxlY3Rvcikge1xuICBcdHZhciBpLCBsZW4sIHF1ZXJ5UmVzdWx0O1xuXG4gIFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0aWYgKHF1ZXJ5UmVzdWx0ID0gdGhpcy5mcmFnbWVudHNbaV0uZmluZChzZWxlY3RvcikpIHtcbiAgXHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGZpbmRBbGwgPSBTZWN0aW9uJGZpbmRBbGw7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRmaW5kQWxsKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdHZhciBpLCBsZW47XG5cbiAgXHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50c1tpXS5maW5kQWxsKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGZpbmRBbGxDb21wb25lbnRzID0gU2VjdGlvbiRmaW5kQWxsQ29tcG9uZW50cztcblxuICBmdW5jdGlvbiBTZWN0aW9uJGZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdHZhciBpLCBsZW47XG5cbiAgXHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50c1tpXS5maW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBmaW5kQ29tcG9uZW50ID0gU2VjdGlvbiRmaW5kQ29tcG9uZW50O1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kZmluZENvbXBvbmVudChzZWxlY3Rvcikge1xuICBcdHZhciBpLCBsZW4sIHF1ZXJ5UmVzdWx0O1xuXG4gIFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0aWYgKHF1ZXJ5UmVzdWx0ID0gdGhpcy5mcmFnbWVudHNbaV0uZmluZENvbXBvbmVudChzZWxlY3RvcikpIHtcbiAgXHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGZpbmROZXh0Tm9kZSA9IFNlY3Rpb24kZmluZE5leHROb2RlO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kZmluZE5leHROb2RlKGZyYWdtZW50KSB7XG4gIFx0aWYgKHRoaXMuZnJhZ21lbnRzW2ZyYWdtZW50LmluZGV4ICsgMV0pIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50c1tmcmFnbWVudC5pbmRleCArIDFdLmZpcnN0Tm9kZSgpO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgfVxuXG4gIHZhciBmaXJzdE5vZGUgPSBTZWN0aW9uJGZpcnN0Tm9kZTtcblxuICBmdW5jdGlvbiBTZWN0aW9uJGZpcnN0Tm9kZSgpIHtcbiAgXHR2YXIgbGVuLCBpLCBub2RlO1xuXG4gIFx0aWYgKGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdGlmIChub2RlID0gdGhpcy5mcmFnbWVudHNbaV0uZmlyc3ROb2RlKCkpIHtcbiAgXHRcdFx0XHRyZXR1cm4gbm9kZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgfVxuXG4gIHZhciBzaHVmZmxlID0gU2VjdGlvbiRzaHVmZmxlO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kc2h1ZmZsZShuZXdJbmRpY2VzKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBwYXJlbnRGcmFnbWVudCwgZmlyc3RDaGFuZ2UsIGksIG5ld0xlbmd0aCwgcmVib3VuZEZyYWdtZW50cywgZnJhZ21lbnRPcHRpb25zLCBmcmFnbWVudDtcblxuICBcdC8vIHNob3J0IGNpcmN1aXQgYW55IGRvdWJsZS11cGRhdGVzLCBhbmQgZW5zdXJlIHRoYXQgdGhpcyBpc24ndCBhcHBsaWVkIHRvXG4gIFx0Ly8gbm9uLWxpc3Qgc2VjdGlvbnNcbiAgXHRpZiAodGhpcy5zaHVmZmxpbmcgfHwgdGhpcy51bmJvdW5kIHx8IHRoaXMuY3VycmVudFN1YnR5cGUgIT09IFNFQ1RJT05fRUFDSCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHRoaXMuc2h1ZmZsaW5nID0gdHJ1ZTtcbiAgXHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIF90aGlzLnNodWZmbGluZyA9IGZhbHNlO1xuICBcdH0pO1xuXG4gIFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50O1xuXG4gIFx0cmVib3VuZEZyYWdtZW50cyA9IFtdO1xuXG4gIFx0Ly8gVE9ETzogbmVlZCB0byB1cGRhdGUgdGhpc1xuICBcdC8vIGZpcnN0LCByZWJpbmQgZXhpc3RpbmcgZnJhZ21lbnRzXG4gIFx0bmV3SW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZXdJbmRleCwgb2xkSW5kZXgpIHtcbiAgXHRcdHZhciBmcmFnbWVudCwgYnksIG9sZEtleXBhdGgsIG5ld0tleXBhdGgsIGRlcHM7XG5cbiAgXHRcdGlmIChuZXdJbmRleCA9PT0gb2xkSW5kZXgpIHtcbiAgXHRcdFx0cmVib3VuZEZyYWdtZW50c1tuZXdJbmRleF0gPSBfdGhpcy5mcmFnbWVudHNbb2xkSW5kZXhdO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGZyYWdtZW50ID0gX3RoaXMuZnJhZ21lbnRzW29sZEluZGV4XTtcblxuICBcdFx0aWYgKGZpcnN0Q2hhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0Zmlyc3RDaGFuZ2UgPSBvbGRJbmRleDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gZG9lcyB0aGlzIGZyYWdtZW50IG5lZWQgdG8gYmUgdG9ybiBkb3duP1xuICBcdFx0aWYgKG5ld0luZGV4ID09PSAtMSkge1xuICBcdFx0XHRfdGhpcy5mcmFnbWVudHNUb1VucmVuZGVyLnB1c2goZnJhZ21lbnQpO1xuICBcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBPdGhlcndpc2UsIGl0IG5lZWRzIHRvIGJlIHJlYm91bmQgdG8gYSBuZXcgaW5kZXhcbiAgXHRcdGJ5ID0gbmV3SW5kZXggLSBvbGRJbmRleDtcbiAgXHRcdG9sZEtleXBhdGggPSBfdGhpcy5rZXlwYXRoLmpvaW4ob2xkSW5kZXgpO1xuICBcdFx0bmV3S2V5cGF0aCA9IF90aGlzLmtleXBhdGguam9pbihuZXdJbmRleCk7XG5cbiAgXHRcdGZyYWdtZW50LmluZGV4ID0gbmV3SW5kZXg7XG5cbiAgXHRcdC8vIG5vdGlmeSBhbnkgcmVnaXN0ZXJlZCBpbmRleCByZWZzIGRpcmVjdGx5XG4gIFx0XHRpZiAoZGVwcyA9IGZyYWdtZW50LnJlZ2lzdGVyZWRJbmRleFJlZnMpIHtcbiAgXHRcdFx0ZGVwcy5mb3JFYWNoKHNodWZmbGVfX2JsaW5kUmViaW5kKTtcbiAgXHRcdH1cblxuICBcdFx0ZnJhZ21lbnQucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0cmVib3VuZEZyYWdtZW50c1tuZXdJbmRleF0gPSBmcmFnbWVudDtcbiAgXHR9KTtcblxuICBcdG5ld0xlbmd0aCA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KHRoaXMua2V5cGF0aCkubGVuZ3RoO1xuXG4gIFx0Ly8gSWYgbm90aGluZyBjaGFuZ2VkIHdpdGggdGhlIGV4aXN0aW5nIGZyYWdtZW50cywgdGhlbiB3ZSBzdGFydCBhZGRpbmdcbiAgXHQvLyBuZXcgZnJhZ21lbnRzIGF0IHRoZSBlbmQuLi5cbiAgXHRpZiAoZmlyc3RDaGFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0Ly8gLi4udW5sZXNzIHRoZXJlIGFyZSBubyBuZXcgZnJhZ21lbnRzIHRvIGFkZFxuICBcdFx0aWYgKHRoaXMubGVuZ3RoID09PSBuZXdMZW5ndGgpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRmaXJzdENoYW5nZSA9IHRoaXMubGVuZ3RoO1xuICBcdH1cblxuICBcdHRoaXMubGVuZ3RoID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoID0gbmV3TGVuZ3RoO1xuXG4gIFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLmFkZFZpZXcodGhpcyk7XG4gIFx0fVxuXG4gIFx0Ly8gUHJlcGFyZSBuZXcgZnJhZ21lbnQgb3B0aW9uc1xuICBcdGZyYWdtZW50T3B0aW9ucyA9IHtcbiAgXHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLmYsXG4gIFx0XHRyb290OiB0aGlzLnJvb3QsXG4gIFx0XHRvd25lcjogdGhpc1xuICBcdH07XG5cbiAgXHQvLyBBZGQgYXMgbWFueSBuZXcgZnJhZ21lbnRzIGFzIHdlIG5lZWQgdG8sIG9yIGFkZCBiYWNrIGV4aXN0aW5nXG4gIFx0Ly8gKGRldGFjaGVkKSBmcmFnbWVudHNcbiAgXHRmb3IgKGkgPSBmaXJzdENoYW5nZTsgaSA8IG5ld0xlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRmcmFnbWVudCA9IHJlYm91bmRGcmFnbWVudHNbaV07XG5cbiAgXHRcdGlmICghZnJhZ21lbnQpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZS5wdXNoKGkpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmZyYWdtZW50c1tpXSA9IGZyYWdtZW50O1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNodWZmbGVfX2JsaW5kUmViaW5kKGRlcCkge1xuICBcdC8vIHRoZSBrZXlwYXRoIGRvZXNuJ3QgYWN0dWFsbHkgbWF0dGVyIGhlcmUgYXMgaXQgd29uJ3QgaGF2ZSBjaGFuZ2VkXG4gIFx0ZGVwLnJlYmluZChcIlwiLCBcIlwiKTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfcmViaW5kID0gZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRNdXN0YWNoZS5yZWJpbmQuY2FsbCh0aGlzLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgfTtcblxuICB2YXIgU2VjdGlvbl9wcm90b3R5cGVfcmVuZGVyID0gU2VjdGlvbiRyZW5kZXI7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRyZW5kZXIoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHRoaXMuZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICBcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgXHRcdHJldHVybiBfdGhpcy5kb2NGcmFnLmFwcGVuZENoaWxkKGYucmVuZGVyKCkpO1xuICBcdH0pO1xuXG4gIFx0dGhpcy5yZW5kZXJlZEZyYWdtZW50cyA9IHRoaXMuZnJhZ21lbnRzLnNsaWNlKCk7XG4gIFx0dGhpcy5mcmFnbWVudHNUb1JlbmRlciA9IFtdO1xuXG4gIFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gIFx0cmV0dXJuIHRoaXMuZG9jRnJhZztcbiAgfVxuXG4gIHZhciBzZXRWYWx1ZSA9IFNlY3Rpb24kc2V0VmFsdWU7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRzZXRWYWx1ZSh2YWx1ZSkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgd3JhcHBlciwgZnJhZ21lbnRPcHRpb25zO1xuXG4gIFx0aWYgKHRoaXMudXBkYXRpbmcpIHtcbiAgXHRcdC8vIElmIGEgY2hpbGQgb2YgdGhpcyBzZWN0aW9uIGNhdXNlcyBhIHJlLWV2YWx1YXRpb24gLSBmb3IgZXhhbXBsZSwgYW5cbiAgXHRcdC8vIGV4cHJlc3Npb24gcmVmZXJzIHRvIGEgZnVuY3Rpb24gdGhhdCBtdXRhdGVzIHRoZSBhcnJheSB0aGF0IHRoaXNcbiAgXHRcdC8vIHNlY3Rpb24gZGVwZW5kcyBvbiAtIHdlJ2xsIGVuZCB1cCB3aXRoIGEgZG91YmxlIHJlbmRlcmluZyBidWcgKHNlZVxuICBcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3Vlcy83NDgpLiBUaGlzIHByZXZlbnRzIGl0LlxuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuXG4gIFx0Ly8gd2l0aCBzZWN0aW9ucywgd2UgbmVlZCB0byBnZXQgdGhlIGZha2UgdmFsdWUgaWYgd2UgaGF2ZSBhIHdyYXBwZWQgb2JqZWN0XG4gIFx0aWYgKHRoaXMua2V5cGF0aCAmJiAod3JhcHBlciA9IHRoaXMucm9vdC52aWV3bW9kZWwud3JhcHBlZFt0aGlzLmtleXBhdGguc3RyXSkpIHtcbiAgXHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcbiAgXHR9XG5cbiAgXHQvLyBJZiBhbnkgZnJhZ21lbnRzIGFyZSBhd2FpdGluZyBjcmVhdGlvbiBhZnRlciBhIHNwbGljZSxcbiAgXHQvLyB0aGlzIGlzIHRoZSBwbGFjZSB0byBkbyBpdFxuICBcdGlmICh0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLmxlbmd0aCkge1xuICBcdFx0ZnJhZ21lbnRPcHRpb25zID0ge1xuICBcdFx0XHR0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZS5mIHx8IFtdLFxuICBcdFx0XHRyb290OiB0aGlzLnJvb3QsXG4gIFx0XHRcdHBFbGVtZW50OiB0aGlzLnBFbGVtZW50LFxuICBcdFx0XHRvd25lcjogdGhpc1xuICBcdFx0fTtcblxuICBcdFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZS5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICBcdFx0XHR2YXIgZnJhZ21lbnQ7XG5cbiAgXHRcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSBfdGhpcy5rZXlwYXRoLmpvaW4oaW5kZXgpO1xuICBcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSBpbmRleDtcblxuICBcdFx0XHRmcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0XHRcdF90aGlzLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goX3RoaXMuZnJhZ21lbnRzW2luZGV4XSA9IGZyYWdtZW50KTtcbiAgXHRcdH0pO1xuXG4gIFx0XHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLmxlbmd0aCA9IDA7XG4gIFx0fSBlbHNlIGlmIChyZWV2YWx1YXRlU2VjdGlvbih0aGlzLCB2YWx1ZSkpIHtcbiAgXHRcdHRoaXMuYnViYmxlKCk7XG5cbiAgXHRcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFZpZXcodGhpcyk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuICBcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYW5nZUN1cnJlbnRTdWJ0eXBlKHNlY3Rpb24sIHZhbHVlLCBvYmopIHtcbiAgXHRpZiAodmFsdWUgPT09IFNFQ1RJT05fRUFDSCkge1xuICBcdFx0Ly8gbWFrZSBzdXJlIHJlZiB0eXBlIGlzIHVwIHRvIGRhdGUgZm9yIGtleSBvciB2YWx1ZSBpbmRpY2VzXG4gIFx0XHRpZiAoc2VjdGlvbi5pbmRleFJlZnMgJiYgc2VjdGlvbi5pbmRleFJlZnNbMF0pIHtcbiAgXHRcdFx0dmFyIHJlZiA9IHNlY3Rpb24uaW5kZXhSZWZzWzBdO1xuXG4gIFx0XHRcdC8vIHdoZW4gc3dpdGNoaW5nIGZsYXZvcnMsIG1ha2Ugc3VyZSB0aGUgc2VjdGlvbiBnZXRzIHVwZGF0ZWRcbiAgXHRcdFx0aWYgKG9iaiAmJiByZWYudCA9PT0gXCJpXCIgfHwgIW9iaiAmJiByZWYudCA9PT0gXCJrXCIpIHtcbiAgXHRcdFx0XHQvLyBpZiBzd2l0Y2hpbmcgZnJvbSBvYmplY3QgdG8gbGlzdCwgdW5iaW5kIGFsbCBvZiB0aGUgb2xkIGZyYWdtZW50c1xuICBcdFx0XHRcdGlmICghb2JqKSB7XG4gIFx0XHRcdFx0XHRzZWN0aW9uLmxlbmd0aCA9IDA7XG4gIFx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zbGljZSgwKTtcbiAgXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gIFx0XHRcdFx0XHRcdHJldHVybiBmLnVuYmluZCgpO1xuICBcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmVmLnQgPSBvYmogPyBcImtcIiA6IFwiaVwiO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHNlY3Rpb24uY3VycmVudFN1YnR5cGUgPSB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZXZhbHVhdGVTZWN0aW9uKHNlY3Rpb24sIHZhbHVlKSB7XG4gIFx0dmFyIGZyYWdtZW50T3B0aW9ucyA9IHtcbiAgXHRcdHRlbXBsYXRlOiBzZWN0aW9uLnRlbXBsYXRlLmYgfHwgW10sXG4gIFx0XHRyb290OiBzZWN0aW9uLnJvb3QsXG4gIFx0XHRwRWxlbWVudDogc2VjdGlvbi5wYXJlbnRGcmFnbWVudC5wRWxlbWVudCxcbiAgXHRcdG93bmVyOiBzZWN0aW9uXG4gIFx0fTtcblxuICBcdHNlY3Rpb24uaGFzQ29udGV4dCA9IHRydWU7XG5cbiAgXHQvLyBJZiB3ZSBhbHJlYWR5IGtub3cgdGhlIHNlY3Rpb24gdHlwZSwgZ3JlYXRcbiAgXHQvLyBUT0RPIGNhbiB0aGlzIGJlIG9wdGltaXNlZD8gaS5lLiBwaWNrIGFuIHJlZXZhbHVhdGVTZWN0aW9uIGZ1bmN0aW9uIGR1cmluZyBpbml0XG4gIFx0Ly8gYW5kIGF2b2lkIGRvaW5nIHRoaXMgZWFjaCB0aW1lP1xuICBcdGlmIChzZWN0aW9uLnN1YnR5cGUpIHtcbiAgXHRcdHN3aXRjaCAoc2VjdGlvbi5zdWJ0eXBlKSB7XG4gIFx0XHRcdGNhc2UgU0VDVElPTl9JRjpcbiAgXHRcdFx0XHRzZWN0aW9uLmhhc0NvbnRleHQgPSBmYWxzZTtcbiAgXHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZmFsc2UsIGZyYWdtZW50T3B0aW9ucyk7XG5cbiAgXHRcdFx0Y2FzZSBTRUNUSU9OX1VOTEVTUzpcbiAgXHRcdFx0XHRzZWN0aW9uLmhhc0NvbnRleHQgPSBmYWxzZTtcbiAgXHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgdHJ1ZSwgZnJhZ21lbnRPcHRpb25zKTtcblxuICBcdFx0XHRjYXNlIFNFQ1RJT05fV0lUSDpcbiAgXHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucyk7XG5cbiAgXHRcdFx0Y2FzZSBTRUNUSU9OX0lGX1dJVEg6XG4gIFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb25kaXRpb25hbENvbnRleHRTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMpO1xuXG4gIFx0XHRcdGNhc2UgU0VDVElPTl9FQUNIOlxuICBcdFx0XHRcdGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgXHRcdFx0XHRcdGNoYW5nZUN1cnJlbnRTdWJ0eXBlKHNlY3Rpb24sIHNlY3Rpb24uc3VidHlwZSwgdHJ1ZSk7XG4gIFx0XHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUxpc3RPYmplY3RTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdC8vIEZhbGx0aHJvdWdoIC0gaWYgaXQncyBhIGNvbmRpdGlvbmFsIG9yIGFuIGFycmF5IHdlIG5lZWQgdG8gY29udGludWVcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byB3b3JrIG91dCB3aGF0IHNvcnQgb2Ygc2VjdGlvbiB3ZSdyZSBkZWFsaW5nIHdpdGhcbiAgXHRzZWN0aW9uLm9yZGVyZWQgPSAhIWlzQXJyYXlMaWtlKHZhbHVlKTtcblxuICBcdC8vIE9yZGVyZWQgbGlzdCBzZWN0aW9uXG4gIFx0aWYgKHNlY3Rpb24ub3JkZXJlZCkge1xuICBcdFx0Y2hhbmdlQ3VycmVudFN1YnR5cGUoc2VjdGlvbiwgU0VDVElPTl9FQUNILCBmYWxzZSk7XG4gIFx0XHRyZXR1cm4gcmVldmFsdWF0ZUxpc3RTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMpO1xuICBcdH1cblxuICBcdC8vIFVub3JkZXJlZCBsaXN0LCBvciBjb250ZXh0XG4gIFx0aWYgKGlzT2JqZWN0KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0Ly8gSW5kZXggcmVmZXJlbmNlIGluZGljYXRlcyBzZWN0aW9uIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgbGlzdFxuICBcdFx0aWYgKHNlY3Rpb24udGVtcGxhdGUuaSkge1xuICBcdFx0XHRjaGFuZ2VDdXJyZW50U3VidHlwZShzZWN0aW9uLCBTRUNUSU9OX0VBQ0gsIHRydWUpO1xuICBcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUxpc3RPYmplY3RTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBPdGhlcndpc2UsIG9iamVjdCBwcm92aWRlcyBjb250ZXh0IGZvciBjb250ZW50c1xuICBcdFx0Y2hhbmdlQ3VycmVudFN1YnR5cGUoc2VjdGlvbiwgU0VDVElPTl9XSVRILCBmYWxzZSk7XG4gIFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0fVxuXG4gIFx0Ly8gQ29uZGl0aW9uYWwgc2VjdGlvblxuICBcdGNoYW5nZUN1cnJlbnRTdWJ0eXBlKHNlY3Rpb24sIFNFQ1RJT05fSUYsIGZhbHNlKTtcbiAgXHRzZWN0aW9uLmhhc0NvbnRleHQgPSBmYWxzZTtcbiAgXHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZmFsc2UsIGZyYWdtZW50T3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiByZWV2YWx1YXRlTGlzdFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucykge1xuICBcdHZhciBpLCBsZW5ndGgsIGZyYWdtZW50O1xuXG4gIFx0bGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXG4gIFx0aWYgKGxlbmd0aCA9PT0gc2VjdGlvbi5sZW5ndGgpIHtcbiAgXHRcdC8vIE5vdGhpbmcgdG8gZG9cbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9XG5cbiAgXHQvLyBpZiB0aGUgYXJyYXkgaXMgc2hvcnRlciB0aGFuIGl0IHdhcyBwcmV2aW91c2x5LCByZW1vdmUgaXRlbXNcbiAgXHRpZiAobGVuZ3RoIDwgc2VjdGlvbi5sZW5ndGgpIHtcbiAgXHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlciA9IHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZShsZW5ndGgsIHNlY3Rpb24ubGVuZ3RoIC0gbGVuZ3RoKTtcbiAgXHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0fVxuXG4gIFx0Ly8gb3RoZXJ3aXNlLi4uXG4gIFx0ZWxzZSB7XG4gIFx0XHRpZiAobGVuZ3RoID4gc2VjdGlvbi5sZW5ndGgpIHtcbiAgXHRcdFx0Ly8gYWRkIGFueSBuZXcgb25lc1xuICBcdFx0XHRmb3IgKGkgPSBzZWN0aW9uLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRcdFx0Ly8gYXBwZW5kIGxpc3QgaXRlbSB0byBjb250ZXh0IHN0YWNrXG4gIFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSBzZWN0aW9uLmtleXBhdGguam9pbihpKTtcbiAgXHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSBpO1xuXG4gIFx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudChmcmFnbWVudE9wdGlvbnMpO1xuICBcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIucHVzaChzZWN0aW9uLmZyYWdtZW50c1tpXSA9IGZyYWdtZW50KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHNlY3Rpb24ubGVuZ3RoID0gbGVuZ3RoO1xuICBcdHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVldmFsdWF0ZUxpc3RPYmplY3RTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMpIHtcbiAgXHR2YXIgaWQsIGksIGhhc0tleSwgZnJhZ21lbnQsIGNoYW5nZWQsIGRlcHM7XG5cbiAgXHRoYXNLZXkgPSBzZWN0aW9uLmhhc0tleSB8fCAoc2VjdGlvbi5oYXNLZXkgPSB7fSk7XG5cbiAgXHQvLyByZW1vdmUgYW55IGZyYWdtZW50cyB0aGF0IHNob3VsZCBubyBsb25nZXIgZXhpc3RcbiAgXHRpID0gc2VjdGlvbi5mcmFnbWVudHMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGZyYWdtZW50ID0gc2VjdGlvbi5mcmFnbWVudHNbaV07XG5cbiAgXHRcdGlmICghKGZyYWdtZW50LmtleSBpbiB2YWx1ZSkpIHtcbiAgXHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cbiAgXHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5wdXNoKGZyYWdtZW50KTtcbiAgXHRcdFx0c2VjdGlvbi5mcmFnbWVudHMuc3BsaWNlKGksIDEpO1xuXG4gIFx0XHRcdGhhc0tleVtmcmFnbWVudC5rZXldID0gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gbm90aWZ5IGFueSBkZXBlbmRlbnRzIGFib3V0IGNoYW5nZWQgaW5kaWNlc1xuICBcdGkgPSBzZWN0aW9uLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0ZnJhZ21lbnQgPSBzZWN0aW9uLmZyYWdtZW50c1tpXTtcblxuICBcdFx0aWYgKGZyYWdtZW50LmluZGV4ICE9PSBpKSB7XG4gIFx0XHRcdGZyYWdtZW50LmluZGV4ID0gaTtcbiAgXHRcdFx0aWYgKGRlcHMgPSBmcmFnbWVudC5yZWdpc3RlcmVkSW5kZXhSZWZzKSB7XG4gIFx0XHRcdFx0ZGVwcy5mb3JFYWNoKHNldFZhbHVlX19ibGluZFJlYmluZCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBhZGQgYW55IHRoYXQgaGF2ZW4ndCBiZWVuIGNyZWF0ZWQgeWV0XG4gIFx0aSA9IHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHRmb3IgKGlkIGluIHZhbHVlKSB7XG4gIFx0XHRpZiAoIWhhc0tleVtpZF0pIHtcbiAgXHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cbiAgXHRcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSBzZWN0aW9uLmtleXBhdGguam9pbihpZCk7XG4gIFx0XHRcdGZyYWdtZW50T3B0aW9ucy5rZXkgPSBpZDtcbiAgXHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gaSsrO1xuXG4gIFx0XHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoZnJhZ21lbnRPcHRpb25zKTtcblxuICBcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goZnJhZ21lbnQpO1xuICBcdFx0XHRzZWN0aW9uLmZyYWdtZW50cy5wdXNoKGZyYWdtZW50KTtcbiAgXHRcdFx0aGFzS2V5W2lkXSA9IHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0c2VjdGlvbi5sZW5ndGggPSBzZWN0aW9uLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0cmV0dXJuIGNoYW5nZWQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWV2YWx1YXRlQ29uZGl0aW9uYWxDb250ZXh0U2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zKSB7XG4gIFx0aWYgKHZhbHVlKSB7XG4gIFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiByZW1vdmVTZWN0aW9uRnJhZ21lbnRzKHNlY3Rpb24pO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZXZhbHVhdGVDb250ZXh0U2VjdGlvbihzZWN0aW9uLCBmcmFnbWVudE9wdGlvbnMpIHtcbiAgXHR2YXIgZnJhZ21lbnQ7XG5cbiAgXHQvLyAuLi50aGVuIGlmIGl0IGlzbid0IHJlbmRlcmVkLCByZW5kZXIgaXQsIGFkZGluZyBzZWN0aW9uLmtleXBhdGggdG8gdGhlIGNvbnRleHQgc3RhY2tcbiAgXHQvLyAoaWYgaXQgaXMgYWxyZWFkeSByZW5kZXJlZCwgdGhlbiBhbnkgY2hpbGRyZW4gZGVwZW5kZW50IG9uIHRoZSBjb250ZXh0IHN0YWNrXG4gIFx0Ly8gd2lsbCB1cGRhdGUgdGhlbXNlbHZlcyB3aXRob3V0IGFueSBwcm9tcHRpbmcpXG4gIFx0aWYgKCFzZWN0aW9uLmxlbmd0aCkge1xuICBcdFx0Ly8gYXBwZW5kIHRoaXMgc2VjdGlvbiB0byB0aGUgY29udGV4dCBzdGFja1xuICBcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSBzZWN0aW9uLmtleXBhdGg7XG4gIFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSAwO1xuXG4gIFx0XHRmcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KGZyYWdtZW50T3B0aW9ucyk7XG5cbiAgXHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIucHVzaChzZWN0aW9uLmZyYWdtZW50c1swXSA9IGZyYWdtZW50KTtcbiAgXHRcdHNlY3Rpb24ubGVuZ3RoID0gMTtcblxuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgaW52ZXJ0ZWQsIGZyYWdtZW50T3B0aW9ucykge1xuICBcdHZhciBkb1JlbmRlciwgZW1wdHlBcnJheSwgZW1wdHlPYmplY3QsIGZyYWdtZW50LCBuYW1lO1xuXG4gIFx0ZW1wdHlBcnJheSA9IGlzQXJyYXlMaWtlKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDA7XG4gIFx0ZW1wdHlPYmplY3QgPSBmYWxzZTtcbiAgXHRpZiAoIWlzQXJyYXlMaWtlKHZhbHVlKSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgXHRcdGVtcHR5T2JqZWN0ID0gdHJ1ZTtcbiAgXHRcdGZvciAobmFtZSBpbiB2YWx1ZSkge1xuICBcdFx0XHRlbXB0eU9iamVjdCA9IGZhbHNlO1xuICBcdFx0XHRicmVhaztcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoaW52ZXJ0ZWQpIHtcbiAgXHRcdGRvUmVuZGVyID0gZW1wdHlBcnJheSB8fCBlbXB0eU9iamVjdCB8fCAhdmFsdWU7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGRvUmVuZGVyID0gdmFsdWUgJiYgIWVtcHR5QXJyYXkgJiYgIWVtcHR5T2JqZWN0O1xuICBcdH1cblxuICBcdGlmIChkb1JlbmRlcikge1xuICBcdFx0aWYgKCFzZWN0aW9uLmxlbmd0aCkge1xuICBcdFx0XHQvLyBubyBjaGFuZ2UgdG8gY29udGV4dCBzdGFja1xuICBcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSAwO1xuXG4gIFx0XHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoZnJhZ21lbnRPcHRpb25zKTtcbiAgXHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5wdXNoKHNlY3Rpb24uZnJhZ21lbnRzWzBdID0gZnJhZ21lbnQpO1xuICBcdFx0XHRzZWN0aW9uLmxlbmd0aCA9IDE7XG5cbiAgXHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChzZWN0aW9uLmxlbmd0aCA+IDEpIHtcbiAgXHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyID0gc2VjdGlvbi5mcmFnbWVudHMuc3BsaWNlKDEpO1xuICBcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuXG4gIFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXR1cm4gcmVtb3ZlU2VjdGlvbkZyYWdtZW50cyhzZWN0aW9uKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVTZWN0aW9uRnJhZ21lbnRzKHNlY3Rpb24pIHtcbiAgXHRpZiAoc2VjdGlvbi5sZW5ndGgpIHtcbiAgXHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlciA9IHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZSgwLCBzZWN0aW9uLmZyYWdtZW50cy5sZW5ndGgpLmZpbHRlcihpc1JlbmRlcmVkKTtcbiAgXHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0XHRzZWN0aW9uLmxlbmd0aCA9IHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIubGVuZ3RoID0gMDtcbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUmVuZGVyZWQoZnJhZ21lbnQpIHtcbiAgXHRyZXR1cm4gZnJhZ21lbnQucmVuZGVyZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRWYWx1ZV9fYmxpbmRSZWJpbmQoZGVwKSB7XG4gIFx0Ly8gdGhlIGtleXBhdGggZG9lc24ndCBhY3R1YWxseSBtYXR0ZXIgaGVyZSBhcyBpdCB3b24ndCBoYXZlIGNoYW5nZWRcbiAgXHRkZXAucmViaW5kKFwiXCIsIFwiXCIpO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV90b1N0cmluZyA9IFNlY3Rpb24kdG9TdHJpbmc7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiR0b1N0cmluZyhlc2NhcGUpIHtcbiAgXHR2YXIgc3RyLCBpLCBsZW47XG5cbiAgXHRzdHIgPSBcIlwiO1xuXG4gIFx0aSA9IDA7XG4gIFx0bGVuID0gdGhpcy5sZW5ndGg7XG5cbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdHN0ciArPSB0aGlzLmZyYWdtZW50c1tpXS50b1N0cmluZyhlc2NhcGUpO1xuICBcdH1cblxuICBcdHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3VuYmluZCA9IFNlY3Rpb24kdW5iaW5kO1xuICBmdW5jdGlvbiBTZWN0aW9uJHVuYmluZCgpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuICBcdHRoaXMuZnJhZ21lbnRzVG9SZW5kZXIuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICBcdFx0cmV0dXJuIHJlbW92ZUZyb21BcnJheShfdGhpcy5mcmFnbWVudHMsIGYpO1xuICBcdH0pO1xuICBcdHRoaXMuZnJhZ21lbnRzVG9SZW5kZXIgPSBbXTtcbiAgXHRzaGFyZWRfdW5iaW5kLmNhbGwodGhpcyk7XG5cbiAgXHR0aGlzLmxlbmd0aCA9IDA7XG4gIFx0dGhpcy51bmJvdW5kID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfdW5yZW5kZXIgPSBTZWN0aW9uJHVucmVuZGVyO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kdW5yZW5kZXIoc2hvdWxkRGVzdHJveSkge1xuICBcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goc2hvdWxkRGVzdHJveSA/IHVucmVuZGVyQW5kRGVzdHJveSA6IHByb3RvdHlwZV91bnJlbmRlcl9fdW5yZW5kZXIpO1xuICBcdHRoaXMucmVuZGVyZWRGcmFnbWVudHMgPSBbXTtcbiAgXHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiB1bnJlbmRlckFuZERlc3Ryb3koZnJhZ21lbnQpIHtcbiAgXHRmcmFnbWVudC51bnJlbmRlcih0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb3RvdHlwZV91bnJlbmRlcl9fdW5yZW5kZXIoZnJhZ21lbnQpIHtcbiAgXHRmcmFnbWVudC51bnJlbmRlcihmYWxzZSk7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3VwZGF0ZSA9IFNlY3Rpb24kdXBkYXRlO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kdXBkYXRlKCkge1xuICBcdHZhciBmcmFnbWVudCwgcmVuZGVySW5kZXgsIHJlbmRlcmVkRnJhZ21lbnRzLCBhbmNob3IsIHRhcmdldCwgaSwgbGVuO1xuXG4gIFx0Ly8gYHRoaXMucmVuZGVyZWRGcmFnbWVudHNgIGlzIGluIHRoZSBvcmRlciBvZiB0aGUgcHJldmlvdXMgcmVuZGVyLlxuICBcdC8vIElmIGZyYWdtZW50cyBoYXZlIHNodWZmbGVkIGFib3V0LCB0aGlzIGFsbG93cyB1cyB0byBxdWlja2x5XG4gIFx0Ly8gcmVpbnNlcnQgdGhlbSBpbiB0aGUgY29ycmVjdCBwbGFjZVxuICBcdHJlbmRlcmVkRnJhZ21lbnRzID0gdGhpcy5yZW5kZXJlZEZyYWdtZW50cztcblxuICBcdC8vIFJlbW92ZSBmcmFnbWVudHMgdGhhdCBoYXZlIGJlZW4gbWFya2VkIGZvciBkZXN0cnVjdGlvblxuICBcdHdoaWxlIChmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzVG9VbnJlbmRlci5wb3AoKSkge1xuICBcdFx0ZnJhZ21lbnQudW5yZW5kZXIodHJ1ZSk7XG4gIFx0XHRyZW5kZXJlZEZyYWdtZW50cy5zcGxpY2UocmVuZGVyZWRGcmFnbWVudHMuaW5kZXhPZihmcmFnbWVudCksIDEpO1xuICBcdH1cblxuICBcdC8vIFJlbmRlciBuZXcgZnJhZ21lbnRzIChidXQgZG9uJ3QgaW5zZXJ0IHRoZW0geWV0KVxuICBcdHdoaWxlIChmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzVG9SZW5kZXIuc2hpZnQoKSkge1xuICBcdFx0ZnJhZ21lbnQucmVuZGVyKCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdHRhcmdldCA9IHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpO1xuICBcdH1cblxuICBcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudHNbaV07XG4gIFx0XHRyZW5kZXJJbmRleCA9IHJlbmRlcmVkRnJhZ21lbnRzLmluZGV4T2YoZnJhZ21lbnQsIGkpOyAvLyBzZWFyY2ggZnJvbSBjdXJyZW50IGluZGV4IC0gaXQncyBndWFyYW50ZWVkIHRvIGJlIHRoZSBzYW1lIG9yIGhpZ2hlclxuXG4gIFx0XHRpZiAocmVuZGVySW5kZXggPT09IGkpIHtcbiAgXHRcdFx0Ly8gYWxyZWFkeSBpbiB0aGUgcmlnaHQgcGxhY2UuIGluc2VydCBhY2N1bXVsYXRlZCBub2RlcyAoaWYgYW55KSBhbmQgY2Fycnkgb25cbiAgXHRcdFx0aWYgKHRoaXMuZG9jRnJhZy5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICBcdFx0XHRcdGFuY2hvciA9IGZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuICBcdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUodGhpcy5kb2NGcmFnLCBhbmNob3IpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Y29udGludWU7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZG9jRnJhZy5hcHBlbmRDaGlsZChmcmFnbWVudC5kZXRhY2goKSk7XG5cbiAgXHRcdC8vIHVwZGF0ZSByZW5kZXJlZEZyYWdtZW50c1xuICBcdFx0aWYgKHJlbmRlckluZGV4ICE9PSAtMSkge1xuICBcdFx0XHRyZW5kZXJlZEZyYWdtZW50cy5zcGxpY2UocmVuZGVySW5kZXgsIDEpO1xuICBcdFx0fVxuICBcdFx0cmVuZGVyZWRGcmFnbWVudHMuc3BsaWNlKGksIDAsIGZyYWdtZW50KTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5yZW5kZXJlZCAmJiB0aGlzLmRvY0ZyYWcuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgXHRcdGFuY2hvciA9IHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICBcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSh0aGlzLmRvY0ZyYWcsIGFuY2hvcik7XG4gIFx0fVxuXG4gIFx0Ly8gU2F2ZSB0aGUgcmVuZGVyaW5nIG9yZGVyIGZvciBuZXh0IHRpbWVcbiAgXHR0aGlzLnJlbmRlcmVkRnJhZ21lbnRzID0gdGhpcy5mcmFnbWVudHMuc2xpY2UoKTtcbiAgfVxuXG4gIHZhciBTZWN0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLnR5cGUgPSBTRUNUSU9OO1xuICBcdHRoaXMuc3VidHlwZSA9IHRoaXMuY3VycmVudFN1YnR5cGUgPSBvcHRpb25zLnRlbXBsYXRlLm47XG4gIFx0dGhpcy5pbnZlcnRlZCA9IHRoaXMuc3VidHlwZSA9PT0gU0VDVElPTl9VTkxFU1M7XG5cbiAgXHR0aGlzLnBFbGVtZW50ID0gb3B0aW9ucy5wRWxlbWVudDtcblxuICBcdHRoaXMuZnJhZ21lbnRzID0gW107XG4gIFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZSA9IFtdO1xuICBcdHRoaXMuZnJhZ21lbnRzVG9SZW5kZXIgPSBbXTtcbiAgXHR0aGlzLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBbXTtcblxuICBcdGlmIChvcHRpb25zLnRlbXBsYXRlLmkpIHtcbiAgXHRcdHRoaXMuaW5kZXhSZWZzID0gb3B0aW9ucy50ZW1wbGF0ZS5pLnNwbGl0KFwiLFwiKS5tYXAoZnVuY3Rpb24gKGssIGkpIHtcbiAgXHRcdFx0cmV0dXJuIHsgbjogaywgdDogaSA9PT0gMCA/IFwia1wiIDogXCJpXCIgfTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHRoaXMucmVuZGVyZWRGcmFnbWVudHMgPSBbXTtcblxuICBcdHRoaXMubGVuZ3RoID0gMDsgLy8gbnVtYmVyIG9mIHRpbWVzIHRoaXMgc2VjdGlvbiBpcyByZW5kZXJlZFxuXG4gIFx0TXVzdGFjaGUuaW5pdCh0aGlzLCBvcHRpb25zKTtcbiAgfTtcblxuICBTZWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IFNlY3Rpb25fcHJvdG90eXBlX2J1YmJsZSxcbiAgXHRkZXRhY2g6IFNlY3Rpb25fcHJvdG90eXBlX2RldGFjaCxcbiAgXHRmaW5kOiBmaW5kLFxuICBcdGZpbmRBbGw6IGZpbmRBbGwsXG4gIFx0ZmluZEFsbENvbXBvbmVudHM6IGZpbmRBbGxDb21wb25lbnRzLFxuICBcdGZpbmRDb21wb25lbnQ6IGZpbmRDb21wb25lbnQsXG4gIFx0ZmluZE5leHROb2RlOiBmaW5kTmV4dE5vZGUsXG4gIFx0Zmlyc3ROb2RlOiBmaXJzdE5vZGUsXG4gIFx0Z2V0SW5kZXhSZWY6IGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0XHRpZiAodGhpcy5pbmRleFJlZnMpIHtcbiAgXHRcdFx0dmFyIGkgPSB0aGlzLmluZGV4UmVmcy5sZW5ndGg7XG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHR2YXIgcmVmID0gdGhpcy5pbmRleFJlZnNbaV07XG4gIFx0XHRcdFx0aWYgKHJlZi5uID09PSBuYW1lKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gcmVmO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG4gIFx0Z2V0VmFsdWU6IE11c3RhY2hlLmdldFZhbHVlLFxuICBcdHNodWZmbGU6IHNodWZmbGUsXG4gIFx0cmViaW5kOiBwcm90b3R5cGVfcmViaW5kLFxuICBcdHJlbmRlcjogU2VjdGlvbl9wcm90b3R5cGVfcmVuZGVyLFxuICBcdHJlc29sdmU6IE11c3RhY2hlLnJlc29sdmUsXG4gIFx0c2V0VmFsdWU6IHNldFZhbHVlLFxuICBcdHRvU3RyaW5nOiBwcm90b3R5cGVfdG9TdHJpbmcsXG4gIFx0dW5iaW5kOiBwcm90b3R5cGVfdW5iaW5kLFxuICBcdHVucmVuZGVyOiBwcm90b3R5cGVfdW5yZW5kZXIsXG4gIFx0dXBkYXRlOiBwcm90b3R5cGVfdXBkYXRlXG4gIH07XG5cbiAgdmFyIF9TZWN0aW9uID0gU2VjdGlvbjtcblxuICB2YXIgVHJpcGxlX3Byb3RvdHlwZV9kZXRhY2ggPSBUcmlwbGUkZGV0YWNoO1xuXG4gIGZ1bmN0aW9uIFRyaXBsZSRkZXRhY2goKSB7XG4gIFx0dmFyIGxlbiwgaTtcblxuICBcdGlmICh0aGlzLmRvY0ZyYWcpIHtcbiAgXHRcdGxlbiA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdHRoaXMuZG9jRnJhZy5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzW2ldKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXMuZG9jRnJhZztcbiAgXHR9XG4gIH1cblxuICB2YXIgVHJpcGxlX3Byb3RvdHlwZV9maW5kID0gVHJpcGxlJGZpbmQ7XG4gIGZ1bmN0aW9uIFRyaXBsZSRmaW5kKHNlbGVjdG9yKSB7XG4gIFx0dmFyIGksIGxlbiwgbm9kZSwgcXVlcnlSZXN1bHQ7XG5cbiAgXHRsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdG5vZGUgPSB0aGlzLm5vZGVzW2ldO1xuXG4gIFx0XHRpZiAobm9kZS5ub2RlVHlwZSAhPT0gMSkge1xuICBcdFx0XHRjb250aW51ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG1hdGNoZXMobm9kZSwgc2VsZWN0b3IpKSB7XG4gIFx0XHRcdHJldHVybiBub2RlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAocXVlcnlSZXN1bHQgPSBub2RlLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpKSB7XG4gIFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX2ZpbmRBbGwgPSBUcmlwbGUkZmluZEFsbDtcbiAgZnVuY3Rpb24gVHJpcGxlJGZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5UmVzdWx0KSB7XG4gIFx0dmFyIGksIGxlbiwgbm9kZSwgcXVlcnlBbGxSZXN1bHQsIG51bU5vZGVzLCBqO1xuXG4gIFx0bGVuID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRub2RlID0gdGhpcy5ub2Rlc1tpXTtcblxuICBcdFx0aWYgKG5vZGUubm9kZVR5cGUgIT09IDEpIHtcbiAgXHRcdFx0Y29udGludWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChtYXRjaGVzKG5vZGUsIHNlbGVjdG9yKSkge1xuICBcdFx0XHRxdWVyeVJlc3VsdC5wdXNoKG5vZGUpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAocXVlcnlBbGxSZXN1bHQgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKSB7XG4gIFx0XHRcdG51bU5vZGVzID0gcXVlcnlBbGxSZXN1bHQubGVuZ3RoO1xuICBcdFx0XHRmb3IgKGogPSAwOyBqIDwgbnVtTm9kZXM7IGogKz0gMSkge1xuICBcdFx0XHRcdHF1ZXJ5UmVzdWx0LnB1c2gocXVlcnlBbGxSZXN1bHRbal0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIFRyaXBsZV9wcm90b3R5cGVfZmlyc3ROb2RlID0gVHJpcGxlJGZpcnN0Tm9kZTtcblxuICBmdW5jdGlvbiBUcmlwbGUkZmlyc3ROb2RlKCkge1xuICBcdGlmICh0aGlzLnJlbmRlcmVkICYmIHRoaXMubm9kZXNbMF0pIHtcbiAgXHRcdHJldHVybiB0aGlzLm5vZGVzWzBdO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgfVxuXG4gIHZhciBlbGVtZW50Q2FjaGUgPSB7fSxcbiAgICAgIGllQnVnLFxuICAgICAgaWVCbGFja2xpc3Q7XG5cbiAgdHJ5IHtcbiAgXHRjcmVhdGVFbGVtZW50KFwidGFibGVcIikuaW5uZXJIVE1MID0gXCJmb29cIjtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gIFx0aWVCdWcgPSB0cnVlO1xuXG4gIFx0aWVCbGFja2xpc3QgPSB7XG4gIFx0XHRUQUJMRTogW1wiPHRhYmxlIGNsYXNzPVxcXCJ4XFxcIj5cIiwgXCI8L3RhYmxlPlwiXSxcbiAgXHRcdFRIRUFEOiBbXCI8dGFibGU+PHRoZWFkIGNsYXNzPVxcXCJ4XFxcIj5cIiwgXCI8L3RoZWFkPjwvdGFibGU+XCJdLFxuICBcdFx0VEJPRFk6IFtcIjx0YWJsZT48dGJvZHkgY2xhc3M9XFxcInhcXFwiPlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIl0sXG4gIFx0XHRUUjogW1wiPHRhYmxlPjx0ciBjbGFzcz1cXFwieFxcXCI+XCIsIFwiPC90cj48L3RhYmxlPlwiXSxcbiAgXHRcdFNFTEVDVDogW1wiPHNlbGVjdCBjbGFzcz1cXFwieFxcXCI+XCIsIFwiPC9zZWxlY3Q+XCJdXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBpbnNlcnRIdG1sID0gZnVuY3Rpb24gKGh0bWwsIG5vZGUsIGRvY0ZyYWcpIHtcbiAgXHR2YXIgY29udGFpbmVyLFxuICBcdCAgICBub2RlcyA9IFtdLFxuICBcdCAgICB3cmFwcGVyLFxuICBcdCAgICBzZWxlY3RlZE9wdGlvbixcbiAgXHQgICAgY2hpbGQsXG4gIFx0ICAgIGk7XG5cbiAgXHQvLyByZW5kZXIgMCBhbmQgZmFsc2VcbiAgXHRpZiAoaHRtbCAhPSBudWxsICYmIGh0bWwgIT09IFwiXCIpIHtcbiAgXHRcdGlmIChpZUJ1ZyAmJiAod3JhcHBlciA9IGllQmxhY2tsaXN0W25vZGUudGFnTmFtZV0pKSB7XG4gIFx0XHRcdGNvbnRhaW5lciA9IGVsZW1lbnQoXCJESVZcIik7XG4gIFx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSB3cmFwcGVyWzBdICsgaHRtbCArIHdyYXBwZXJbMV07XG4gIFx0XHRcdGNvbnRhaW5lciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLnhcIik7XG5cbiAgXHRcdFx0aWYgKGNvbnRhaW5lci50YWdOYW1lID09PSBcIlNFTEVDVFwiKSB7XG4gIFx0XHRcdFx0c2VsZWN0ZWRPcHRpb24gPSBjb250YWluZXIub3B0aW9uc1tjb250YWluZXIuc2VsZWN0ZWRJbmRleF07XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSBpZiAobm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuc3ZnKSB7XG4gIFx0XHRcdGNvbnRhaW5lciA9IGVsZW1lbnQoXCJESVZcIik7XG4gIFx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSBcIjxzdmcgY2xhc3M9XFxcInhcXFwiPlwiICsgaHRtbCArIFwiPC9zdmc+XCI7XG4gIFx0XHRcdGNvbnRhaW5lciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLnhcIik7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRjb250YWluZXIgPSBlbGVtZW50KG5vZGUudGFnTmFtZSk7XG4gIFx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuXG4gIFx0XHRcdGlmIChjb250YWluZXIudGFnTmFtZSA9PT0gXCJTRUxFQ1RcIikge1xuICBcdFx0XHRcdHNlbGVjdGVkT3B0aW9uID0gY29udGFpbmVyLm9wdGlvbnNbY29udGFpbmVyLnNlbGVjdGVkSW5kZXhdO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHdoaWxlIChjaGlsZCA9IGNvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gIFx0XHRcdG5vZGVzLnB1c2goY2hpbGQpO1xuICBcdFx0XHRkb2NGcmFnLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gVGhpcyBpcyByZWFsbHkgYW5ub3lpbmcuIEV4dHJhY3RpbmcgPG9wdGlvbj4gbm9kZXMgZnJvbSB0aGVcbiAgXHRcdC8vIHRlbXBvcmFyeSBjb250YWluZXIgPHNlbGVjdD4gY2F1c2VzIHRoZSByZW1haW5pbmcgb25lcyB0b1xuICBcdFx0Ly8gYmVjb21lIHNlbGVjdGVkLiBTbyBub3cgd2UgaGF2ZSB0byBkZXNlbGVjdCB0aGVtLiBJRTgsIHlvdVxuICBcdFx0Ly8gYW1hemUgbWUuIFlvdSByZWFsbHkgZG9cbiAgXHRcdC8vIC4uLmFuZCBub3cgQ2hyb21lIHRvb1xuICBcdFx0aWYgKG5vZGUudGFnTmFtZSA9PT0gXCJTRUxFQ1RcIikge1xuICBcdFx0XHRpID0gbm9kZXMubGVuZ3RoO1xuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0aWYgKG5vZGVzW2ldICE9PSBzZWxlY3RlZE9wdGlvbikge1xuICBcdFx0XHRcdFx0bm9kZXNbaV0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gbm9kZXM7XG4gIH07XG5cbiAgZnVuY3Rpb24gZWxlbWVudCh0YWdOYW1lKSB7XG4gIFx0cmV0dXJuIGVsZW1lbnRDYWNoZVt0YWdOYW1lXSB8fCAoZWxlbWVudENhY2hlW3RhZ05hbWVdID0gY3JlYXRlRWxlbWVudCh0YWdOYW1lKSk7XG4gIH1cblxuICB2YXIgaGVscGVyc191cGRhdGVTZWxlY3QgPSB1cGRhdGVTZWxlY3Q7XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2VsZWN0KHBhcmVudEVsZW1lbnQpIHtcbiAgXHR2YXIgc2VsZWN0ZWRPcHRpb25zLCBvcHRpb24sIHZhbHVlO1xuXG4gIFx0aWYgKCFwYXJlbnRFbGVtZW50IHx8IHBhcmVudEVsZW1lbnQubmFtZSAhPT0gXCJzZWxlY3RcIiB8fCAhcGFyZW50RWxlbWVudC5iaW5kaW5nKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0c2VsZWN0ZWRPcHRpb25zID0gdG9BcnJheShwYXJlbnRFbGVtZW50Lm5vZGUub3B0aW9ucykuZmlsdGVyKGlzU2VsZWN0ZWQpO1xuXG4gIFx0Ly8gSWYgb25lIG9mIHRoZW0gaGFkIGEgYHNlbGVjdGVkYCBhdHRyaWJ1dGUsIHdlIG5lZWQgdG8gc3luY1xuICBcdC8vIHRoZSBtb2RlbCB0byB0aGUgdmlld1xuICBcdGlmIChwYXJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIpKSB7XG4gIFx0XHR2YWx1ZSA9IHNlbGVjdGVkT3B0aW9ucy5tYXAoZnVuY3Rpb24gKG8pIHtcbiAgXHRcdFx0cmV0dXJuIG8udmFsdWU7XG4gIFx0XHR9KTtcbiAgXHR9IGVsc2UgaWYgKG9wdGlvbiA9IHNlbGVjdGVkT3B0aW9uc1swXSkge1xuICBcdFx0dmFsdWUgPSBvcHRpb24udmFsdWU7XG4gIFx0fVxuXG4gIFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdHBhcmVudEVsZW1lbnQuYmluZGluZy5zZXRWYWx1ZSh2YWx1ZSk7XG4gIFx0fVxuXG4gIFx0cGFyZW50RWxlbWVudC5idWJibGUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU2VsZWN0ZWQob3B0aW9uKSB7XG4gIFx0cmV0dXJuIG9wdGlvbi5zZWxlY3RlZDtcbiAgfVxuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX3JlbmRlciA9IFRyaXBsZSRyZW5kZXI7XG4gIGZ1bmN0aW9uIFRyaXBsZSRyZW5kZXIoKSB7XG4gIFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byByZW5kZXIgYW4gaXRlbSB0aGF0IHdhcyBhbHJlYWR5IHJlbmRlcmVkXCIpO1xuICBcdH1cblxuICBcdHRoaXMuZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgXHR0aGlzLm5vZGVzID0gaW5zZXJ0SHRtbCh0aGlzLnZhbHVlLCB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKSwgdGhpcy5kb2NGcmFnKTtcblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHdlJ3JlIGluc2VydGluZyB0aGUgY29udGVudHMgb2YgYSA8c2VsZWN0PlxuICBcdGhlbHBlcnNfdXBkYXRlU2VsZWN0KHRoaXMucEVsZW1lbnQpO1xuXG4gIFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gIFx0cmV0dXJuIHRoaXMuZG9jRnJhZztcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfc2V0VmFsdWUgPSBUcmlwbGUkc2V0VmFsdWU7XG4gIGZ1bmN0aW9uIFRyaXBsZSRzZXRWYWx1ZSh2YWx1ZSkge1xuICBcdHZhciB3cmFwcGVyO1xuXG4gIFx0Ly8gVE9ETyBpcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gYXBwcm9hY2ggdGhpcz9cbiAgXHRpZiAod3JhcHBlciA9IHRoaXMucm9vdC52aWV3bW9kZWwud3JhcHBlZFt0aGlzLmtleXBhdGguc3RyXSkge1xuICBcdFx0dmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuICBcdH1cblxuICBcdGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSkge1xuICBcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuICBcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblxuICBcdFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVmlldyh0aGlzKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgVHJpcGxlX3Byb3RvdHlwZV90b1N0cmluZyA9IFRyaXBsZSR0b1N0cmluZztcbiAgZnVuY3Rpb24gVHJpcGxlJHRvU3RyaW5nKCkge1xuICBcdHJldHVybiB0aGlzLnZhbHVlICE9IHVuZGVmaW5lZCA/IGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMoXCJcIiArIHRoaXMudmFsdWUpIDogXCJcIjtcbiAgfVxuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX3VucmVuZGVyID0gVHJpcGxlJHVucmVuZGVyO1xuICBmdW5jdGlvbiBUcmlwbGUkdW5yZW5kZXIoc2hvdWxkRGVzdHJveSkge1xuICBcdGlmICh0aGlzLnJlbmRlcmVkICYmIHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdHRoaXMubm9kZXMuZm9yRWFjaChkZXRhY2hOb2RlKTtcbiAgXHRcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgXHR9XG5cbiAgXHQvLyBUT0RPIHVwZGF0ZSBsaXZlIHF1ZXJpZXNcbiAgfVxuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX3VwZGF0ZSA9IFRyaXBsZSR1cGRhdGU7XG4gIGZ1bmN0aW9uIFRyaXBsZSR1cGRhdGUoKSB7XG4gIFx0dmFyIG5vZGUsIHBhcmVudE5vZGU7XG5cbiAgXHRpZiAoIXRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHQvLyBSZW1vdmUgZXhpc3Rpbmcgbm9kZXNcbiAgXHR3aGlsZSAodGhpcy5ub2RlcyAmJiB0aGlzLm5vZGVzLmxlbmd0aCkge1xuICBcdFx0bm9kZSA9IHRoaXMubm9kZXMucG9wKCk7XG4gIFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gIFx0fVxuXG4gIFx0Ly8gSW5zZXJ0IG5ldyBub2Rlc1xuICBcdHBhcmVudE5vZGUgPSB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKTtcblxuICBcdHRoaXMubm9kZXMgPSBpbnNlcnRIdG1sKHRoaXMudmFsdWUsIHBhcmVudE5vZGUsIHRoaXMuZG9jRnJhZyk7XG4gIFx0cGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5kb2NGcmFnLCB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKSk7XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSB3ZSdyZSBpbnNlcnRpbmcgdGhlIGNvbnRlbnRzIG9mIGEgPHNlbGVjdD5cbiAgXHRoZWxwZXJzX3VwZGF0ZVNlbGVjdCh0aGlzLnBFbGVtZW50KTtcbiAgfVxuXG4gIHZhciBUcmlwbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMudHlwZSA9IFRSSVBMRTtcbiAgXHRNdXN0YWNoZS5pbml0KHRoaXMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIFRyaXBsZS5wcm90b3R5cGUgPSB7XG4gIFx0ZGV0YWNoOiBUcmlwbGVfcHJvdG90eXBlX2RldGFjaCxcbiAgXHRmaW5kOiBUcmlwbGVfcHJvdG90eXBlX2ZpbmQsXG4gIFx0ZmluZEFsbDogVHJpcGxlX3Byb3RvdHlwZV9maW5kQWxsLFxuICBcdGZpcnN0Tm9kZTogVHJpcGxlX3Byb3RvdHlwZV9maXJzdE5vZGUsXG4gIFx0Z2V0VmFsdWU6IE11c3RhY2hlLmdldFZhbHVlLFxuICBcdHJlYmluZDogTXVzdGFjaGUucmViaW5kLFxuICBcdHJlbmRlcjogVHJpcGxlX3Byb3RvdHlwZV9yZW5kZXIsXG4gIFx0cmVzb2x2ZTogTXVzdGFjaGUucmVzb2x2ZSxcbiAgXHRzZXRWYWx1ZTogcHJvdG90eXBlX3NldFZhbHVlLFxuICBcdHRvU3RyaW5nOiBUcmlwbGVfcHJvdG90eXBlX3RvU3RyaW5nLFxuICBcdHVuYmluZDogc2hhcmVkX3VuYmluZCxcbiAgXHR1bnJlbmRlcjogVHJpcGxlX3Byb3RvdHlwZV91bnJlbmRlcixcbiAgXHR1cGRhdGU6IFRyaXBsZV9wcm90b3R5cGVfdXBkYXRlXG4gIH07XG5cbiAgdmFyIF9UcmlwbGUgPSBUcmlwbGU7XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2J1YmJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuICB9O1xuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9kZXRhY2ggPSBFbGVtZW50JGRldGFjaDtcblxuICBmdW5jdGlvbiBFbGVtZW50JGRldGFjaCgpIHtcbiAgXHR2YXIgbm9kZSA9IHRoaXMubm9kZSxcbiAgXHQgICAgcGFyZW50Tm9kZTtcblxuICBcdGlmIChub2RlKSB7XG4gIFx0XHQvLyBuZWVkIHRvIGNoZWNrIGZvciBwYXJlbnQgbm9kZSAtIERPTSBtYXkgaGF2ZSBiZWVuIGFsdGVyZWRcbiAgXHRcdC8vIGJ5IHNvbWV0aGluZyBvdGhlciB0aGFuIFJhY3RpdmUhIGUuZy4galF1ZXJ5IFVJLi4uXG4gIFx0XHRpZiAocGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xuICBcdFx0XHRwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbm9kZTtcbiAgXHR9XG4gIH1cblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfZmluZCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICBcdGlmICghdGhpcy5ub2RlKSB7XG4gIFx0XHQvLyB0aGlzIGVsZW1lbnQgaGFzbid0IGJlZW4gcmVuZGVyZWQgeWV0XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAobWF0Y2hlcyh0aGlzLm5vZGUsIHNlbGVjdG9yKSkge1xuICBcdFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5mcmFnbWVudCAmJiB0aGlzLmZyYWdtZW50LmZpbmQpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoc2VsZWN0b3IpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfZmluZEFsbCA9IGZ1bmN0aW9uIChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHQvLyBBZGQgdGhpcyBub2RlIHRvIHRoZSBxdWVyeSwgaWYgYXBwbGljYWJsZSwgYW5kIHJlZ2lzdGVyIHRoZVxuICBcdC8vIHF1ZXJ5IG9uIHRoaXMgZWxlbWVudFxuICBcdGlmIChxdWVyeS5fdGVzdCh0aGlzLCB0cnVlKSAmJiBxdWVyeS5saXZlKSB7XG4gIFx0XHQodGhpcy5saXZlUXVlcmllcyB8fCAodGhpcy5saXZlUXVlcmllcyA9IFtdKSkucHVzaChxdWVyeSk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQuZmluZEFsbChzZWxlY3RvciwgcXVlcnkpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2ZpbmRDb21wb25lbnQgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudChzZWxlY3Rvcik7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9maW5kTmV4dE5vZGUgPSBFbGVtZW50JGZpbmROZXh0Tm9kZTtcblxuICBmdW5jdGlvbiBFbGVtZW50JGZpbmROZXh0Tm9kZSgpIHtcbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9maXJzdE5vZGUgPSBFbGVtZW50JGZpcnN0Tm9kZTtcblxuICBmdW5jdGlvbiBFbGVtZW50JGZpcnN0Tm9kZSgpIHtcbiAgXHRyZXR1cm4gdGhpcy5ub2RlO1xuICB9XG5cbiAgdmFyIGdldEF0dHJpYnV0ZSA9IEVsZW1lbnQkZ2V0QXR0cmlidXRlO1xuXG4gIGZ1bmN0aW9uIEVsZW1lbnQkZ2V0QXR0cmlidXRlKG5hbWUpIHtcbiAgXHRpZiAoIXRoaXMuYXR0cmlidXRlcyB8fCAhdGhpcy5hdHRyaWJ1dGVzW25hbWVdKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlc1tuYW1lXS52YWx1ZTtcbiAgfVxuXG4gIHZhciB0cnV0aHkgPSAvXnRydWV8b258eWVzfDEkL2k7XG4gIHZhciBwcm9jZXNzQmluZGluZ0F0dHJpYnV0ZXNfX2lzTnVtZXJpYyA9IC9eWzAtOV0rJC87XG5cbiAgdmFyIHByb2Nlc3NCaW5kaW5nQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChlbGVtZW50LCB0ZW1wbGF0ZSkge1xuICBcdHZhciB2YWwsIGF0dHJzLCBhdHRyaWJ1dGVzO1xuXG4gIFx0YXR0cmlidXRlcyA9IHRlbXBsYXRlLmEgfHwge307XG4gIFx0YXR0cnMgPSB7fTtcblxuICBcdC8vIGF0dHJpYnV0ZXMgdGhhdCBhcmUgcHJlc2VudCBidXQgZG9uJ3QgaGF2ZSBhIHZhbHVlICg9KVxuICBcdC8vIHdpbGwgYmUgc2V0IHRvIHRoZSBudW1iZXIgMCwgd2hpY2ggd2UgY29uZGlkZXIgdG8gYmUgdHJ1ZVxuICBcdC8vIHRoZSBzdHJpbmcgJzAnLCBob3dldmVyIGlzIGZhbHNlXG5cbiAgXHR2YWwgPSBhdHRyaWJ1dGVzLnR3b3dheTtcbiAgXHRpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdGF0dHJzLnR3b3dheSA9IHZhbCA9PT0gMCB8fCB0cnV0aHkudGVzdCh2YWwpO1xuICBcdH1cblxuICBcdHZhbCA9IGF0dHJpYnV0ZXMubGF6eTtcbiAgXHRpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdC8vIGNoZWNrIGZvciB0aW1lb3V0IHZhbHVlXG4gIFx0XHRpZiAodmFsICE9PSAwICYmIHByb2Nlc3NCaW5kaW5nQXR0cmlidXRlc19faXNOdW1lcmljLnRlc3QodmFsKSkge1xuICBcdFx0XHRhdHRycy5sYXp5ID0gcGFyc2VJbnQodmFsKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGF0dHJzLmxhenkgPSB2YWwgPT09IDAgfHwgdHJ1dGh5LnRlc3QodmFsKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gYXR0cnM7XG4gIH07XG5cbiAgdmFyIEF0dHJpYnV0ZV9wcm90b3R5cGVfYnViYmxlID0gQXR0cmlidXRlJGJ1YmJsZTtcbiAgZnVuY3Rpb24gQXR0cmlidXRlJGJ1YmJsZSgpIHtcbiAgXHR2YXIgdmFsdWUgPSB0aGlzLnVzZVByb3BlcnR5IHx8ICF0aGlzLnJlbmRlcmVkID8gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpIDogdGhpcy5mcmFnbWVudC50b1N0cmluZygpO1xuXG4gIFx0Ly8gVE9ETyB0aGlzIGNhbiByZWdpc3RlciB0aGUgYXR0cmlidXRlIG11bHRpcGxlIHRpbWVzIChzZWUgcmVuZGVyIHRlc3RcbiAgXHQvLyAnQXR0cmlidXRlIHdpdGggbmVzdGVkIG11c3RhY2hlcycpXG4gIFx0aWYgKCFpc0VxdWFsKHZhbHVlLCB0aGlzLnZhbHVlKSkge1xuXG4gIFx0XHQvLyBOZWVkIHRvIGNsZWFyIG9sZCBpZCBmcm9tIHJhY3RpdmUubm9kZXNcbiAgXHRcdGlmICh0aGlzLm5hbWUgPT09IFwiaWRcIiAmJiB0aGlzLnZhbHVlKSB7XG4gIFx0XHRcdGRlbGV0ZSB0aGlzLnJvb3Qubm9kZXNbdGhpcy52YWx1ZV07XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICBcdFx0aWYgKHRoaXMubmFtZSA9PT0gXCJ2YWx1ZVwiICYmIHRoaXMubm9kZSkge1xuICBcdFx0XHQvLyBXZSBuZWVkIHRvIHN0b3JlIHRoZSB2YWx1ZSBvbiB0aGUgRE9NIGxpa2UgdGhpcyBzbyB3ZVxuICBcdFx0XHQvLyBjYW4gcmV0cmlldmUgaXQgbGF0ZXIgd2l0aG91dCBpdCBiZWluZyBjb2VyY2VkIHRvIGEgc3RyaW5nXG4gIFx0XHRcdHRoaXMubm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRWaWV3KHRoaXMpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBzdmdDYW1lbENhc2VFbGVtZW50cywgc3ZnQ2FtZWxDYXNlQXR0cmlidXRlcywgY3JlYXRlTWFwLCBtYXA7XG4gIHN2Z0NhbWVsQ2FzZUVsZW1lbnRzID0gXCJhbHRHbHlwaCBhbHRHbHlwaERlZiBhbHRHbHlwaEl0ZW0gYW5pbWF0ZUNvbG9yIGFuaW1hdGVNb3Rpb24gYW5pbWF0ZVRyYW5zZm9ybSBjbGlwUGF0aCBmZUJsZW5kIGZlQ29sb3JNYXRyaXggZmVDb21wb25lbnRUcmFuc2ZlciBmZUNvbXBvc2l0ZSBmZUNvbnZvbHZlTWF0cml4IGZlRGlmZnVzZUxpZ2h0aW5nIGZlRGlzcGxhY2VtZW50TWFwIGZlRGlzdGFudExpZ2h0IGZlRmxvb2QgZmVGdW5jQSBmZUZ1bmNCIGZlRnVuY0cgZmVGdW5jUiBmZUdhdXNzaWFuQmx1ciBmZUltYWdlIGZlTWVyZ2UgZmVNZXJnZU5vZGUgZmVNb3JwaG9sb2d5IGZlT2Zmc2V0IGZlUG9pbnRMaWdodCBmZVNwZWN1bGFyTGlnaHRpbmcgZmVTcG90TGlnaHQgZmVUaWxlIGZlVHVyYnVsZW5jZSBmb3JlaWduT2JqZWN0IGdseXBoUmVmIGxpbmVhckdyYWRpZW50IHJhZGlhbEdyYWRpZW50IHRleHRQYXRoIHZrZXJuXCIuc3BsaXQoXCIgXCIpO1xuICBzdmdDYW1lbENhc2VBdHRyaWJ1dGVzID0gXCJhdHRyaWJ1dGVOYW1lIGF0dHJpYnV0ZVR5cGUgYmFzZUZyZXF1ZW5jeSBiYXNlUHJvZmlsZSBjYWxjTW9kZSBjbGlwUGF0aFVuaXRzIGNvbnRlbnRTY3JpcHRUeXBlIGNvbnRlbnRTdHlsZVR5cGUgZGlmZnVzZUNvbnN0YW50IGVkZ2VNb2RlIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQgZmlsdGVyUmVzIGZpbHRlclVuaXRzIGdseXBoUmVmIGdyYWRpZW50VHJhbnNmb3JtIGdyYWRpZW50VW5pdHMga2VybmVsTWF0cml4IGtlcm5lbFVuaXRMZW5ndGgga2V5UG9pbnRzIGtleVNwbGluZXMga2V5VGltZXMgbGVuZ3RoQWRqdXN0IGxpbWl0aW5nQ29uZUFuZ2xlIG1hcmtlckhlaWdodCBtYXJrZXJVbml0cyBtYXJrZXJXaWR0aCBtYXNrQ29udGVudFVuaXRzIG1hc2tVbml0cyBudW1PY3RhdmVzIHBhdGhMZW5ndGggcGF0dGVybkNvbnRlbnRVbml0cyBwYXR0ZXJuVHJhbnNmb3JtIHBhdHRlcm5Vbml0cyBwb2ludHNBdFggcG9pbnRzQXRZIHBvaW50c0F0WiBwcmVzZXJ2ZUFscGhhIHByZXNlcnZlQXNwZWN0UmF0aW8gcHJpbWl0aXZlVW5pdHMgcmVmWCByZWZZIHJlcGVhdENvdW50IHJlcGVhdER1ciByZXF1aXJlZEV4dGVuc2lvbnMgcmVxdWlyZWRGZWF0dXJlcyBzcGVjdWxhckNvbnN0YW50IHNwZWN1bGFyRXhwb25lbnQgc3ByZWFkTWV0aG9kIHN0YXJ0T2Zmc2V0IHN0ZERldmlhdGlvbiBzdGl0Y2hUaWxlcyBzdXJmYWNlU2NhbGUgc3lzdGVtTGFuZ3VhZ2UgdGFibGVWYWx1ZXMgdGFyZ2V0WCB0YXJnZXRZIHRleHRMZW5ndGggdmlld0JveCB2aWV3VGFyZ2V0IHhDaGFubmVsU2VsZWN0b3IgeUNoYW5uZWxTZWxlY3RvciB6b29tQW5kUGFuXCIuc3BsaXQoXCIgXCIpO1xuXG4gIGNyZWF0ZU1hcCA9IGZ1bmN0aW9uIChpdGVtcykge1xuICBcdHZhciBtYXAgPSB7fSxcbiAgXHQgICAgaSA9IGl0ZW1zLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRtYXBbaXRlbXNbaV0udG9Mb3dlckNhc2UoKV0gPSBpdGVtc1tpXTtcbiAgXHR9XG4gIFx0cmV0dXJuIG1hcDtcbiAgfTtcblxuICBtYXAgPSBjcmVhdGVNYXAoc3ZnQ2FtZWxDYXNlRWxlbWVudHMuY29uY2F0KHN2Z0NhbWVsQ2FzZUF0dHJpYnV0ZXMpKTtcblxuICB2YXIgZW5mb3JjZUNhc2UgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUpIHtcbiAgXHR2YXIgbG93ZXJDYXNlRWxlbWVudE5hbWUgPSBlbGVtZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICBcdHJldHVybiBtYXBbbG93ZXJDYXNlRWxlbWVudE5hbWVdIHx8IGxvd2VyQ2FzZUVsZW1lbnROYW1lO1xuICB9O1xuXG4gIHZhciBkZXRlcm1pbmVOYW1lQW5kTmFtZXNwYWNlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgbmFtZSkge1xuICBcdHZhciBjb2xvbkluZGV4LCBuYW1lc3BhY2VQcmVmaXg7XG5cbiAgXHQvLyBhcmUgd2UgZGVhbGluZyB3aXRoIGEgbmFtZXNwYWNlZCBhdHRyaWJ1dGUsIGUuZy4geGxpbms6aHJlZj9cbiAgXHRjb2xvbkluZGV4ID0gbmFtZS5pbmRleE9mKFwiOlwiKTtcbiAgXHRpZiAoY29sb25JbmRleCAhPT0gLTEpIHtcblxuICBcdFx0Ly8gbG9va3MgbGlrZSB3ZSBhcmUsIHllcy4uLlxuICBcdFx0bmFtZXNwYWNlUHJlZml4ID0gbmFtZS5zdWJzdHIoMCwgY29sb25JbmRleCk7XG5cbiAgXHRcdC8vIC4uLnVubGVzcyBpdCdzIGEgbmFtZXNwYWNlICpkZWNsYXJhdGlvbiosIHdoaWNoIHdlIGlnbm9yZSAob24gdGhlIGFzc3VtcHRpb25cbiAgXHRcdC8vIHRoYXQgb25seSB2YWxpZCBuYW1lc3BhY2VzIHdpbGwgYmUgdXNlZClcbiAgXHRcdGlmIChuYW1lc3BhY2VQcmVmaXggIT09IFwieG1sbnNcIikge1xuICBcdFx0XHRuYW1lID0gbmFtZS5zdWJzdHJpbmcoY29sb25JbmRleCArIDEpO1xuXG4gIFx0XHRcdGF0dHJpYnV0ZS5uYW1lID0gZW5mb3JjZUNhc2UobmFtZSk7XG4gIFx0XHRcdGF0dHJpYnV0ZS5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzW25hbWVzcGFjZVByZWZpeC50b0xvd2VyQ2FzZSgpXTtcbiAgXHRcdFx0YXR0cmlidXRlLm5hbWVzcGFjZVByZWZpeCA9IG5hbWVzcGFjZVByZWZpeDtcblxuICBcdFx0XHRpZiAoIWF0dHJpYnV0ZS5uYW1lc3BhY2UpIHtcbiAgXHRcdFx0XHR0aHJvdyBcIlVua25vd24gbmFtZXNwYWNlIChcXFwiXCIgKyBuYW1lc3BhY2VQcmVmaXggKyBcIlxcXCIpXCI7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gU1ZHIGF0dHJpYnV0ZSBuYW1lcyBhcmUgY2FzZSBzZW5zaXRpdmVcbiAgXHRhdHRyaWJ1dGUubmFtZSA9IGF0dHJpYnV0ZS5lbGVtZW50Lm5hbWVzcGFjZSAhPT0gbmFtZXNwYWNlcy5odG1sID8gZW5mb3JjZUNhc2UobmFtZSkgOiBuYW1lO1xuICB9O1xuXG4gIHZhciBoZWxwZXJzX2dldEludGVycG9sYXRvciA9IGdldEludGVycG9sYXRvcjtcbiAgZnVuY3Rpb24gZ2V0SW50ZXJwb2xhdG9yKGF0dHJpYnV0ZSkge1xuICBcdHZhciBpdGVtcyA9IGF0dHJpYnV0ZS5mcmFnbWVudC5pdGVtcztcblxuICBcdGlmIChpdGVtcy5sZW5ndGggIT09IDEpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAoaXRlbXNbMF0udHlwZSA9PT0gSU5URVJQT0xBVE9SKSB7XG4gIFx0XHRyZXR1cm4gaXRlbXNbMF07XG4gIFx0fVxuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9pbml0ID0gQXR0cmlidXRlJGluaXQ7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSRpbml0KG9wdGlvbnMpIHtcbiAgXHR0aGlzLnR5cGUgPSBBVFRSSUJVVEU7XG4gIFx0dGhpcy5lbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuICBcdHRoaXMucm9vdCA9IG9wdGlvbnMucm9vdDtcblxuICBcdGRldGVybWluZU5hbWVBbmROYW1lc3BhY2UodGhpcywgb3B0aW9ucy5uYW1lKTtcbiAgXHR0aGlzLmlzQm9vbGVhbiA9IGJvb2xlYW5BdHRyaWJ1dGVzLnRlc3QodGhpcy5uYW1lKTtcblxuICBcdC8vIGlmIGl0J3MgYW4gZW1wdHkgYXR0cmlidXRlLCBvciBqdXN0IGEgc3RyYWlnaHQga2V5LXZhbHVlIHBhaXIsIHdpdGggbm9cbiAgXHQvLyBtdXN0YWNoZSBzaGVuYW5pZ2Fucywgc2V0IHRoZSBhdHRyaWJ1dGUgYWNjb3JkaW5nbHkgYW5kIGdvIGhvbWVcbiAgXHRpZiAoIW9wdGlvbnMudmFsdWUgfHwgdHlwZW9mIG9wdGlvbnMudmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHRoaXMudmFsdWUgPSB0aGlzLmlzQm9vbGVhbiA/IHRydWUgOiBvcHRpb25zLnZhbHVlIHx8IFwiXCI7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0Ly8gb3RoZXJ3aXNlIHdlIG5lZWQgdG8gZG8gc29tZSB3b3JrXG5cbiAgXHQvLyBzaGFyZSBwYXJlbnRGcmFnbWVudCB3aXRoIHBhcmVudCBlbGVtZW50XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IHRoaXMuZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcblxuICBcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHR0ZW1wbGF0ZTogb3B0aW9ucy52YWx1ZSxcbiAgXHRcdHJvb3Q6IHRoaXMucm9vdCxcbiAgXHRcdG93bmVyOiB0aGlzXG4gIFx0fSk7XG5cbiAgXHQvLyBUT0RPIGNhbiB3ZSB1c2UgdGhpcy5mcmFnbWVudC50b1N0cmluZygpIGluIHNvbWUgY2FzZXM/IEl0J3MgcXVpY2tlclxuICBcdHRoaXMudmFsdWUgPSB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCk7XG5cbiAgXHQvLyBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGlzIGF0dHJpYnV0ZSdzIGludGVycG9sYXRvciwgaWYgaXRzIGZyYWdtZW50XG4gIFx0Ly8gdGFrZXMgdGhlIGZvcm0gYHt7Zm9vfX1gLiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgdHdvLXdheSBiaW5kaW5nIGFuZFxuICBcdC8vIGZvciBjb3JyZWN0bHkgcmVuZGVyaW5nIEhUTUwgbGF0ZXJcbiAgXHR0aGlzLmludGVycG9sYXRvciA9IGhlbHBlcnNfZ2V0SW50ZXJwb2xhdG9yKHRoaXMpO1xuICBcdHRoaXMuaXNCaW5kYWJsZSA9ICEhdGhpcy5pbnRlcnBvbGF0b3IgJiYgIXRoaXMuaW50ZXJwb2xhdG9yLmlzU3RhdGljO1xuXG4gIFx0Ly8gbWFyayBhcyByZWFkeVxuICBcdHRoaXMucmVhZHkgPSB0cnVlO1xuICB9XG5cbiAgdmFyIEF0dHJpYnV0ZV9wcm90b3R5cGVfcmViaW5kID0gQXR0cmlidXRlJHJlYmluZDtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkcmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEF0dHJpYnV0ZV9wcm90b3R5cGVfcmVuZGVyID0gQXR0cmlidXRlJHJlbmRlcjtcbiAgdmFyIHByb3BlcnR5TmFtZXMgPSB7XG4gIFx0XCJhY2NlcHQtY2hhcnNldFwiOiBcImFjY2VwdENoYXJzZXRcIixcbiAgXHRhY2Nlc3NrZXk6IFwiYWNjZXNzS2V5XCIsXG4gIFx0Ymdjb2xvcjogXCJiZ0NvbG9yXCIsXG4gIFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiLFxuICBcdGNvZGViYXNlOiBcImNvZGVCYXNlXCIsXG4gIFx0Y29sc3BhbjogXCJjb2xTcGFuXCIsXG4gIFx0Y29udGVudGVkaXRhYmxlOiBcImNvbnRlbnRFZGl0YWJsZVwiLFxuICBcdGRhdGV0aW1lOiBcImRhdGVUaW1lXCIsXG4gIFx0ZGlybmFtZTogXCJkaXJOYW1lXCIsXG4gIFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG4gIFx0XCJodHRwLWVxdWl2XCI6IFwiaHR0cEVxdWl2XCIsXG4gIFx0aXNtYXA6IFwiaXNNYXBcIixcbiAgXHRtYXhsZW5ndGg6IFwibWF4TGVuZ3RoXCIsXG4gIFx0bm92YWxpZGF0ZTogXCJub1ZhbGlkYXRlXCIsXG4gIFx0cHViZGF0ZTogXCJwdWJEYXRlXCIsXG4gIFx0cmVhZG9ubHk6IFwicmVhZE9ubHlcIixcbiAgXHRyb3dzcGFuOiBcInJvd1NwYW5cIixcbiAgXHR0YWJpbmRleDogXCJ0YWJJbmRleFwiLFxuICBcdHVzZW1hcDogXCJ1c2VNYXBcIlxuICB9O1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUkcmVuZGVyKG5vZGUpIHtcbiAgXHR2YXIgcHJvcGVydHlOYW1lO1xuXG4gIFx0dGhpcy5ub2RlID0gbm9kZTtcblxuICBcdC8vIHNob3VsZCB3ZSB1c2UgZGlyZWN0IHByb3BlcnR5IGFjY2Vzcywgb3Igc2V0QXR0cmlidXRlP1xuICBcdGlmICghbm9kZS5uYW1lc3BhY2VVUkkgfHwgbm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuaHRtbCkge1xuICBcdFx0cHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lc1t0aGlzLm5hbWVdIHx8IHRoaXMubmFtZTtcblxuICBcdFx0aWYgKG5vZGVbcHJvcGVydHlOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRoaXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBpcyBhdHRyaWJ1dGUgYSBib29sZWFuIGF0dHJpYnV0ZSBvciAndmFsdWUnPyBJZiBzbyB3ZSdyZSBiZXR0ZXIgb2ZmIGRvaW5nIGUuZy5cbiAgXHRcdC8vIG5vZGUuc2VsZWN0ZWQgPSB0cnVlIHJhdGhlciB0aGFuIG5vZGUuc2V0QXR0cmlidXRlKCAnc2VsZWN0ZWQnLCAnJyApXG4gIFx0XHRpZiAodGhpcy5pc0Jvb2xlYW4gfHwgdGhpcy5pc1R3b3dheSkge1xuICBcdFx0XHR0aGlzLnVzZVByb3BlcnR5ID0gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHByb3BlcnR5TmFtZSA9PT0gXCJ2YWx1ZVwiKSB7XG4gIFx0XHRcdG5vZGUuX3JhY3RpdmUudmFsdWUgPSB0aGlzLnZhbHVlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICBcdHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICB2YXIgQXR0cmlidXRlX3Byb3RvdHlwZV90b1N0cmluZyA9IEF0dHJpYnV0ZSR0b1N0cmluZztcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdG9TdHJpbmcoKSB7XG4gIFx0dmFyIF9yZWYgPSB0aGlzO1xuXG4gIFx0dmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gIFx0dmFyIG5hbWVzcGFjZVByZWZpeCA9IF9yZWYubmFtZXNwYWNlUHJlZml4O1xuICBcdHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG4gIFx0dmFyIGludGVycG9sYXRvciA9IF9yZWYuaW50ZXJwb2xhdG9yO1xuICBcdHZhciBmcmFnbWVudCA9IF9yZWYuZnJhZ21lbnQ7XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSBzZWxlY3QgYW5kIHRleHRhcmVhIHZhbHVlcyAoc2hvdWxkIG5vdCBiZSBzdHJpbmdpZmllZClcbiAgXHRpZiAobmFtZSA9PT0gXCJ2YWx1ZVwiICYmICh0aGlzLmVsZW1lbnQubmFtZSA9PT0gXCJzZWxlY3RcIiB8fCB0aGlzLmVsZW1lbnQubmFtZSA9PT0gXCJ0ZXh0YXJlYVwiKSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIGNvbnRlbnQgZWRpdGFibGVcbiAgXHRpZiAobmFtZSA9PT0gXCJ2YWx1ZVwiICYmIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHJhZGlvIG5hbWVzXG4gIFx0aWYgKG5hbWUgPT09IFwibmFtZVwiICYmIHRoaXMuZWxlbWVudC5uYW1lID09PSBcImlucHV0XCIgJiYgaW50ZXJwb2xhdG9yKSB7XG4gIFx0XHRyZXR1cm4gXCJuYW1lPXt7XCIgKyAoaW50ZXJwb2xhdG9yLmtleXBhdGguc3RyIHx8IGludGVycG9sYXRvci5yZWYpICsgXCJ9fVwiO1xuICBcdH1cblxuICBcdC8vIEJvb2xlYW4gYXR0cmlidXRlc1xuICBcdGlmICh0aGlzLmlzQm9vbGVhbikge1xuICBcdFx0cmV0dXJuIHZhbHVlID8gbmFtZSA6IFwiXCI7XG4gIFx0fVxuXG4gIFx0aWYgKGZyYWdtZW50KSB7XG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSB0aGlzIGNhdGNoZXMgdW5kZWZpbmVkL251bGwgdmFsdWVzICgjMTIxMSlcbiAgXHRcdGlmIChmcmFnbWVudC5pdGVtcy5sZW5ndGggPT09IDEgJiYgZnJhZ21lbnQuaXRlbXNbMF0udmFsdWUgPT0gbnVsbCkge1xuICBcdFx0XHRyZXR1cm4gXCJcIjtcbiAgXHRcdH1cblxuICBcdFx0dmFsdWUgPSBmcmFnbWVudC50b1N0cmluZygpO1xuICBcdH1cblxuICBcdGlmIChuYW1lc3BhY2VQcmVmaXgpIHtcbiAgXHRcdG5hbWUgPSBuYW1lc3BhY2VQcmVmaXggKyBcIjpcIiArIG5hbWU7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHZhbHVlID8gbmFtZSArIFwiPVxcXCJcIiArIEF0dHJpYnV0ZV9wcm90b3R5cGVfdG9TdHJpbmdfX2VzY2FwZSh2YWx1ZSkgKyBcIlxcXCJcIiA6IG5hbWU7XG4gIH1cblxuICBmdW5jdGlvbiBBdHRyaWJ1dGVfcHJvdG90eXBlX3RvU3RyaW5nX19lc2NhcGUodmFsdWUpIHtcbiAgXHRyZXR1cm4gdmFsdWUucmVwbGFjZSgvJi9nLCBcIiZhbXA7XCIpLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpLnJlcGxhY2UoLycvZywgXCImIzM5O1wiKTtcbiAgfVxuXG4gIHZhciBBdHRyaWJ1dGVfcHJvdG90eXBlX3VuYmluZCA9IEF0dHJpYnV0ZSR1bmJpbmQ7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVuYmluZCgpIHtcbiAgXHQvLyBpZ25vcmUgbm9uLWR5bmFtaWMgYXR0cmlidXRlc1xuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLm5hbWUgPT09IFwiaWRcIikge1xuICBcdFx0ZGVsZXRlIHRoaXMucm9vdC5ub2Rlc1t0aGlzLnZhbHVlXTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdXBkYXRlU2VsZWN0VmFsdWUgPSBBdHRyaWJ1dGUkdXBkYXRlU2VsZWN0O1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVTZWxlY3QoKSB7XG4gIFx0dmFyIHZhbHVlID0gdGhpcy52YWx1ZSxcbiAgXHQgICAgb3B0aW9ucyxcbiAgXHQgICAgb3B0aW9uLFxuICBcdCAgICBvcHRpb25WYWx1ZSxcbiAgXHQgICAgaTtcblxuICBcdGlmICghdGhpcy5sb2NrZWQpIHtcbiAgXHRcdHRoaXMubm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHZhbHVlO1xuXG4gIFx0XHRvcHRpb25zID0gdGhpcy5ub2RlLm9wdGlvbnM7XG4gIFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0b3B0aW9uID0gb3B0aW9uc1tpXTtcbiAgXHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7IC8vIG9wdGlvbnMgaW5zZXJ0ZWQgdmlhIGEgdHJpcGxlIGRvbid0IGhhdmUgX3JhY3RpdmVcblxuICBcdFx0XHRpZiAob3B0aW9uVmFsdWUgPT0gdmFsdWUpIHtcbiAgXHRcdFx0XHQvLyBkb3VibGUgZXF1YWxzIGFzIHdlIG1heSBiZSBjb21wYXJpbmcgbnVtYmVycyB3aXRoIHN0cmluZ3NcbiAgXHRcdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuICBcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gaWYgd2UncmUgc3RpbGwgaGVyZSwgaXQgbWVhbnMgdGhlIG5ldyB2YWx1ZSBkaWRuJ3QgbWF0Y2ggYW55IG9mIHRoZSBvcHRpb25zLi4uXG4gIFx0Ly8gVE9ETyBmaWd1cmUgb3V0IHdoYXQgdG8gZG8gaW4gdGhpcyBzaXR1YXRpb25cbiAgfVxuXG4gIHZhciB1cGRhdGVNdWx0aXBsZVNlbGVjdFZhbHVlID0gQXR0cmlidXRlJHVwZGF0ZU11bHRpcGxlU2VsZWN0O1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlTXVsdGlwbGVTZWxlY3QoKSB7XG4gIFx0dmFyIHZhbHVlID0gdGhpcy52YWx1ZSxcbiAgXHQgICAgb3B0aW9ucyxcbiAgXHQgICAgaSxcbiAgXHQgICAgb3B0aW9uLFxuICBcdCAgICBvcHRpb25WYWx1ZTtcblxuICBcdGlmICghaXNBcnJheSh2YWx1ZSkpIHtcbiAgXHRcdHZhbHVlID0gW3ZhbHVlXTtcbiAgXHR9XG5cbiAgXHRvcHRpb25zID0gdGhpcy5ub2RlLm9wdGlvbnM7XG4gIFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0b3B0aW9uID0gb3B0aW9uc1tpXTtcbiAgXHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlOyAvLyBvcHRpb25zIGluc2VydGVkIHZpYSBhIHRyaXBsZSBkb24ndCBoYXZlIF9yYWN0aXZlXG4gIFx0XHRvcHRpb24uc2VsZWN0ZWQgPSBhcnJheUNvbnRhaW5zKHZhbHVlLCBvcHRpb25WYWx1ZSk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHVwZGF0ZVJhZGlvTmFtZSA9IEF0dHJpYnV0ZSR1cGRhdGVSYWRpb05hbWU7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVJhZGlvTmFtZSgpIHtcbiAgXHR2YXIgX3JlZiA9IHRoaXM7XG5cbiAgXHR2YXIgbm9kZSA9IF9yZWYubm9kZTtcbiAgXHR2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuXG4gIFx0bm9kZS5jaGVja2VkID0gdmFsdWUgPT0gbm9kZS5fcmFjdGl2ZS52YWx1ZTtcbiAgfVxuXG4gIHZhciB1cGRhdGVSYWRpb1ZhbHVlID0gQXR0cmlidXRlJHVwZGF0ZVJhZGlvVmFsdWU7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVSYWRpb1ZhbHVlKCkge1xuICBcdHZhciB3YXNDaGVja2VkLFxuICBcdCAgICBub2RlID0gdGhpcy5ub2RlLFxuICBcdCAgICBiaW5kaW5nLFxuICBcdCAgICBiaW5kaW5ncyxcbiAgXHQgICAgaTtcblxuICBcdHdhc0NoZWNrZWQgPSBub2RlLmNoZWNrZWQ7XG5cbiAgXHRub2RlLnZhbHVlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdG5vZGUuY2hlY2tlZCA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSA9PT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG5cbiAgXHQvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIC0gaWYgdGhlIGlucHV0IHdhcyBjaGVja2VkLCBhbmQgdGhlIHZhbHVlXG4gIFx0Ly8gY2hhbmdlZCBzbyB0aGF0IGl0J3Mgbm8gbG9uZ2VyIGNoZWNrZWQsIHRoZSB0d293YXkgYmluZGluZyBpc1xuICBcdC8vIG1vc3QgbGlrZWx5IG91dCBvZiBkYXRlLiBUbyBmaXggaXQgd2UgaGF2ZSB0byBqdW1wIHRocm91Z2ggc29tZVxuICBcdC8vIGhvb3BzLi4uIHRoaXMgaXMgYSBsaXR0bGUga2x1ZGd5IGJ1dCBpdCB3b3Jrc1xuICBcdGlmICh3YXNDaGVja2VkICYmICFub2RlLmNoZWNrZWQgJiYgdGhpcy5lbGVtZW50LmJpbmRpbmcpIHtcbiAgXHRcdGJpbmRpbmdzID0gdGhpcy5lbGVtZW50LmJpbmRpbmcuc2libGluZ3M7XG5cbiAgXHRcdGlmIChpID0gYmluZGluZ3MubGVuZ3RoKSB7XG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRiaW5kaW5nID0gYmluZGluZ3NbaV07XG5cbiAgXHRcdFx0XHRpZiAoIWJpbmRpbmcuZWxlbWVudC5ub2RlKSB7XG4gIFx0XHRcdFx0XHQvLyB0aGlzIGlzIHRoZSBpbml0aWFsIHJlbmRlciwgc2libGluZ3MgYXJlIHN0aWxsIHJlbmRlcmluZyFcbiAgXHRcdFx0XHRcdC8vIHdlJ2xsIGNvbWUgYmFjayBsYXRlci4uLlxuICBcdFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmIChiaW5kaW5nLmVsZW1lbnQubm9kZS5jaGVja2VkKSB7XG4gIFx0XHRcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRSYWN0aXZlKGJpbmRpbmcucm9vdCk7XG4gIFx0XHRcdFx0XHRyZXR1cm4gYmluZGluZy5oYW5kbGVDaGFuZ2UoKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldChiaW5kaW5nLmtleXBhdGgsIHVuZGVmaW5lZCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIHVwZGF0ZUNoZWNrYm94TmFtZSA9IEF0dHJpYnV0ZSR1cGRhdGVDaGVja2JveE5hbWU7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVDaGVja2JveE5hbWUoKSB7XG4gIFx0dmFyIF9yZWYgPSB0aGlzO1xuXG4gIFx0dmFyIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQ7XG4gIFx0dmFyIG5vZGUgPSBfcmVmLm5vZGU7XG4gIFx0dmFyIHZhbHVlID0gX3JlZi52YWx1ZTt2YXIgYmluZGluZyA9IGVsZW1lbnQuYmluZGluZzt2YXIgdmFsdWVBdHRyaWJ1dGU7dmFyIGk7XG5cbiAgXHR2YWx1ZUF0dHJpYnV0ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRpZiAoIWlzQXJyYXkodmFsdWUpKSB7XG4gIFx0XHRiaW5kaW5nLmlzQ2hlY2tlZCA9IG5vZGUuY2hlY2tlZCA9IHZhbHVlID09IHZhbHVlQXR0cmlidXRlO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRpID0gdmFsdWUubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRpZiAodmFsdWVBdHRyaWJ1dGUgPT0gdmFsdWVbaV0pIHtcbiAgXHRcdFx0XHRiaW5kaW5nLmlzQ2hlY2tlZCA9IG5vZGUuY2hlY2tlZCA9IHRydWU7XG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHRiaW5kaW5nLmlzQ2hlY2tlZCA9IG5vZGUuY2hlY2tlZCA9IGZhbHNlO1xuICBcdH1cbiAgfVxuXG4gIHZhciB1cGRhdGVDbGFzc05hbWUgPSBBdHRyaWJ1dGUkdXBkYXRlQ2xhc3NOYW1lO1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQ2xhc3NOYW1lKCkge1xuICBcdHRoaXMubm9kZS5jbGFzc05hbWUgPSBzYWZlVG9TdHJpbmdWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVJZEF0dHJpYnV0ZSA9IEF0dHJpYnV0ZSR1cGRhdGVJZEF0dHJpYnV0ZTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlSWRBdHRyaWJ1dGUoKSB7XG4gIFx0dmFyIF9yZWYgPSB0aGlzO1xuXG4gIFx0dmFyIG5vZGUgPSBfcmVmLm5vZGU7XG4gIFx0dmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcblxuICBcdHRoaXMucm9vdC5ub2Rlc1t2YWx1ZV0gPSBub2RlO1xuICBcdG5vZGUuaWQgPSB2YWx1ZTtcbiAgfVxuXG4gIHZhciB1cGRhdGVJRVN0eWxlQXR0cmlidXRlID0gQXR0cmlidXRlJHVwZGF0ZUlFU3R5bGVBdHRyaWJ1dGU7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUoKSB7XG4gIFx0dmFyIG5vZGUsIHZhbHVlO1xuXG4gIFx0bm9kZSA9IHRoaXMubm9kZTtcbiAgXHR2YWx1ZSA9IHRoaXMudmFsdWU7XG5cbiAgXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0dmFsdWUgPSBcIlwiO1xuICBcdH1cblxuICBcdG5vZGUuc3R5bGUuc2V0QXR0cmlidXRlKFwiY3NzVGV4dFwiLCB2YWx1ZSk7XG4gIH1cblxuICB2YXIgdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWUgPSBBdHRyaWJ1dGUkdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWU7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlKCkge1xuICBcdHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG5cbiAgXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0dmFsdWUgPSBcIlwiO1xuICBcdH1cblxuICBcdGlmICghdGhpcy5sb2NrZWQpIHtcbiAgXHRcdHRoaXMubm9kZS5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdXBkYXRlVmFsdWUgPSBBdHRyaWJ1dGUkdXBkYXRlVmFsdWU7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVZhbHVlKCkge1xuICBcdHZhciBfcmVmID0gdGhpcztcblxuICBcdHZhciBub2RlID0gX3JlZi5ub2RlO1xuICBcdHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG5cbiAgXHQvLyBzdG9yZSBhY3R1YWwgdmFsdWUsIHNvIGl0IGRvZXNuJ3QgZ2V0IGNvZXJjZWQgdG8gYSBzdHJpbmdcbiAgXHRub2RlLl9yYWN0aXZlLnZhbHVlID0gdmFsdWU7XG5cbiAgXHQvLyB3aXRoIHR3by13YXkgYmluZGluZywgb25seSB1cGRhdGUgaWYgdGhlIGNoYW5nZSB3YXNuJ3QgaW5pdGlhdGVkIGJ5IHRoZSB1c2VyXG4gIFx0Ly8gb3RoZXJ3aXNlIHRoZSBjdXJzb3Igd2lsbCBvZnRlbiBiZSBzZW50IHRvIHRoZSB3cm9uZyBwbGFjZVxuICBcdGlmICghdGhpcy5sb2NrZWQpIHtcbiAgXHRcdG5vZGUudmFsdWUgPSB2YWx1ZSA9PSB1bmRlZmluZWQgPyBcIlwiIDogdmFsdWU7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHVwZGF0ZUJvb2xlYW4gPSBBdHRyaWJ1dGUkdXBkYXRlQm9vbGVhbkF0dHJpYnV0ZTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQm9vbGVhbkF0dHJpYnV0ZSgpIHtcbiAgXHQvLyB3aXRoIHR3by13YXkgYmluZGluZywgb25seSB1cGRhdGUgaWYgdGhlIGNoYW5nZSB3YXNuJ3QgaW5pdGlhdGVkIGJ5IHRoZSB1c2VyXG4gIFx0Ly8gb3RoZXJ3aXNlIHRoZSBjdXJzb3Igd2lsbCBvZnRlbiBiZSBzZW50IHRvIHRoZSB3cm9uZyBwbGFjZVxuICBcdGlmICghdGhpcy5sb2NrZWQpIHtcbiAgXHRcdHRoaXMubm9kZVt0aGlzLnByb3BlcnR5TmFtZV0gPSB0aGlzLnZhbHVlO1xuICBcdH1cbiAgfVxuXG4gIHZhciB1cGRhdGVFdmVyeXRoaW5nRWxzZSA9IEF0dHJpYnV0ZSR1cGRhdGVFdmVyeXRoaW5nRWxzZTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlRXZlcnl0aGluZ0Vsc2UoKSB7XG4gIFx0dmFyIF9yZWYgPSB0aGlzO1xuXG4gIFx0dmFyIG5vZGUgPSBfcmVmLm5vZGU7XG4gIFx0dmFyIG5hbWVzcGFjZSA9IF9yZWYubmFtZXNwYWNlO1xuICBcdHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICBcdHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG4gIFx0dmFyIGZyYWdtZW50ID0gX3JlZi5mcmFnbWVudDtcblxuICBcdGlmIChuYW1lc3BhY2UpIHtcbiAgXHRcdG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lLCAoZnJhZ21lbnQgfHwgdmFsdWUpLnRvU3RyaW5nKCkpO1xuICBcdH0gZWxzZSBpZiAoIXRoaXMuaXNCb29sZWFuKSB7XG4gIFx0XHRpZiAodmFsdWUgPT0gbnVsbCkge1xuICBcdFx0XHRub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIChmcmFnbWVudCB8fCB2YWx1ZSkudG9TdHJpbmcoKSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIC0gdHJ1dGh5IGJlY29tZXMgJycsIGZhbHN5IG1lYW5zICdyZW1vdmUgYXR0cmlidXRlJ1xuICBcdGVsc2Uge1xuICBcdFx0aWYgKHZhbHVlKSB7XG4gIFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIFwiXCIpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0bm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgLy8gVGhlcmUgYXJlIGEgZmV3IHNwZWNpYWwgY2FzZXMgd2hlbiBpdCBjb21lcyB0byB1cGRhdGluZyBhdHRyaWJ1dGVzLiBGb3IgdGhpcyByZWFzb24sXG4gIC8vIHRoZSBwcm90b3R5cGUgLnVwZGF0ZSgpIG1ldGhvZCBwb2ludHMgdG8gdGhpcyBtZXRob2QsIHdoaWNoIHdhaXRzIHVudGlsIHRoZVxuICAvLyBhdHRyaWJ1dGUgaGFzIGZpbmlzaGVkIGluaXRpYWxpc2luZywgdGhlbiByZXBsYWNlcyB0aGUgcHJvdG90eXBlIG1ldGhvZCB3aXRoIGEgbW9yZVxuICAvLyBzdWl0YWJsZSBvbmUuIFRoYXQgd2F5LCB3ZSBzYXZlIG91cnNlbHZlcyBkb2luZyBhIGJ1bmNoIG9mIHRlc3RzIG9uIGVhY2ggY2FsbFxuICB2YXIgQXR0cmlidXRlX3Byb3RvdHlwZV91cGRhdGUgPSBBdHRyaWJ1dGUkdXBkYXRlO1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlKCkge1xuICBcdHZhciBfcmVmID0gdGhpcztcblxuICBcdHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICBcdHZhciBlbGVtZW50ID0gX3JlZi5lbGVtZW50O1xuICBcdHZhciBub2RlID0gX3JlZi5ub2RlO3ZhciB0eXBlO3ZhciB1cGRhdGVNZXRob2Q7XG5cbiAgXHRpZiAobmFtZSA9PT0gXCJpZFwiKSB7XG4gIFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVJZEF0dHJpYnV0ZTtcbiAgXHR9IGVsc2UgaWYgKG5hbWUgPT09IFwidmFsdWVcIikge1xuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gc2VsZWN0c1xuICBcdFx0aWYgKGVsZW1lbnQubmFtZSA9PT0gXCJzZWxlY3RcIiAmJiBuYW1lID09PSBcInZhbHVlXCIpIHtcbiAgXHRcdFx0dXBkYXRlTWV0aG9kID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSA/IHVwZGF0ZU11bHRpcGxlU2VsZWN0VmFsdWUgOiB1cGRhdGVTZWxlY3RWYWx1ZTtcbiAgXHRcdH0gZWxzZSBpZiAoZWxlbWVudC5uYW1lID09PSBcInRleHRhcmVhXCIpIHtcbiAgXHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlVmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIGNvbnRlbnRlZGl0YWJsZVxuICBcdFx0ZWxzZSBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikgIT0gbnVsbCkge1xuICBcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gPGlucHV0PlxuICBcdFx0ZWxzZSBpZiAoZWxlbWVudC5uYW1lID09PSBcImlucHV0XCIpIHtcbiAgXHRcdFx0dHlwZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtcblxuICBcdFx0XHQvLyB0eXBlPSdmaWxlJyB2YWx1ZT0ne3tmaWxlTGlzdH19Jz5cbiAgXHRcdFx0aWYgKHR5cGUgPT09IFwiZmlsZVwiKSB7XG4gIFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gbm9vcDsgLy8gcmVhZC1vbmx5XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyB0eXBlPSdyYWRpbycgbmFtZT0ne3t0d293YXl9fSdcbiAgXHRcdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCJyYWRpb1wiICYmIGVsZW1lbnQuYmluZGluZyAmJiBlbGVtZW50LmJpbmRpbmcubmFtZSA9PT0gXCJuYW1lXCIpIHtcbiAgXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVSYWRpb1ZhbHVlO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZVZhbHVlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gc3BlY2lhbCBjYXNlIC0gPGlucHV0IHR5cGU9J3JhZGlvJyBuYW1lPSd7e3R3b3dheX19JyB2YWx1ZT0nZm9vJz5cbiAgXHRlbHNlIGlmICh0aGlzLmlzVHdvd2F5ICYmIG5hbWUgPT09IFwibmFtZVwiKSB7XG4gIFx0XHRpZiAobm9kZS50eXBlID09PSBcInJhZGlvXCIpIHtcbiAgXHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlUmFkaW9OYW1lO1xuICBcdFx0fSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICBcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVDaGVja2JveE5hbWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gc3BlY2lhbCBjYXNlIC0gc3R5bGUgYXR0cmlidXRlcyBpbiBJbnRlcm5ldCBFeHBsb2RlclxuICBcdGVsc2UgaWYgKG5hbWUgPT09IFwic3R5bGVcIiAmJiBub2RlLnN0eWxlLnNldEF0dHJpYnV0ZSkge1xuICBcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZTtcbiAgXHR9XG5cbiAgXHQvLyBzcGVjaWFsIGNhc2UgLSBjbGFzcyBuYW1lcy4gSUUgZnVja3MgdGhpbmdzIHVwLCBhZ2FpblxuICBcdGVsc2UgaWYgKG5hbWUgPT09IFwiY2xhc3NcIiAmJiAoIW5vZGUubmFtZXNwYWNlVVJJIHx8IG5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLmh0bWwpKSB7XG4gIFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVDbGFzc05hbWU7XG4gIFx0fSBlbHNlIGlmICh0aGlzLnVzZVByb3BlcnR5KSB7XG4gIFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVCb29sZWFuO1xuICBcdH1cblxuICBcdGlmICghdXBkYXRlTWV0aG9kKSB7XG4gIFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVFdmVyeXRoaW5nRWxzZTtcbiAgXHR9XG5cbiAgXHR0aGlzLnVwZGF0ZSA9IHVwZGF0ZU1ldGhvZDtcbiAgXHR0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgdmFyIEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy5pbml0KG9wdGlvbnMpO1xuICB9O1xuXG4gIEF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XG4gIFx0YnViYmxlOiBBdHRyaWJ1dGVfcHJvdG90eXBlX2J1YmJsZSxcbiAgXHRpbml0OiBwcm90b3R5cGVfaW5pdCxcbiAgXHRyZWJpbmQ6IEF0dHJpYnV0ZV9wcm90b3R5cGVfcmViaW5kLFxuICBcdHJlbmRlcjogQXR0cmlidXRlX3Byb3RvdHlwZV9yZW5kZXIsXG4gIFx0dG9TdHJpbmc6IEF0dHJpYnV0ZV9wcm90b3R5cGVfdG9TdHJpbmcsXG4gIFx0dW5iaW5kOiBBdHRyaWJ1dGVfcHJvdG90eXBlX3VuYmluZCxcbiAgXHR1cGRhdGU6IEF0dHJpYnV0ZV9wcm90b3R5cGVfdXBkYXRlXG4gIH07XG5cbiAgdmFyIF9BdHRyaWJ1dGUgPSBBdHRyaWJ1dGU7XG5cbiAgdmFyIGNyZWF0ZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICBcdHZhciBuYW1lLFxuICBcdCAgICBhdHRyaWJ1dGUsXG4gIFx0ICAgIHJlc3VsdCA9IFtdO1xuXG4gIFx0Zm9yIChuYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgXHRcdC8vIHNraXAgYmluZGluZyBhdHRyaWJ1dGVzXG4gIFx0XHRpZiAobmFtZSA9PT0gXCJ0d293YXlcIiB8fCBuYW1lID09PSBcImxhenlcIikge1xuICBcdFx0XHRjb250aW51ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgXHRcdFx0YXR0cmlidXRlID0gbmV3IF9BdHRyaWJ1dGUoe1xuICBcdFx0XHRcdGVsZW1lbnQ6IGVsZW1lbnQsXG4gIFx0XHRcdFx0bmFtZTogbmFtZSxcbiAgXHRcdFx0XHR2YWx1ZTogYXR0cmlidXRlc1tuYW1lXSxcbiAgXHRcdFx0XHRyb290OiBlbGVtZW50LnJvb3RcbiAgXHRcdFx0fSk7XG5cbiAgXHRcdFx0cmVzdWx0W25hbWVdID0gYXR0cmlidXRlO1xuXG4gIFx0XHRcdGlmIChuYW1lICE9PSBcInZhbHVlXCIpIHtcbiAgXHRcdFx0XHRyZXN1bHQucHVzaChhdHRyaWJ1dGUpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gdmFsdWUgYXR0cmlidXRlIGdvZXMgbGFzdC4gVGhpcyBpcyBiZWNhdXNlIGl0XG4gIFx0Ly8gbWF5IGdldCBjbGFtcGVkIG9uIHJlbmRlciBvdGhlcndpc2UsIGUuZy4gaW5cbiAgXHQvLyBgPGlucHV0IHR5cGU9J3JhbmdlJyB2YWx1ZT0nOTk5JyBtaW49JzAnIG1heD0nMTAwMCc+YFxuICBcdC8vIHNpbmNlIGRlZmF1bHQgbWF4IGlzIDEwMFxuICBcdGlmIChhdHRyaWJ1dGUgPSByZXN1bHQudmFsdWUpIHtcbiAgXHRcdHJlc3VsdC5wdXNoKGF0dHJpYnV0ZSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgX0NvbmRpdGlvbmFsQXR0cmlidXRlX19kaXY7XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBcdF9Db25kaXRpb25hbEF0dHJpYnV0ZV9fZGl2ID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgfVxuXG4gIHZhciBDb25kaXRpb25hbEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCB0ZW1wbGF0ZSkge1xuICBcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIFx0dGhpcy5yb290ID0gZWxlbWVudC5yb290O1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBlbGVtZW50LnBhcmVudEZyYWdtZW50O1xuXG4gIFx0dGhpcy5hdHRyaWJ1dGVzID0gW107XG5cbiAgXHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0cm9vdDogZWxlbWVudC5yb290LFxuICBcdFx0b3duZXI6IHRoaXMsXG4gIFx0XHR0ZW1wbGF0ZTogW3RlbXBsYXRlXVxuICBcdH0pO1xuICB9O1xuXG4gIENvbmRpdGlvbmFsQXR0cmlidXRlLnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLm5vZGUpIHtcbiAgXHRcdFx0dGhpcy51cGRhdGUoKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5lbGVtZW50LmJ1YmJsZSgpO1xuICBcdH0sXG5cbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICBcdFx0dGhpcy5ub2RlID0gbm9kZTtcbiAgXHRcdHRoaXMuaXNTdmcgPSBub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5zdmc7XG5cbiAgXHRcdHRoaXMudXBkYXRlKCk7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHR9LFxuXG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgc3RyLCBhdHRycztcblxuICBcdFx0c3RyID0gdGhpcy5mcmFnbWVudC50b1N0cmluZygpO1xuICBcdFx0YXR0cnMgPSBwYXJzZUF0dHJpYnV0ZXMoc3RyLCB0aGlzLmlzU3ZnKTtcblxuICBcdFx0Ly8gYW55IGF0dHJpYnV0ZXMgdGhhdCBwcmV2aW91c2x5IGV4aXN0ZWQgYnV0IG5vIGxvbmdlciBkb1xuICBcdFx0Ly8gbXVzdCBiZSByZW1vdmVkXG4gIFx0XHR0aGlzLmF0dHJpYnV0ZXMuZmlsdGVyKGZ1bmN0aW9uIChhKSB7XG4gIFx0XHRcdHJldHVybiBub3RJbihhdHRycywgYSk7XG4gIFx0XHR9KS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gIFx0XHRcdF90aGlzLm5vZGUucmVtb3ZlQXR0cmlidXRlKGEubmFtZSk7XG4gIFx0XHR9KTtcblxuICBcdFx0YXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICBcdFx0XHRfdGhpcy5ub2RlLnNldEF0dHJpYnV0ZShhLm5hbWUsIGEudmFsdWUpO1xuICBcdFx0fSk7XG5cbiAgXHRcdHRoaXMuYXR0cmlidXRlcyA9IGF0dHJzO1xuICBcdH0sXG5cbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIF9Db25kaXRpb25hbEF0dHJpYnV0ZSA9IENvbmRpdGlvbmFsQXR0cmlidXRlO1xuXG4gIGZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlcyhzdHIsIGlzU3ZnKSB7XG4gIFx0dmFyIHRhZyA9IGlzU3ZnID8gXCJzdmdcIiA6IFwiZGl2XCI7XG4gIFx0X0NvbmRpdGlvbmFsQXR0cmlidXRlX19kaXYuaW5uZXJIVE1MID0gXCI8XCIgKyB0YWcgKyBcIiBcIiArIHN0ciArIFwiPjwvXCIgKyB0YWcgKyBcIj5cIjtcblxuICBcdHJldHVybiB0b0FycmF5KF9Db25kaXRpb25hbEF0dHJpYnV0ZV9fZGl2LmNoaWxkTm9kZXNbMF0uYXR0cmlidXRlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBub3RJbihoYXlzdGFjaywgbmVlZGxlKSB7XG4gIFx0dmFyIGkgPSBoYXlzdGFjay5sZW5ndGg7XG5cbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpZiAoaGF5c3RhY2tbaV0ubmFtZSA9PT0gbmVlZGxlLm5hbWUpIHtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGNyZWF0ZUNvbmRpdGlvbmFsQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gIFx0aWYgKCFhdHRyaWJ1dGVzKSB7XG4gIFx0XHRyZXR1cm4gW107XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGF0dHJpYnV0ZXMubWFwKGZ1bmN0aW9uIChhKSB7XG4gIFx0XHRyZXR1cm4gbmV3IF9Db25kaXRpb25hbEF0dHJpYnV0ZShlbGVtZW50LCBhKTtcbiAgXHR9KTtcbiAgfTtcblxuICB2YXIgQmluZGluZyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIFx0dmFyIGludGVycG9sYXRvciwga2V5cGF0aCwgdmFsdWUsIHBhcmVudEZvcm07XG5cbiAgXHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICBcdHRoaXMucm9vdCA9IGVsZW1lbnQucm9vdDtcbiAgXHR0aGlzLmF0dHJpYnV0ZSA9IGVsZW1lbnQuYXR0cmlidXRlc1t0aGlzLm5hbWUgfHwgXCJ2YWx1ZVwiXTtcblxuICBcdGludGVycG9sYXRvciA9IHRoaXMuYXR0cmlidXRlLmludGVycG9sYXRvcjtcbiAgXHRpbnRlcnBvbGF0b3IudHdvd2F5QmluZGluZyA9IHRoaXM7XG5cbiAgXHRpZiAoa2V5cGF0aCA9IGludGVycG9sYXRvci5rZXlwYXRoKSB7XG4gIFx0XHRpZiAoa2V5cGF0aC5zdHIuc2xpY2UoLTEpID09PSBcIn1cIikge1xuICBcdFx0XHR3YXJuT25jZUlmRGVidWcoXCJUd28td2F5IGJpbmRpbmcgZG9lcyBub3Qgd29yayB3aXRoIGV4cHJlc3Npb25zIChgJXNgIG9uIDwlcz4pXCIsIGludGVycG9sYXRvci5yZXNvbHZlci51bmlxdWVTdHJpbmcsIGVsZW1lbnQubmFtZSwgeyByYWN0aXZlOiB0aGlzLnJvb3QgfSk7XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGtleXBhdGguaXNTcGVjaWFsKSB7XG4gIFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhcIlR3by13YXkgYmluZGluZyBkb2VzIG5vdCB3b3JrIHdpdGggJXNcIiwgaW50ZXJwb2xhdG9yLnJlc29sdmVyLnJlZiwgeyByYWN0aXZlOiB0aGlzLnJvb3QgfSk7XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0Ly8gQSBtdXN0YWNoZSBtYXkgYmUgKmFtYmlndW91cyouIExldCdzIHNheSB3ZSB3ZXJlIGdpdmVuXG4gIFx0XHQvLyBgdmFsdWU9XCJ7e2Jhcn19XCJgLiBJZiB0aGUgY29udGV4dCB3YXMgYGZvb2AsIGFuZCBgZm9vLmJhcmBcbiAgXHRcdC8vICp3YXNuJ3QqIGB1bmRlZmluZWRgLCB0aGUga2V5cGF0aCB3b3VsZCBiZSBgZm9vLmJhcmAuXG4gIFx0XHQvLyBUaGVuLCBhbnkgdXNlciBpbnB1dCB3b3VsZCByZXN1bHQgaW4gYGZvby5iYXJgIGJlaW5nIHVwZGF0ZWQuXG4gIFx0XHQvL1xuICBcdFx0Ly8gSWYsIGhvd2V2ZXIsIGBmb28uYmFyYCAqd2FzKiB1bmRlZmluZWQsIGFuZCBzbyB3YXMgYGJhcmAsIHdlIHdvdWxkIGJlXG4gIFx0XHQvLyBsZWZ0IHdpdGggYW4gdW5yZXNvbHZlZCBwYXJ0aWFsIGtleXBhdGggLSBzbyB3ZSBhcmUgZm9yY2VkIHRvIG1ha2UgYW5cbiAgXHRcdC8vIGFzc3VtcHRpb24uIFRoYXQgYXNzdW1wdGlvbiBpcyB0aGF0IHRoZSBpbnB1dCBpbiBxdWVzdGlvbiBzaG91bGRcbiAgXHRcdC8vIGJlIGZvcmNlZCB0byByZXNvbHZlIHRvIGBiYXJgLCBhbmQgYW55IHVzZXIgaW5wdXQgd291bGQgYWZmZWN0IGBiYXJgXG4gIFx0XHQvLyBhbmQgbm90IGBmb28uYmFyYC5cbiAgXHRcdC8vXG4gIFx0XHQvLyBEaWQgdGhhdCBtYWtlIGFueSBzZW5zZT8gTm8/IE9oLiBTb3JyeS4gV2VsbCB0aGUgbW9yYWwgb2YgdGhlIHN0b3J5IGlzXG4gIFx0XHQvLyBiZSBleHBsaWNpdCB3aGVuIHVzaW5nIHR3by13YXkgZGF0YS1iaW5kaW5nIGFib3V0IHdoYXQga2V5cGF0aCB5b3UncmVcbiAgXHRcdC8vIHVwZGF0aW5nLiBVc2luZyBpdCBpbiBsaXN0cyBpcyBwcm9iYWJseSBhIHJlY2lwZSBmb3IgY29uZnVzaW9uLi4uXG4gIFx0XHR2YXIgcmVmID0gaW50ZXJwb2xhdG9yLnRlbXBsYXRlLnIgPyBcIidcIiArIGludGVycG9sYXRvci50ZW1wbGF0ZS5yICsgXCInIHJlZmVyZW5jZVwiIDogXCJleHByZXNzaW9uXCI7XG4gIFx0XHR3YXJuSWZEZWJ1ZyhcIlRoZSAlcyBiZWluZyB1c2VkIGZvciB0d28td2F5IGJpbmRpbmcgaXMgYW1iaWd1b3VzLCBhbmQgbWF5IGNhdXNlIHVuZXhwZWN0ZWQgcmVzdWx0cy4gQ29uc2lkZXIgaW5pdGlhbGlzaW5nIHlvdXIgZGF0YSB0byBlbGltaW5hdGUgdGhlIGFtYmlndWl0eVwiLCByZWYsIHsgcmFjdGl2ZTogdGhpcy5yb290IH0pO1xuICBcdFx0aW50ZXJwb2xhdG9yLnJlc29sdmVyLmZvcmNlUmVzb2x1dGlvbigpO1xuICBcdFx0a2V5cGF0aCA9IGludGVycG9sYXRvci5rZXlwYXRoO1xuICBcdH1cblxuICBcdHRoaXMuYXR0cmlidXRlLmlzVHdvd2F5ID0gdHJ1ZTtcbiAgXHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXG4gIFx0Ly8gaW5pdGlhbGlzZSB2YWx1ZSwgaWYgaXQncyB1bmRlZmluZWRcbiAgXHR2YWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuXG4gIFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgdGhpcy5nZXRJbml0aWFsVmFsdWUpIHtcbiAgXHRcdHZhbHVlID0gdGhpcy5nZXRJbml0aWFsVmFsdWUoKTtcblxuICBcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoa2V5cGF0aCwgdmFsdWUpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChwYXJlbnRGb3JtID0gZmluZFBhcmVudEZvcm0oZWxlbWVudCkpIHtcbiAgXHRcdHRoaXMucmVzZXRWYWx1ZSA9IHZhbHVlO1xuICBcdFx0cGFyZW50Rm9ybS5mb3JtQmluZGluZ3MucHVzaCh0aGlzKTtcbiAgXHR9XG4gIH07XG5cbiAgQmluZGluZy5wcm90b3R5cGUgPSB7XG4gIFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLnJvb3QpO1xuICBcdFx0dGhpcy5hdHRyaWJ1dGUubG9ja2VkID0gdHJ1ZTtcbiAgXHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KHRoaXMua2V5cGF0aCwgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiBfdGhpcy5hdHRyaWJ1dGUubG9ja2VkID0gZmFsc2U7XG4gIFx0XHR9KTtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuICBcdH0sXG5cbiAgXHRyZWJvdW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgYmluZGluZ3MsIG9sZEtleXBhdGgsIG5ld0tleXBhdGg7XG5cbiAgXHRcdG9sZEtleXBhdGggPSB0aGlzLmtleXBhdGg7XG4gIFx0XHRuZXdLZXlwYXRoID0gdGhpcy5hdHRyaWJ1dGUuaW50ZXJwb2xhdG9yLmtleXBhdGg7XG5cbiAgXHRcdC8vIFRoZSBhdHRyaWJ1dGUgdGhpcyBiaW5kaW5nIGlzIGxpbmtlZCB0byBoYXMgYWxyZWFkeSBkb25lIHRoZSB3b3JrXG4gIFx0XHRpZiAob2xkS2V5cGF0aCA9PT0gbmV3S2V5cGF0aCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzW29sZEtleXBhdGguc3RyXSwgdGhpcyk7XG5cbiAgXHRcdHRoaXMua2V5cGF0aCA9IG5ld0tleXBhdGg7XG5cbiAgXHRcdGJpbmRpbmdzID0gdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1tuZXdLZXlwYXRoLnN0cl0gfHwgKHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbbmV3S2V5cGF0aC5zdHJdID0gW10pO1xuICBcdFx0YmluZGluZ3MucHVzaCh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7fVxuICB9O1xuXG4gIEJpbmRpbmcuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgXHR2YXIgUGFyZW50ID0gdGhpcyxcbiAgXHQgICAgU3BlY2lhbGlzZWRCaW5kaW5nO1xuXG4gIFx0U3BlY2lhbGlzZWRCaW5kaW5nID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgXHRcdEJpbmRpbmcuY2FsbCh0aGlzLCBlbGVtZW50KTtcblxuICBcdFx0aWYgKHRoaXMuaW5pdCkge1xuICBcdFx0XHR0aGlzLmluaXQoKTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0U3BlY2lhbGlzZWRCaW5kaW5nLnByb3RvdHlwZSA9IGNyZWF0ZShQYXJlbnQucHJvdG90eXBlKTtcbiAgXHR1dGlsc19vYmplY3RfX2V4dGVuZChTcGVjaWFsaXNlZEJpbmRpbmcucHJvdG90eXBlLCBwcm9wZXJ0aWVzKTtcblxuICBcdFNwZWNpYWxpc2VkQmluZGluZy5leHRlbmQgPSBCaW5kaW5nLmV4dGVuZDtcblxuICBcdHJldHVybiBTcGVjaWFsaXNlZEJpbmRpbmc7XG4gIH07XG5cbiAgdmFyIEJpbmRpbmdfQmluZGluZyA9IEJpbmRpbmc7XG5cbiAgZnVuY3Rpb24gZmluZFBhcmVudEZvcm0oZWxlbWVudCkge1xuICBcdHdoaWxlIChlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQpIHtcbiAgXHRcdGlmIChlbGVtZW50Lm5hbWUgPT09IFwiZm9ybVwiKSB7XG4gIFx0XHRcdHJldHVybiBlbGVtZW50O1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIC8vIHRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgdW5ib3VuZC5cbiAgLy8gU3BlY2lhbGlzZWQgYmluZGluZ3MgY2FuIG92ZXJyaWRlIGl0XG5cbiAgLy8gVGhpcyBpcyB0aGUgaGFuZGxlciBmb3IgRE9NIGV2ZW50cyB0aGF0IHdvdWxkIGxlYWQgdG8gYSBjaGFuZ2UgaW4gdGhlIG1vZGVsXG4gIC8vIChpLmUuIGNoYW5nZSwgc29tZXRpbWVzLCBpbnB1dCwgYW5kIG9jY2FzaW9uYWxseSBjbGljayBhbmQga2V5dXApXG4gIHZhciBoYW5kbGVEb21FdmVudCA9IGhhbmRsZUNoYW5nZTtcblxuICBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UoKSB7XG4gIFx0dGhpcy5fcmFjdGl2ZS5iaW5kaW5nLmhhbmRsZUNoYW5nZSgpO1xuICB9XG5cbiAgdmFyIEdlbmVyaWNCaW5kaW5nO1xuXG4gIEdlbmVyaWNCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gXCJcIjtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS52YWx1ZTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlLFxuICBcdFx0ICAgIGxhenksXG4gIFx0XHQgICAgdGltZW91dCA9IGZhbHNlO1xuICBcdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG5cbiAgXHRcdC8vIGFueSBsYXp5IHNldHRpbmcgZm9yIHRoaXMgZWxlbWVudCBvdmVycmlkZXMgdGhlIHJvb3RcbiAgXHRcdC8vIGlmIHRoZSB2YWx1ZSBpcyBhIG51bWJlciwgaXQncyBhIHRpbWVvdXRcbiAgXHRcdGxhenkgPSB0aGlzLnJvb3QubGF6eTtcbiAgXHRcdGlmICh0aGlzLmVsZW1lbnQubGF6eSA9PT0gdHJ1ZSkge1xuICBcdFx0XHRsYXp5ID0gdHJ1ZTtcbiAgXHRcdH0gZWxzZSBpZiAodGhpcy5lbGVtZW50LmxhenkgPT09IGZhbHNlKSB7XG4gIFx0XHRcdGxhenkgPSBmYWxzZTtcbiAgXHRcdH0gZWxzZSBpZiAoaXNfX2lzTnVtZXJpYyh0aGlzLmVsZW1lbnQubGF6eSkpIHtcbiAgXHRcdFx0bGF6eSA9IGZhbHNlO1xuICBcdFx0XHR0aW1lb3V0ID0gK3RoaXMuZWxlbWVudC5sYXp5O1xuICBcdFx0fSBlbHNlIGlmIChpc19faXNOdW1lcmljKGxhenkgfHwgXCJcIikpIHtcbiAgXHRcdFx0dGltZW91dCA9ICtsYXp5O1xuICBcdFx0XHRsYXp5ID0gZmFsc2U7XG5cbiAgXHRcdFx0Ly8gbWFrZSBzdXJlIHRoZSB0aW1lb3V0IGlzIGF2YWlsYWJsZSB0byB0aGUgaGFuZGxlclxuICBcdFx0XHR0aGlzLmVsZW1lbnQubGF6eSA9IHRpbWVvdXQ7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuaGFuZGxlciA9IHRpbWVvdXQgPyBoYW5kbGVEZWxheSA6IGhhbmRsZURvbUV2ZW50O1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0aWYgKCFsYXp5KSB7XG4gIFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuaGFuZGxlciwgZmFsc2UpO1xuXG4gIFx0XHRcdGlmIChub2RlLmF0dGFjaEV2ZW50KSB7XG4gIFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5oYW5kbGVyLCBmYWxzZSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBoYW5kbGVCbHVyLCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuICBcdFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuXG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuaGFuZGxlciwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5oYW5kbGVyLCBmYWxzZSk7XG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGhhbmRsZUJsdXIsIGZhbHNlKTtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBCaW5kaW5nX0dlbmVyaWNCaW5kaW5nID0gR2VuZXJpY0JpbmRpbmc7XG5cbiAgZnVuY3Rpb24gaGFuZGxlQmx1cigpIHtcbiAgXHR2YXIgdmFsdWU7XG5cbiAgXHRoYW5kbGVEb21FdmVudC5jYWxsKHRoaXMpO1xuXG4gIFx0dmFsdWUgPSB0aGlzLl9yYWN0aXZlLnJvb3Qudmlld21vZGVsLmdldCh0aGlzLl9yYWN0aXZlLmJpbmRpbmcua2V5cGF0aCk7XG4gIFx0dGhpcy52YWx1ZSA9IHZhbHVlID09IHVuZGVmaW5lZCA/IFwiXCIgOiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZURlbGF5KCkge1xuICBcdHZhciBiaW5kaW5nID0gdGhpcy5fcmFjdGl2ZS5iaW5kaW5nLFxuICBcdCAgICBlbCA9IHRoaXM7XG5cbiAgXHRpZiAoISFiaW5kaW5nLl90aW1lb3V0KSBjbGVhclRpbWVvdXQoYmluZGluZy5fdGltZW91dCk7XG5cbiAgXHRiaW5kaW5nLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoYmluZGluZy5yZW5kZXJlZCkgaGFuZGxlRG9tRXZlbnQuY2FsbChlbCk7XG4gIFx0XHRiaW5kaW5nLl90aW1lb3V0ID0gdW5kZWZpbmVkO1xuICBcdH0sIGJpbmRpbmcuZWxlbWVudC5sYXp5KTtcbiAgfVxuXG4gIHZhciBDb250ZW50RWRpdGFibGVCaW5kaW5nID0gQmluZGluZ19HZW5lcmljQmluZGluZy5leHRlbmQoe1xuICBcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5mcmFnbWVudCA/IHRoaXMuZWxlbWVudC5mcmFnbWVudC50b1N0cmluZygpIDogXCJcIjtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5pbm5lckhUTUw7XG4gIFx0fVxuICB9KTtcblxuICB2YXIgQmluZGluZ19Db250ZW50RWRpdGFibGVCaW5kaW5nID0gQ29udGVudEVkaXRhYmxlQmluZGluZztcblxuICB2YXIgc2hhcmVkX2dldFNpYmxpbmdzID0gZ2V0U2libGluZ3M7XG4gIHZhciBzZXRzID0ge307XG4gIGZ1bmN0aW9uIGdldFNpYmxpbmdzKGlkLCBncm91cCwga2V5cGF0aCkge1xuICBcdHZhciBoYXNoID0gaWQgKyBncm91cCArIGtleXBhdGg7XG4gIFx0cmV0dXJuIHNldHNbaGFzaF0gfHwgKHNldHNbaGFzaF0gPSBbXSk7XG4gIH1cblxuICB2YXIgUmFkaW9CaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0bmFtZTogXCJjaGVja2VkXCIsXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnNpYmxpbmdzID0gc2hhcmVkX2dldFNpYmxpbmdzKHRoaXMucm9vdC5fZ3VpZCwgXCJyYWRpb1wiLCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSk7XG4gIFx0XHR0aGlzLnNpYmxpbmdzLnB1c2godGhpcyk7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblxuICBcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG5cbiAgXHRcdGlmIChub2RlLmF0dGFjaEV2ZW50KSB7XG4gIFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24gKCkge1xuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcy5yb290KTtcblxuICBcdFx0dGhpcy5zaWJsaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gIFx0XHRcdGJpbmRpbmcucm9vdC52aWV3bW9kZWwuc2V0KGJpbmRpbmcua2V5cGF0aCwgYmluZGluZy5nZXRWYWx1ZSgpKTtcbiAgXHRcdH0pO1xuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLnNpYmxpbmdzLCB0aGlzKTtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBCaW5kaW5nX1JhZGlvQmluZGluZyA9IFJhZGlvQmluZGluZztcblxuICB2YXIgUmFkaW9OYW1lQmluZGluZyA9IEJpbmRpbmdfQmluZGluZy5leHRlbmQoe1xuICBcdG5hbWU6IFwibmFtZVwiLFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5zaWJsaW5ncyA9IHNoYXJlZF9nZXRTaWJsaW5ncyh0aGlzLnJvb3QuX2d1aWQsIFwicmFkaW9uYW1lXCIsIHRoaXMua2V5cGF0aC5zdHIpO1xuICBcdFx0dGhpcy5zaWJsaW5ncy5wdXNoKHRoaXMpO1xuXG4gIFx0XHR0aGlzLnJhZGlvTmFtZSA9IHRydWU7IC8vIHNvIHRoYXQgcmFjdGl2ZS51cGRhdGVNb2RlbCgpIGtub3dzIHdoYXQgdG8gZG8gd2l0aCB0aGlzXG4gIFx0fSxcblxuICBcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIpKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblxuICBcdFx0bm9kZS5uYW1lID0gXCJ7e1wiICsgdGhpcy5rZXlwYXRoLnN0ciArIFwifX1cIjtcbiAgXHRcdG5vZGUuY2hlY2tlZCA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KHRoaXMua2V5cGF0aCkgPT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0aWYgKG5vZGUuYXR0YWNoRXZlbnQpIHtcbiAgXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG4gIFx0XHRyZXR1cm4gbm9kZS5fcmFjdGl2ZSA/IG5vZGUuX3JhY3RpdmUudmFsdWUgOiBub2RlLnZhbHVlO1xuICBcdH0sXG5cbiAgXHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIElmIHRoaXMgPGlucHV0PiBpcyB0aGUgb25lIHRoYXQncyBjaGVja2VkLCB0aGVuIHRoZSB2YWx1ZSBvZiBpdHNcbiAgXHRcdC8vIGBuYW1lYCBrZXlwYXRoIGdldHMgc2V0IHRvIGl0cyB2YWx1ZVxuICBcdFx0aWYgKHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQpIHtcbiAgXHRcdFx0QmluZGluZ19CaW5kaW5nLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UuY2FsbCh0aGlzKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmVib3VuZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdHZhciBub2RlO1xuXG4gIFx0XHRCaW5kaW5nX0JpbmRpbmcucHJvdG90eXBlLnJlYm91bmQuY2FsbCh0aGlzLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcblxuICBcdFx0aWYgKG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZSkge1xuICBcdFx0XHRub2RlLm5hbWUgPSBcInt7XCIgKyB0aGlzLmtleXBhdGguc3RyICsgXCJ9fVwiO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLnNpYmxpbmdzLCB0aGlzKTtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBCaW5kaW5nX1JhZGlvTmFtZUJpbmRpbmcgPSBSYWRpb05hbWVCaW5kaW5nO1xuXG4gIHZhciBDaGVja2JveE5hbWVCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0bmFtZTogXCJuYW1lXCIsXG5cbiAgXHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIFRoaXMgb25seSBnZXRzIGNhbGxlZCBvbmNlIHBlciBncm91cCAob2YgaW5wdXRzIHRoYXRcbiAgXHRcdC8vIHNoYXJlIGEgbmFtZSksIGJlY2F1c2UgaXQgb25seSBnZXRzIGNhbGxlZCBpZiB0aGVyZVxuICBcdFx0Ly8gaXNuJ3QgYW4gaW5pdGlhbCB2YWx1ZS4gQnkgdGhlIHNhbWUgdG9rZW4sIHdlIGNhbiBtYWtlXG4gIFx0XHQvLyBhIG5vdGUgb2YgdGhhdCBmYWN0IHRoYXQgdGhlcmUgd2FzIG5vIGluaXRpYWwgdmFsdWUsXG4gIFx0XHQvLyBhbmQgcG9wdWxhdGUgaXQgdXNpbmcgYW55IGBjaGVja2VkYCBhdHRyaWJ1dGVzIHRoYXRcbiAgXHRcdC8vIGV4aXN0ICh3aGljaCB1c2VycyBzaG91bGQgYXZvaWQsIGJ1dCB3aGljaCB3ZSBzaG91bGRcbiAgXHRcdC8vIHN1cHBvcnQgYW55d2F5IHRvIGF2b2lkIGJyZWFraW5nIGV4cGVjdGF0aW9ucylcbiAgXHRcdHRoaXMubm9Jbml0aWFsVmFsdWUgPSB0cnVlO1xuICBcdFx0cmV0dXJuIFtdO1xuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZXhpc3RpbmdWYWx1ZSwgYmluZGluZ1ZhbHVlO1xuXG4gIFx0XHR0aGlzLmNoZWNrYm94TmFtZSA9IHRydWU7IC8vIHNvIHRoYXQgcmFjdGl2ZS51cGRhdGVNb2RlbCgpIGtub3dzIHdoYXQgdG8gZG8gd2l0aCB0aGlzXG5cbiAgXHRcdC8vIEVhY2ggaW5wdXQgaGFzIGEgcmVmZXJlbmNlIHRvIGFuIGFycmF5IGNvbnRhaW5pbmcgaXQgYW5kIGl0c1xuICBcdFx0Ly8gc2libGluZ3MsIGFzIHR3by13YXkgYmluZGluZyBkZXBlbmRzIG9uIGJlaW5nIGFibGUgdG8gYXNjZXJ0YWluXG4gIFx0XHQvLyB0aGUgc3RhdHVzIG9mIGFsbCBpbnB1dHMgd2l0aGluIHRoZSBncm91cFxuICBcdFx0dGhpcy5zaWJsaW5ncyA9IHNoYXJlZF9nZXRTaWJsaW5ncyh0aGlzLnJvb3QuX2d1aWQsIFwiY2hlY2tib3hlc1wiLCB0aGlzLmtleXBhdGguc3RyKTtcbiAgXHRcdHRoaXMuc2libGluZ3MucHVzaCh0aGlzKTtcblxuICBcdFx0aWYgKHRoaXMubm9Jbml0aWFsVmFsdWUpIHtcbiAgXHRcdFx0dGhpcy5zaWJsaW5ncy5ub0luaXRpYWxWYWx1ZSA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIElmIG5vIGluaXRpYWwgdmFsdWUgd2FzIHNldCwgYW5kIHRoaXMgaW5wdXQgaXMgY2hlY2tlZCwgd2VcbiAgXHRcdC8vIHVwZGF0ZSB0aGUgbW9kZWxcbiAgXHRcdGlmICh0aGlzLnNpYmxpbmdzLm5vSW5pdGlhbFZhbHVlICYmIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIpKSB7XG4gIFx0XHRcdGV4aXN0aW5nVmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCh0aGlzLmtleXBhdGgpO1xuICBcdFx0XHRiaW5kaW5nVmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRcdFx0ZXhpc3RpbmdWYWx1ZS5wdXNoKGJpbmRpbmdWYWx1ZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMuc2libGluZ3MsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGUsXG4gIFx0XHQgICAgZXhpc3RpbmdWYWx1ZSxcbiAgXHRcdCAgICBiaW5kaW5nVmFsdWU7XG5cbiAgXHRcdGV4aXN0aW5nVmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCh0aGlzLmtleXBhdGgpO1xuICBcdFx0YmluZGluZ1ZhbHVlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuXG4gIFx0XHRpZiAoaXNBcnJheShleGlzdGluZ1ZhbHVlKSkge1xuICBcdFx0XHR0aGlzLmlzQ2hlY2tlZCA9IGFycmF5Q29udGFpbnMoZXhpc3RpbmdWYWx1ZSwgYmluZGluZ1ZhbHVlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuaXNDaGVja2VkID0gZXhpc3RpbmdWYWx1ZSA9PSBiaW5kaW5nVmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdG5vZGUubmFtZSA9IFwie3tcIiArIHRoaXMua2V5cGF0aC5zdHIgKyBcIn19XCI7XG4gIFx0XHRub2RlLmNoZWNrZWQgPSB0aGlzLmlzQ2hlY2tlZDtcblxuICBcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG5cbiAgXHRcdC8vIGluIGNhc2Ugb2YgSUUgZW1lcmdlbmN5LCBiaW5kIHRvIGNsaWNrIGV2ZW50IGFzIHdlbGxcbiAgXHRcdGlmIChub2RlLmF0dGFjaEV2ZW50KSB7XG4gIFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdGNoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciB3YXNDaGVja2VkID0gISF0aGlzLmlzQ2hlY2tlZDtcbiAgXHRcdHRoaXMuaXNDaGVja2VkID0gdGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZDtcbiAgXHRcdHJldHVybiB0aGlzLmlzQ2hlY2tlZCA9PT0gd2FzQ2hlY2tlZDtcbiAgXHR9LFxuXG4gIFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmlzQ2hlY2tlZCA9IHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG4gIFx0XHRCaW5kaW5nX0JpbmRpbmcucHJvdG90eXBlLmhhbmRsZUNoYW5nZS5jYWxsKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuc2libGluZ3MuZmlsdGVyKGlzQ2hlY2tlZCkubWFwKEJpbmRpbmdfQ2hlY2tib3hOYW1lQmluZGluZ19fZ2V0VmFsdWUpO1xuICBcdH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gaXNDaGVja2VkKGJpbmRpbmcpIHtcbiAgXHRyZXR1cm4gYmluZGluZy5pc0NoZWNrZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBCaW5kaW5nX0NoZWNrYm94TmFtZUJpbmRpbmdfX2dldFZhbHVlKGJpbmRpbmcpIHtcbiAgXHRyZXR1cm4gYmluZGluZy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICB9XG5cbiAgdmFyIEJpbmRpbmdfQ2hlY2tib3hOYW1lQmluZGluZyA9IENoZWNrYm94TmFtZUJpbmRpbmc7XG5cbiAgdmFyIENoZWNrYm94QmluZGluZyA9IEJpbmRpbmdfQmluZGluZy5leHRlbmQoe1xuICBcdG5hbWU6IFwiY2hlY2tlZFwiLFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0aWYgKG5vZGUuYXR0YWNoRXZlbnQpIHtcbiAgXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfQ2hlY2tib3hCaW5kaW5nID0gQ2hlY2tib3hCaW5kaW5nO1xuXG4gIHZhciBTZWxlY3RCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuZWxlbWVudC5vcHRpb25zLFxuICBcdFx0ICAgIGxlbixcbiAgXHRcdCAgICBpLFxuICBcdFx0ICAgIHZhbHVlLFxuICBcdFx0ICAgIG9wdGlvbldhc1NlbGVjdGVkO1xuXG4gIFx0XHRpZiAodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpID0gbGVuID0gb3B0aW9ucy5sZW5ndGg7XG5cbiAgXHRcdGlmICghbGVuKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Ly8gdGFrZSB0aGUgZmluYWwgc2VsZWN0ZWQgb3B0aW9uLi4uXG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGlmIChvcHRpb25zW2ldLmdldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIpKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSBvcHRpb25zW2ldLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdFx0XHRcdG9wdGlvbldhc1NlbGVjdGVkID0gdHJ1ZTtcbiAgXHRcdFx0XHRicmVhaztcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBvciB0aGUgZmlyc3Qgbm9uLWRpc2FibGVkIG9wdGlvbiwgaWYgbm9uZSBhcmUgc2VsZWN0ZWRcbiAgXHRcdGlmICghb3B0aW9uV2FzU2VsZWN0ZWQpIHtcbiAgXHRcdFx0d2hpbGUgKCsraSA8IGxlbikge1xuICBcdFx0XHRcdGlmICghb3B0aW9uc1tpXS5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSkge1xuICBcdFx0XHRcdFx0dmFsdWUgPSBvcHRpb25zW2ldLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFRoaXMgaXMgYW4gb3B0aW1pc2F0aW9uIChha2EgaGFjaykgdGhhdCBhbGxvd3MgdXMgdG8gZm9yZ28gc29tZVxuICBcdFx0Ly8gb3RoZXIgbW9yZSBleHBlbnNpdmUgd29ya1xuICBcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy5lbGVtZW50LmF0dHJpYnV0ZXMudmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHZhbHVlO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZWxlbWVudC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZWxlbWVudC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0Ly8gVE9ETyB0aGlzIG1ldGhvZCBpcyBhbiBhbm9tYWx5Li4uIGlzIGl0IG5lY2Vzc2FyeT9cbiAgXHRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCh0aGlzLmtleXBhdGgsIHZhbHVlKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBvcHRpb25zLCBpLCBsZW4sIG9wdGlvbiwgb3B0aW9uVmFsdWU7XG5cbiAgXHRcdG9wdGlvbnMgPSB0aGlzLmVsZW1lbnQubm9kZS5vcHRpb25zO1xuICBcdFx0bGVuID0gb3B0aW9ucy5sZW5ndGg7XG5cbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRvcHRpb24gPSBvcHRpb25zW2ldO1xuXG4gIFx0XHRcdGlmIChvcHRpb25zW2ldLnNlbGVjdGVkKSB7XG4gIFx0XHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7XG4gIFx0XHRcdFx0cmV0dXJuIG9wdGlvblZhbHVlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cbiAgXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRoaXMuYXR0cmlidXRlLmxvY2tlZCA9IHRydWU7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIF90aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSBmYWxzZTtcbiAgXHRcdFx0fSk7XG4gIFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KHRoaXMua2V5cGF0aCwgdmFsdWUpO1xuICBcdFx0fVxuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfU2VsZWN0QmluZGluZyA9IFNlbGVjdEJpbmRpbmc7XG5cbiAgdmFyIE11bHRpcGxlU2VsZWN0QmluZGluZyA9IEJpbmRpbmdfU2VsZWN0QmluZGluZy5leHRlbmQoe1xuICBcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5vcHRpb25zLmZpbHRlcihmdW5jdGlvbiAob3B0aW9uKSB7XG4gIFx0XHRcdHJldHVybiBvcHRpb24uZ2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIik7XG4gIFx0XHR9KS5tYXAoZnVuY3Rpb24gKG9wdGlvbikge1xuICBcdFx0XHRyZXR1cm4gb3B0aW9uLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdFx0fSk7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHZhbHVlRnJvbU1vZGVsO1xuXG4gIFx0XHR0aGlzLmVsZW1lbnQubm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG5cbiAgXHRcdHZhbHVlRnJvbU1vZGVsID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQodGhpcy5rZXlwYXRoKTtcblxuICBcdFx0aWYgKHZhbHVlRnJvbU1vZGVsID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0Ly8gZ2V0IHZhbHVlIGZyb20gRE9NLCBpZiBwb3NzaWJsZVxuICBcdFx0XHR0aGlzLmhhbmRsZUNoYW5nZSgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5lbGVtZW50Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHRzZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiVE9ETyBub3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHNlbGVjdGVkVmFsdWVzLCBvcHRpb25zLCBpLCBsZW4sIG9wdGlvbiwgb3B0aW9uVmFsdWU7XG5cbiAgXHRcdHNlbGVjdGVkVmFsdWVzID0gW107XG4gIFx0XHRvcHRpb25zID0gdGhpcy5lbGVtZW50Lm5vZGUub3B0aW9ucztcbiAgXHRcdGxlbiA9IG9wdGlvbnMubGVuZ3RoO1xuXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0b3B0aW9uID0gb3B0aW9uc1tpXTtcblxuICBcdFx0XHRpZiAob3B0aW9uLnNlbGVjdGVkKSB7XG4gIFx0XHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7XG4gIFx0XHRcdFx0c2VsZWN0ZWRWYWx1ZXMucHVzaChvcHRpb25WYWx1ZSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHNlbGVjdGVkVmFsdWVzO1xuICBcdH0sXG5cbiAgXHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBhdHRyaWJ1dGUsIHByZXZpb3VzVmFsdWUsIHZhbHVlO1xuXG4gIFx0XHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZTtcbiAgXHRcdHByZXZpb3VzVmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG5cbiAgXHRcdHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXG4gIFx0XHRpZiAocHJldmlvdXNWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICFhcnJheUNvbnRlbnRzTWF0Y2godmFsdWUsIHByZXZpb3VzVmFsdWUpKSB7XG4gIFx0XHRcdEJpbmRpbmdfU2VsZWN0QmluZGluZy5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlLmNhbGwodGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHRmb3JjZVVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXG4gIFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSB0cnVlO1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdHJldHVybiBfdGhpcy5hdHRyaWJ1dGUubG9ja2VkID0gZmFsc2U7XG4gIFx0XHRcdH0pO1xuICBcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCh0aGlzLmtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dXBkYXRlTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmF0dHJpYnV0ZS52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICF0aGlzLmF0dHJpYnV0ZS52YWx1ZS5sZW5ndGgpIHtcbiAgXHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQodGhpcy5rZXlwYXRoLCB0aGlzLmluaXRpYWxWYWx1ZSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICB2YXIgQmluZGluZ19NdWx0aXBsZVNlbGVjdEJpbmRpbmcgPSBNdWx0aXBsZVNlbGVjdEJpbmRpbmc7XG5cbiAgdmFyIEZpbGVMaXN0QmluZGluZyA9IEJpbmRpbmdfQmluZGluZy5leHRlbmQoe1xuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5lbGVtZW50Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5lbGVtZW50Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmZpbGVzO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfRmlsZUxpc3RCaW5kaW5nID0gRmlsZUxpc3RCaW5kaW5nO1xuXG4gIHZhciBOdW1lcmljQmluZGluZyA9IEJpbmRpbmdfR2VuZXJpY0JpbmRpbmcuZXh0ZW5kKHtcbiAgXHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB1bmRlZmluZWQ7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgdmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMuZWxlbWVudC5ub2RlLnZhbHVlKTtcbiAgXHRcdHJldHVybiBpc05hTih2YWx1ZSkgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBpbml0X2NyZWF0ZVR3b3dheUJpbmRpbmcgPSBjcmVhdGVUd293YXlCaW5kaW5nO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVR3b3dheUJpbmRpbmcoZWxlbWVudCkge1xuICBcdHZhciBhdHRyaWJ1dGVzID0gZWxlbWVudC5hdHRyaWJ1dGVzLFxuICBcdCAgICB0eXBlLFxuICBcdCAgICBCaW5kaW5nLFxuICBcdCAgICBiaW5kTmFtZSxcbiAgXHQgICAgYmluZENoZWNrZWQsXG4gIFx0ICAgIGJpbmRpbmc7XG5cbiAgXHQvLyBpZiB0aGlzIGlzIGEgbGF0ZSBiaW5kaW5nLCBhbmQgdGhlcmUncyBhbHJlYWR5IG9uZSwgaXRcbiAgXHQvLyBuZWVkcyB0byBiZSB0b3JuIGRvd25cbiAgXHRpZiAoZWxlbWVudC5iaW5kaW5nKSB7XG4gIFx0XHRlbGVtZW50LmJpbmRpbmcudGVhcmRvd24oKTtcbiAgXHRcdGVsZW1lbnQuYmluZGluZyA9IG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gY29udGVudGVkaXRhYmxlXG4gIFx0aWYgKFxuICBcdC8vIGlmIHRoZSBjb250ZW50ZWRpdGFibGUgYXR0cmlidXRlIGlzIHRydWUgb3IgaXMgYmluZGFibGUgYW5kIG1heSB0aHVzIGJlY29tZSB0cnVlXG4gIFx0KGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpIHx8ICEhYXR0cmlidXRlcy5jb250ZW50ZWRpdGFibGUgJiYgaXNCaW5kYWJsZShhdHRyaWJ1dGVzLmNvbnRlbnRlZGl0YWJsZSkpICYmIGlzQmluZGFibGUoYXR0cmlidXRlcy52YWx1ZSkpIHtcbiAgXHRcdEJpbmRpbmcgPSBCaW5kaW5nX0NvbnRlbnRFZGl0YWJsZUJpbmRpbmc7XG4gIFx0fVxuXG4gIFx0Ly8gPGlucHV0PlxuICBcdGVsc2UgaWYgKGVsZW1lbnQubmFtZSA9PT0gXCJpbnB1dFwiKSB7XG4gIFx0XHR0eXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuXG4gIFx0XHRpZiAodHlwZSA9PT0gXCJyYWRpb1wiIHx8IHR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICBcdFx0XHRiaW5kTmFtZSA9IGlzQmluZGFibGUoYXR0cmlidXRlcy5uYW1lKTtcbiAgXHRcdFx0YmluZENoZWNrZWQgPSBpc0JpbmRhYmxlKGF0dHJpYnV0ZXMuY2hlY2tlZCk7XG5cbiAgXHRcdFx0Ly8gd2UgY2FuIGVpdGhlciBiaW5kIHRoZSBuYW1lIGF0dHJpYnV0ZSwgb3IgdGhlIGNoZWNrZWQgYXR0cmlidXRlIC0gbm90IGJvdGhcbiAgXHRcdFx0aWYgKGJpbmROYW1lICYmIGJpbmRDaGVja2VkKSB7XG4gIFx0XHRcdFx0d2FybklmRGVidWcoXCJBIHJhZGlvIGlucHV0IGNhbiBoYXZlIHR3by13YXkgYmluZGluZyBvbiBpdHMgbmFtZSBhdHRyaWJ1dGUsIG9yIGl0cyBjaGVja2VkIGF0dHJpYnV0ZSAtIG5vdCBib3RoXCIsIHsgcmFjdGl2ZTogZWxlbWVudC5yb290IH0pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGJpbmROYW1lKSB7XG4gIFx0XHRcdFx0QmluZGluZyA9IHR5cGUgPT09IFwicmFkaW9cIiA/IEJpbmRpbmdfUmFkaW9OYW1lQmluZGluZyA6IEJpbmRpbmdfQ2hlY2tib3hOYW1lQmluZGluZztcbiAgXHRcdFx0fSBlbHNlIGlmIChiaW5kQ2hlY2tlZCkge1xuICBcdFx0XHRcdEJpbmRpbmcgPSB0eXBlID09PSBcInJhZGlvXCIgPyBCaW5kaW5nX1JhZGlvQmluZGluZyA6IEJpbmRpbmdfQ2hlY2tib3hCaW5kaW5nO1xuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IFwiZmlsZVwiICYmIGlzQmluZGFibGUoYXR0cmlidXRlcy52YWx1ZSkpIHtcbiAgXHRcdFx0QmluZGluZyA9IEJpbmRpbmdfRmlsZUxpc3RCaW5kaW5nO1xuICBcdFx0fSBlbHNlIGlmIChpc0JpbmRhYmxlKGF0dHJpYnV0ZXMudmFsdWUpKSB7XG4gIFx0XHRcdEJpbmRpbmcgPSB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwicmFuZ2VcIiA/IE51bWVyaWNCaW5kaW5nIDogQmluZGluZ19HZW5lcmljQmluZGluZztcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyA8c2VsZWN0PlxuICBcdGVsc2UgaWYgKGVsZW1lbnQubmFtZSA9PT0gXCJzZWxlY3RcIiAmJiBpc0JpbmRhYmxlKGF0dHJpYnV0ZXMudmFsdWUpKSB7XG4gIFx0XHRCaW5kaW5nID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSA/IEJpbmRpbmdfTXVsdGlwbGVTZWxlY3RCaW5kaW5nIDogQmluZGluZ19TZWxlY3RCaW5kaW5nO1xuICBcdH1cblxuICBcdC8vIDx0ZXh0YXJlYT5cbiAgXHRlbHNlIGlmIChlbGVtZW50Lm5hbWUgPT09IFwidGV4dGFyZWFcIiAmJiBpc0JpbmRhYmxlKGF0dHJpYnV0ZXMudmFsdWUpKSB7XG4gIFx0XHRCaW5kaW5nID0gQmluZGluZ19HZW5lcmljQmluZGluZztcbiAgXHR9XG5cbiAgXHRpZiAoQmluZGluZyAmJiAoYmluZGluZyA9IG5ldyBCaW5kaW5nKGVsZW1lbnQpKSAmJiBiaW5kaW5nLmtleXBhdGgpIHtcbiAgXHRcdHJldHVybiBiaW5kaW5nO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQmluZGFibGUoYXR0cmlidXRlKSB7XG4gIFx0cmV0dXJuIGF0dHJpYnV0ZSAmJiBhdHRyaWJ1dGUuaXNCaW5kYWJsZTtcbiAgfVxuXG4gIC8vIGFuZCB0aGlzIGVsZW1lbnQgYWxzbyBoYXMgYSB2YWx1ZSBhdHRyaWJ1dGUgdG8gYmluZFxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX2J1YmJsZSA9IEV2ZW50SGFuZGxlciRidWJibGU7XG5cbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGJ1YmJsZSgpIHtcbiAgXHR2YXIgaGFzQWN0aW9uID0gdGhpcy5nZXRBY3Rpb24oKTtcblxuICBcdGlmIChoYXNBY3Rpb24gJiYgIXRoaXMuaGFzTGlzdGVuZXIpIHtcbiAgXHRcdHRoaXMubGlzdGVuKCk7XG4gIFx0fSBlbHNlIGlmICghaGFzQWN0aW9uICYmIHRoaXMuaGFzTGlzdGVuZXIpIHtcbiAgXHRcdHRoaXMudW5yZW5kZXIoKTtcbiAgXHR9XG4gIH1cblxuICAvLyBUaGlzIGZ1bmN0aW9uIG1heSBiZSBvdmVyd3JpdHRlbiwgaWYgdGhlIGV2ZW50IGRpcmVjdGl2ZVxuICAvLyBpbmNsdWRlcyBwYXJhbWV0ZXJzXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX2ZpcmUgPSBFdmVudEhhbmRsZXIkZmlyZTtcbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGZpcmUoZXZlbnQpIHtcbiAgXHRzaGFyZWRfZmlyZUV2ZW50KHRoaXMucm9vdCwgdGhpcy5nZXRBY3Rpb24oKSwgeyBldmVudDogZXZlbnQgfSk7XG4gIH1cblxuICB2YXIgZ2V0QWN0aW9uID0gRXZlbnRIYW5kbGVyJGdldEFjdGlvbjtcblxuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkZ2V0QWN0aW9uKCkge1xuICBcdHJldHVybiB0aGlzLmFjdGlvbi50b1N0cmluZygpLnRyaW0oKTtcbiAgfVxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX2luaXQgPSBFdmVudEhhbmRsZXIkaW5pdDtcblxuICB2YXIgZXZlbnRQYXR0ZXJuID0gL15ldmVudCg/OlxcLiguKykpPy87XG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRpbml0KGVsZW1lbnQsIG5hbWUsIHRlbXBsYXRlKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBhY3Rpb24sIHJlZnMsIHJhY3RpdmU7XG5cbiAgXHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICBcdHRoaXMucm9vdCA9IGVsZW1lbnQucm9vdDtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLm5hbWUgPSBuYW1lO1xuXG4gIFx0aWYgKG5hbWUuaW5kZXhPZihcIipcIikgIT09IC0xKSB7XG4gIFx0XHRmYXRhbChcIk9ubHkgY29tcG9uZW50IHByb3h5LWV2ZW50cyBtYXkgY29udGFpbiBcXFwiKlxcXCIgd2lsZGNhcmRzLCA8JXMgb24tJXM9XFxcIi4uLlxcXCIvPiBpcyBub3QgdmFsaWRcIiwgZWxlbWVudC5uYW1lLCBuYW1lKTtcbiAgXHRcdHRoaXMuaW52YWxpZCA9IHRydWU7XG4gIFx0fVxuXG4gIFx0aWYgKHRlbXBsYXRlLm0pIHtcbiAgXHRcdHJlZnMgPSB0ZW1wbGF0ZS5hLnI7XG5cbiAgXHRcdC8vIFRoaXMgaXMgYSBtZXRob2QgY2FsbFxuICBcdFx0dGhpcy5tZXRob2QgPSB0ZW1wbGF0ZS5tO1xuICBcdFx0dGhpcy5rZXlwYXRocyA9IFtdO1xuICBcdFx0dGhpcy5mbiA9IHNoYXJlZF9nZXRGdW5jdGlvbkZyb21TdHJpbmcodGVtcGxhdGUuYS5zLCByZWZzLmxlbmd0aCk7XG5cbiAgXHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBlbGVtZW50LnBhcmVudEZyYWdtZW50O1xuICBcdFx0cmFjdGl2ZSA9IHRoaXMucm9vdDtcblxuICBcdFx0Ly8gQ3JlYXRlIHJlc29sdmVycyBmb3IgZWFjaCByZWZlcmVuY2VcbiAgXHRcdHRoaXMucmVmUmVzb2x2ZXJzID0gW107XG4gIFx0XHRyZWZzLmZvckVhY2goZnVuY3Rpb24gKHJlZiwgaSkge1xuICBcdFx0XHR2YXIgbWF0Y2ggPSB1bmRlZmluZWQ7XG5cbiAgXHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gdGhlIGBldmVudGAgb2JqZWN0XG4gIFx0XHRcdGlmIChtYXRjaCA9IGV2ZW50UGF0dGVybi5leGVjKHJlZikpIHtcbiAgXHRcdFx0XHRfdGhpcy5rZXlwYXRoc1tpXSA9IHtcbiAgXHRcdFx0XHRcdGV2ZW50T2JqZWN0OiB0cnVlLFxuICBcdFx0XHRcdFx0cmVmaW5lbWVudHM6IG1hdGNoWzFdID8gbWF0Y2hbMV0uc3BsaXQoXCIuXCIpIDogW11cbiAgXHRcdFx0XHR9O1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdF90aGlzLnJlZlJlc29sdmVycy5wdXNoKFJlc29sdmVyc19jcmVhdGVSZWZlcmVuY2VSZXNvbHZlcihfdGhpcywgcmVmLCBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRcdFx0cmV0dXJuIF90aGlzLnJlc29sdmUoaSwga2V5cGF0aCk7XG4gIFx0XHRcdFx0fSkpO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcblxuICBcdFx0dGhpcy5maXJlID0gZmlyZU1ldGhvZENhbGw7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdC8vIEdldCBhY3Rpb24gKCdmb28nIGluICdvbi1jbGljaz0nZm9vJylcbiAgXHRcdGFjdGlvbiA9IHRlbXBsYXRlLm4gfHwgdGVtcGxhdGU7XG4gIFx0XHRpZiAodHlwZW9mIGFjdGlvbiAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRhY3Rpb24gPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdFx0dGVtcGxhdGU6IGFjdGlvbixcbiAgXHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG4gIFx0XHRcdFx0b3duZXI6IHRoaXNcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuYWN0aW9uID0gYWN0aW9uO1xuXG4gIFx0XHQvLyBHZXQgcGFyYW1ldGVyc1xuICBcdFx0aWYgKHRlbXBsYXRlLmQpIHtcbiAgXHRcdFx0dGhpcy5keW5hbWljUGFyYW1zID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5kLFxuICBcdFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcbiAgXHRcdFx0XHRvd25lcjogdGhpcy5lbGVtZW50XG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdHRoaXMuZmlyZSA9IGZpcmVFdmVudFdpdGhEeW5hbWljUGFyYW1zO1xuICBcdFx0fSBlbHNlIGlmICh0ZW1wbGF0ZS5hKSB7XG4gIFx0XHRcdHRoaXMucGFyYW1zID0gdGVtcGxhdGUuYTtcbiAgXHRcdFx0dGhpcy5maXJlID0gZmlyZUV2ZW50V2l0aFBhcmFtcztcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlTWV0aG9kQ2FsbChldmVudCkge1xuICBcdHZhciByYWN0aXZlLCB2YWx1ZXMsIGFyZ3M7XG5cbiAgXHRyYWN0aXZlID0gdGhpcy5yb290O1xuXG4gIFx0aWYgKHR5cGVvZiByYWN0aXZlW3RoaXMubWV0aG9kXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gY2FsbCBhIG5vbi1leGlzdGVudCBtZXRob2QgKFxcXCJcIiArIHRoaXMubWV0aG9kICsgXCJcXFwiKVwiKTtcbiAgXHR9XG5cbiAgXHR2YWx1ZXMgPSB0aGlzLmtleXBhdGhzLm1hcChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0dmFyIHZhbHVlLCBsZW4sIGk7XG5cbiAgXHRcdGlmIChrZXlwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0Ly8gbm90IHlldCByZXNvbHZlZFxuICBcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBUT0RPIHRoZSByZWZpbmVtZW50cyBzdHVmZiB3b3VsZCBiZSBiZXR0ZXIgaGFuZGxlZCBhdCBwYXJzZSB0aW1lXG4gIFx0XHRpZiAoa2V5cGF0aC5ldmVudE9iamVjdCkge1xuICBcdFx0XHR2YWx1ZSA9IGV2ZW50O1xuXG4gIFx0XHRcdGlmIChsZW4gPSBrZXlwYXRoLnJlZmluZW1lbnRzLmxlbmd0aCkge1xuICBcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtrZXlwYXRoLnJlZmluZW1lbnRzW2ldXTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHZhbHVlID0gcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0fSk7XG5cbiAgXHRzaGFyZWRfZXZlbnRTdGFjay5lbnF1ZXVlKHJhY3RpdmUsIGV2ZW50KTtcblxuICBcdGFyZ3MgPSB0aGlzLmZuLmFwcGx5KG51bGwsIHZhbHVlcyk7XG4gIFx0cmFjdGl2ZVt0aGlzLm1ldGhvZF0uYXBwbHkocmFjdGl2ZSwgYXJncyk7XG5cbiAgXHRzaGFyZWRfZXZlbnRTdGFjay5kZXF1ZXVlKHJhY3RpdmUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZUV2ZW50V2l0aFBhcmFtcyhldmVudCkge1xuICBcdHNoYXJlZF9maXJlRXZlbnQodGhpcy5yb290LCB0aGlzLmdldEFjdGlvbigpLCB7IGV2ZW50OiBldmVudCwgYXJnczogdGhpcy5wYXJhbXMgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlRXZlbnRXaXRoRHluYW1pY1BhcmFtcyhldmVudCkge1xuICBcdHZhciBhcmdzID0gdGhpcy5keW5hbWljUGFyYW1zLmdldEFyZ3NMaXN0KCk7XG5cbiAgXHQvLyBuZWVkIHRvIHN0cmlwIFtdIGZyb20gZW5kcyBpZiBhIHN0cmluZyFcbiAgXHRpZiAodHlwZW9mIGFyZ3MgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGFyZ3MgPSBhcmdzLnN1YnN0cigxLCBhcmdzLmxlbmd0aCAtIDIpO1xuICBcdH1cblxuICBcdHNoYXJlZF9maXJlRXZlbnQodGhpcy5yb290LCB0aGlzLmdldEFjdGlvbigpLCB7IGV2ZW50OiBldmVudCwgYXJnczogYXJncyB9KTtcbiAgfVxuXG4gIHZhciBzaGFyZWRfZ2VuZXJpY0hhbmRsZXIgPSBnZW5lcmljSGFuZGxlcjtcbiAgZnVuY3Rpb24gZ2VuZXJpY0hhbmRsZXIoZXZlbnQpIHtcbiAgXHR2YXIgc3RvcmFnZSxcbiAgXHQgICAgaGFuZGxlcixcbiAgXHQgICAgaW5kaWNlcyxcbiAgXHQgICAgaW5kZXggPSB7fTtcblxuICBcdHN0b3JhZ2UgPSB0aGlzLl9yYWN0aXZlO1xuICBcdGhhbmRsZXIgPSBzdG9yYWdlLmV2ZW50c1tldmVudC50eXBlXTtcblxuICBcdGlmIChpbmRpY2VzID0gUmVzb2x2ZXJzX2ZpbmRJbmRleFJlZnMoaGFuZGxlci5lbGVtZW50LnBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0aW5kZXggPSBSZXNvbHZlcnNfZmluZEluZGV4UmVmcy5yZXNvbHZlKGluZGljZXMpO1xuICBcdH1cblxuICBcdGhhbmRsZXIuZmlyZSh7XG4gIFx0XHRub2RlOiB0aGlzLFxuICBcdFx0b3JpZ2luYWw6IGV2ZW50LFxuICBcdFx0aW5kZXg6IGluZGV4LFxuICBcdFx0a2V5cGF0aDogc3RvcmFnZS5rZXlwYXRoLnN0cixcbiAgXHRcdGNvbnRleHQ6IHN0b3JhZ2Uucm9vdC52aWV3bW9kZWwuZ2V0KHN0b3JhZ2Uua2V5cGF0aClcbiAgXHR9KTtcbiAgfVxuXG4gIHZhciBsaXN0ZW4gPSBFdmVudEhhbmRsZXIkbGlzdGVuO1xuXG4gIHZhciBjdXN0b21IYW5kbGVycyA9IHt9LFxuICAgICAgdG91Y2hFdmVudHMgPSB7XG4gIFx0dG91Y2hzdGFydDogdHJ1ZSxcbiAgXHR0b3VjaG1vdmU6IHRydWUsXG4gIFx0dG91Y2hlbmQ6IHRydWUsXG4gIFx0dG91Y2hjYW5jZWw6IHRydWUsXG4gIFx0Ly9ub3QgdzNjLCBidXQgc3VwcG9ydGVkIGluIHNvbWUgYnJvd3NlcnNcbiAgXHR0b3VjaGxlYXZlOiB0cnVlXG4gIH07XG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRsaXN0ZW4oKSB7XG4gIFx0dmFyIGRlZmluaXRpb24sXG4gIFx0ICAgIG5hbWUgPSB0aGlzLm5hbWU7XG5cbiAgXHRpZiAodGhpcy5pbnZhbGlkKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKGRlZmluaXRpb24gPSBmaW5kSW5WaWV3SGllcmFyY2h5KFwiZXZlbnRzXCIsIHRoaXMucm9vdCwgbmFtZSkpIHtcbiAgXHRcdHRoaXMuY3VzdG9tID0gZGVmaW5pdGlvbih0aGlzLm5vZGUsIGdldEN1c3RvbUhhbmRsZXIobmFtZSkpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBMb29rcyBsaWtlIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIHN0YW5kYXJkIERPTSBldmVudC4uLiBidXQgbGV0J3MgY2hlY2tcbiAgXHRcdGlmICghKFwib25cIiArIG5hbWUgaW4gdGhpcy5ub2RlKSAmJiAhKHdpbmRvdyAmJiBcIm9uXCIgKyBuYW1lIGluIHdpbmRvdykgJiYgIWlzSnNkb20pIHtcblxuICBcdFx0XHQvLyBva2F5IHRvIHVzZSB0b3VjaCBldmVudHMgaWYgdGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGVtXG4gIFx0XHRcdGlmICghdG91Y2hFdmVudHNbbmFtZV0pIHtcbiAgXHRcdFx0XHR3YXJuT25jZUlmRGVidWcobWlzc2luZ1BsdWdpbihuYW1lLCBcImV2ZW50XCIpLCB7IG5vZGU6IHRoaXMubm9kZSB9KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgc2hhcmVkX2dlbmVyaWNIYW5kbGVyLCBmYWxzZSk7XG4gIFx0fVxuXG4gIFx0dGhpcy5oYXNMaXN0ZW5lciA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDdXN0b21IYW5kbGVyKG5hbWUpIHtcbiAgXHRpZiAoIWN1c3RvbUhhbmRsZXJzW25hbWVdKSB7XG4gIFx0XHRjdXN0b21IYW5kbGVyc1tuYW1lXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICBcdFx0XHR2YXIgc3RvcmFnZSA9IGV2ZW50Lm5vZGUuX3JhY3RpdmU7XG5cbiAgXHRcdFx0ZXZlbnQuaW5kZXggPSBzdG9yYWdlLmluZGV4O1xuICBcdFx0XHRldmVudC5rZXlwYXRoID0gc3RvcmFnZS5rZXlwYXRoLnN0cjtcbiAgXHRcdFx0ZXZlbnQuY29udGV4dCA9IHN0b3JhZ2Uucm9vdC52aWV3bW9kZWwuZ2V0KHN0b3JhZ2Uua2V5cGF0aCk7XG5cbiAgXHRcdFx0c3RvcmFnZS5ldmVudHNbbmFtZV0uZmlyZShldmVudCk7XG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJldHVybiBjdXN0b21IYW5kbGVyc1tuYW1lXTtcbiAgfVxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3JlYmluZCA9IEV2ZW50SGFuZGxlciRyZWJpbmQ7XG5cbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0dmFyIGZyYWdtZW50O1xuICBcdGlmICh0aGlzLm1ldGhvZCkge1xuICBcdFx0ZnJhZ21lbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50RnJhZ21lbnQ7XG4gIFx0XHR0aGlzLnJlZlJlc29sdmVycy5mb3JFYWNoKHJlYmluZCk7XG5cbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZW9mIHRoaXMuYWN0aW9uICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRyZWJpbmQodGhpcy5hY3Rpb24pO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmR5bmFtaWNQYXJhbXMpIHtcbiAgXHRcdHJlYmluZCh0aGlzLmR5bmFtaWNQYXJhbXMpO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIHJlYmluZCh0aGluZykge1xuICBcdFx0dGhpbmcgJiYgdGhpbmcucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3JlbmRlciA9IEV2ZW50SGFuZGxlciRyZW5kZXI7XG5cbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHJlbmRlcigpIHtcbiAgXHR0aGlzLm5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcbiAgXHQvLyBzdG9yZSB0aGlzIG9uIHRoZSBub2RlIGl0c2VsZiwgc28gaXQgY2FuIGJlIHJldHJpZXZlZCBieSBhXG4gIFx0Ly8gdW5pdmVyc2FsIGhhbmRsZXJcbiAgXHR0aGlzLm5vZGUuX3JhY3RpdmUuZXZlbnRzW3RoaXMubmFtZV0gPSB0aGlzO1xuXG4gIFx0aWYgKHRoaXMubWV0aG9kIHx8IHRoaXMuZ2V0QWN0aW9uKCkpIHtcbiAgXHRcdHRoaXMubGlzdGVuKCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9yZXNvbHZlID0gRXZlbnRIYW5kbGVyJHJlc29sdmU7XG5cbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHJlc29sdmUoaW5kZXgsIGtleXBhdGgpIHtcbiAgXHR0aGlzLmtleXBhdGhzW2luZGV4XSA9IGtleXBhdGg7XG4gIH1cblxuICB2YXIgRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV91bmJpbmQgPSBFdmVudEhhbmRsZXIkdW5iaW5kO1xuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkdW5iaW5kKCkge1xuICBcdGlmICh0aGlzLm1ldGhvZCkge1xuICBcdFx0dGhpcy5yZWZSZXNvbHZlcnMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIFRlYXIgZG93biBkeW5hbWljIG5hbWVcbiAgXHRpZiAodHlwZW9mIHRoaXMuYWN0aW9uICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHR0aGlzLmFjdGlvbi51bmJpbmQoKTtcbiAgXHR9XG5cbiAgXHQvLyBUZWFyIGRvd24gZHluYW1pYyBwYXJhbWV0ZXJzXG4gIFx0aWYgKHRoaXMuZHluYW1pY1BhcmFtcykge1xuICBcdFx0dGhpcy5keW5hbWljUGFyYW1zLnVuYmluZCgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3VucmVuZGVyID0gRXZlbnRIYW5kbGVyJHVucmVuZGVyO1xuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkdW5yZW5kZXIoKSB7XG5cbiAgXHRpZiAodGhpcy5jdXN0b20pIHtcbiAgXHRcdHRoaXMuY3VzdG9tLnRlYXJkb3duKCk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMubmFtZSwgc2hhcmVkX2dlbmVyaWNIYW5kbGVyLCBmYWxzZSk7XG4gIFx0fVxuXG4gIFx0dGhpcy5oYXNMaXN0ZW5lciA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIEV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lLCB0ZW1wbGF0ZSkge1xuICBcdHRoaXMuaW5pdChlbGVtZW50LCBuYW1lLCB0ZW1wbGF0ZSk7XG4gIH07XG5cbiAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfYnViYmxlLFxuICBcdGZpcmU6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfZmlyZSxcbiAgXHRnZXRBY3Rpb246IGdldEFjdGlvbixcbiAgXHRpbml0OiBFdmVudEhhbmRsZXJfcHJvdG90eXBlX2luaXQsXG4gIFx0bGlzdGVuOiBsaXN0ZW4sXG4gIFx0cmViaW5kOiBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3JlYmluZCxcbiAgXHRyZW5kZXI6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfcmVuZGVyLFxuICBcdHJlc29sdmU6IHByb3RvdHlwZV9yZXNvbHZlLFxuICBcdHVuYmluZDogRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV91bmJpbmQsXG4gIFx0dW5yZW5kZXI6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfdW5yZW5kZXJcbiAgfTtcblxuICB2YXIgX0V2ZW50SGFuZGxlciA9IEV2ZW50SGFuZGxlcjtcblxuICB2YXIgY3JlYXRlRXZlbnRIYW5kbGVycyA9IGZ1bmN0aW9uIChlbGVtZW50LCB0ZW1wbGF0ZSkge1xuICBcdHZhciBpLFxuICBcdCAgICBuYW1lLFxuICBcdCAgICBuYW1lcyxcbiAgXHQgICAgaGFuZGxlcixcbiAgXHQgICAgcmVzdWx0ID0gW107XG5cbiAgXHRmb3IgKG5hbWUgaW4gdGVtcGxhdGUpIHtcbiAgXHRcdGlmICh0ZW1wbGF0ZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICBcdFx0XHRuYW1lcyA9IG5hbWUuc3BsaXQoXCItXCIpO1xuICBcdFx0XHRpID0gbmFtZXMubGVuZ3RoO1xuXG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRoYW5kbGVyID0gbmV3IF9FdmVudEhhbmRsZXIoZWxlbWVudCwgbmFtZXNbaV0sIHRlbXBsYXRlW25hbWVdKTtcbiAgXHRcdFx0XHRyZXN1bHQucHVzaChoYW5kbGVyKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIERlY29yYXRvciA9IGZ1bmN0aW9uIChlbGVtZW50LCB0ZW1wbGF0ZSkge1xuICBcdHZhciBzZWxmID0gdGhpcyxcbiAgXHQgICAgcmFjdGl2ZSxcbiAgXHQgICAgbmFtZSxcbiAgXHQgICAgZnJhZ21lbnQ7XG5cbiAgXHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICBcdHRoaXMucm9vdCA9IHJhY3RpdmUgPSBlbGVtZW50LnJvb3Q7XG5cbiAgXHRuYW1lID0gdGVtcGxhdGUubiB8fCB0ZW1wbGF0ZTtcblxuICBcdGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0ZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdHRlbXBsYXRlOiBuYW1lLFxuICBcdFx0XHRyb290OiByYWN0aXZlLFxuICBcdFx0XHRvd25lcjogZWxlbWVudFxuICBcdFx0fSk7XG5cbiAgXHRcdG5hbWUgPSBmcmFnbWVudC50b1N0cmluZygpO1xuICBcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cbiAgXHRcdGlmIChuYW1lID09PSBcIlwiKSB7XG4gIFx0XHRcdC8vIGVtcHR5IHN0cmluZyBva2F5LCBqdXN0IG5vIGRlY29yYXRvclxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHRlbXBsYXRlLmEpIHtcbiAgXHRcdHRoaXMucGFyYW1zID0gdGVtcGxhdGUuYTtcbiAgXHR9IGVsc2UgaWYgKHRlbXBsYXRlLmQpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5kLFxuICBcdFx0XHRyb290OiByYWN0aXZlLFxuICBcdFx0XHRvd25lcjogZWxlbWVudFxuICBcdFx0fSk7XG5cbiAgXHRcdHRoaXMucGFyYW1zID0gdGhpcy5mcmFnbWVudC5nZXRBcmdzTGlzdCgpO1xuXG4gIFx0XHR0aGlzLmZyYWdtZW50LmJ1YmJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dGhpcy5kaXJ0eUFyZ3MgPSB0aGlzLmRpcnR5VmFsdWUgPSB0cnVlO1xuICBcdFx0XHRzZWxmLnBhcmFtcyA9IHRoaXMuZ2V0QXJnc0xpc3QoKTtcblxuICBcdFx0XHRpZiAoc2VsZi5yZWFkeSkge1xuICBcdFx0XHRcdHNlbGYudXBkYXRlKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0dGhpcy5mbiA9IGZpbmRJblZpZXdIaWVyYXJjaHkoXCJkZWNvcmF0b3JzXCIsIHJhY3RpdmUsIG5hbWUpO1xuXG4gIFx0aWYgKCF0aGlzLmZuKSB7XG4gIFx0XHRmYXRhbChtaXNzaW5nUGx1Z2luKG5hbWUsIFwiZGVjb3JhdG9yXCIpKTtcbiAgXHR9XG4gIH07XG5cbiAgRGVjb3JhdG9yLnByb3RvdHlwZSA9IHtcbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSwgcmVzdWx0LCBhcmdzO1xuXG4gIFx0XHRub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdGlmICh0aGlzLnBhcmFtcykge1xuICBcdFx0XHRhcmdzID0gW25vZGVdLmNvbmNhdCh0aGlzLnBhcmFtcyk7XG4gIFx0XHRcdHJlc3VsdCA9IHRoaXMuZm4uYXBwbHkodGhpcy5yb290LCBhcmdzKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJlc3VsdCA9IHRoaXMuZm4uY2FsbCh0aGlzLnJvb3QsIG5vZGUpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LnRlYXJkb3duKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkRlY29yYXRvciBkZWZpbml0aW9uIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aXRoIGEgdGVhcmRvd24gbWV0aG9kXCIpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBUT0RPIGRvZXMgdGhpcyBtYWtlIHNlbnNlP1xuICBcdFx0dGhpcy5hY3R1YWwgPSByZXN1bHQ7XG4gIFx0XHR0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgXHR9LFxuXG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5hY3R1YWwudXBkYXRlKSB7XG4gIFx0XHRcdHRoaXMuYWN0dWFsLnVwZGF0ZS5hcHBseSh0aGlzLnJvb3QsIHRoaXMucGFyYW1zKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuYWN0dWFsLnRlYXJkb3duKHRydWUpO1xuICBcdFx0XHR0aGlzLmluaXQoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHRlYXJkb3duOiBmdW5jdGlvbiAodXBkYXRpbmcpIHtcbiAgXHRcdHRoaXMudG9ybmRvd24gPSB0cnVlO1xuICBcdFx0aWYgKHRoaXMucmVhZHkpIHtcbiAgXHRcdFx0dGhpcy5hY3R1YWwudGVhcmRvd24oKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCF1cGRhdGluZyAmJiB0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBfRGVjb3JhdG9yID0gRGVjb3JhdG9yO1xuXG4gIGZ1bmN0aW9uIHNlbGVjdF9fYnViYmxlKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRpZiAoIXRoaXMuZGlydHkpIHtcbiAgXHRcdHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRzeW5jKF90aGlzKTtcbiAgXHRcdFx0X3RoaXMuZGlydHkgPSBmYWxzZTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7IC8vIGRlZmF1bHQgYmVoYXZpb3VyXG4gIH1cblxuICBmdW5jdGlvbiBzeW5jKHNlbGVjdEVsZW1lbnQpIHtcbiAgXHR2YXIgc2VsZWN0Tm9kZSwgc2VsZWN0VmFsdWUsIGlzTXVsdGlwbGUsIG9wdGlvbnMsIG9wdGlvbldhc1NlbGVjdGVkO1xuXG4gIFx0c2VsZWN0Tm9kZSA9IHNlbGVjdEVsZW1lbnQubm9kZTtcblxuICBcdGlmICghc2VsZWN0Tm9kZSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdG9wdGlvbnMgPSB0b0FycmF5KHNlbGVjdE5vZGUub3B0aW9ucyk7XG5cbiAgXHRzZWxlY3RWYWx1ZSA9IHNlbGVjdEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0aXNNdWx0aXBsZSA9IHNlbGVjdEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIik7XG5cbiAgXHQvLyBJZiB0aGUgPHNlbGVjdD4gaGFzIGEgc3BlY2lmaWVkIHZhbHVlLCB0aGF0IHNob3VsZCBvdmVycmlkZVxuICBcdC8vIHRoZXNlIG9wdGlvbnNcbiAgXHRpZiAoc2VsZWN0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0b3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gIFx0XHRcdHZhciBvcHRpb25WYWx1ZSwgc2hvdWxkU2VsZWN0O1xuXG4gIFx0XHRcdG9wdGlvblZhbHVlID0gby5fcmFjdGl2ZSA/IG8uX3JhY3RpdmUudmFsdWUgOiBvLnZhbHVlO1xuICBcdFx0XHRzaG91bGRTZWxlY3QgPSBpc011bHRpcGxlID8gdmFsdWVDb250YWlucyhzZWxlY3RWYWx1ZSwgb3B0aW9uVmFsdWUpIDogc2VsZWN0VmFsdWUgPT0gb3B0aW9uVmFsdWU7XG5cbiAgXHRcdFx0aWYgKHNob3VsZFNlbGVjdCkge1xuICBcdFx0XHRcdG9wdGlvbldhc1NlbGVjdGVkID0gdHJ1ZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdG8uc2VsZWN0ZWQgPSBzaG91bGRTZWxlY3Q7XG4gIFx0XHR9KTtcblxuICBcdFx0aWYgKCFvcHRpb25XYXNTZWxlY3RlZCkge1xuICBcdFx0XHRpZiAob3B0aW9uc1swXSkge1xuICBcdFx0XHRcdG9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKHNlbGVjdEVsZW1lbnQuYmluZGluZykge1xuICBcdFx0XHRcdHNlbGVjdEVsZW1lbnQuYmluZGluZy5mb3JjZVVwZGF0ZSgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gT3RoZXJ3aXNlIHRoZSB2YWx1ZSBzaG91bGQgYmUgaW5pdGlhbGlzZWQgYWNjb3JkaW5nIHRvIHdoaWNoXG4gIFx0Ly8gPG9wdGlvbj4gZWxlbWVudCBpcyBzZWxlY3RlZCwgaWYgdHdvd2F5IGJpbmRpbmcgaXMgaW4gZWZmZWN0XG4gIFx0ZWxzZSBpZiAoc2VsZWN0RWxlbWVudC5iaW5kaW5nKSB7XG4gIFx0XHRzZWxlY3RFbGVtZW50LmJpbmRpbmcuZm9yY2VVcGRhdGUoKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiB2YWx1ZUNvbnRhaW5zKHNlbGVjdFZhbHVlLCBvcHRpb25WYWx1ZSkge1xuICBcdHZhciBpID0gc2VsZWN0VmFsdWUubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGlmIChzZWxlY3RWYWx1ZVtpXSA9PSBvcHRpb25WYWx1ZSkge1xuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBzcGVjaWFsX29wdGlvbl9faW5pdChvcHRpb24sIHRlbXBsYXRlKSB7XG4gIFx0b3B0aW9uLnNlbGVjdCA9IGZpbmRQYXJlbnRTZWxlY3Qob3B0aW9uLnBhcmVudCk7XG5cbiAgXHQvLyB3ZSBtaWdodCBiZSBpbnNpZGUgYSA8ZGF0YWxpc3Q+IGVsZW1lbnRcbiAgXHRpZiAoIW9wdGlvbi5zZWxlY3QpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRvcHRpb24uc2VsZWN0Lm9wdGlvbnMucHVzaChvcHRpb24pO1xuXG4gIFx0Ly8gSWYgdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyBtaXNzaW5nLCB1c2UgdGhlIGVsZW1lbnQncyBjb250ZW50XG4gIFx0aWYgKCF0ZW1wbGF0ZS5hKSB7XG4gIFx0XHR0ZW1wbGF0ZS5hID0ge307XG4gIFx0fVxuXG4gIFx0Ly8gLi4uYXMgbG9uZyBhcyBpdCBpc24ndCBkaXNhYmxlZFxuICBcdGlmICh0ZW1wbGF0ZS5hLnZhbHVlID09PSB1bmRlZmluZWQgJiYgIXRlbXBsYXRlLmEuaGFzT3duUHJvcGVydHkoXCJkaXNhYmxlZFwiKSkge1xuICBcdFx0dGVtcGxhdGUuYS52YWx1ZSA9IHRlbXBsYXRlLmY7XG4gIFx0fVxuXG4gIFx0Ly8gSWYgdGhlcmUgaXMgYSBgc2VsZWN0ZWRgIGF0dHJpYnV0ZSwgYnV0IHRoZSA8c2VsZWN0PlxuICBcdC8vIGFscmVhZHkgaGFzIGEgdmFsdWUsIGRlbGV0ZSBpdFxuICBcdGlmIChcInNlbGVjdGVkXCIgaW4gdGVtcGxhdGUuYSAmJiBvcHRpb24uc2VsZWN0LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdGRlbGV0ZSB0ZW1wbGF0ZS5hLnNlbGVjdGVkO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNwZWNpYWxfb3B0aW9uX191bmJpbmQob3B0aW9uKSB7XG4gIFx0aWYgKG9wdGlvbi5zZWxlY3QpIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheShvcHRpb24uc2VsZWN0Lm9wdGlvbnMsIG9wdGlvbik7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZFBhcmVudFNlbGVjdChlbGVtZW50KSB7XG4gIFx0aWYgKCFlbGVtZW50KSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0ZG8ge1xuICBcdFx0aWYgKGVsZW1lbnQubmFtZSA9PT0gXCJzZWxlY3RcIikge1xuICBcdFx0XHRyZXR1cm4gZWxlbWVudDtcbiAgXHRcdH1cbiAgXHR9IHdoaWxlIChlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQpO1xuICB9XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2luaXQgPSBFbGVtZW50JGluaXQ7XG4gIGZ1bmN0aW9uIEVsZW1lbnQkaW5pdChvcHRpb25zKSB7XG4gIFx0dmFyIHBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZSwgcmFjdGl2ZSwgYmluZGluZywgYmluZGluZ3MsIHR3b3dheSwgYmluZGluZ0F0dHJzO1xuXG4gIFx0dGhpcy50eXBlID0gRUxFTUVOVDtcblxuICBcdC8vIHN0dWZmIHdlJ2xsIG5lZWQgbGF0ZXJcbiAgXHRwYXJlbnRGcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuICBcdHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cbiAgXHR0aGlzLnBhcmVudCA9IG9wdGlvbnMucEVsZW1lbnQgfHwgcGFyZW50RnJhZ21lbnQucEVsZW1lbnQ7XG5cbiAgXHR0aGlzLnJvb3QgPSByYWN0aXZlID0gcGFyZW50RnJhZ21lbnQucm9vdDtcbiAgXHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcbiAgXHR0aGlzLmtleSA9IG9wdGlvbnMua2V5O1xuXG4gIFx0dGhpcy5uYW1lID0gZW5mb3JjZUNhc2UodGVtcGxhdGUuZSk7XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSA8b3B0aW9uPiBlbGVtZW50c1xuICBcdGlmICh0aGlzLm5hbWUgPT09IFwib3B0aW9uXCIpIHtcbiAgXHRcdHNwZWNpYWxfb3B0aW9uX19pbml0KHRoaXMsIHRlbXBsYXRlKTtcbiAgXHR9XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSA8c2VsZWN0PiBlbGVtZW50c1xuICBcdGlmICh0aGlzLm5hbWUgPT09IFwic2VsZWN0XCIpIHtcbiAgXHRcdHRoaXMub3B0aW9ucyA9IFtdO1xuICBcdFx0dGhpcy5idWJibGUgPSBzZWxlY3RfX2J1YmJsZTsgLy8gVE9ETyB0aGlzIGlzIGEga2x1ZGdlXG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gPGZvcm0+IGVsZW1lbnRzXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJmb3JtXCIpIHtcbiAgXHRcdHRoaXMuZm9ybUJpbmRpbmdzID0gW107XG4gIFx0fVxuXG4gIFx0Ly8gaGFuZGxlIGJpbmRpbmcgYXR0cmlidXRlcyBmaXJzdCAodHdvd2F5LCBsYXp5KVxuICBcdGJpbmRpbmdBdHRycyA9IHByb2Nlc3NCaW5kaW5nQXR0cmlidXRlcyh0aGlzLCB0ZW1wbGF0ZSk7XG5cbiAgXHQvLyBjcmVhdGUgYXR0cmlidXRlc1xuICBcdHRoaXMuYXR0cmlidXRlcyA9IGNyZWF0ZUF0dHJpYnV0ZXModGhpcywgdGVtcGxhdGUuYSk7XG4gIFx0dGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMgPSBjcmVhdGVDb25kaXRpb25hbEF0dHJpYnV0ZXModGhpcywgdGVtcGxhdGUubSk7XG5cbiAgXHQvLyBhcHBlbmQgY2hpbGRyZW4sIGlmIHRoZXJlIGFyZSBhbnlcbiAgXHRpZiAodGVtcGxhdGUuZikge1xuICBcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmYsXG4gIFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG4gIFx0XHRcdG93bmVyOiB0aGlzLFxuICBcdFx0XHRwRWxlbWVudDogdGhpcyxcbiAgXHRcdFx0Y3NzSWRzOiBudWxsXG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHQvLyB0aGUgZWxlbWVudCBzZXR0aW5nIHNob3VsZCBvdmVycmlkZSB0aGUgcmFjdGl2ZSBzZXR0aW5nXG4gIFx0dHdvd2F5ID0gcmFjdGl2ZS50d293YXk7XG4gIFx0aWYgKGJpbmRpbmdBdHRycy50d293YXkgPT09IGZhbHNlKSB0d293YXkgPSBmYWxzZTtlbHNlIGlmIChiaW5kaW5nQXR0cnMudHdvd2F5ID09PSB0cnVlKSB0d293YXkgPSB0cnVlO1xuXG4gIFx0dGhpcy50d293YXkgPSB0d293YXk7XG4gIFx0dGhpcy5sYXp5ID0gYmluZGluZ0F0dHJzLmxhenk7XG5cbiAgXHQvLyBjcmVhdGUgdHdvd2F5IGJpbmRpbmdcbiAgXHRpZiAodHdvd2F5ICYmIChiaW5kaW5nID0gaW5pdF9jcmVhdGVUd293YXlCaW5kaW5nKHRoaXMsIHRlbXBsYXRlLmEpKSkge1xuICBcdFx0dGhpcy5iaW5kaW5nID0gYmluZGluZztcblxuICBcdFx0Ly8gcmVnaXN0ZXIgdGhpcyB3aXRoIHRoZSByb290LCBzbyB0aGF0IHdlIGNhbiBkbyByYWN0aXZlLnVwZGF0ZU1vZGVsKClcbiAgXHRcdGJpbmRpbmdzID0gdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1tiaW5kaW5nLmtleXBhdGguc3RyXSB8fCAodGhpcy5yb290Ll90d293YXlCaW5kaW5nc1tiaW5kaW5nLmtleXBhdGguc3RyXSA9IFtdKTtcbiAgXHRcdGJpbmRpbmdzLnB1c2goYmluZGluZyk7XG4gIFx0fVxuXG4gIFx0Ly8gY3JlYXRlIGV2ZW50IHByb3hpZXNcbiAgXHRpZiAodGVtcGxhdGUudikge1xuICBcdFx0dGhpcy5ldmVudEhhbmRsZXJzID0gY3JlYXRlRXZlbnRIYW5kbGVycyh0aGlzLCB0ZW1wbGF0ZS52KTtcbiAgXHR9XG5cbiAgXHQvLyBjcmVhdGUgZGVjb3JhdG9yXG4gIFx0aWYgKHRlbXBsYXRlLm8pIHtcbiAgXHRcdHRoaXMuZGVjb3JhdG9yID0gbmV3IF9EZWNvcmF0b3IodGhpcywgdGVtcGxhdGUubyk7XG4gIFx0fVxuXG4gIFx0Ly8gY3JlYXRlIHRyYW5zaXRpb25zXG4gIFx0dGhpcy5pbnRybyA9IHRlbXBsYXRlLnQwIHx8IHRlbXBsYXRlLnQxO1xuICBcdHRoaXMub3V0cm8gPSB0ZW1wbGF0ZS50MCB8fCB0ZW1wbGF0ZS50MjtcbiAgfVxuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9yZWJpbmQgPSBFbGVtZW50JHJlYmluZDtcbiAgZnVuY3Rpb24gRWxlbWVudCRyZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdHZhciBpLCBzdG9yYWdlLCBsaXZlUXVlcmllcywgcmFjdGl2ZTtcblxuICBcdGlmICh0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgXHRcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKHJlYmluZCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzKSB7XG4gIFx0XHR0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcy5mb3JFYWNoKHJlYmluZCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZXZlbnRIYW5kbGVycykge1xuICBcdFx0dGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2gocmViaW5kKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5kZWNvcmF0b3IpIHtcbiAgXHRcdHJlYmluZCh0aGlzLmRlY29yYXRvcik7XG4gIFx0fVxuXG4gIFx0Ly8gcmViaW5kIGNoaWxkcmVuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHJlYmluZCh0aGlzLmZyYWdtZW50KTtcbiAgXHR9XG5cbiAgXHQvLyBVcGRhdGUgbGl2ZSBxdWVyaWVzLCBpZiBuZWNlc3NhcnlcbiAgXHRpZiAobGl2ZVF1ZXJpZXMgPSB0aGlzLmxpdmVRdWVyaWVzKSB7XG4gIFx0XHRyYWN0aXZlID0gdGhpcy5yb290O1xuXG4gIFx0XHRpID0gbGl2ZVF1ZXJpZXMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRsaXZlUXVlcmllc1tpXS5fbWFrZURpcnR5KCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMubm9kZSAmJiAoc3RvcmFnZSA9IHRoaXMubm9kZS5fcmFjdGl2ZSkpIHtcblxuICBcdFx0Ly8gYWRqdXN0IGtleXBhdGggaWYgbmVlZGVkXG4gIFx0XHRhc3NpZ25OZXdLZXlwYXRoKHN0b3JhZ2UsIFwia2V5cGF0aFwiLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiByZWJpbmQodGhpbmcpIHtcbiAgXHRcdHRoaW5nLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBzcGVjaWFsX2ltZ19fcmVuZGVyKGltZykge1xuICBcdHZhciBsb2FkSGFuZGxlcjtcblxuICBcdC8vIGlmIHRoaXMgaXMgYW4gPGltZz4sIGFuZCB3ZSdyZSBpbiBhIGNyYXAgYnJvd3Nlciwgd2UgbWF5IG5lZWQgdG8gcHJldmVudCBpdFxuICBcdC8vIGZyb20gb3ZlcnJpZGluZyB3aWR0aCBhbmQgaGVpZ2h0IHdoZW4gaXQgbG9hZHMgdGhlIHNyY1xuICBcdGlmIChpbWcuYXR0cmlidXRlcy53aWR0aCB8fCBpbWcuYXR0cmlidXRlcy5oZWlnaHQpIHtcbiAgXHRcdGltZy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGxvYWRIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICBcdFx0XHR2YXIgd2lkdGggPSBpbWcuZ2V0QXR0cmlidXRlKFwid2lkdGhcIiksXG4gIFx0XHRcdCAgICBoZWlnaHQgPSBpbWcuZ2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIpO1xuXG4gIFx0XHRcdGlmICh3aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0aW1nLm5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgd2lkdGgpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0aW1nLm5vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpbWcubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCBsb2FkSGFuZGxlciwgZmFsc2UpO1xuICBcdFx0fSwgZmFsc2UpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1fX3JlbmRlcihlbGVtZW50KSB7XG4gIFx0ZWxlbWVudC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldFwiLCBoYW5kbGVSZXNldCwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybV9fdW5yZW5kZXIoZWxlbWVudCkge1xuICBcdGVsZW1lbnQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzZXRcIiwgaGFuZGxlUmVzZXQsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVJlc2V0KCkge1xuICBcdHZhciBlbGVtZW50ID0gdGhpcy5fcmFjdGl2ZS5wcm94eTtcblxuICBcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KCk7XG4gIFx0ZWxlbWVudC5mb3JtQmluZGluZ3MuZm9yRWFjaCh1cGRhdGVNb2RlbCk7XG4gIFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVNb2RlbChiaW5kaW5nKSB7XG4gIFx0YmluZGluZy5yb290LnZpZXdtb2RlbC5zZXQoYmluZGluZy5rZXlwYXRoLCBiaW5kaW5nLnJlc2V0VmFsdWUpO1xuICB9XG5cbiAgdmFyIFRyYW5zaXRpb25fcHJvdG90eXBlX2luaXQgPSBUcmFuc2l0aW9uJGluaXQ7XG4gIGZ1bmN0aW9uIFRyYW5zaXRpb24kaW5pdChlbGVtZW50LCB0ZW1wbGF0ZSwgaXNJbnRybykge1xuICBcdHZhciByYWN0aXZlLCBuYW1lLCBmcmFnbWVudDtcblxuICBcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZSA9IGVsZW1lbnQucm9vdDtcbiAgXHR0aGlzLmlzSW50cm8gPSBpc0ludHJvO1xuXG4gIFx0bmFtZSA9IHRlbXBsYXRlLm4gfHwgdGVtcGxhdGU7XG5cbiAgXHRpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHR0ZW1wbGF0ZTogbmFtZSxcbiAgXHRcdFx0cm9vdDogcmFjdGl2ZSxcbiAgXHRcdFx0b3duZXI6IGVsZW1lbnRcbiAgXHRcdH0pO1xuXG4gIFx0XHRuYW1lID0gZnJhZ21lbnQudG9TdHJpbmcoKTtcbiAgXHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXG4gIFx0XHRpZiAobmFtZSA9PT0gXCJcIikge1xuICBcdFx0XHQvLyBlbXB0eSBzdHJpbmcgb2theSwganVzdCBubyB0cmFuc2l0aW9uXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR0aGlzLm5hbWUgPSBuYW1lO1xuXG4gIFx0aWYgKHRlbXBsYXRlLmEpIHtcbiAgXHRcdHRoaXMucGFyYW1zID0gdGVtcGxhdGUuYTtcbiAgXHR9IGVsc2UgaWYgKHRlbXBsYXRlLmQpIHtcbiAgXHRcdC8vIFRPRE8gaXMgdGhlcmUgYSB3YXkgdG8gaW50ZXJwcmV0IGR5bmFtaWMgYXJndW1lbnRzIHdpdGhvdXQgYWxsIHRoZVxuICBcdFx0Ly8gJ2RlcGVuZGVuY3kgdGhyYXNoaW5nJz9cbiAgXHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuZCxcbiAgXHRcdFx0cm9vdDogcmFjdGl2ZSxcbiAgXHRcdFx0b3duZXI6IGVsZW1lbnRcbiAgXHRcdH0pO1xuXG4gIFx0XHR0aGlzLnBhcmFtcyA9IGZyYWdtZW50LmdldEFyZ3NMaXN0KCk7XG4gIFx0XHRmcmFnbWVudC51bmJpbmQoKTtcbiAgXHR9XG5cbiAgXHR0aGlzLl9mbiA9IGZpbmRJblZpZXdIaWVyYXJjaHkoXCJ0cmFuc2l0aW9uc1wiLCByYWN0aXZlLCBuYW1lKTtcblxuICBcdGlmICghdGhpcy5fZm4pIHtcbiAgXHRcdHdhcm5PbmNlSWZEZWJ1ZyhtaXNzaW5nUGx1Z2luKG5hbWUsIFwidHJhbnNpdGlvblwiKSwgeyByYWN0aXZlOiB0aGlzLnJvb3QgfSk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGNhbWVsQ2FzZSA9IGZ1bmN0aW9uIChoeXBoZW5hdGVkU3RyKSB7XG4gIFx0cmV0dXJuIGh5cGhlbmF0ZWRTdHIucmVwbGFjZSgvLShbYS16QS1aXSkvZywgZnVuY3Rpb24gKG1hdGNoLCAkMSkge1xuICBcdFx0cmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7XG4gIFx0fSk7XG4gIH07XG5cbiAgdmFyIGhlbHBlcnNfcHJlZml4X19wcmVmaXgsIHByZWZpeENhY2hlLCBoZWxwZXJzX3ByZWZpeF9fdGVzdFN0eWxlO1xuXG4gIGlmICghaXNDbGllbnQpIHtcbiAgXHRoZWxwZXJzX3ByZWZpeF9fcHJlZml4ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgXHRwcmVmaXhDYWNoZSA9IHt9O1xuICBcdGhlbHBlcnNfcHJlZml4X190ZXN0U3R5bGUgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlO1xuXG4gIFx0aGVscGVyc19wcmVmaXhfX3ByZWZpeCA9IGZ1bmN0aW9uIChwcm9wKSB7XG4gIFx0XHR2YXIgaSwgdmVuZG9yLCBjYXBwZWQ7XG5cbiAgXHRcdHByb3AgPSBjYW1lbENhc2UocHJvcCk7XG5cbiAgXHRcdGlmICghcHJlZml4Q2FjaGVbcHJvcF0pIHtcbiAgXHRcdFx0aWYgKGhlbHBlcnNfcHJlZml4X190ZXN0U3R5bGVbcHJvcF0gIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdHByZWZpeENhY2hlW3Byb3BdID0gcHJvcDtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHQvLyB0ZXN0IHZlbmRvcnMuLi5cbiAgXHRcdFx0XHRjYXBwZWQgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zdWJzdHJpbmcoMSk7XG5cbiAgXHRcdFx0XHRpID0gdmVuZG9ycy5sZW5ndGg7XG4gIFx0XHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdFx0dmVuZG9yID0gdmVuZG9yc1tpXTtcbiAgXHRcdFx0XHRcdGlmIChoZWxwZXJzX3ByZWZpeF9fdGVzdFN0eWxlW3ZlbmRvciArIGNhcHBlZF0gIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdFx0XHRwcmVmaXhDYWNoZVtwcm9wXSA9IHZlbmRvciArIGNhcHBlZDtcbiAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBwcmVmaXhDYWNoZVtwcm9wXTtcbiAgXHR9O1xuICB9XG5cbiAgdmFyIGhlbHBlcnNfcHJlZml4ID0gaGVscGVyc19wcmVmaXhfX3ByZWZpeDtcblxuICB2YXIgZ2V0U3R5bGUsIHByb3RvdHlwZV9nZXRTdHlsZV9fZ2V0Q29tcHV0ZWRTdHlsZTtcblxuICBpZiAoIWlzQ2xpZW50KSB7XG4gIFx0Z2V0U3R5bGUgPSBudWxsO1xuICB9IGVsc2Uge1xuICBcdHByb3RvdHlwZV9nZXRTdHlsZV9fZ2V0Q29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlIHx8IGxlZ2FjeS5nZXRDb21wdXRlZFN0eWxlO1xuXG4gIFx0Z2V0U3R5bGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgXHRcdHZhciBjb21wdXRlZFN0eWxlLCBzdHlsZXMsIGksIHByb3AsIHZhbHVlO1xuXG4gIFx0XHRjb21wdXRlZFN0eWxlID0gcHJvdG90eXBlX2dldFN0eWxlX19nZXRDb21wdXRlZFN0eWxlKHRoaXMubm9kZSk7XG5cbiAgXHRcdGlmICh0eXBlb2YgcHJvcHMgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0dmFsdWUgPSBjb21wdXRlZFN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3BzKV07XG4gIFx0XHRcdGlmICh2YWx1ZSA9PT0gXCIwcHhcIikge1xuICBcdFx0XHRcdHZhbHVlID0gMDtcbiAgXHRcdFx0fVxuICBcdFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghaXNBcnJheShwcm9wcykpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVHJhbnNpdGlvbiRnZXRTdHlsZSBtdXN0IGJlIHBhc3NlZCBhIHN0cmluZywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgQ1NTIHByb3BlcnRpZXNcIik7XG4gIFx0XHR9XG5cbiAgXHRcdHN0eWxlcyA9IHt9O1xuXG4gIFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRwcm9wID0gcHJvcHNbaV07XG4gIFx0XHRcdHZhbHVlID0gY29tcHV0ZWRTdHlsZVtoZWxwZXJzX3ByZWZpeChwcm9wKV07XG4gIFx0XHRcdGlmICh2YWx1ZSA9PT0gXCIwcHhcIikge1xuICBcdFx0XHRcdHZhbHVlID0gMDtcbiAgXHRcdFx0fVxuICBcdFx0XHRzdHlsZXNbcHJvcF0gPSB2YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHN0eWxlcztcbiAgXHR9O1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9nZXRTdHlsZSA9IGdldFN0eWxlO1xuXG4gIHZhciBzZXRTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSwgdmFsdWUpIHtcbiAgXHR2YXIgcHJvcDtcblxuICBcdGlmICh0eXBlb2Ygc3R5bGUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHRoaXMubm9kZS5zdHlsZVtoZWxwZXJzX3ByZWZpeChzdHlsZSldID0gdmFsdWU7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGZvciAocHJvcCBpbiBzdHlsZSkge1xuICBcdFx0XHRpZiAoc3R5bGUuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgXHRcdFx0XHR0aGlzLm5vZGUuc3R5bGVbaGVscGVyc19wcmVmaXgocHJvcCldID0gc3R5bGVbcHJvcF07XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgVGlja2VyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR2YXIgZWFzaW5nO1xuXG4gIFx0dGhpcy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XG4gIFx0dGhpcy5zdGVwID0gb3B0aW9ucy5zdGVwO1xuICBcdHRoaXMuY29tcGxldGUgPSBvcHRpb25zLmNvbXBsZXRlO1xuXG4gIFx0Ly8gZWFzaW5nXG4gIFx0aWYgKHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0ZWFzaW5nID0gb3B0aW9ucy5yb290LmVhc2luZ1tvcHRpb25zLmVhc2luZ107XG5cbiAgXHRcdGlmICghZWFzaW5nKSB7XG4gIFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhtaXNzaW5nUGx1Z2luKG9wdGlvbnMuZWFzaW5nLCBcImVhc2luZ1wiKSk7XG4gIFx0XHRcdGVhc2luZyA9IGxpbmVhcjtcbiAgXHRcdH1cbiAgXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRlYXNpbmcgPSBvcHRpb25zLmVhc2luZztcbiAgXHR9IGVsc2Uge1xuICBcdFx0ZWFzaW5nID0gbGluZWFyO1xuICBcdH1cblxuICBcdHRoaXMuZWFzaW5nID0gZWFzaW5nO1xuXG4gIFx0dGhpcy5zdGFydCA9IHV0aWxzX2dldFRpbWUoKTtcbiAgXHR0aGlzLmVuZCA9IHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuXG4gIFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgXHRzaGFyZWRfYW5pbWF0aW9ucy5hZGQodGhpcyk7XG4gIH07XG5cbiAgVGlja2VyLnByb3RvdHlwZSA9IHtcbiAgXHR0aWNrOiBmdW5jdGlvbiAobm93KSB7XG4gIFx0XHR2YXIgZWxhcHNlZCwgZWFzZWQ7XG5cbiAgXHRcdGlmICghdGhpcy5ydW5uaW5nKSB7XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG5vdyA+IHRoaXMuZW5kKSB7XG4gIFx0XHRcdGlmICh0aGlzLnN0ZXApIHtcbiAgXHRcdFx0XHR0aGlzLnN0ZXAoMSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAodGhpcy5jb21wbGV0ZSkge1xuICBcdFx0XHRcdHRoaXMuY29tcGxldGUoMSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdGVsYXBzZWQgPSBub3cgLSB0aGlzLnN0YXJ0O1xuICBcdFx0ZWFzZWQgPSB0aGlzLmVhc2luZyhlbGFwc2VkIC8gdGhpcy5kdXJhdGlvbik7XG5cbiAgXHRcdGlmICh0aGlzLnN0ZXApIHtcbiAgXHRcdFx0dGhpcy5zdGVwKGVhc2VkKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fSxcblxuICBcdHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmFib3J0KSB7XG4gIFx0XHRcdHRoaXMuYWJvcnQoKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBzaGFyZWRfVGlja2VyID0gVGlja2VyO1xuICBmdW5jdGlvbiBsaW5lYXIodCkge1xuICBcdHJldHVybiB0O1xuICB9XG5cbiAgdmFyIHVucHJlZml4UGF0dGVybiA9IG5ldyBSZWdFeHAoXCJeLSg/OlwiICsgdmVuZG9ycy5qb2luKFwifFwiKSArIFwiKS1cIik7XG5cbiAgdmFyIHVucHJlZml4ID0gZnVuY3Rpb24gKHByb3ApIHtcbiAgXHRyZXR1cm4gcHJvcC5yZXBsYWNlKHVucHJlZml4UGF0dGVybiwgXCJcIik7XG4gIH07XG5cbiAgdmFyIHZlbmRvclBhdHRlcm4gPSBuZXcgUmVnRXhwKFwiXig/OlwiICsgdmVuZG9ycy5qb2luKFwifFwiKSArIFwiKShbQS1aXSlcIik7XG5cbiAgdmFyIGh5cGhlbmF0ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgXHR2YXIgaHlwaGVuYXRlZDtcblxuICBcdGlmICghc3RyKSB7XG4gIFx0XHRyZXR1cm4gXCJcIjsgLy8gZWRnZSBjYXNlXG4gIFx0fVxuXG4gIFx0aWYgKHZlbmRvclBhdHRlcm4udGVzdChzdHIpKSB7XG4gIFx0XHRzdHIgPSBcIi1cIiArIHN0cjtcbiAgXHR9XG5cbiAgXHRoeXBoZW5hdGVkID0gc3RyLnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICBcdFx0cmV0dXJuIFwiLVwiICsgbWF0Y2gudG9Mb3dlckNhc2UoKTtcbiAgXHR9KTtcblxuICBcdHJldHVybiBoeXBoZW5hdGVkO1xuICB9O1xuXG4gIHZhciBjcmVhdGVUcmFuc2l0aW9ucyxcbiAgICAgIGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9uc19fdGVzdFN0eWxlLFxuICAgICAgVFJBTlNJVElPTixcbiAgICAgIFRSQU5TSVRJT05FTkQsXG4gICAgICBDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCxcbiAgICAgIFRSQU5TSVRJT05fRFVSQVRJT04sXG4gICAgICBUUkFOU0lUSU9OX1BST1BFUlRZLFxuICAgICAgVFJBTlNJVElPTl9USU1JTkdfRlVOQ1RJT04sXG4gICAgICBjYW5Vc2VDc3NUcmFuc2l0aW9ucyA9IHt9LFxuICAgICAgY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnMgPSB7fTtcblxuICBpZiAoIWlzQ2xpZW50KSB7XG4gIFx0Y3JlYXRlVHJhbnNpdGlvbnMgPSBudWxsO1xuICB9IGVsc2Uge1xuICBcdGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9uc19fdGVzdFN0eWxlID0gY3JlYXRlRWxlbWVudChcImRpdlwiKS5zdHlsZTtcblxuICBcdC8vIGRldGVybWluZSBzb21lIGZhY3RzIGFib3V0IG91ciBlbnZpcm9ubWVudFxuICBcdChmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoYW5pbWF0ZVN0eWxlX2NyZWF0ZVRyYW5zaXRpb25zX190ZXN0U3R5bGUudHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFRSQU5TSVRJT04gPSBcInRyYW5zaXRpb25cIjtcbiAgXHRcdFx0VFJBTlNJVElPTkVORCA9IFwidHJhbnNpdGlvbmVuZFwiO1xuICBcdFx0XHRDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCA9IHRydWU7XG4gIFx0XHR9IGVsc2UgaWYgKGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9uc19fdGVzdFN0eWxlLndlYmtpdFRyYW5zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRUUkFOU0lUSU9OID0gXCJ3ZWJraXRUcmFuc2l0aW9uXCI7XG4gIFx0XHRcdFRSQU5TSVRJT05FTkQgPSBcIndlYmtpdFRyYW5zaXRpb25FbmRcIjtcbiAgXHRcdFx0Q1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgPSB0cnVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Q1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgPSBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9KSgpO1xuXG4gIFx0aWYgKFRSQU5TSVRJT04pIHtcbiAgXHRcdFRSQU5TSVRJT05fRFVSQVRJT04gPSBUUkFOU0lUSU9OICsgXCJEdXJhdGlvblwiO1xuICBcdFx0VFJBTlNJVElPTl9QUk9QRVJUWSA9IFRSQU5TSVRJT04gKyBcIlByb3BlcnR5XCI7XG4gIFx0XHRUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTiA9IFRSQU5TSVRJT04gKyBcIlRpbWluZ0Z1bmN0aW9uXCI7XG4gIFx0fVxuXG4gIFx0Y3JlYXRlVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiAodCwgdG8sIG9wdGlvbnMsIGNoYW5nZWRQcm9wZXJ0aWVzLCByZXNvbHZlKSB7XG5cbiAgXHRcdC8vIFdhaXQgYSBiZWF0IChvdGhlcndpc2UgdGhlIHRhcmdldCBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkIGltbWVkaWF0ZWx5KVxuICBcdFx0Ly8gVE9ETyB1c2UgYSBmYXN0ZG9tLXN0eWxlIG1lY2hhbmlzbT9cbiAgXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXG4gIFx0XHRcdHZhciBoYXNoUHJlZml4LCBqc1RyYW5zaXRpb25zQ29tcGxldGUsIGNzc1RyYW5zaXRpb25zQ29tcGxldGUsIGNoZWNrQ29tcGxldGUsIHRyYW5zaXRpb25FbmRIYW5kbGVyO1xuXG4gIFx0XHRcdGNoZWNrQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0aWYgKGpzVHJhbnNpdGlvbnNDb21wbGV0ZSAmJiBjc3NUcmFuc2l0aW9uc0NvbXBsZXRlKSB7XG4gIFx0XHRcdFx0XHQvLyB3aWxsIGNoYW5nZXMgdG8gZXZlbnRzIGFuZCBmaXJlIGhhdmUgYW4gdW5leHBlY3RlZCBjb25zZXF1ZW5jZSBoZXJlP1xuICBcdFx0XHRcdFx0dC5yb290LmZpcmUodC5uYW1lICsgXCI6ZW5kXCIsIHQubm9kZSwgdC5pc0ludHJvKTtcbiAgXHRcdFx0XHRcdHJlc29sdmUoKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0Ly8gdGhpcyBpcyB1c2VkIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggZWxlbWVudHMgY2FuIHVzZSBDU1MgdG8gYW5pbWF0ZVxuICBcdFx0XHQvLyB3aGljaCBwcm9wZXJ0aWVzXG4gIFx0XHRcdGhhc2hQcmVmaXggPSAodC5ub2RlLm5hbWVzcGFjZVVSSSB8fCBcIlwiKSArIHQubm9kZS50YWdOYW1lO1xuXG4gIFx0XHRcdHQubm9kZS5zdHlsZVtUUkFOU0lUSU9OX1BST1BFUlRZXSA9IGNoYW5nZWRQcm9wZXJ0aWVzLm1hcChoZWxwZXJzX3ByZWZpeCkubWFwKGh5cGhlbmF0ZSkuam9pbihcIixcIik7XG4gIFx0XHRcdHQubm9kZS5zdHlsZVtUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTl0gPSBoeXBoZW5hdGUob3B0aW9ucy5lYXNpbmcgfHwgXCJsaW5lYXJcIik7XG4gIFx0XHRcdHQubm9kZS5zdHlsZVtUUkFOU0lUSU9OX0RVUkFUSU9OXSA9IG9wdGlvbnMuZHVyYXRpb24gLyAxMDAwICsgXCJzXCI7XG5cbiAgXHRcdFx0dHJhbnNpdGlvbkVuZEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgXHRcdFx0XHR2YXIgaW5kZXg7XG5cbiAgXHRcdFx0XHRpbmRleCA9IGNoYW5nZWRQcm9wZXJ0aWVzLmluZGV4T2YoY2FtZWxDYXNlKHVucHJlZml4KGV2ZW50LnByb3BlcnR5TmFtZSkpKTtcbiAgXHRcdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG4gIFx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmIChjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRcdC8vIHN0aWxsIHRyYW5zaXRpb25pbmcuLi5cbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHR0Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9ORU5ELCB0cmFuc2l0aW9uRW5kSGFuZGxlciwgZmFsc2UpO1xuXG4gIFx0XHRcdFx0Y3NzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG4gIFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuICBcdFx0XHR9O1xuXG4gIFx0XHRcdHQubm9kZS5hZGRFdmVudExpc3RlbmVyKFRSQU5TSVRJT05FTkQsIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBmYWxzZSk7XG5cbiAgXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0dmFyIGkgPSBjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGgsXG4gIFx0XHRcdFx0ICAgIGhhc2gsXG4gIFx0XHRcdFx0ICAgIG9yaWdpbmFsVmFsdWUsXG4gIFx0XHRcdFx0ICAgIGluZGV4LFxuICBcdFx0XHRcdCAgICBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5KcyA9IFtdLFxuICBcdFx0XHRcdCAgICBwcm9wLFxuICBcdFx0XHRcdCAgICBzdWZmaXg7XG5cbiAgXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0XHRwcm9wID0gY2hhbmdlZFByb3BlcnRpZXNbaV07XG4gIFx0XHRcdFx0XHRoYXNoID0gaGFzaFByZWZpeCArIHByb3A7XG5cbiAgXHRcdFx0XHRcdGlmIChDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCAmJiAhY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbaGFzaF0pIHtcbiAgXHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3ApXSA9IHRvW3Byb3BdO1xuXG4gIFx0XHRcdFx0XHRcdC8vIElmIHdlJ3JlIG5vdCBzdXJlIGlmIENTUyB0cmFuc2l0aW9ucyBhcmUgc3VwcG9ydGVkIGZvclxuICBcdFx0XHRcdFx0XHQvLyB0aGlzIHRhZy9wcm9wZXJ0eSBjb21ibywgZmluZCBvdXQgbm93XG4gIFx0XHRcdFx0XHRcdGlmICghY2FuVXNlQ3NzVHJhbnNpdGlvbnNbaGFzaF0pIHtcbiAgXHRcdFx0XHRcdFx0XHRvcmlnaW5hbFZhbHVlID0gdC5nZXRTdHlsZShwcm9wKTtcblxuICBcdFx0XHRcdFx0XHRcdC8vIGlmIHRoaXMgcHJvcGVydHkgaXMgdHJhbnNpdGlvbmFibGUgaW4gdGhpcyBicm93c2VyLFxuICBcdFx0XHRcdFx0XHRcdC8vIHRoZSBjdXJyZW50IHN0eWxlIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gdGhlIHRhcmdldCBzdHlsZVxuICBcdFx0XHRcdFx0XHRcdGNhblVzZUNzc1RyYW5zaXRpb25zW2hhc2hdID0gdC5nZXRTdHlsZShwcm9wKSAhPSB0b1twcm9wXTtcbiAgXHRcdFx0XHRcdFx0XHRjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1toYXNoXSA9ICFjYW5Vc2VDc3NUcmFuc2l0aW9uc1toYXNoXTtcblxuICBcdFx0XHRcdFx0XHRcdC8vIFJlc2V0LCBpZiB3ZSdyZSBnb2luZyB0byB1c2UgdGltZXJzIGFmdGVyIGFsbFxuICBcdFx0XHRcdFx0XHRcdGlmIChjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1toYXNoXSkge1xuICBcdFx0XHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3ApXSA9IG9yaWdpbmFsVmFsdWU7XG4gIFx0XHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdGlmICghQ1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgfHwgY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbaGFzaF0pIHtcbiAgXHRcdFx0XHRcdFx0Ly8gd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gdGltZXItYmFzZWQgc3R1ZmZcbiAgXHRcdFx0XHRcdFx0aWYgKG9yaWdpbmFsVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdFx0XHRcdG9yaWdpbmFsVmFsdWUgPSB0LmdldFN0eWxlKHByb3ApO1xuICBcdFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdFx0Ly8gbmVlZCB0byByZW1vdmUgdGhpcyBmcm9tIGNoYW5nZWRQcm9wZXJ0aWVzLCBvdGhlcndpc2UgdHJhbnNpdGlvbkVuZEhhbmRsZXJcbiAgXHRcdFx0XHRcdFx0Ly8gd2lsbCBnZXQgY29uZnVzZWRcbiAgXHRcdFx0XHRcdFx0aW5kZXggPSBjaGFuZ2VkUHJvcGVydGllcy5pbmRleE9mKHByb3ApO1xuICBcdFx0XHRcdFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdFx0XHRcdFx0d2FybklmRGVidWcoXCJTb21ldGhpbmcgdmVyeSBzdHJhbmdlIGhhcHBlbmVkIHdpdGggdHJhbnNpdGlvbnMuIFBsZWFzZSByYWlzZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzIC0gdGhhbmtzIVwiLCB7IG5vZGU6IHQubm9kZSB9KTtcbiAgXHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdFx0Ly8gVE9ETyBEZXRlcm1pbmUgd2hldGhlciB0aGlzIHByb3BlcnR5IGlzIGFuaW1hdGFibGUgYXQgYWxsXG5cbiAgXHRcdFx0XHRcdFx0c3VmZml4ID0gL1teXFxkXSokLy5leGVjKHRvW3Byb3BdKVswXTtcblxuICBcdFx0XHRcdFx0XHQvLyAuLi50aGVuIGtpY2sgb2ZmIGEgdGltZXItYmFzZWQgdHJhbnNpdGlvblxuICBcdFx0XHRcdFx0XHRwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5wdXNoKHtcbiAgXHRcdFx0XHRcdFx0XHRuYW1lOiBoZWxwZXJzX3ByZWZpeChwcm9wKSxcbiAgXHRcdFx0XHRcdFx0XHRpbnRlcnBvbGF0b3I6IHNoYXJlZF9pbnRlcnBvbGF0ZShwYXJzZUZsb2F0KG9yaWdpbmFsVmFsdWUpLCBwYXJzZUZsb2F0KHRvW3Byb3BdKSksXG4gIFx0XHRcdFx0XHRcdFx0c3VmZml4OiBzdWZmaXhcbiAgXHRcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0Ly8gamF2YXNjcmlwdCB0cmFuc2l0aW9uc1xuICBcdFx0XHRcdGlmIChwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRcdG5ldyBzaGFyZWRfVGlja2VyKHtcbiAgXHRcdFx0XHRcdFx0cm9vdDogdC5yb290LFxuICBcdFx0XHRcdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcbiAgXHRcdFx0XHRcdFx0ZWFzaW5nOiBjYW1lbENhc2Uob3B0aW9ucy5lYXNpbmcgfHwgXCJcIiksXG4gIFx0XHRcdFx0XHRcdHN0ZXA6IGZ1bmN0aW9uIChwb3MpIHtcbiAgXHRcdFx0XHRcdFx0XHR2YXIgcHJvcCwgaTtcblxuICBcdFx0XHRcdFx0XHRcdGkgPSBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5sZW5ndGg7XG4gIFx0XHRcdFx0XHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdFx0XHRcdFx0cHJvcCA9IHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzW2ldO1xuICBcdFx0XHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlW3Byb3AubmFtZV0gPSBwcm9wLmludGVycG9sYXRvcihwb3MpICsgcHJvcC5zdWZmaXg7XG4gIFx0XHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0XHR9LFxuICBcdFx0XHRcdFx0XHRjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0XHRcdGpzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG4gIFx0XHRcdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuICBcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0anNUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAoIWNoYW5nZWRQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICBcdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byBjYW5jZWwgdGhlIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBhbmQgZGVhbCB3aXRoXG4gIFx0XHRcdFx0XHQvLyB0aGUgZmFjdCB0aGF0IGl0IHdpbGwgbmV2ZXIgZmlyZVxuICBcdFx0XHRcdFx0dC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoVFJBTlNJVElPTkVORCwgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGZhbHNlKTtcbiAgXHRcdFx0XHRcdGNzc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuICBcdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSwgMCk7XG4gIFx0XHR9LCBvcHRpb25zLmRlbGF5IHx8IDApO1xuICBcdH07XG4gIH1cblxuICB2YXIgYW5pbWF0ZVN0eWxlX2NyZWF0ZVRyYW5zaXRpb25zID0gY3JlYXRlVHJhbnNpdGlvbnM7XG5cbiAgdmFyIGhpZGRlbiwgdmVuZG9yLCBhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9fcHJlZml4LCBhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9faSwgdmlzaWJpbGl0eTtcblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIFx0aGlkZGVuID0gXCJoaWRkZW5cIjtcblxuICBcdHZpc2liaWxpdHkgPSB7fTtcblxuICBcdGlmIChoaWRkZW4gaW4gZG9jdW1lbnQpIHtcbiAgXHRcdGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19wcmVmaXggPSBcIlwiO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9faSA9IHZlbmRvcnMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19pLS0pIHtcbiAgXHRcdFx0dmVuZG9yID0gdmVuZG9yc1thbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9faV07XG4gIFx0XHRcdGhpZGRlbiA9IHZlbmRvciArIFwiSGlkZGVuXCI7XG5cbiAgXHRcdFx0aWYgKGhpZGRlbiBpbiBkb2N1bWVudCkge1xuICBcdFx0XHRcdGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19wcmVmaXggPSB2ZW5kb3I7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHlfX3ByZWZpeCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19wcmVmaXggKyBcInZpc2liaWxpdHljaGFuZ2VcIiwgb25DaGFuZ2UpO1xuXG4gIFx0XHQvLyBpbml0aWFsaXNlXG4gIFx0XHRvbkNoYW5nZSgpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBnYWgsIHdlJ3JlIGluIGFuIG9sZCBicm93c2VyXG4gIFx0XHRpZiAoXCJvbmZvY3Vzb3V0XCIgaW4gZG9jdW1lbnQpIHtcbiAgXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIG9uSGlkZSk7XG4gIFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIG9uU2hvdyk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIG9uSGlkZSk7XG4gIFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBvbkhpZGUpO1xuXG4gIFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZXNob3dcIiwgb25TaG93KTtcbiAgXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBvblNob3cpO1xuICBcdFx0fVxuXG4gIFx0XHR2aXNpYmlsaXR5LmhpZGRlbiA9IGZhbHNlOyAvLyB1bnRpbCBwcm92ZW4gb3RoZXJ3aXNlLiBOb3QgaWRlYWwgYnV0IGhleVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICBcdHZpc2liaWxpdHkuaGlkZGVuID0gZG9jdW1lbnRbaGlkZGVuXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uSGlkZSgpIHtcbiAgXHR2aXNpYmlsaXR5LmhpZGRlbiA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBvblNob3coKSB7XG4gIFx0dmlzaWJpbGl0eS5oaWRkZW4gPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBhbmltYXRlU3R5bGVfdmlzaWJpbGl0eSA9IHZpc2liaWxpdHk7XG5cbiAgdmFyIGFuaW1hdGVTdHlsZSwgX2FuaW1hdGVTdHlsZV9fZ2V0Q29tcHV0ZWRTdHlsZSwgcmVzb2x2ZWQ7XG5cbiAgaWYgKCFpc0NsaWVudCkge1xuICBcdGFuaW1hdGVTdHlsZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gIFx0X2FuaW1hdGVTdHlsZV9fZ2V0Q29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlIHx8IGxlZ2FjeS5nZXRDb21wdXRlZFN0eWxlO1xuXG4gIFx0YW5pbWF0ZVN0eWxlID0gZnVuY3Rpb24gKHN0eWxlLCB2YWx1ZSwgb3B0aW9ucykge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIHRvO1xuXG4gIFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ0LmFuaW1hdGVTdHlsZSgpIHJldHVybnMgYSBwcm9taXNlIC0gdXNlIC50aGVuKCkgaW5zdGVhZCBvZiBwYXNzaW5nIGEgY2FsbGJhY2tcIik7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFNwZWNpYWwgY2FzZSAtIHBhZ2UgaXNuJ3QgdmlzaWJsZS4gRG9uJ3QgYW5pbWF0ZSBhbnl0aGluZywgYmVjYXVzZVxuICBcdFx0Ly8gdGhhdCB3YXkgeW91J2xsIG5ldmVyIGdldCBDU1MgdHJhbnNpdGlvbmVuZCBldmVudHNcbiAgXHRcdGlmIChhbmltYXRlU3R5bGVfdmlzaWJpbGl0eS5oaWRkZW4pIHtcbiAgXHRcdFx0dGhpcy5zZXRTdHlsZShzdHlsZSwgdmFsdWUpO1xuICBcdFx0XHRyZXR1cm4gcmVzb2x2ZWQgfHwgKHJlc29sdmVkID0gdXRpbHNfUHJvbWlzZS5yZXNvbHZlKCkpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodHlwZW9mIHN0eWxlID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdHRvID0ge307XG4gIFx0XHRcdHRvW3N0eWxlXSA9IHZhbHVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dG8gPSBzdHlsZTtcblxuICBcdFx0XHQvLyBzaHVmZmxlIGFyZ3VtZW50c1xuICBcdFx0XHRvcHRpb25zID0gdmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIEFzIG9mIDAuMy45LCB0cmFuc2l0aW9uIGF1dGhvcnMgc2hvdWxkIHN1cHBseSBhbiBgb3B0aW9uYCBvYmplY3Qgd2l0aFxuICBcdFx0Ly8gYGR1cmF0aW9uYCBhbmQgYGVhc2luZ2AgcHJvcGVydGllcyAoYW5kIG9wdGlvbmFsIGBkZWxheWApLCBwbHVzIGFcbiAgXHRcdC8vIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBjb21wbGV0ZXNcblxuICBcdFx0Ly8gVE9ETyByZW1vdmUgdGhpcyBjaGVjayBpbiBhIGZ1dHVyZSB2ZXJzaW9uXG4gIFx0XHRpZiAoIW9wdGlvbnMpIHtcbiAgXHRcdFx0d2Fybk9uY2VJZkRlYnVnKFwiVGhlIFxcXCIlc1xcXCIgdHJhbnNpdGlvbiBkb2VzIG5vdCBzdXBwbHkgYW4gb3B0aW9ucyBvYmplY3QgdG8gYHQuYW5pbWF0ZVN0eWxlKClgLiBUaGlzIHdpbGwgYnJlYWsgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSYWN0aXZlLiBGb3IgbW9yZSBpbmZvIHNlZSBodHRwczovL2dpdGh1Yi5jb20vUmFjdGl2ZUpTL1JhY3RpdmUvaXNzdWVzLzM0MFwiLCB0aGlzLm5hbWUpO1xuICBcdFx0XHRvcHRpb25zID0gdGhpcztcbiAgXHRcdH1cblxuICBcdFx0dmFyIHByb21pc2UgPSBuZXcgdXRpbHNfUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICBcdFx0XHR2YXIgcHJvcGVydHlOYW1lcywgY2hhbmdlZFByb3BlcnRpZXMsIGNvbXB1dGVkU3R5bGUsIGN1cnJlbnQsIGZyb20sIGksIHByb3A7XG5cbiAgXHRcdFx0Ly8gRWRnZSBjYXNlIC0gaWYgZHVyYXRpb24gaXMgemVybywgc2V0IHN0eWxlIHN5bmNocm9ub3VzbHkgYW5kIGNvbXBsZXRlXG4gIFx0XHRcdGlmICghb3B0aW9ucy5kdXJhdGlvbikge1xuICBcdFx0XHRcdF90aGlzLnNldFN0eWxlKHRvKTtcbiAgXHRcdFx0XHRyZXNvbHZlKCk7XG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gR2V0IGEgbGlzdCBvZiB0aGUgcHJvcGVydGllcyB3ZSdyZSBhbmltYXRpbmdcbiAgXHRcdFx0cHJvcGVydHlOYW1lcyA9IE9iamVjdC5rZXlzKHRvKTtcbiAgXHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMgPSBbXTtcblxuICBcdFx0XHQvLyBTdG9yZSB0aGUgY3VycmVudCBzdHlsZXNcbiAgXHRcdFx0Y29tcHV0ZWRTdHlsZSA9IF9hbmltYXRlU3R5bGVfX2dldENvbXB1dGVkU3R5bGUoX3RoaXMubm9kZSk7XG5cbiAgXHRcdFx0ZnJvbSA9IHt9O1xuICBcdFx0XHRpID0gcHJvcGVydHlOYW1lcy5sZW5ndGg7XG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRwcm9wID0gcHJvcGVydHlOYW1lc1tpXTtcbiAgXHRcdFx0XHRjdXJyZW50ID0gY29tcHV0ZWRTdHlsZVtoZWxwZXJzX3ByZWZpeChwcm9wKV07XG5cbiAgXHRcdFx0XHRpZiAoY3VycmVudCA9PT0gXCIwcHhcIikge1xuICBcdFx0XHRcdFx0Y3VycmVudCA9IDA7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0Ly8gd2UgbmVlZCB0byBrbm93IGlmIHdlJ3JlIGFjdHVhbGx5IGNoYW5naW5nIGFueXRoaW5nXG4gIFx0XHRcdFx0aWYgKGN1cnJlbnQgIT0gdG9bcHJvcF0pIHtcbiAgXHRcdFx0XHRcdC8vIHVzZSAhPSBpbnN0ZWFkIG9mICE9PSwgc28gd2UgY2FuIGNvbXBhcmUgc3RyaW5ncyB3aXRoIG51bWJlcnNcbiAgXHRcdFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG5cbiAgXHRcdFx0XHRcdC8vIG1ha2UgdGhlIGNvbXB1dGVkIHN0eWxlIGV4cGxpY2l0LCBzbyB3ZSBjYW4gYW5pbWF0ZSB3aGVyZVxuICBcdFx0XHRcdFx0Ly8gZS5nLiBoZWlnaHQ9J2F1dG8nXG4gIFx0XHRcdFx0XHRfdGhpcy5ub2RlLnN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3ApXSA9IGN1cnJlbnQ7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gSWYgd2UncmUgbm90IGFjdHVhbGx5IGNoYW5naW5nIGFueXRoaW5nLCB0aGUgdHJhbnNpdGlvbmVuZCBldmVudFxuICBcdFx0XHQvLyB3aWxsIG5ldmVyIGZpcmUhIFNvIHdlIGNvbXBsZXRlIGVhcmx5XG4gIFx0XHRcdGlmICghY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0cmVzb2x2ZSgpO1xuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9ucyhfdGhpcywgdG8sIG9wdGlvbnMsIGNoYW5nZWRQcm9wZXJ0aWVzLCByZXNvbHZlKTtcbiAgXHRcdH0pO1xuXG4gIFx0XHRyZXR1cm4gcHJvbWlzZTtcbiAgXHR9O1xuICB9XG5cbiAgdmFyIF9hbmltYXRlU3R5bGUgPSBhbmltYXRlU3R5bGU7XG5cbiAgdmFyIHByb2Nlc3NQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCBkZWZhdWx0cykge1xuICBcdGlmICh0eXBlb2YgcGFyYW1zID09PSBcIm51bWJlclwiKSB7XG4gIFx0XHRwYXJhbXMgPSB7IGR1cmF0aW9uOiBwYXJhbXMgfTtcbiAgXHR9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGlmIChwYXJhbXMgPT09IFwic2xvd1wiKSB7XG4gIFx0XHRcdHBhcmFtcyA9IHsgZHVyYXRpb246IDYwMCB9O1xuICBcdFx0fSBlbHNlIGlmIChwYXJhbXMgPT09IFwiZmFzdFwiKSB7XG4gIFx0XHRcdHBhcmFtcyA9IHsgZHVyYXRpb246IDIwMCB9O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGFyYW1zID0geyBkdXJhdGlvbjogNDAwIH07XG4gIFx0XHR9XG4gIFx0fSBlbHNlIGlmICghcGFyYW1zKSB7XG4gIFx0XHRwYXJhbXMgPSB7fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gZmlsbEdhcHMoe30sIHBhcmFtcywgZGVmYXVsdHMpO1xuICB9O1xuXG4gIHZhciBwcm90b3R5cGVfc3RhcnQgPSBUcmFuc2l0aW9uJHN0YXJ0O1xuXG4gIGZ1bmN0aW9uIFRyYW5zaXRpb24kc3RhcnQoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBub2RlLCBvcmlnaW5hbFN0eWxlLCBjb21wbGV0ZWQ7XG5cbiAgXHRub2RlID0gdGhpcy5ub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG4gIFx0b3JpZ2luYWxTdHlsZSA9IG5vZGUuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG5cbiAgXHQvLyBjcmVhdGUgdC5jb21wbGV0ZSgpIC0gd2UgZG9uJ3Qgd2FudCB0aGlzIG9uIHRoZSBwcm90b3R5cGUsXG4gIFx0Ly8gYmVjYXVzZSB3ZSBkb24ndCB3YW50IGB0aGlzYCBzaWxsaW5lc3Mgd2hlbiBwYXNzaW5nIGl0IGFzXG4gIFx0Ly8gYW4gYXJndW1lbnRcbiAgXHR0aGlzLmNvbXBsZXRlID0gZnVuY3Rpb24gKG5vUmVzZXQpIHtcbiAgXHRcdGlmIChjb21wbGV0ZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIW5vUmVzZXQgJiYgX3RoaXMuaXNJbnRybykge1xuICBcdFx0XHRyZXNldFN0eWxlKG5vZGUsIG9yaWdpbmFsU3R5bGUpO1xuICBcdFx0fVxuXG4gIFx0XHRub2RlLl9yYWN0aXZlLnRyYW5zaXRpb24gPSBudWxsO1xuICBcdFx0X3RoaXMuX21hbmFnZXIucmVtb3ZlKF90aGlzKTtcblxuICBcdFx0Y29tcGxldGVkID0gdHJ1ZTtcbiAgXHR9O1xuXG4gIFx0Ly8gSWYgdGhlIHRyYW5zaXRpb24gZnVuY3Rpb24gZG9lc24ndCBleGlzdCwgYWJvcnRcbiAgXHRpZiAoIXRoaXMuX2ZuKSB7XG4gIFx0XHR0aGlzLmNvbXBsZXRlKCk7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0dGhpcy5fZm4uYXBwbHkodGhpcy5yb290LCBbdGhpc10uY29uY2F0KHRoaXMucGFyYW1zKSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFN0eWxlKG5vZGUsIHN0eWxlKSB7XG4gIFx0aWYgKHN0eWxlKSB7XG4gIFx0XHRub2RlLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIHN0eWxlKTtcbiAgXHR9IGVsc2Uge1xuXG4gIFx0XHQvLyBOZXh0IGxpbmUgaXMgbmVjZXNzYXJ5LCB0byByZW1vdmUgZW1wdHkgc3R5bGUgYXR0cmlidXRlIVxuICBcdFx0Ly8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcxNjc1NTNcbiAgXHRcdG5vZGUuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gIFx0XHRub2RlLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG93bmVyLCB0ZW1wbGF0ZSwgaXNJbnRybykge1xuICBcdHRoaXMuaW5pdChvd25lciwgdGVtcGxhdGUsIGlzSW50cm8pO1xuICB9O1xuXG4gIFRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuICBcdGluaXQ6IFRyYW5zaXRpb25fcHJvdG90eXBlX2luaXQsXG4gIFx0c3RhcnQ6IHByb3RvdHlwZV9zdGFydCxcbiAgXHRnZXRTdHlsZTogcHJvdG90eXBlX2dldFN0eWxlLFxuICBcdHNldFN0eWxlOiBzZXRTdHlsZSxcbiAgXHRhbmltYXRlU3R5bGU6IF9hbmltYXRlU3R5bGUsXG4gIFx0cHJvY2Vzc1BhcmFtczogcHJvY2Vzc1BhcmFtc1xuICB9O1xuXG4gIHZhciBfVHJhbnNpdGlvbiA9IFRyYW5zaXRpb247XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX3JlbmRlciA9IEVsZW1lbnQkcmVuZGVyO1xuXG4gIHZhciB1cGRhdGVDc3MsIHVwZGF0ZVNjcmlwdDtcblxuICB1cGRhdGVDc3MgPSBmdW5jdGlvbiAoKSB7XG4gIFx0dmFyIG5vZGUgPSB0aGlzLm5vZGUsXG4gIFx0ICAgIGNvbnRlbnQgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKGZhbHNlKTtcblxuICBcdC8vIElFOCBoYXMgbm8gc3R5bGVTaGVldCB1bmxlc3MgdGhlcmUncyBhIHR5cGUgdGV4dC9jc3NcbiAgXHRpZiAod2luZG93ICYmIHdpbmRvdy5hcHBlYXJzVG9CZUlFTGVzc0VxdWFsOCkge1xuICBcdFx0bm9kZS50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuICBcdH1cblxuICBcdGlmIChub2RlLnN0eWxlU2hlZXQpIHtcbiAgXHRcdG5vZGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY29udGVudDtcbiAgXHR9IGVsc2Uge1xuXG4gIFx0XHR3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgXHRcdFx0bm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICBcdFx0fVxuXG4gIFx0XHRub2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvbnRlbnQpKTtcbiAgXHR9XG4gIH07XG5cbiAgdXBkYXRlU2NyaXB0ID0gZnVuY3Rpb24gKCkge1xuICBcdGlmICghdGhpcy5ub2RlLnR5cGUgfHwgdGhpcy5ub2RlLnR5cGUgPT09IFwidGV4dC9qYXZhc2NyaXB0XCIpIHtcbiAgXHRcdHdhcm5JZkRlYnVnKFwiU2NyaXB0IHRhZyB3YXMgdXBkYXRlZC4gVGhpcyBkb2VzIG5vdCBjYXVzZSB0aGUgY29kZSB0byBiZSByZS1ldmFsdWF0ZWQhXCIsIHsgcmFjdGl2ZTogdGhpcy5yb290IH0pO1xuICBcdFx0Ly8gQXMgaXQgaGFwcGVucywgd2UgQVJFIGluIGEgcG9zaXRpb24gdG8gcmUtZXZhbHVhdGUgdGhlIGNvZGUgaWYgd2Ugd2FudGVkXG4gIFx0XHQvLyB0byAtIHdlIGNvdWxkIGV2YWwoKSBpdCwgb3IgaW5zZXJ0IGl0IGludG8gYSBmcmVzaCAodGVtcG9yYXJ5KSBzY3JpcHQgdGFnLlxuICBcdFx0Ly8gQnV0IHRoaXMgd291bGQgYmUgYSB0ZXJyaWJsZSBpZGVhIHdpdGggdW5wcmVkaWN0YWJsZSByZXN1bHRzLCBzbyBsZXQncyBub3QuXG4gIFx0fVxuXG4gIFx0dGhpcy5ub2RlLnRleHQgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKGZhbHNlKTtcbiAgfTtcbiAgZnVuY3Rpb24gRWxlbWVudCRyZW5kZXIoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciByb290ID0gdGhpcy5yb290LFxuICBcdCAgICBuYW1lc3BhY2UsXG4gIFx0ICAgIG5vZGUsXG4gIFx0ICAgIHRyYW5zaXRpb247XG5cbiAgXHRuYW1lc3BhY2UgPSBnZXROYW1lc3BhY2UodGhpcyk7XG4gIFx0bm9kZSA9IHRoaXMubm9kZSA9IGNyZWF0ZUVsZW1lbnQodGhpcy5uYW1lLCBuYW1lc3BhY2UpO1xuXG4gIFx0Ly8gSXMgdGhpcyBhIHRvcC1sZXZlbCBub2RlIG9mIGEgY29tcG9uZW50PyBJZiBzbywgd2UgbWF5IG5lZWQgdG8gYWRkXG4gIFx0Ly8gYSBkYXRhLXJhY3RpdmUtY3NzIGF0dHJpYnV0ZSwgZm9yIENTUyBlbmNhcHN1bGF0aW9uXG4gIFx0aWYgKHRoaXMucGFyZW50RnJhZ21lbnQuY3NzSWRzKSB7XG4gIFx0XHR0aGlzLm5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS1yYWN0aXZlLWNzc1wiLCB0aGlzLnBhcmVudEZyYWdtZW50LmNzc0lkcy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgXHRcdFx0cmV0dXJuIFwie1wiICsgeCArIFwifVwiO1xuICBcdFx0fSkuam9pbihcIiBcIikpO1xuICBcdH1cblxuICBcdC8vIEFkZCBfcmFjdGl2ZSBwcm9wZXJ0eSB0byB0aGUgbm9kZSAtIHdlIHVzZSB0aGlzIG9iamVjdCB0byBzdG9yZSBzdHVmZlxuICBcdC8vIHJlbGF0ZWQgdG8gcHJveHkgZXZlbnRzLCB0d28td2F5IGJpbmRpbmdzIGV0Y1xuICBcdGRlZmluZVByb3BlcnR5KHRoaXMubm9kZSwgXCJfcmFjdGl2ZVwiLCB7XG4gIFx0XHR2YWx1ZToge1xuICBcdFx0XHRwcm94eTogdGhpcyxcbiAgXHRcdFx0a2V5cGF0aDogZ2V0SW5uZXJDb250ZXh0KHRoaXMucGFyZW50RnJhZ21lbnQpLFxuICBcdFx0XHRldmVudHM6IGNyZWF0ZShudWxsKSxcbiAgXHRcdFx0cm9vdDogcm9vdFxuICBcdFx0fVxuICBcdH0pO1xuXG4gIFx0Ly8gUmVuZGVyIGF0dHJpYnV0ZXNcbiAgXHR0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICBcdFx0cmV0dXJuIGEucmVuZGVyKG5vZGUpO1xuICBcdH0pO1xuICBcdHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgXHRcdHJldHVybiBhLnJlbmRlcihub2RlKTtcbiAgXHR9KTtcblxuICBcdC8vIFJlbmRlciBjaGlsZHJlblxuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHQvLyBTcGVjaWFsIGNhc2UgLSA8c2NyaXB0PiBlbGVtZW50XG4gIFx0XHRpZiAodGhpcy5uYW1lID09PSBcInNjcmlwdFwiKSB7XG4gIFx0XHRcdHRoaXMuYnViYmxlID0gdXBkYXRlU2NyaXB0O1xuICBcdFx0XHR0aGlzLm5vZGUudGV4dCA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoZmFsc2UpOyAvLyBieXBhc3Mgd2FybmluZyBpbml0aWFsbHlcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciA9IG5vb3A7IC8vIFRPRE8gdGhpcyBpcyBhIGtsdWRnZVxuICBcdFx0fVxuXG4gIFx0XHQvLyBTcGVjaWFsIGNhc2UgLSA8c3R5bGU+IGVsZW1lbnRcbiAgXHRcdGVsc2UgaWYgKHRoaXMubmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gIFx0XHRcdHRoaXMuYnViYmxlID0gdXBkYXRlQ3NzO1xuICBcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyID0gbm9vcDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gY29udGVudGVkaXRhYmxlXG4gIFx0XHRlbHNlIGlmICh0aGlzLmJpbmRpbmcgJiYgdGhpcy5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciA9IG5vb3A7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5mcmFnbWVudC5yZW5kZXIoKSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gZGVhbCB3aXRoIHR3by13YXkgYmluZGluZ3NcbiAgXHRpZiAodGhpcy5iaW5kaW5nKSB7XG4gIFx0XHR0aGlzLmJpbmRpbmcucmVuZGVyKCk7XG4gIFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUuYmluZGluZyA9IHRoaXMuYmluZGluZztcbiAgXHR9XG5cbiAgXHQvLyBBZGQgcHJveHkgZXZlbnQgaGFuZGxlcnNcbiAgXHRpZiAodGhpcy5ldmVudEhhbmRsZXJzKSB7XG4gIFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaCkge1xuICBcdFx0XHRyZXR1cm4gaC5yZW5kZXIoKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdGlmICh0aGlzLm5hbWUgPT09IFwib3B0aW9uXCIpIHtcbiAgXHRcdHByb2Nlc3NPcHRpb24odGhpcyk7XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlc1xuICBcdGlmICh0aGlzLm5hbWUgPT09IFwiaW1nXCIpIHtcbiAgXHRcdC8vIGlmIHRoaXMgaXMgYW4gPGltZz4sIGFuZCB3ZSdyZSBpbiBhIGNyYXAgYnJvd3Nlciwgd2UgbWF5XG4gIFx0XHQvLyBuZWVkIHRvIHByZXZlbnQgaXQgZnJvbSBvdmVycmlkaW5nIHdpZHRoIGFuZCBoZWlnaHQgd2hlblxuICBcdFx0Ly8gaXQgbG9hZHMgdGhlIHNyY1xuICBcdFx0c3BlY2lhbF9pbWdfX3JlbmRlcih0aGlzKTtcbiAgXHR9IGVsc2UgaWYgKHRoaXMubmFtZSA9PT0gXCJmb3JtXCIpIHtcbiAgXHRcdC8vIGZvcm1zIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB0aGVpciBiaW5kaW5ncywgaW4gY2FzZSBvZiByZXNldFxuICBcdFx0Zm9ybV9fcmVuZGVyKHRoaXMpO1xuICBcdH0gZWxzZSBpZiAodGhpcy5uYW1lID09PSBcImlucHV0XCIgfHwgdGhpcy5uYW1lID09PSBcInRleHRhcmVhXCIpIHtcbiAgXHRcdC8vIGlucHV0cyBhbmQgdGV4dGFyZWFzIHNob3VsZCBzdG9yZSB0aGVpciBpbml0aWFsIHZhbHVlIGFzXG4gIFx0XHQvLyBgZGVmYXVsdFZhbHVlYCBpbiBjYXNlIG9mIHJlc2V0XG4gIFx0XHR0aGlzLm5vZGUuZGVmYXVsdFZhbHVlID0gdGhpcy5ub2RlLnZhbHVlO1xuICBcdH0gZWxzZSBpZiAodGhpcy5uYW1lID09PSBcIm9wdGlvblwiKSB7XG4gIFx0XHQvLyBzaW1pbGFybHkgZm9yIG9wdGlvbiBub2Rlc1xuICBcdFx0dGhpcy5ub2RlLmRlZmF1bHRTZWxlY3RlZCA9IHRoaXMubm9kZS5zZWxlY3RlZDtcbiAgXHR9XG5cbiAgXHQvLyBhcHBseSBkZWNvcmF0b3IocylcbiAgXHRpZiAodGhpcy5kZWNvcmF0b3IgJiYgdGhpcy5kZWNvcmF0b3IuZm4pIHtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdGlmICghX3RoaXMuZGVjb3JhdG9yLnRvcm5kb3duKSB7XG4gIFx0XHRcdFx0X3RoaXMuZGVjb3JhdG9yLmluaXQoKTtcbiAgXHRcdFx0fVxuICBcdFx0fSwgdHJ1ZSk7XG4gIFx0fVxuXG4gIFx0Ly8gdHJpZ2dlciBpbnRybyB0cmFuc2l0aW9uXG4gIFx0aWYgKHJvb3QudHJhbnNpdGlvbnNFbmFibGVkICYmIHRoaXMuaW50cm8pIHtcbiAgXHRcdHRyYW5zaXRpb24gPSBuZXcgX1RyYW5zaXRpb24odGhpcywgdGhpcy5pbnRybywgdHJ1ZSk7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5yZWdpc3RlclRyYW5zaXRpb24odHJhbnNpdGlvbik7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gdHJhbnNpdGlvbi5zdGFydCgpO1xuICBcdFx0fSwgdHJ1ZSk7XG5cbiAgXHRcdHRoaXMudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMubm9kZS5hdXRvZm9jdXMpIHtcbiAgXHRcdC8vIFNwZWNpYWwgY2FzZS4gU29tZSBicm93c2VycyAoKmNvdWdoKiBGaXJlZml4ICpjb3VnaCopIGhhdmUgYSBwcm9ibGVtXG4gIFx0XHQvLyB3aXRoIGR5bmFtaWNhbGx5LWdlbmVyYXRlZCBlbGVtZW50cyBoYXZpbmcgYXV0b2ZvY3VzLCBhbmQgdGhleSB3b24ndFxuICBcdFx0Ly8gYWxsb3cgeW91IHRvIHByb2dyYW1tYXRpY2FsbHkgZm9jdXMgdGhlIGVsZW1lbnQgdW50aWwgaXQncyBpbiB0aGUgRE9NXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gX3RoaXMubm9kZS5mb2N1cygpO1xuICBcdFx0fSwgdHJ1ZSk7XG4gIFx0fVxuXG4gIFx0dXBkYXRlTGl2ZVF1ZXJpZXModGhpcyk7XG4gIFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5hbWVzcGFjZShlbGVtZW50KSB7XG4gIFx0dmFyIG5hbWVzcGFjZSwgeG1sbnMsIHBhcmVudDtcblxuICBcdC8vIFVzZSBzcGVjaWZpZWQgbmFtZXNwYWNlLi4uXG4gIFx0aWYgKHhtbG5zID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ4bWxuc1wiKSkge1xuICBcdFx0bmFtZXNwYWNlID0geG1sbnM7XG4gIFx0fVxuXG4gIFx0Ly8gLi4ub3IgU1ZHIG5hbWVzcGFjZSwgaWYgdGhpcyBpcyBhbiA8c3ZnPiBlbGVtZW50XG4gIFx0ZWxzZSBpZiAoZWxlbWVudC5uYW1lID09PSBcInN2Z1wiKSB7XG4gIFx0XHRuYW1lc3BhY2UgPSBuYW1lc3BhY2VzLnN2ZztcbiAgXHR9IGVsc2UgaWYgKHBhcmVudCA9IGVsZW1lbnQucGFyZW50KSB7XG4gIFx0XHQvLyAuLi5vciBIVE1MLCBpZiB0aGUgcGFyZW50IGlzIGEgPGZvcmVpZ25PYmplY3Q+XG4gIFx0XHRpZiAocGFyZW50Lm5hbWUgPT09IFwiZm9yZWlnbk9iamVjdFwiKSB7XG4gIFx0XHRcdG5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuaHRtbDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gLi4ub3IgaW5oZXJpdCBmcm9tIHRoZSBwYXJlbnQgbm9kZVxuICBcdFx0ZWxzZSB7XG4gIFx0XHRcdG5hbWVzcGFjZSA9IHBhcmVudC5ub2RlLm5hbWVzcGFjZVVSSTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0bmFtZXNwYWNlID0gZWxlbWVudC5yb290LmVsLm5hbWVzcGFjZVVSSTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbmFtZXNwYWNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc09wdGlvbihvcHRpb24pIHtcbiAgXHR2YXIgb3B0aW9uVmFsdWUsIHNlbGVjdFZhbHVlLCBpO1xuXG4gIFx0aWYgKCFvcHRpb24uc2VsZWN0KSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0c2VsZWN0VmFsdWUgPSBvcHRpb24uc2VsZWN0LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdGlmIChzZWxlY3RWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRpZiAob3B0aW9uLnNlbGVjdC5ub2RlLm11bHRpcGxlICYmIGlzQXJyYXkoc2VsZWN0VmFsdWUpKSB7XG4gIFx0XHRpID0gc2VsZWN0VmFsdWUubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRpZiAob3B0aW9uVmFsdWUgPT0gc2VsZWN0VmFsdWVbaV0pIHtcbiAgXHRcdFx0XHRvcHRpb24ubm9kZS5zZWxlY3RlZCA9IHRydWU7XG4gIFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0b3B0aW9uLm5vZGUuc2VsZWN0ZWQgPSBvcHRpb25WYWx1ZSA9PSBzZWxlY3RWYWx1ZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaXZlUXVlcmllcyhlbGVtZW50KSB7XG4gIFx0dmFyIGluc3RhbmNlLCBsaXZlUXVlcmllcywgaSwgc2VsZWN0b3IsIHF1ZXJ5O1xuXG4gIFx0Ly8gRG9lcyB0aGlzIG5lZWQgdG8gYmUgYWRkZWQgdG8gYW55IGxpdmUgcXVlcmllcz9cbiAgXHRpbnN0YW5jZSA9IGVsZW1lbnQucm9vdDtcblxuICBcdGRvIHtcbiAgXHRcdGxpdmVRdWVyaWVzID0gaW5zdGFuY2UuX2xpdmVRdWVyaWVzO1xuXG4gIFx0XHRpID0gbGl2ZVF1ZXJpZXMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRzZWxlY3RvciA9IGxpdmVRdWVyaWVzW2ldO1xuICBcdFx0XHRxdWVyeSA9IGxpdmVRdWVyaWVzW1wiX1wiICsgc2VsZWN0b3JdO1xuXG4gIFx0XHRcdGlmIChxdWVyeS5fdGVzdChlbGVtZW50KSkge1xuICBcdFx0XHRcdC8vIGtlZXAgcmVnaXN0ZXIgb2YgYXBwbGljYWJsZSBzZWxlY3RvcnMsIGZvciB3aGVuIHdlIHRlYXJkb3duXG4gIFx0XHRcdFx0KGVsZW1lbnQubGl2ZVF1ZXJpZXMgfHwgKGVsZW1lbnQubGl2ZVF1ZXJpZXMgPSBbXSkpLnB1c2gocXVlcnkpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoaW5zdGFuY2UgPSBpbnN0YW5jZS5wYXJlbnQpO1xuICB9XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX3RvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICBcdHZhciBzdHIsIGVzY2FwZTtcblxuICBcdGlmICh0aGlzLnRlbXBsYXRlLnkpIHtcbiAgXHRcdC8vIERPQ1RZUEUgZGVjbGFyYXRpb25cbiAgXHRcdHJldHVybiBcIjwhRE9DVFlQRVwiICsgdGhpcy50ZW1wbGF0ZS5kZCArIFwiPlwiO1xuICBcdH1cblxuICBcdHN0ciA9IFwiPFwiICsgdGhpcy50ZW1wbGF0ZS5lO1xuXG4gIFx0c3RyICs9IHRoaXMuYXR0cmlidXRlcy5tYXAoc3RyaW5naWZ5QXR0cmlidXRlKS5qb2luKFwiXCIpICsgdGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMubWFwKHN0cmluZ2lmeUF0dHJpYnV0ZSkuam9pbihcIlwiKTtcblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHNlbGVjdGVkIG9wdGlvbnNcbiAgXHRpZiAodGhpcy5uYW1lID09PSBcIm9wdGlvblwiICYmIG9wdGlvbklzU2VsZWN0ZWQodGhpcykpIHtcbiAgXHRcdHN0ciArPSBcIiBzZWxlY3RlZFwiO1xuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHR3by13YXkgcmFkaW8gbmFtZSBiaW5kaW5nc1xuICBcdGlmICh0aGlzLm5hbWUgPT09IFwiaW5wdXRcIiAmJiBpbnB1dElzQ2hlY2tlZFJhZGlvKHRoaXMpKSB7XG4gIFx0XHRzdHIgKz0gXCIgY2hlY2tlZFwiO1xuICBcdH1cblxuICBcdHN0ciArPSBcIj5cIjtcblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHRleHRhcmVhXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICYmIHRoaXMuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0c3RyICs9IGVzY2FwZUh0bWwodGhpcy5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSk7XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gY29udGVudGVkaXRhYmxlXG4gIFx0ZWxzZSBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0c3RyICs9IHRoaXMuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgfHwgXCJcIjtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0ZXNjYXBlID0gdGhpcy5uYW1lICE9PSBcInNjcmlwdFwiICYmIHRoaXMubmFtZSAhPT0gXCJzdHlsZVwiO1xuICBcdFx0c3RyICs9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoZXNjYXBlKTtcbiAgXHR9XG5cbiAgXHQvLyBhZGQgYSBjbG9zaW5nIHRhZyBpZiB0aGlzIGlzbid0IGEgdm9pZCBlbGVtZW50XG4gIFx0aWYgKCF2b2lkRWxlbWVudE5hbWVzLnRlc3QodGhpcy50ZW1wbGF0ZS5lKSkge1xuICBcdFx0c3RyICs9IFwiPC9cIiArIHRoaXMudGVtcGxhdGUuZSArIFwiPlwiO1xuICBcdH1cblxuICBcdHJldHVybiBzdHI7XG4gIH07XG5cbiAgZnVuY3Rpb24gb3B0aW9uSXNTZWxlY3RlZChlbGVtZW50KSB7XG4gIFx0dmFyIG9wdGlvblZhbHVlLCBzZWxlY3RWYWx1ZSwgaTtcblxuICBcdG9wdGlvblZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcblxuICBcdGlmIChvcHRpb25WYWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICFlbGVtZW50LnNlbGVjdCkge1xuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH1cblxuICBcdHNlbGVjdFZhbHVlID0gZWxlbWVudC5zZWxlY3QuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRpZiAoc2VsZWN0VmFsdWUgPT0gb3B0aW9uVmFsdWUpIHtcbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cblxuICBcdGlmIChlbGVtZW50LnNlbGVjdC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSAmJiBpc0FycmF5KHNlbGVjdFZhbHVlKSkge1xuICBcdFx0aSA9IHNlbGVjdFZhbHVlLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0aWYgKHNlbGVjdFZhbHVlW2ldID09IG9wdGlvblZhbHVlKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBpbnB1dElzQ2hlY2tlZFJhZGlvKGVsZW1lbnQpIHtcbiAgXHR2YXIgYXR0cmlidXRlcywgdHlwZUF0dHJpYnV0ZSwgdmFsdWVBdHRyaWJ1dGUsIG5hbWVBdHRyaWJ1dGU7XG5cbiAgXHRhdHRyaWJ1dGVzID0gZWxlbWVudC5hdHRyaWJ1dGVzO1xuXG4gIFx0dHlwZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMudHlwZTtcbiAgXHR2YWx1ZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMudmFsdWU7XG4gIFx0bmFtZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMubmFtZTtcblxuICBcdGlmICghdHlwZUF0dHJpYnV0ZSB8fCB0eXBlQXR0cmlidXRlLnZhbHVlICE9PSBcInJhZGlvXCIgfHwgIXZhbHVlQXR0cmlidXRlIHx8ICFuYW1lQXR0cmlidXRlLmludGVycG9sYXRvcikge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGlmICh2YWx1ZUF0dHJpYnV0ZS52YWx1ZSA9PT0gbmFtZUF0dHJpYnV0ZS5pbnRlcnBvbGF0b3IudmFsdWUpIHtcbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeUF0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcbiAgXHR2YXIgc3RyID0gYXR0cmlidXRlLnRvU3RyaW5nKCk7XG4gIFx0cmV0dXJuIHN0ciA/IFwiIFwiICsgc3RyIDogXCJcIjtcbiAgfVxuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV91bmJpbmQgPSBFbGVtZW50JHVuYmluZDtcbiAgZnVuY3Rpb24gRWxlbWVudCR1bmJpbmQoKSB7XG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuYmluZGluZykge1xuICBcdFx0dGhpcy5iaW5kaW5nLnVuYmluZCgpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmV2ZW50SGFuZGxlcnMpIHtcbiAgXHRcdHRoaXMuZXZlbnRIYW5kbGVycy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gPG9wdGlvbj5cbiAgXHRpZiAodGhpcy5uYW1lID09PSBcIm9wdGlvblwiKSB7XG4gIFx0XHRzcGVjaWFsX29wdGlvbl9fdW5iaW5kKHRoaXMpO1xuICBcdH1cblxuICBcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0dGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuICB9XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX3VucmVuZGVyID0gRWxlbWVudCR1bnJlbmRlcjtcblxuICBmdW5jdGlvbiBFbGVtZW50JHVucmVuZGVyKHNob3VsZERlc3Ryb3kpIHtcbiAgXHR2YXIgYmluZGluZywgYmluZGluZ3MsIHRyYW5zaXRpb247XG5cbiAgXHRpZiAodHJhbnNpdGlvbiA9IHRoaXMudHJhbnNpdGlvbikge1xuICBcdFx0dHJhbnNpdGlvbi5jb21wbGV0ZSgpO1xuICBcdH1cblxuICBcdC8vIERldGFjaCBhcyBzb29uIGFzIHdlIGNhblxuICBcdGlmICh0aGlzLm5hbWUgPT09IFwib3B0aW9uXCIpIHtcbiAgXHRcdC8vIDxvcHRpb24+IGVsZW1lbnRzIGRldGFjaCBpbW1lZGlhdGVseSwgc28gdGhhdFxuICBcdFx0Ly8gdGhlaXIgcGFyZW50IDxzZWxlY3Q+IGVsZW1lbnQgc3luY3MgY29ycmVjdGx5LCBhbmRcbiAgXHRcdC8vIHNpbmNlIG9wdGlvbiBlbGVtZW50cyBjYW4ndCBoYXZlIHRyYW5zaXRpb25zIGFueXdheVxuICBcdFx0dGhpcy5kZXRhY2goKTtcbiAgXHR9IGVsc2UgaWYgKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLmRldGFjaFdoZW5SZWFkeSh0aGlzKTtcbiAgXHR9XG5cbiAgXHQvLyBDaGlsZHJlbiBmaXJzdC4gdGhhdCB3YXksIGFueSB0cmFuc2l0aW9ucyBvbiBjaGlsZCBlbGVtZW50cyB3aWxsIGJlXG4gIFx0Ly8gaGFuZGxlZCBieSB0aGUgY3VycmVudCB0cmFuc2l0aW9uTWFuYWdlclxuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKGZhbHNlKTtcbiAgXHR9XG5cbiAgXHRpZiAoYmluZGluZyA9IHRoaXMuYmluZGluZykge1xuICBcdFx0dGhpcy5iaW5kaW5nLnVucmVuZGVyKCk7XG5cbiAgXHRcdHRoaXMubm9kZS5fcmFjdGl2ZS5iaW5kaW5nID0gbnVsbDtcbiAgXHRcdGJpbmRpbmdzID0gdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1tiaW5kaW5nLmtleXBhdGguc3RyXTtcbiAgXHRcdGJpbmRpbmdzLnNwbGljZShiaW5kaW5ncy5pbmRleE9mKGJpbmRpbmcpLCAxKTtcbiAgXHR9XG5cbiAgXHQvLyBSZW1vdmUgZXZlbnQgaGFuZGxlcnNcbiAgXHRpZiAodGhpcy5ldmVudEhhbmRsZXJzKSB7XG4gIFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bnJlbmRlcik7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZGVjb3JhdG9yKSB7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5yZWdpc3RlckRlY29yYXRvcih0aGlzLmRlY29yYXRvcik7XG4gIFx0fVxuXG4gIFx0Ly8gdHJpZ2dlciBvdXRybyB0cmFuc2l0aW9uIGlmIG5lY2Vzc2FyeVxuICBcdGlmICh0aGlzLnJvb3QudHJhbnNpdGlvbnNFbmFibGVkICYmIHRoaXMub3V0cm8pIHtcbiAgXHRcdHRyYW5zaXRpb24gPSBuZXcgX1RyYW5zaXRpb24odGhpcywgdGhpcy5vdXRybywgZmFsc2UpO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AucmVnaXN0ZXJUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIHRyYW5zaXRpb24uc3RhcnQoKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdC8vIFJlbW92ZSB0aGlzIG5vZGUgZnJvbSBhbnkgbGl2ZSBxdWVyaWVzXG4gIFx0aWYgKHRoaXMubGl2ZVF1ZXJpZXMpIHtcbiAgXHRcdHJlbW92ZUZyb21MaXZlUXVlcmllcyh0aGlzKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5uYW1lID09PSBcImZvcm1cIikge1xuICBcdFx0Zm9ybV9fdW5yZW5kZXIodGhpcyk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRnJvbUxpdmVRdWVyaWVzKGVsZW1lbnQpIHtcbiAgXHR2YXIgcXVlcnksIHNlbGVjdG9yLCBpO1xuXG4gIFx0aSA9IGVsZW1lbnQubGl2ZVF1ZXJpZXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdHF1ZXJ5ID0gZWxlbWVudC5saXZlUXVlcmllc1tpXTtcbiAgXHRcdHNlbGVjdG9yID0gcXVlcnkuc2VsZWN0b3I7XG5cbiAgXHRcdHF1ZXJ5Ll9yZW1vdmUoZWxlbWVudC5ub2RlKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgRWxlbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy5pbml0KG9wdGlvbnMpO1xuICB9O1xuXG4gIEVsZW1lbnQucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogRWxlbWVudF9wcm90b3R5cGVfYnViYmxlLFxuICBcdGRldGFjaDogRWxlbWVudF9wcm90b3R5cGVfZGV0YWNoLFxuICBcdGZpbmQ6IEVsZW1lbnRfcHJvdG90eXBlX2ZpbmQsXG4gIFx0ZmluZEFsbDogRWxlbWVudF9wcm90b3R5cGVfZmluZEFsbCxcbiAgXHRmaW5kQWxsQ29tcG9uZW50czogRWxlbWVudF9wcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMsXG4gIFx0ZmluZENvbXBvbmVudDogRWxlbWVudF9wcm90b3R5cGVfZmluZENvbXBvbmVudCxcbiAgXHRmaW5kTmV4dE5vZGU6IEVsZW1lbnRfcHJvdG90eXBlX2ZpbmROZXh0Tm9kZSxcbiAgXHRmaXJzdE5vZGU6IEVsZW1lbnRfcHJvdG90eXBlX2ZpcnN0Tm9kZSxcbiAgXHRnZXRBdHRyaWJ1dGU6IGdldEF0dHJpYnV0ZSxcbiAgXHRpbml0OiBFbGVtZW50X3Byb3RvdHlwZV9pbml0LFxuICBcdHJlYmluZDogRWxlbWVudF9wcm90b3R5cGVfcmViaW5kLFxuICBcdHJlbmRlcjogRWxlbWVudF9wcm90b3R5cGVfcmVuZGVyLFxuICBcdHRvU3RyaW5nOiBFbGVtZW50X3Byb3RvdHlwZV90b1N0cmluZyxcbiAgXHR1bmJpbmQ6IEVsZW1lbnRfcHJvdG90eXBlX3VuYmluZCxcbiAgXHR1bnJlbmRlcjogRWxlbWVudF9wcm90b3R5cGVfdW5yZW5kZXJcbiAgfTtcblxuICB2YXIgX0VsZW1lbnQgPSBFbGVtZW50O1xuXG4gIHZhciBkZUluZGVudF9fZW1wdHkgPSAvXlxccyokLyxcbiAgICAgIGRlSW5kZW50X19sZWFkaW5nV2hpdGVzcGFjZSA9IC9eXFxzKi87XG5cbiAgdmFyIGRlSW5kZW50ID0gZnVuY3Rpb24gKHN0cikge1xuICBcdHZhciBsaW5lcywgZmlyc3RMaW5lLCBsYXN0TGluZSwgbWluSW5kZW50O1xuXG4gIFx0bGluZXMgPSBzdHIuc3BsaXQoXCJcXG5cIik7XG5cbiAgXHQvLyByZW1vdmUgZmlyc3QgYW5kIGxhc3QgbGluZSwgaWYgdGhleSBvbmx5IGNvbnRhaW4gd2hpdGVzcGFjZVxuICBcdGZpcnN0TGluZSA9IGxpbmVzWzBdO1xuICBcdGlmIChmaXJzdExpbmUgIT09IHVuZGVmaW5lZCAmJiBkZUluZGVudF9fZW1wdHkudGVzdChmaXJzdExpbmUpKSB7XG4gIFx0XHRsaW5lcy5zaGlmdCgpO1xuICBcdH1cblxuICBcdGxhc3RMaW5lID0gbGFzdEl0ZW0obGluZXMpO1xuICBcdGlmIChsYXN0TGluZSAhPT0gdW5kZWZpbmVkICYmIGRlSW5kZW50X19lbXB0eS50ZXN0KGxhc3RMaW5lKSkge1xuICBcdFx0bGluZXMucG9wKCk7XG4gIFx0fVxuXG4gIFx0bWluSW5kZW50ID0gbGluZXMucmVkdWNlKHJlZHVjZXIsIG51bGwpO1xuXG4gIFx0aWYgKG1pbkluZGVudCkge1xuICBcdFx0c3RyID0gbGluZXMubWFwKGZ1bmN0aW9uIChsaW5lKSB7XG4gIFx0XHRcdHJldHVybiBsaW5lLnJlcGxhY2UobWluSW5kZW50LCBcIlwiKTtcbiAgXHRcdH0pLmpvaW4oXCJcXG5cIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHN0cjtcbiAgfTtcblxuICBmdW5jdGlvbiByZWR1Y2VyKHByZXZpb3VzLCBsaW5lKSB7XG4gIFx0dmFyIGxpbmVJbmRlbnQgPSBkZUluZGVudF9fbGVhZGluZ1doaXRlc3BhY2UuZXhlYyhsaW5lKVswXTtcblxuICBcdGlmIChwcmV2aW91cyA9PT0gbnVsbCB8fCBsaW5lSW5kZW50Lmxlbmd0aCA8IHByZXZpb3VzLmxlbmd0aCkge1xuICBcdFx0cmV0dXJuIGxpbmVJbmRlbnQ7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHByZXZpb3VzO1xuICB9XG5cbiAgdmFyIFBhcnRpYWxfZ2V0UGFydGlhbFRlbXBsYXRlID0gZ2V0UGFydGlhbFRlbXBsYXRlO1xuXG4gIGZ1bmN0aW9uIGdldFBhcnRpYWxUZW1wbGF0ZShyYWN0aXZlLCBuYW1lLCBwYXJlbnRGcmFnbWVudCkge1xuICBcdHZhciBwYXJ0aWFsO1xuXG4gIFx0Ly8gSWYgdGhlIHBhcnRpYWwgaW4gaW5zdGFuY2Ugb3IgdmlldyBoZWlyYXJjaHkgaW5zdGFuY2VzLCBncmVhdFxuICBcdGlmIChwYXJ0aWFsID0gZ2V0UGFydGlhbEZyb21SZWdpc3RyeShyYWN0aXZlLCBuYW1lLCBwYXJlbnRGcmFnbWVudCB8fCB7fSkpIHtcbiAgXHRcdHJldHVybiBwYXJ0aWFsO1xuICBcdH1cblxuICBcdC8vIERvZXMgaXQgZXhpc3Qgb24gdGhlIHBhZ2UgYXMgYSBzY3JpcHQgdGFnP1xuICBcdHBhcnRpYWwgPSB0ZW1wbGF0ZV9wYXJzZXIuZnJvbUlkKG5hbWUsIHsgbm9UaHJvdzogdHJ1ZSB9KTtcblxuICBcdGlmIChwYXJ0aWFsKSB7XG4gIFx0XHQvLyBpcyB0aGlzIG5lY2Vzc2FyeT9cbiAgXHRcdHBhcnRpYWwgPSBkZUluZGVudChwYXJ0aWFsKTtcblxuICBcdFx0Ly8gcGFyc2UgYW5kIHJlZ2lzdGVyIHRvIHRoaXMgcmFjdGl2ZSBpbnN0YW5jZVxuICBcdFx0dmFyIHBhcnNlZCA9IHRlbXBsYXRlX3BhcnNlci5wYXJzZShwYXJ0aWFsLCB0ZW1wbGF0ZV9wYXJzZXIuZ2V0UGFyc2VPcHRpb25zKHJhY3RpdmUpKTtcblxuICBcdFx0Ly8gcmVnaXN0ZXIgKGFuZCByZXR1cm4gbWFpbiBwYXJ0aWFsIGlmIHRoZXJlIGFyZSBvdGhlcnMgaW4gdGhlIHRlbXBsYXRlKVxuICBcdFx0cmV0dXJuIHJhY3RpdmUucGFydGlhbHNbbmFtZV0gPSBwYXJzZWQudDtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXJ0aWFsRnJvbVJlZ2lzdHJ5KHJhY3RpdmUsIG5hbWUsIHBhcmVudEZyYWdtZW50KSB7XG4gIFx0dmFyIGZuID0gdW5kZWZpbmVkLFxuICBcdCAgICBwYXJ0aWFsID0gZmluZFBhcmVudFBhcnRpYWwobmFtZSwgcGFyZW50RnJhZ21lbnQub3duZXIpO1xuXG4gIFx0Ly8gaWYgdGhlcmUgd2FzIGFuIGluc3RhbmNlIHVwLWhpZXJhcmNoeSwgY29vbFxuICBcdGlmIChwYXJ0aWFsKSByZXR1cm4gcGFydGlhbDtcblxuICBcdC8vIGZpbmQgZmlyc3QgaW5zdGFuY2UgaW4gdGhlIHJhY3RpdmUgb3IgdmlldyBoaWVyYXJjaHkgdGhhdCBoYXMgdGhpcyBwYXJ0aWFsXG4gIFx0dmFyIGluc3RhbmNlID0gZmluZEluc3RhbmNlKFwicGFydGlhbHNcIiwgcmFjdGl2ZSwgbmFtZSk7XG5cbiAgXHRpZiAoIWluc3RhbmNlKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0cGFydGlhbCA9IGluc3RhbmNlLnBhcnRpYWxzW25hbWVdO1xuXG4gIFx0Ly8gcGFydGlhbCBpcyBhIGZ1bmN0aW9uP1xuICBcdGlmICh0eXBlb2YgcGFydGlhbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRmbiA9IHBhcnRpYWwuYmluZChpbnN0YW5jZSk7XG4gIFx0XHRmbi5pc093bmVyID0gaW5zdGFuY2UucGFydGlhbHMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIFx0XHRwYXJ0aWFsID0gZm4uY2FsbChyYWN0aXZlLCB0ZW1wbGF0ZV9wYXJzZXIpO1xuICBcdH1cblxuICBcdGlmICghcGFydGlhbCAmJiBwYXJ0aWFsICE9PSBcIlwiKSB7XG4gIFx0XHR3YXJuSWZEZWJ1Zyhub1JlZ2lzdHJ5RnVuY3Rpb25SZXR1cm4sIG5hbWUsIFwicGFydGlhbFwiLCBcInBhcnRpYWxcIiwgeyByYWN0aXZlOiByYWN0aXZlIH0pO1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIElmIHRoaXMgd2FzIGFkZGVkIG1hbnVhbGx5IHRvIHRoZSByZWdpc3RyeSxcbiAgXHQvLyBidXQgaGFzbid0IGJlZW4gcGFyc2VkLCBwYXJzZSBpdCBub3dcbiAgXHRpZiAoIXRlbXBsYXRlX3BhcnNlci5pc1BhcnNlZChwYXJ0aWFsKSkge1xuXG4gIFx0XHQvLyB1c2UgdGhlIHBhcnNlT3B0aW9ucyBvZiB0aGUgcmFjdGl2ZSBpbnN0YW5jZSBvbiB3aGljaCBpdCB3YXMgZm91bmRcbiAgXHRcdHZhciBwYXJzZWQgPSB0ZW1wbGF0ZV9wYXJzZXIucGFyc2UocGFydGlhbCwgdGVtcGxhdGVfcGFyc2VyLmdldFBhcnNlT3B0aW9ucyhpbnN0YW5jZSkpO1xuXG4gIFx0XHQvLyBQYXJ0aWFscyBjYW5ub3QgY29udGFpbiBuZXN0ZWQgcGFydGlhbHMhXG4gIFx0XHQvLyBUT0RPIGFkZCBhIHRlc3QgZm9yIHRoaXNcbiAgXHRcdGlmIChwYXJzZWQucCkge1xuICBcdFx0XHR3YXJuSWZEZWJ1ZyhcIlBhcnRpYWxzICh7ez4lc319KSBjYW5ub3QgY29udGFpbiBuZXN0ZWQgaW5saW5lIHBhcnRpYWxzXCIsIG5hbWUsIHsgcmFjdGl2ZTogcmFjdGl2ZSB9KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gaWYgZm4sIHVzZSBpbnN0YW5jZSB0byBzdG9yZSByZXN1bHQsIG90aGVyd2lzZSBuZWVkcyB0byBnb1xuICBcdFx0Ly8gaW4gdGhlIGNvcnJlY3QgcG9pbnQgaW4gcHJvdG90eXBlIGNoYWluIG9uIGluc3RhbmNlIG9yIGNvbnN0cnVjdG9yXG4gIFx0XHR2YXIgdGFyZ2V0ID0gZm4gPyBpbnN0YW5jZSA6IGZpbmRPd25lcihpbnN0YW5jZSwgbmFtZSk7XG5cbiAgXHRcdC8vIG1heSBiZSBhIHRlbXBsYXRlIHdpdGggcGFydGlhbHMsIHdoaWNoIG5lZWQgdG8gYmUgcmVnaXN0ZXJlZCBhbmQgbWFpbiB0ZW1wbGF0ZSBleHRyYWN0ZWRcbiAgXHRcdHRhcmdldC5wYXJ0aWFsc1tuYW1lXSA9IHBhcnRpYWwgPSBwYXJzZWQudDtcbiAgXHR9XG5cbiAgXHQvLyBzdG9yZSBmb3IgcmVzZXRcbiAgXHRpZiAoZm4pIHtcbiAgXHRcdHBhcnRpYWwuX2ZuID0gZm47XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHBhcnRpYWwudiA/IHBhcnRpYWwudCA6IHBhcnRpYWw7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kT3duZXIocmFjdGl2ZSwga2V5KSB7XG4gIFx0cmV0dXJuIHJhY3RpdmUucGFydGlhbHMuaGFzT3duUHJvcGVydHkoa2V5KSA/IHJhY3RpdmUgOiBmaW5kQ29uc3RydWN0b3IocmFjdGl2ZS5jb25zdHJ1Y3Rvciwga2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRDb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvciwga2V5KSB7XG4gIFx0aWYgKCFjb25zdHJ1Y3Rvcikge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cbiAgXHRyZXR1cm4gY29uc3RydWN0b3IucGFydGlhbHMuaGFzT3duUHJvcGVydHkoa2V5KSA/IGNvbnN0cnVjdG9yIDogZmluZENvbnN0cnVjdG9yKGNvbnN0cnVjdG9yLl9QYXJlbnQsIGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kUGFyZW50UGFydGlhbChuYW1lLCBwYXJlbnQpIHtcbiAgXHRpZiAocGFyZW50KSB7XG4gIFx0XHRpZiAocGFyZW50LnRlbXBsYXRlICYmIHBhcmVudC50ZW1wbGF0ZS5wICYmIHBhcmVudC50ZW1wbGF0ZS5wW25hbWVdKSB7XG4gIFx0XHRcdHJldHVybiBwYXJlbnQudGVtcGxhdGUucFtuYW1lXTtcbiAgXHRcdH0gZWxzZSBpZiAocGFyZW50LnBhcmVudEZyYWdtZW50ICYmIHBhcmVudC5wYXJlbnRGcmFnbWVudC5vd25lcikge1xuICBcdFx0XHRyZXR1cm4gZmluZFBhcmVudFBhcnRpYWwobmFtZSwgcGFyZW50LnBhcmVudEZyYWdtZW50Lm93bmVyKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgYXBwbHlJbmRlbnQgPSBmdW5jdGlvbiAoc3RyaW5nLCBpbmRlbnQpIHtcbiAgXHR2YXIgaW5kZW50ZWQ7XG5cbiAgXHRpZiAoIWluZGVudCkge1xuICBcdFx0cmV0dXJuIHN0cmluZztcbiAgXHR9XG5cbiAgXHRpbmRlbnRlZCA9IHN0cmluZy5zcGxpdChcIlxcblwiKS5tYXAoZnVuY3Rpb24gKGxpbmUsIG5vdEZpcnN0TGluZSkge1xuICBcdFx0cmV0dXJuIG5vdEZpcnN0TGluZSA/IGluZGVudCArIGxpbmUgOiBsaW5lO1xuICBcdH0pLmpvaW4oXCJcXG5cIik7XG5cbiAgXHRyZXR1cm4gaW5kZW50ZWQ7XG4gIH07XG5cbiAgdmFyIG1pc3NpbmdQYXJ0aWFsTWVzc2FnZSA9IFwiQ291bGQgbm90IGZpbmQgdGVtcGxhdGUgZm9yIHBhcnRpYWwgXFxcIiVzXFxcIlwiO1xuXG4gIHZhciBQYXJ0aWFsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR2YXIgcGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlO1xuXG4gIFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcblxuICBcdHRoaXMucm9vdCA9IHBhcmVudEZyYWdtZW50LnJvb3Q7XG4gIFx0dGhpcy50eXBlID0gUEFSVElBTDtcbiAgXHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcbiAgXHR0aGlzLm5hbWUgPSBvcHRpb25zLnRlbXBsYXRlLnI7XG4gIFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuXG4gIFx0dGhpcy5mcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRUb1JlbmRlciA9IHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyID0gbnVsbDtcblxuICBcdE11c3RhY2hlLmluaXQodGhpcywgb3B0aW9ucyk7XG5cbiAgXHQvLyBJZiB0aGlzIGRpZG4ndCByZXNvbHZlLCBpdCBtb3N0IGxpa2VseSBtZWFucyB3ZSBoYXZlIGEgbmFtZWQgcGFydGlhbFxuICBcdC8vIChpLmUuIGB7ez5mb299fWAgbWVhbnMgJ3VzZSB0aGUgZm9vIHBhcnRpYWwnLCBub3QgJ3VzZSB0aGUgcGFydGlhbFxuICBcdC8vIHdob3NlIG5hbWUgaXMgdGhlIHZhbHVlIG9mIGBmb29gJylcbiAgXHRpZiAoIXRoaXMua2V5cGF0aCkge1xuICBcdFx0aWYgKHRlbXBsYXRlID0gUGFydGlhbF9nZXRQYXJ0aWFsVGVtcGxhdGUodGhpcy5yb290LCB0aGlzLm5hbWUsIHBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0XHRzaGFyZWRfdW5iaW5kLmNhbGwodGhpcyk7IC8vIHByZXZlbnQgYW55IGZ1cnRoZXIgY2hhbmdlc1xuICBcdFx0XHR0aGlzLmlzTmFtZWQgPSB0cnVlO1xuICBcdFx0XHR0aGlzLnNldFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhtaXNzaW5nUGFydGlhbE1lc3NhZ2UsIHRoaXMubmFtZSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIFBhcnRpYWwucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcbiAgXHR9LFxuXG4gIFx0ZGV0YWNoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5kZXRhY2goKTtcbiAgXHR9LFxuXG4gIFx0ZmluZDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kKHNlbGVjdG9yKTtcbiAgXHR9LFxuXG4gIFx0ZmluZEFsbDogZnVuY3Rpb24gKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbChzZWxlY3RvciwgcXVlcnkpO1xuICBcdH0sXG5cbiAgXHRmaW5kQ29tcG9uZW50OiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRDb21wb25lbnQoc2VsZWN0b3IpO1xuICBcdH0sXG5cbiAgXHRmaW5kQWxsQ29tcG9uZW50czogZnVuY3Rpb24gKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9LFxuXG4gIFx0Zmlyc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maXJzdE5vZGUoKTtcbiAgXHR9LFxuXG4gIFx0ZmluZE5leHROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUodGhpcyk7XG4gIFx0fSxcblxuICBcdGdldFBhcnRpYWxOYW1lOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5pc05hbWVkICYmIHRoaXMubmFtZSkgcmV0dXJuIHRoaXMubmFtZTtlbHNlIGlmICh0aGlzLnZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLm5hbWU7ZWxzZSByZXR1cm4gdGhpcy52YWx1ZTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCk7XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdC8vIG5hbWVkIHBhcnRpYWxzIGFyZW4ndCBib3VuZCwgc28gZG9uJ3QgcmViaW5kXG4gIFx0XHRpZiAoIXRoaXMuaXNOYW1lZCkge1xuICBcdFx0XHRNdXN0YWNoZV9yZWJpbmQuY2FsbCh0aGlzLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5kb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBcdFx0dGhpcy51cGRhdGUoKTtcblxuICBcdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gIFx0XHRyZXR1cm4gdGhpcy5kb2NGcmFnO1xuICBcdH0sXG5cbiAgXHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuXG4gIFx0c2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0dmFyIHRlbXBsYXRlO1xuXG4gIFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA9PT0gdGhpcy52YWx1ZSkge1xuICBcdFx0XHQvLyBub3RoaW5nIGhhcyBjaGFuZ2VkLCBzbyBubyB3b3JrIHRvIGJlIGRvbmVcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0ZW1wbGF0ZSA9IFBhcnRpYWxfZ2V0UGFydGlhbFRlbXBsYXRlKHRoaXMucm9vdCwgXCJcIiArIHZhbHVlLCB0aGlzLnBhcmVudEZyYWdtZW50KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gd2UgbWF5IGJlIGhlcmUgaWYgd2UgaGF2ZSBhIHBhcnRpYWwgbGlrZSBge3s+Zm9vfX1gIGFuZCBgZm9vYCBpcyB0aGVcbiAgXHRcdC8vIG5hbWUgb2YgYm90aCBhIGRhdGEgcHJvcGVydHkgKHdob3NlIHZhbHVlIElTTidUIHRoZSBuYW1lIG9mIGEgcGFydGlhbClcbiAgXHRcdC8vIGFuZCBhIHBhcnRpYWwuIEluIHRob3NlIGNhc2VzLCB0aGlzIGJlY29tZXMgYSBuYW1lZCBwYXJ0aWFsXG4gIFx0XHRpZiAoIXRlbXBsYXRlICYmIHRoaXMubmFtZSAmJiAodGVtcGxhdGUgPSBQYXJ0aWFsX2dldFBhcnRpYWxUZW1wbGF0ZSh0aGlzLnJvb3QsIHRoaXMubmFtZSwgdGhpcy5wYXJlbnRGcmFnbWVudCkpKSB7XG4gIFx0XHRcdHNoYXJlZF91bmJpbmQuY2FsbCh0aGlzKTtcbiAgXHRcdFx0dGhpcy5pc05hbWVkID0gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCF0ZW1wbGF0ZSkge1xuICBcdFx0XHR3YXJuT25jZUlmRGVidWcobWlzc2luZ1BhcnRpYWxNZXNzYWdlLCB0aGlzLm5hbWUsIHsgcmFjdGl2ZTogdGhpcy5yb290IH0pO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cbiAgXHRcdHRoaXMuc2V0VGVtcGxhdGUodGVtcGxhdGUgfHwgW10pO1xuXG4gIFx0XHR0aGlzLmJ1YmJsZSgpO1xuXG4gIFx0XHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRWaWV3KHRoaXMpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRzZXRUZW1wbGF0ZTogZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gIFx0XHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdFx0XHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0XHRcdHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyID0gdGhpcy5mcmFnbWVudDtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gIFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcbiAgXHRcdFx0b3duZXI6IHRoaXMsXG4gIFx0XHRcdHBFbGVtZW50OiB0aGlzLnBhcmVudEZyYWdtZW50LnBFbGVtZW50XG4gIFx0XHR9KTtcblxuICBcdFx0dGhpcy5mcmFnbWVudFRvUmVuZGVyID0gdGhpcy5mcmFnbWVudDtcbiAgXHR9LFxuXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uICh0b1N0cmluZykge1xuICBcdFx0dmFyIHN0cmluZywgcHJldmlvdXNJdGVtLCBsYXN0TGluZSwgbWF0Y2g7XG5cbiAgXHRcdHN0cmluZyA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcodG9TdHJpbmcpO1xuXG4gIFx0XHRwcmV2aW91c0l0ZW0gPSB0aGlzLnBhcmVudEZyYWdtZW50Lml0ZW1zW3RoaXMuaW5kZXggLSAxXTtcblxuICBcdFx0aWYgKCFwcmV2aW91c0l0ZW0gfHwgcHJldmlvdXNJdGVtLnR5cGUgIT09IFRFWFQpIHtcbiAgXHRcdFx0cmV0dXJuIHN0cmluZztcbiAgXHRcdH1cblxuICBcdFx0bGFzdExpbmUgPSBwcmV2aW91c0l0ZW0udGV4dC5zcGxpdChcIlxcblwiKS5wb3AoKTtcblxuICBcdFx0aWYgKG1hdGNoID0gL15cXHMrJC8uZXhlYyhsYXN0TGluZSkpIHtcbiAgXHRcdFx0cmV0dXJuIGFwcGx5SW5kZW50KHN0cmluZywgbWF0Y2hbMF0pO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gc3RyaW5nO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5pc05hbWVkKSB7XG4gIFx0XHRcdC8vIGR5bmFtaWMgcGFydGlhbCAtIG5lZWQgdG8gdW5iaW5kIHNlbGZcbiAgXHRcdFx0c2hhcmVkX3VuYmluZC5jYWxsKHRoaXMpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlcihzaG91bGREZXN0cm95KTtcbiAgXHRcdFx0fVxuICBcdFx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHRhcmdldCwgYW5jaG9yO1xuXG4gIFx0XHRpZiAodGhpcy5mcmFnbWVudFRvVW5yZW5kZXIpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudFRvVW5yZW5kZXIudW5yZW5kZXIodHJ1ZSk7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyID0gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnRUb1JlbmRlcikge1xuICBcdFx0XHR0aGlzLmRvY0ZyYWcuYXBwZW5kQ2hpbGQodGhpcy5mcmFnbWVudFRvUmVuZGVyLnJlbmRlcigpKTtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudFRvUmVuZGVyID0gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdFx0dGFyZ2V0ID0gdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCk7XG4gIFx0XHRcdGFuY2hvciA9IHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICBcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuZG9jRnJhZywgYW5jaG9yKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIF9QYXJ0aWFsID0gUGFydGlhbDtcblxuICAvLyBmaW5kcyB0aGUgY29tcG9uZW50IGNvbnN0cnVjdG9yIGluIHRoZSByZWdpc3RyeSBvciB2aWV3IGhpZXJhcmNoeSByZWdpc3RyaWVzXG5cbiAgdmFyIENvbXBvbmVudF9nZXRDb21wb25lbnQgPSBnZXRDb21wb25lbnQ7XG4gIGZ1bmN0aW9uIGdldENvbXBvbmVudChyYWN0aXZlLCBuYW1lKSB7XG5cbiAgXHR2YXIgQ29tcG9uZW50LFxuICBcdCAgICBpbnN0YW5jZSA9IGZpbmRJbnN0YW5jZShcImNvbXBvbmVudHNcIiwgcmFjdGl2ZSwgbmFtZSk7XG5cbiAgXHRpZiAoaW5zdGFuY2UpIHtcbiAgXHRcdENvbXBvbmVudCA9IGluc3RhbmNlLmNvbXBvbmVudHNbbmFtZV07XG5cbiAgXHRcdC8vIGJlc3QgdGVzdCB3ZSBoYXZlIGZvciBub3QgUmFjdGl2ZS5leHRlbmRcbiAgXHRcdGlmICghQ29tcG9uZW50Ll9QYXJlbnQpIHtcbiAgXHRcdFx0Ly8gZnVuY3Rpb24gb3B0aW9uLCBleGVjdXRlIGFuZCBzdG9yZSBmb3IgcmVzZXRcbiAgXHRcdFx0dmFyIGZuID0gQ29tcG9uZW50LmJpbmQoaW5zdGFuY2UpO1xuICBcdFx0XHRmbi5pc093bmVyID0gaW5zdGFuY2UuY29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgXHRcdFx0Q29tcG9uZW50ID0gZm4oKTtcblxuICBcdFx0XHRpZiAoIUNvbXBvbmVudCkge1xuICBcdFx0XHRcdHdhcm5JZkRlYnVnKG5vUmVnaXN0cnlGdW5jdGlvblJldHVybiwgbmFtZSwgXCJjb21wb25lbnRcIiwgXCJjb21wb25lbnRcIiwgeyByYWN0aXZlOiByYWN0aXZlIH0pO1xuXG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKHR5cGVvZiBDb21wb25lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0XHQvLyBhbGxvdyBzdHJpbmcgbG9va3VwXG4gIFx0XHRcdFx0Q29tcG9uZW50ID0gZ2V0Q29tcG9uZW50KHJhY3RpdmUsIENvbXBvbmVudCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRDb21wb25lbnQuX2ZuID0gZm47XG4gIFx0XHRcdGluc3RhbmNlLmNvbXBvbmVudHNbbmFtZV0gPSBDb21wb25lbnQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIENvbXBvbmVudDtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2RldGFjaCA9IENvbXBvbmVudCRkZXRhY2g7XG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2RldGFjaF9fZGV0YWNoSG9vayA9IG5ldyBob29rc19Ib29rKFwiZGV0YWNoXCIpO1xuICBmdW5jdGlvbiBDb21wb25lbnQkZGV0YWNoKCkge1xuICBcdHZhciBkZXRhY2hlZCA9IHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZGV0YWNoKCk7XG4gIFx0Q29tcG9uZW50X3Byb3RvdHlwZV9kZXRhY2hfX2RldGFjaEhvb2suZmlyZSh0aGlzLmluc3RhbmNlKTtcbiAgXHRyZXR1cm4gZGV0YWNoZWQ7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kID0gQ29tcG9uZW50JGZpbmQ7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JGZpbmQoc2VsZWN0b3IpIHtcbiAgXHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kKHNlbGVjdG9yKTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmRBbGwgPSBDb21wb25lbnQkZmluZEFsbDtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkZmluZEFsbChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kQWxsKHNlbGVjdG9yLCBxdWVyeSk7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyA9IENvbXBvbmVudCRmaW5kQWxsQ29tcG9uZW50cztcblxuICBmdW5jdGlvbiBDb21wb25lbnQkZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0cXVlcnkuX3Rlc3QodGhpcywgdHJ1ZSk7XG5cbiAgXHRpZiAodGhpcy5pbnN0YW5jZS5mcmFnbWVudCkge1xuICBcdFx0dGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmRDb21wb25lbnQgPSBDb21wb25lbnQkZmluZENvbXBvbmVudDtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkZmluZENvbXBvbmVudChzZWxlY3Rvcikge1xuICBcdGlmICghc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IHRoaXMubmFtZSkge1xuICBcdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQpIHtcbiAgXHRcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpbmRDb21wb25lbnQoc2VsZWN0b3IpO1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfZmluZE5leHROb2RlID0gQ29tcG9uZW50JGZpbmROZXh0Tm9kZTtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkZmluZE5leHROb2RlKCkge1xuICBcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2ZpcnN0Tm9kZSA9IENvbXBvbmVudCRmaXJzdE5vZGU7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JGZpcnN0Tm9kZSgpIHtcbiAgXHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmlyc3ROb2RlKCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcHJvY2Vzc1dyYXBwZXIgPSBmdW5jdGlvbiAod3JhcHBlciwgYXJyYXksIG1ldGhvZE5hbWUsIG5ld0luZGljZXMpIHtcbiAgXHR2YXIgcm9vdCA9IHdyYXBwZXIucm9vdDtcbiAgXHR2YXIga2V5cGF0aCA9IHdyYXBwZXIua2V5cGF0aDtcblxuICBcdGlmICghIW5ld0luZGljZXMpIHtcbiAgXHRcdHJvb3Qudmlld21vZGVsLnNtYXJ0VXBkYXRlKGtleXBhdGgsIGFycmF5LCBuZXdJbmRpY2VzKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0Ly8gSWYgdGhpcyBpcyBhIHNvcnQgb3IgcmV2ZXJzZSwgd2UganVzdCBkbyByb290LnNldCgpLi4uXG4gIFx0XHQvLyBUT0RPIHVzZSBtZXJnZSBsb2dpYz9cbiAgXHRcdHJvb3Qudmlld21vZGVsLm1hcmsoa2V5cGF0aCk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBwYXRjaGVkQXJyYXlQcm90byA9IFtdLFxuICAgICAgbXV0YXRvck1ldGhvZHMgPSBbXCJwb3BcIiwgXCJwdXNoXCIsIFwicmV2ZXJzZVwiLCBcInNoaWZ0XCIsIFwic29ydFwiLCBcInNwbGljZVwiLCBcInVuc2hpZnRcIl0sXG4gICAgICB0ZXN0T2JqLFxuICAgICAgcGF0Y2hBcnJheU1ldGhvZHMsXG4gICAgICB1bnBhdGNoQXJyYXlNZXRob2RzO1xuXG4gIG11dGF0b3JNZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgXHR2YXIgbWV0aG9kID0gZnVuY3Rpb24gKCkge1xuICBcdFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdFx0YXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIG5ld0luZGljZXMsIHJlc3VsdCwgd3JhcHBlciwgaTtcblxuICBcdFx0bmV3SW5kaWNlcyA9IHNoYXJlZF9nZXROZXdJbmRpY2VzKHRoaXMsIG1ldGhvZE5hbWUsIGFyZ3MpO1xuXG4gIFx0XHQvLyBhcHBseSB0aGUgdW5kZXJseWluZyBtZXRob2RcbiAgXHRcdHJlc3VsdCA9IEFycmF5LnByb3RvdHlwZVttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIFx0XHQvLyB0cmlnZ2VyIGNoYW5nZXNcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KCk7XG5cbiAgXHRcdHRoaXMuX3JhY3RpdmUuc2V0dGluZyA9IHRydWU7XG4gIFx0XHRpID0gdGhpcy5fcmFjdGl2ZS53cmFwcGVycy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdHdyYXBwZXIgPSB0aGlzLl9yYWN0aXZlLndyYXBwZXJzW2ldO1xuXG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFJhY3RpdmUod3JhcHBlci5yb290KTtcbiAgXHRcdFx0cHJvY2Vzc1dyYXBwZXIod3JhcHBlciwgdGhpcywgbWV0aG9kTmFtZSwgbmV3SW5kaWNlcyk7XG4gIFx0XHR9XG5cbiAgXHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0XHR0aGlzLl9yYWN0aXZlLnNldHRpbmcgPSBmYWxzZTtcbiAgXHRcdHJldHVybiByZXN1bHQ7XG4gIFx0fTtcblxuICBcdGRlZmluZVByb3BlcnR5KHBhdGNoZWRBcnJheVByb3RvLCBtZXRob2ROYW1lLCB7XG4gIFx0XHR2YWx1ZTogbWV0aG9kXG4gIFx0fSk7XG4gIH0pO1xuXG4gIC8vIGNhbiB3ZSB1c2UgcHJvdG90eXBlIGNoYWluIGluamVjdGlvbj9cbiAgLy8gaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vaG93LWVjbWFzY3JpcHQtNS1zdGlsbC1kb2VzLW5vdC1hbGxvdy10by1zdWJjbGFzcy1hbi1hcnJheS8jd3JhcHBlcnNfcHJvdG90eXBlX2NoYWluX2luamVjdGlvblxuICB0ZXN0T2JqID0ge307XG5cbiAgaWYgKHRlc3RPYmouX19wcm90b19fKSB7XG4gIFx0Ly8geWVzLCB3ZSBjYW5cbiAgXHRwYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uIChhcnJheSkge1xuICBcdFx0YXJyYXkuX19wcm90b19fID0gcGF0Y2hlZEFycmF5UHJvdG87XG4gIFx0fTtcblxuICBcdHVucGF0Y2hBcnJheU1ldGhvZHMgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgXHRcdGFycmF5Ll9fcHJvdG9fXyA9IEFycmF5LnByb3RvdHlwZTtcbiAgXHR9O1xuICB9IGVsc2Uge1xuICBcdC8vIG5vLCB3ZSBjYW4ndFxuICBcdHBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gIFx0XHR2YXIgaSwgbWV0aG9kTmFtZTtcblxuICBcdFx0aSA9IG11dGF0b3JNZXRob2RzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0bWV0aG9kTmFtZSA9IG11dGF0b3JNZXRob2RzW2ldO1xuICBcdFx0XHRkZWZpbmVQcm9wZXJ0eShhcnJheSwgbWV0aG9kTmFtZSwge1xuICBcdFx0XHRcdHZhbHVlOiBwYXRjaGVkQXJyYXlQcm90b1ttZXRob2ROYW1lXSxcbiAgXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdHVucGF0Y2hBcnJheU1ldGhvZHMgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgXHRcdHZhciBpO1xuXG4gIFx0XHRpID0gbXV0YXRvck1ldGhvZHMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRkZWxldGUgYXJyYXlbbXV0YXRvck1ldGhvZHNbaV1dO1xuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICBwYXRjaEFycmF5TWV0aG9kcy51bnBhdGNoID0gdW5wYXRjaEFycmF5TWV0aG9kcztcbiAgdmFyIHBhdGNoID0gcGF0Y2hBcnJheU1ldGhvZHM7XG5cbiAgdmFyIGFycmF5QWRhcHRvcixcblxuICAvLyBoZWxwZXJzXG4gIEFycmF5V3JhcHBlciwgYXJyYXlfaW5kZXhfX2Vycm9yTWVzc2FnZTtcblxuICBhcnJheUFkYXB0b3IgPSB7XG4gIFx0ZmlsdGVyOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIFx0XHQvLyB3cmFwIHRoZSBhcnJheSBpZiBhKSBiKSBpdCdzIGFuIGFycmF5LCBhbmQgYikgZWl0aGVyIGl0IGhhc24ndCBiZWVuIHdyYXBwZWQgYWxyZWFkeSxcbiAgXHRcdC8vIG9yIHRoZSBhcnJheSBkaWRuJ3QgdHJpZ2dlciB0aGUgZ2V0KCkgaXRzZWxmXG4gIFx0XHRyZXR1cm4gaXNBcnJheShvYmplY3QpICYmICghb2JqZWN0Ll9yYWN0aXZlIHx8ICFvYmplY3QuX3JhY3RpdmUuc2V0dGluZyk7XG4gIFx0fSxcbiAgXHR3cmFwOiBmdW5jdGlvbiAocmFjdGl2ZSwgYXJyYXksIGtleXBhdGgpIHtcbiAgXHRcdHJldHVybiBuZXcgQXJyYXlXcmFwcGVyKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKTtcbiAgXHR9XG4gIH07XG5cbiAgQXJyYXlXcmFwcGVyID0gZnVuY3Rpb24gKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKSB7XG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcbiAgXHR0aGlzLnZhbHVlID0gYXJyYXk7XG4gIFx0dGhpcy5rZXlwYXRoID0gZ2V0S2V5cGF0aChrZXlwYXRoKTtcblxuICBcdC8vIGlmIHRoaXMgYXJyYXkgaGFzbid0IGFscmVhZHkgYmVlbiByYWN0aWZpZWQsIHJhY3RpZnkgaXRcbiAgXHRpZiAoIWFycmF5Ll9yYWN0aXZlKSB7XG5cbiAgXHRcdC8vIGRlZmluZSBhIG5vbi1lbnVtZXJhYmxlIF9yYWN0aXZlIHByb3BlcnR5IHRvIHN0b3JlIHRoZSB3cmFwcGVyc1xuICBcdFx0ZGVmaW5lUHJvcGVydHkoYXJyYXksIFwiX3JhY3RpdmVcIiwge1xuICBcdFx0XHR2YWx1ZToge1xuICBcdFx0XHRcdHdyYXBwZXJzOiBbXSxcbiAgXHRcdFx0XHRpbnN0YW5jZXM6IFtdLFxuICBcdFx0XHRcdHNldHRpbmc6IGZhbHNlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICBcdFx0fSk7XG5cbiAgXHRcdHBhdGNoKGFycmF5KTtcbiAgXHR9XG5cbiAgXHQvLyBzdG9yZSB0aGUgcmFjdGl2ZSBpbnN0YW5jZSwgc28gd2UgY2FuIGhhbmRsZSB0cmFuc2l0aW9ucyBsYXRlclxuICBcdGlmICghYXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzW3JhY3RpdmUuX2d1aWRdKSB7XG4gIFx0XHRhcnJheS5fcmFjdGl2ZS5pbnN0YW5jZXNbcmFjdGl2ZS5fZ3VpZF0gPSAwO1xuICBcdFx0YXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzLnB1c2gocmFjdGl2ZSk7XG4gIFx0fVxuXG4gIFx0YXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzW3JhY3RpdmUuX2d1aWRdICs9IDE7XG4gIFx0YXJyYXkuX3JhY3RpdmUud3JhcHBlcnMucHVzaCh0aGlzKTtcbiAgfTtcblxuICBBcnJheVdyYXBwZXIucHJvdG90eXBlID0ge1xuICBcdGdldDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIFx0fSxcbiAgXHR0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGFycmF5LCBzdG9yYWdlLCB3cmFwcGVycywgaW5zdGFuY2VzLCBpbmRleDtcblxuICBcdFx0YXJyYXkgPSB0aGlzLnZhbHVlO1xuICBcdFx0c3RvcmFnZSA9IGFycmF5Ll9yYWN0aXZlO1xuICBcdFx0d3JhcHBlcnMgPSBzdG9yYWdlLndyYXBwZXJzO1xuICBcdFx0aW5zdGFuY2VzID0gc3RvcmFnZS5pbnN0YW5jZXM7XG5cbiAgXHRcdC8vIGlmIHRlYXJkb3duKCkgd2FzIGludm9rZWQgYmVjYXVzZSB3ZSdyZSBjbGVhcmluZyB0aGUgY2FjaGUgYXMgYSByZXN1bHQgb2ZcbiAgXHRcdC8vIGEgY2hhbmdlIHRoYXQgdGhlIGFycmF5IGl0c2VsZiB0cmlnZ2VyZWQsIHdlIGNhbiBzYXZlIG91cnNlbHZlcyB0aGUgdGVhcmRvd25cbiAgXHRcdC8vIGFuZCBpbW1lZGlhdGUgc2V0dXBcbiAgXHRcdGlmIChzdG9yYWdlLnNldHRpbmcpIHtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBzbyB0aGF0IHdlIGRvbid0IHJlbW92ZSBpdCBmcm9tIHRoaXMucm9vdC52aWV3bW9kZWwud3JhcHBlZFxuICBcdFx0fVxuXG4gIFx0XHRpbmRleCA9IHdyYXBwZXJzLmluZGV4T2YodGhpcyk7XG4gIFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihhcnJheV9pbmRleF9fZXJyb3JNZXNzYWdlKTtcbiAgXHRcdH1cblxuICBcdFx0d3JhcHBlcnMuc3BsaWNlKGluZGV4LCAxKTtcblxuICBcdFx0Ly8gaWYgbm90aGluZyBlbHNlIGRlcGVuZHMgb24gdGhpcyBhcnJheSwgd2UgY2FuIHJldmVydCBpdCB0byBpdHNcbiAgXHRcdC8vIG5hdHVyYWwgc3RhdGVcbiAgXHRcdGlmICghd3JhcHBlcnMubGVuZ3RoKSB7XG4gIFx0XHRcdGRlbGV0ZSBhcnJheS5fcmFjdGl2ZTtcbiAgXHRcdFx0cGF0Y2gudW5wYXRjaCh0aGlzLnZhbHVlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdC8vIHJlbW92ZSByYWN0aXZlIGluc3RhbmNlIGlmIHBvc3NpYmxlXG4gIFx0XHRcdGluc3RhbmNlc1t0aGlzLnJvb3QuX2d1aWRdIC09IDE7XG4gIFx0XHRcdGlmICghaW5zdGFuY2VzW3RoaXMucm9vdC5fZ3VpZF0pIHtcbiAgXHRcdFx0XHRpbmRleCA9IGluc3RhbmNlcy5pbmRleE9mKHRoaXMucm9vdCk7XG5cbiAgXHRcdFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYXJyYXlfaW5kZXhfX2Vycm9yTWVzc2FnZSk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0aW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgYXJyYXlfaW5kZXhfX2Vycm9yTWVzc2FnZSA9IFwiU29tZXRoaW5nIHdlbnQgd3JvbmcgaW4gYSByYXRoZXIgaW50ZXJlc3Rpbmcgd2F5XCI7XG4gIHZhciBhcnJheV9pbmRleCA9IGFycmF5QWRhcHRvcjtcblxuICB2YXIgbnVtZXJpYyA9IC9eXFxzKlswLTldK1xccyokLztcblxuICB2YXIgY3JlYXRlQnJhbmNoID0gZnVuY3Rpb24gKGtleSkge1xuICBcdHJldHVybiBudW1lcmljLnRlc3Qoa2V5KSA/IFtdIDoge307XG4gIH07XG5cbiAgdmFyIG1hZ2ljQWRhcHRvciwgTWFnaWNXcmFwcGVyO1xuXG4gIHRyeSB7XG4gIFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInRlc3RcIiwgeyB2YWx1ZTogMCB9KTtcblxuICBcdG1hZ2ljQWRhcHRvciA9IHtcbiAgXHRcdGZpbHRlcjogZnVuY3Rpb24gKG9iamVjdCwga2V5cGF0aCwgcmFjdGl2ZSkge1xuICBcdFx0XHR2YXIgcGFyZW50V3JhcHBlciwgcGFyZW50VmFsdWU7XG5cbiAgXHRcdFx0aWYgKCFrZXlwYXRoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0a2V5cGF0aCA9IGdldEtleXBhdGgoa2V5cGF0aCk7XG5cbiAgXHRcdFx0Ly8gSWYgdGhlIHBhcmVudCB2YWx1ZSBpcyBhIHdyYXBwZXIsIG90aGVyIHRoYW4gYSBtYWdpYyB3cmFwcGVyLFxuICBcdFx0XHQvLyB3ZSBzaG91bGRuJ3Qgd3JhcCB0aGlzIHByb3BlcnR5XG4gIFx0XHRcdGlmICgocGFyZW50V3JhcHBlciA9IHJhY3RpdmUudmlld21vZGVsLndyYXBwZWRba2V5cGF0aC5wYXJlbnQuc3RyXSkgJiYgIXBhcmVudFdyYXBwZXIubWFnaWMpIHtcbiAgXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRwYXJlbnRWYWx1ZSA9IHJhY3RpdmUudmlld21vZGVsLmdldChrZXlwYXRoLnBhcmVudCk7XG5cbiAgXHRcdFx0Ly8gaWYgcGFyZW50VmFsdWUgaXMgYW4gYXJyYXkgdGhhdCBkb2Vzbid0IGluY2x1ZGUgdGhpcyBtZW1iZXIsXG4gIFx0XHRcdC8vIHdlIHNob3VsZCByZXR1cm4gZmFsc2Ugb3RoZXJ3aXNlIGxlbmd0aHMgd2lsbCBnZXQgbWVzc2VkIHVwXG4gIFx0XHRcdGlmIChpc0FycmF5KHBhcmVudFZhbHVlKSAmJiAvXlswLTldKyQvLnRlc3Qoa2V5cGF0aC5sYXN0S2V5KSkge1xuICBcdFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBwYXJlbnRWYWx1ZSAmJiAodHlwZW9mIHBhcmVudFZhbHVlID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKTtcbiAgXHRcdH0sXG4gIFx0XHR3cmFwOiBmdW5jdGlvbiAocmFjdGl2ZSwgcHJvcGVydHksIGtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIG5ldyBNYWdpY1dyYXBwZXIocmFjdGl2ZSwgcHJvcGVydHksIGtleXBhdGgpO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRNYWdpY1dyYXBwZXIgPSBmdW5jdGlvbiAocmFjdGl2ZSwgdmFsdWUsIGtleXBhdGgpIHtcbiAgXHRcdHZhciBvYmpLZXlwYXRoLCB0ZW1wbGF0ZSwgc2libGluZ3M7XG5cbiAgXHRcdGtleXBhdGggPSBnZXRLZXlwYXRoKGtleXBhdGgpO1xuXG4gIFx0XHR0aGlzLm1hZ2ljID0gdHJ1ZTtcblxuICBcdFx0dGhpcy5yYWN0aXZlID0gcmFjdGl2ZTtcbiAgXHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cbiAgXHRcdHRoaXMucHJvcCA9IGtleXBhdGgubGFzdEtleTtcblxuICBcdFx0b2JqS2V5cGF0aCA9IGtleXBhdGgucGFyZW50O1xuICBcdFx0dGhpcy5vYmogPSBvYmpLZXlwYXRoLmlzUm9vdCA/IHJhY3RpdmUudmlld21vZGVsLmRhdGEgOiByYWN0aXZlLnZpZXdtb2RlbC5nZXQob2JqS2V5cGF0aCk7XG5cbiAgXHRcdHRlbXBsYXRlID0gdGhpcy5vcmlnaW5hbERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMub2JqLCB0aGlzLnByb3ApO1xuXG4gIFx0XHQvLyBIYXMgdGhpcyBwcm9wZXJ0eSBhbHJlYWR5IGJlZW4gd3JhcHBlZD9cbiAgXHRcdGlmICh0ZW1wbGF0ZSAmJiB0ZW1wbGF0ZS5zZXQgJiYgKHNpYmxpbmdzID0gdGVtcGxhdGUuc2V0Ll9yYWN0aXZlV3JhcHBlcnMpKSB7XG5cbiAgXHRcdFx0Ly8gWWVzLiBSZWdpc3RlciB0aGlzIHdyYXBwZXIgdG8gdGhpcyBwcm9wZXJ0eSwgaWYgaXQgaGFzbid0IGJlZW4gYWxyZWFkeVxuICBcdFx0XHRpZiAoc2libGluZ3MuaW5kZXhPZih0aGlzKSA9PT0gLTEpIHtcbiAgXHRcdFx0XHRzaWJsaW5ncy5wdXNoKHRoaXMpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuOyAvLyBhbHJlYWR5IHdyYXBwZWRcbiAgXHRcdH1cblxuICBcdFx0Ly8gTm8sIGl0IGhhc24ndCBiZWVuIHdyYXBwZWRcbiAgXHRcdGNyZWF0ZUFjY2Vzc29ycyh0aGlzLCB2YWx1ZSwgdGVtcGxhdGUpO1xuICBcdH07XG5cbiAgXHRNYWdpY1dyYXBwZXIucHJvdG90eXBlID0ge1xuICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLnZhbHVlO1xuICBcdFx0fSxcbiAgXHRcdHJlc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdFx0aWYgKHRoaXMudXBkYXRpbmcpIHtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcbiAgXHRcdFx0dGhpcy5vYmpbdGhpcy5wcm9wXSA9IHZhbHVlOyAvLyB0cmlnZ2VyIHNldCgpIGFjY2Vzc29yXG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFJhY3RpdmUodGhpcy5yYWN0aXZlKTtcbiAgXHRcdFx0dGhpcy5yYWN0aXZlLnZpZXdtb2RlbC5tYXJrKHRoaXMua2V5cGF0aCwgeyBrZWVwRXhpc3RpbmdXcmFwcGVyOiB0cnVlIH0pO1xuICBcdFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG4gIFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0fSxcbiAgXHRcdHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgXHRcdFx0aWYgKHRoaXMudXBkYXRpbmcpIHtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIXRoaXMub2JqW3RoaXMucHJvcF0pIHtcbiAgXHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcbiAgXHRcdFx0XHR0aGlzLm9ialt0aGlzLnByb3BdID0gY3JlYXRlQnJhbmNoKGtleSk7XG4gIFx0XHRcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGhpcy5vYmpbdGhpcy5wcm9wXVtrZXldID0gdmFsdWU7XG4gIFx0XHR9LFxuICBcdFx0dGVhcmRvd246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dmFyIHRlbXBsYXRlLCBzZXQsIHZhbHVlLCB3cmFwcGVycywgaW5kZXg7XG5cbiAgXHRcdFx0Ly8gSWYgdGhpcyBtZXRob2Qgd2FzIGNhbGxlZCBiZWNhdXNlIHRoZSBjYWNoZSB3YXMgYmVpbmcgY2xlYXJlZCBhcyBhXG4gIFx0XHRcdC8vIHJlc3VsdCBvZiBhIHNldCgpL3VwZGF0ZSgpIGNhbGwgbWFkZSBieSB0aGlzIHdyYXBwZXIsIHdlIHJldHVybiBmYWxzZVxuICBcdFx0XHQvLyBzbyB0aGF0IGl0IGRvZXNuJ3QgZ2V0IHRvcm4gZG93blxuICBcdFx0XHRpZiAodGhpcy51cGRhdGluZykge1xuICBcdFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRlbXBsYXRlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLm9iaiwgdGhpcy5wcm9wKTtcbiAgXHRcdFx0c2V0ID0gdGVtcGxhdGUgJiYgdGVtcGxhdGUuc2V0O1xuXG4gIFx0XHRcdGlmICghc2V0KSB7XG4gIFx0XHRcdFx0Ly8gbW9zdCBsaWtlbHksIHRoaXMgd2FzIGFuIGFycmF5IG1lbWJlciB0aGF0IHdhcyBzcGxpY2VkIG91dFxuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHdyYXBwZXJzID0gc2V0Ll9yYWN0aXZlV3JhcHBlcnM7XG5cbiAgXHRcdFx0aW5kZXggPSB3cmFwcGVycy5pbmRleE9mKHRoaXMpO1xuICBcdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG4gIFx0XHRcdFx0d3JhcHBlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIExhc3Qgb25lIG91dCwgdHVybiBvZmYgdGhlIGxpZ2h0c1xuICBcdFx0XHRpZiAoIXdyYXBwZXJzLmxlbmd0aCkge1xuICBcdFx0XHRcdHZhbHVlID0gdGhpcy5vYmpbdGhpcy5wcm9wXTtcblxuICBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLm9iaiwgdGhpcy5wcm9wLCB0aGlzLm9yaWdpbmFsRGVzY3JpcHRvciB8fCB7XG4gIFx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcbiAgXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gIFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcbiAgXHRcdFx0XHR9KTtcblxuICBcdFx0XHRcdHRoaXMub2JqW3RoaXMucHJvcF0gPSB2YWx1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH07XG4gIH0gY2F0Y2ggKGVycikge1xuICBcdG1hZ2ljQWRhcHRvciA9IGZhbHNlOyAvLyBubyBtYWdpYyBpbiB0aGlzIGJyb3dzZXJcbiAgfVxuXG4gIHZhciBhZGFwdG9yc19tYWdpYyA9IG1hZ2ljQWRhcHRvcjtcblxuICBmdW5jdGlvbiBjcmVhdGVBY2Nlc3NvcnMob3JpZ2luYWxXcmFwcGVyLCB2YWx1ZSwgdGVtcGxhdGUpIHtcblxuICBcdHZhciBvYmplY3QsIHByb3BlcnR5LCBvbGRHZXQsIG9sZFNldCwgZ2V0LCBzZXQ7XG5cbiAgXHRvYmplY3QgPSBvcmlnaW5hbFdyYXBwZXIub2JqO1xuICBcdHByb3BlcnR5ID0gb3JpZ2luYWxXcmFwcGVyLnByb3A7XG5cbiAgXHQvLyBJcyB0aGlzIHRlbXBsYXRlIGNvbmZpZ3VyYWJsZT9cbiAgXHRpZiAodGVtcGxhdGUgJiYgIXRlbXBsYXRlLmNvbmZpZ3VyYWJsZSkge1xuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gYXJyYXkgbGVuZ3RoXG4gIFx0XHRpZiAocHJvcGVydHkgPT09IFwibGVuZ3RoXCIpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIG1hZ2ljIG1vZGUgd2l0aCBwcm9wZXJ0eSBcXFwiXCIgKyBwcm9wZXJ0eSArIFwiXFxcIiAtIG9iamVjdCBpcyBub3QgY29uZmlndXJhYmxlXCIpO1xuICBcdH1cblxuICBcdC8vIFRpbWUgdG8gd3JhcCB0aGlzIHByb3BlcnR5XG4gIFx0aWYgKHRlbXBsYXRlKSB7XG4gIFx0XHRvbGRHZXQgPSB0ZW1wbGF0ZS5nZXQ7XG4gIFx0XHRvbGRTZXQgPSB0ZW1wbGF0ZS5zZXQ7XG4gIFx0fVxuXG4gIFx0Z2V0ID0gb2xkR2V0IHx8IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB2YWx1ZTtcbiAgXHR9O1xuXG4gIFx0c2V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgXHRcdGlmIChvbGRTZXQpIHtcbiAgXHRcdFx0b2xkU2V0KHYpO1xuICBcdFx0fVxuXG4gIFx0XHR2YWx1ZSA9IG9sZEdldCA/IG9sZEdldCgpIDogdjtcbiAgXHRcdHNldC5fcmFjdGl2ZVdyYXBwZXJzLmZvckVhY2godXBkYXRlV3JhcHBlcik7XG4gIFx0fTtcblxuICBcdGZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIod3JhcHBlcikge1xuICBcdFx0dmFyIGtleXBhdGgsIHJhY3RpdmU7XG5cbiAgXHRcdHdyYXBwZXIudmFsdWUgPSB2YWx1ZTtcblxuICBcdFx0aWYgKHdyYXBwZXIudXBkYXRpbmcpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRyYWN0aXZlID0gd3JhcHBlci5yYWN0aXZlO1xuICBcdFx0a2V5cGF0aCA9IHdyYXBwZXIua2V5cGF0aDtcblxuICBcdFx0d3JhcHBlci51cGRhdGluZyA9IHRydWU7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zdGFydChyYWN0aXZlKTtcblxuICBcdFx0cmFjdGl2ZS52aWV3bW9kZWwubWFyayhrZXlwYXRoKTtcblxuICBcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIFx0XHR3cmFwcGVyLnVwZGF0aW5nID0gZmFsc2U7XG4gIFx0fVxuXG4gIFx0Ly8gQ3JlYXRlIGFuIGFycmF5IG9mIHdyYXBwZXJzLCBpbiBjYXNlIG90aGVyIGtleXBhdGhzL3JhY3RpdmVzIGRlcGVuZCBvbiB0aGlzIHByb3BlcnR5LlxuICBcdC8vIEhhbmRpbHksIHdlIGNhbiBzdG9yZSB0aGVtIGFzIGEgcHJvcGVydHkgb2YgdGhlIHNldCBmdW5jdGlvbi4gWWF5IEphdmFTY3JpcHQuXG4gIFx0c2V0Ll9yYWN0aXZlV3JhcHBlcnMgPSBbb3JpZ2luYWxXcmFwcGVyXTtcbiAgXHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgeyBnZXQ6IGdldCwgc2V0OiBzZXQsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIHZhciBtYWdpY0FycmF5QWRhcHRvciwgTWFnaWNBcnJheVdyYXBwZXI7XG5cbiAgaWYgKGFkYXB0b3JzX21hZ2ljKSB7XG4gIFx0bWFnaWNBcnJheUFkYXB0b3IgPSB7XG4gIFx0XHRmaWx0ZXI6IGZ1bmN0aW9uIChvYmplY3QsIGtleXBhdGgsIHJhY3RpdmUpIHtcbiAgXHRcdFx0cmV0dXJuIGFkYXB0b3JzX21hZ2ljLmZpbHRlcihvYmplY3QsIGtleXBhdGgsIHJhY3RpdmUpICYmIGFycmF5X2luZGV4LmZpbHRlcihvYmplY3QpO1xuICBcdFx0fSxcblxuICBcdFx0d3JhcDogZnVuY3Rpb24gKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiBuZXcgTWFnaWNBcnJheVdyYXBwZXIocmFjdGl2ZSwgYXJyYXksIGtleXBhdGgpO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRNYWdpY0FycmF5V3JhcHBlciA9IGZ1bmN0aW9uIChyYWN0aXZlLCBhcnJheSwga2V5cGF0aCkge1xuICBcdFx0dGhpcy52YWx1ZSA9IGFycmF5O1xuXG4gIFx0XHR0aGlzLm1hZ2ljID0gdHJ1ZTtcblxuICBcdFx0dGhpcy5tYWdpY1dyYXBwZXIgPSBhZGFwdG9yc19tYWdpYy53cmFwKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKTtcbiAgXHRcdHRoaXMuYXJyYXlXcmFwcGVyID0gYXJyYXlfaW5kZXgud3JhcChyYWN0aXZlLCBhcnJheSwga2V5cGF0aCk7XG4gIFx0fTtcblxuICBcdE1hZ2ljQXJyYXlXcmFwcGVyLnByb3RvdHlwZSA9IHtcbiAgXHRcdGdldDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcbiAgXHRcdH0sXG4gIFx0XHR0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xuICBcdFx0XHR0aGlzLmFycmF5V3JhcHBlci50ZWFyZG93bigpO1xuICBcdFx0XHR0aGlzLm1hZ2ljV3JhcHBlci50ZWFyZG93bigpO1xuICBcdFx0fSxcbiAgXHRcdHJlc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMubWFnaWNXcmFwcGVyLnJlc2V0KHZhbHVlKTtcbiAgXHRcdH1cbiAgXHR9O1xuICB9XG5cbiAgdmFyIG1hZ2ljQXJyYXkgPSBtYWdpY0FycmF5QWRhcHRvcjtcblxuICB2YXIgcHJvdG90eXBlX2FkYXB0ID0gVmlld21vZGVsJGFkYXB0O1xuXG4gIHZhciBwcmVmaXhlcnMgPSB7fTtcbiAgZnVuY3Rpb24gVmlld21vZGVsJGFkYXB0KGtleXBhdGgsIHZhbHVlKSB7XG4gIFx0dmFyIGxlbiwgaSwgYWRhcHRvciwgd3JhcHBlZDtcblxuICBcdGlmICghdGhpcy5hZGFwdG9ycykgcmV0dXJuO1xuXG4gIFx0Ly8gRG8gd2UgaGF2ZSBhbiBhZGFwdG9yIGZvciB0aGlzIHZhbHVlP1xuICBcdGxlbiA9IHRoaXMuYWRhcHRvcnMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0YWRhcHRvciA9IHRoaXMuYWRhcHRvcnNbaV07XG5cbiAgXHRcdGlmIChhZGFwdG9yLmZpbHRlcih2YWx1ZSwga2V5cGF0aCwgdGhpcy5yYWN0aXZlKSkge1xuICBcdFx0XHR3cmFwcGVkID0gdGhpcy53cmFwcGVkW2tleXBhdGhdID0gYWRhcHRvci53cmFwKHRoaXMucmFjdGl2ZSwgdmFsdWUsIGtleXBhdGgsIGdldFByZWZpeGVyKGtleXBhdGgpKTtcbiAgXHRcdFx0d3JhcHBlZC52YWx1ZSA9IHZhbHVlO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcHJlZml4S2V5cGF0aChvYmosIHByZWZpeCkge1xuICBcdHZhciBwcmVmaXhlZCA9IHt9LFxuICBcdCAgICBrZXk7XG5cbiAgXHRpZiAoIXByZWZpeCkge1xuICBcdFx0cmV0dXJuIG9iajtcbiAgXHR9XG5cbiAgXHRwcmVmaXggKz0gXCIuXCI7XG5cbiAgXHRmb3IgKGtleSBpbiBvYmopIHtcbiAgXHRcdGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICBcdFx0XHRwcmVmaXhlZFtwcmVmaXggKyBrZXldID0gb2JqW2tleV07XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHByZWZpeGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UHJlZml4ZXIocm9vdEtleXBhdGgpIHtcbiAgXHR2YXIgcm9vdERvdDtcblxuICBcdGlmICghcHJlZml4ZXJzW3Jvb3RLZXlwYXRoXSkge1xuICBcdFx0cm9vdERvdCA9IHJvb3RLZXlwYXRoID8gcm9vdEtleXBhdGggKyBcIi5cIiA6IFwiXCI7XG5cbiAgXHRcdHByZWZpeGVyc1tyb290S2V5cGF0aF0gPSBmdW5jdGlvbiAocmVsYXRpdmVLZXlwYXRoLCB2YWx1ZSkge1xuICBcdFx0XHR2YXIgb2JqO1xuXG4gIFx0XHRcdGlmICh0eXBlb2YgcmVsYXRpdmVLZXlwYXRoID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdFx0b2JqID0ge307XG4gIFx0XHRcdFx0b2JqW3Jvb3REb3QgKyByZWxhdGl2ZUtleXBhdGhdID0gdmFsdWU7XG4gIFx0XHRcdFx0cmV0dXJuIG9iajtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICh0eXBlb2YgcmVsYXRpdmVLZXlwYXRoID09PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRcdFx0Ly8gJ3JlbGF0aXZlS2V5cGF0aCcgaXMgaW4gZmFjdCBhIGhhc2gsIG5vdCBhIGtleXBhdGhcbiAgXHRcdFx0XHRyZXR1cm4gcm9vdERvdCA/IHByZWZpeEtleXBhdGgocmVsYXRpdmVLZXlwYXRoLCByb290S2V5cGF0aCkgOiByZWxhdGl2ZUtleXBhdGg7XG4gIFx0XHRcdH1cbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHByZWZpeGVyc1tyb290S2V5cGF0aF07XG4gIH1cblxuICAvLyBURU1QXG5cbiAgdmFyIGhlbHBlcnNfZ2V0VXBzdHJlYW1DaGFuZ2VzID0gZ2V0VXBzdHJlYW1DaGFuZ2VzO1xuICBmdW5jdGlvbiBnZXRVcHN0cmVhbUNoYW5nZXMoY2hhbmdlcykge1xuICBcdHZhciB1cHN0cmVhbUNoYW5nZXMgPSBbcm9vdEtleXBhdGhdLFxuICBcdCAgICBpLFxuICBcdCAgICBrZXlwYXRoO1xuXG4gIFx0aSA9IGNoYW5nZXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGtleXBhdGggPSBjaGFuZ2VzW2ldLnBhcmVudDtcblxuICBcdFx0d2hpbGUgKGtleXBhdGggJiYgIWtleXBhdGguaXNSb290KSB7XG4gIFx0XHRcdGlmIChjaGFuZ2VzLmluZGV4T2Yoa2V5cGF0aCkgPT09IC0xKSB7XG4gIFx0XHRcdFx0YWRkVG9BcnJheSh1cHN0cmVhbUNoYW5nZXMsIGtleXBhdGgpO1xuICBcdFx0XHR9XG4gIFx0XHRcdGtleXBhdGggPSBrZXlwYXRoLnBhcmVudDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdXBzdHJlYW1DaGFuZ2VzO1xuICB9XG5cbiAgdmFyIGFwcGx5Q2hhbmdlc19ub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzID0gbm90aWZ5UGF0dGVybk9ic2VydmVycztcblxuICBmdW5jdGlvbiBub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzKHZpZXdtb2RlbCwga2V5cGF0aCwgb25seURpcmVjdCkge1xuICBcdHZhciBwb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXM7XG5cbiAgXHR1cGRhdGVNYXRjaGluZ1BhdHRlcm5PYnNlcnZlcnModmlld21vZGVsLCBrZXlwYXRoKTtcblxuICBcdGlmIChvbmx5RGlyZWN0KSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0cG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzID0ga2V5cGF0aC53aWxkY2FyZE1hdGNoZXMoKTtcbiAgXHRwb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAodXBzdHJlYW1QYXR0ZXJuKSB7XG4gIFx0XHRjYXNjYWRlKHZpZXdtb2RlbCwgdXBzdHJlYW1QYXR0ZXJuLCBrZXlwYXRoKTtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhc2NhZGUodmlld21vZGVsLCB1cHN0cmVhbVBhdHRlcm4sIGtleXBhdGgpIHtcbiAgXHR2YXIgZ3JvdXAsIG1hcCwgYWN0dWFsQ2hpbGRLZXlwYXRoO1xuXG4gIFx0Ly8gVE9ETyBzaG91bGQgYmUgb25lIG9yIHRoZSBvdGhlclxuICBcdHVwc3RyZWFtUGF0dGVybiA9IHVwc3RyZWFtUGF0dGVybi5zdHIgfHwgdXBzdHJlYW1QYXR0ZXJuO1xuXG4gIFx0Z3JvdXAgPSB2aWV3bW9kZWwuZGVwc01hcC5wYXR0ZXJuT2JzZXJ2ZXJzO1xuICBcdG1hcCA9IGdyb3VwICYmIGdyb3VwW3Vwc3RyZWFtUGF0dGVybl07XG5cbiAgXHRpZiAoIW1hcCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdG1hcC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZEtleXBhdGgpIHtcbiAgXHRcdGFjdHVhbENoaWxkS2V5cGF0aCA9IGtleXBhdGguam9pbihjaGlsZEtleXBhdGgubGFzdEtleSk7IC8vICdmb28uYmFyLmJheidcblxuICBcdFx0dXBkYXRlTWF0Y2hpbmdQYXR0ZXJuT2JzZXJ2ZXJzKHZpZXdtb2RlbCwgYWN0dWFsQ2hpbGRLZXlwYXRoKTtcbiAgXHRcdGNhc2NhZGUodmlld21vZGVsLCBjaGlsZEtleXBhdGgsIGFjdHVhbENoaWxkS2V5cGF0aCk7XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVNYXRjaGluZ1BhdHRlcm5PYnNlcnZlcnModmlld21vZGVsLCBrZXlwYXRoKSB7XG4gIFx0dmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgXHRcdGlmIChvYnNlcnZlci5yZWdleC50ZXN0KGtleXBhdGguc3RyKSkge1xuICBcdFx0XHRvYnNlcnZlci51cGRhdGUoa2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSk7XG4gIH1cblxuICB2YXIgYXBwbHlDaGFuZ2VzID0gVmlld21vZGVsJGFwcGx5Q2hhbmdlcztcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkYXBwbHlDaGFuZ2VzKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgc2VsZiA9IHRoaXMsXG4gIFx0ICAgIGNoYW5nZXMsXG4gIFx0ICAgIHVwc3RyZWFtQ2hhbmdlcyxcbiAgXHQgICAgaGFzaCA9IHt9LFxuICBcdCAgICBiaW5kaW5ncztcblxuICBcdGNoYW5nZXMgPSB0aGlzLmNoYW5nZXM7XG5cbiAgXHRpZiAoIWNoYW5nZXMubGVuZ3RoKSB7XG4gIFx0XHQvLyBUT0RPIHdlIGVuZCB1cCBoZXJlIG9uIGluaXRpYWwgcmVuZGVyLiBQZXJoYXBzIHdlIHNob3VsZG4ndD9cbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiBpbnZhbGlkYXRlQ29tcHV0YXRpb24oY29tcHV0YXRpb24pIHtcbiAgXHRcdHZhciBrZXkgPSBjb21wdXRhdGlvbi5rZXk7XG5cbiAgXHRcdGlmIChjb21wdXRhdGlvbi52aWV3bW9kZWwgPT09IHNlbGYpIHtcbiAgXHRcdFx0c2VsZi5jbGVhckNhY2hlKGtleS5zdHIpO1xuICBcdFx0XHRjb21wdXRhdGlvbi5pbnZhbGlkYXRlKCk7XG5cbiAgXHRcdFx0Y2hhbmdlcy5wdXNoKGtleSk7XG4gIFx0XHRcdGNhc2NhZGUoa2V5KTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGNvbXB1dGF0aW9uLnZpZXdtb2RlbC5tYXJrKGtleSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gY2FzY2FkZShrZXlwYXRoKSB7XG4gIFx0XHR2YXIgbWFwLCBjb21wdXRhdGlvbnM7XG5cbiAgXHRcdGlmIChzZWxmLm5vQ2FzY2FkZS5oYXNPd25Qcm9wZXJ0eShrZXlwYXRoLnN0cikpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoY29tcHV0YXRpb25zID0gc2VsZi5kZXBzLmNvbXB1dGVkW2tleXBhdGguc3RyXSkge1xuICBcdFx0XHRjb21wdXRhdGlvbnMuZm9yRWFjaChpbnZhbGlkYXRlQ29tcHV0YXRpb24pO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobWFwID0gc2VsZi5kZXBzTWFwLmNvbXB1dGVkW2tleXBhdGguc3RyXSkge1xuICBcdFx0XHRtYXAuZm9yRWFjaChjYXNjYWRlKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRjaGFuZ2VzLnNsaWNlKCkuZm9yRWFjaChjYXNjYWRlKTtcblxuICBcdHVwc3RyZWFtQ2hhbmdlcyA9IGhlbHBlcnNfZ2V0VXBzdHJlYW1DaGFuZ2VzKGNoYW5nZXMpO1xuICBcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHR2YXIgY29tcHV0YXRpb25zO1xuXG4gIFx0XHQvLyBtYWtlIHN1cmUgd2UgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gZG93biB0aGlzIHBhcnRpY3VsYXIga2V5cGF0aCBpbiB0aGlzIHR1cm5cbiAgXHRcdGlmIChjaGFuZ2VzLmluZGV4T2Yoa2V5cGF0aCkgPT09IC0xICYmIChjb21wdXRhdGlvbnMgPSBzZWxmLmRlcHMuY29tcHV0ZWRba2V5cGF0aC5zdHJdKSkge1xuICBcdFx0XHRjb21wdXRhdGlvbnMuZm9yRWFjaChpbnZhbGlkYXRlQ29tcHV0YXRpb24pO1xuICBcdFx0fVxuICBcdH0pO1xuXG4gIFx0dGhpcy5jaGFuZ2VzID0gW107XG5cbiAgXHQvLyBQYXR0ZXJuIG9ic2VydmVycyBhcmUgYSB3ZWlyZCBzcGVjaWFsIGNhc2VcbiAgXHRpZiAodGhpcy5wYXR0ZXJuT2JzZXJ2ZXJzLmxlbmd0aCkge1xuICBcdFx0dXBzdHJlYW1DaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIGFwcGx5Q2hhbmdlc19ub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzKF90aGlzLCBrZXlwYXRoLCB0cnVlKTtcbiAgXHRcdH0pO1xuICBcdFx0Y2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiBhcHBseUNoYW5nZXNfbm90aWZ5UGF0dGVybk9ic2VydmVycyhfdGhpcywga2V5cGF0aCk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5kZXBzLm9ic2VydmVycykge1xuICBcdFx0dXBzdHJlYW1DaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIG5vdGlmeVVwc3RyZWFtRGVwZW5kYW50cyhfdGhpcywgbnVsbCwga2V5cGF0aCwgXCJvYnNlcnZlcnNcIik7XG4gIFx0XHR9KTtcbiAgXHRcdG5vdGlmeUFsbERlcGVuZGFudHModGhpcywgY2hhbmdlcywgXCJvYnNlcnZlcnNcIik7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZGVwc1tcImRlZmF1bHRcIl0pIHtcbiAgXHRcdGJpbmRpbmdzID0gW107XG4gIFx0XHR1cHN0cmVhbUNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRyZXR1cm4gbm90aWZ5VXBzdHJlYW1EZXBlbmRhbnRzKF90aGlzLCBiaW5kaW5ncywga2V5cGF0aCwgXCJkZWZhdWx0XCIpO1xuICBcdFx0fSk7XG5cbiAgXHRcdGlmIChiaW5kaW5ncy5sZW5ndGgpIHtcbiAgXHRcdFx0bm90aWZ5QmluZGluZ3ModGhpcywgYmluZGluZ3MsIGNoYW5nZXMpO1xuICBcdFx0fVxuXG4gIFx0XHRub3RpZnlBbGxEZXBlbmRhbnRzKHRoaXMsIGNoYW5nZXMsIFwiZGVmYXVsdFwiKTtcbiAgXHR9XG5cbiAgXHQvLyBSZXR1cm4gYSBoYXNoIG9mIGtleXBhdGhzIHRvIHVwZGF0ZWQgdmFsdWVzXG4gIFx0Y2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRoYXNoW2tleXBhdGguc3RyXSA9IF90aGlzLmdldChrZXlwYXRoKTtcbiAgXHR9KTtcblxuICBcdHRoaXMuaW1wbGljaXRDaGFuZ2VzID0ge307XG4gIFx0dGhpcy5ub0Nhc2NhZGUgPSB7fTtcblxuICBcdHJldHVybiBoYXNoO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5VXBzdHJlYW1EZXBlbmRhbnRzKHZpZXdtb2RlbCwgYmluZGluZ3MsIGtleXBhdGgsIGdyb3VwTmFtZSkge1xuICBcdHZhciBkZXBlbmRhbnRzLCB2YWx1ZTtcblxuICBcdGlmIChkZXBlbmRhbnRzID0gZmluZERlcGVuZGFudHModmlld21vZGVsLCBrZXlwYXRoLCBncm91cE5hbWUpKSB7XG4gIFx0XHR2YWx1ZSA9IHZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRcdGRlcGVuZGFudHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICBcdFx0XHQvLyBkb24ndCBcInNldFwiIHRoZSBwYXJlbnQgdmFsdWUsIHJlZmluZSBpdFxuICBcdFx0XHQvLyBpLmUuIG5vdCBkYXRhID0gdmFsdWUsIGJ1dCBkYXRhW2Zvb10gPSBmb29WYWx1ZVxuICBcdFx0XHRpZiAoYmluZGluZ3MgJiYgZC5yZWZpbmVWYWx1ZSkge1xuICBcdFx0XHRcdGJpbmRpbmdzLnB1c2goZCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0ZC5zZXRWYWx1ZSh2YWx1ZSk7XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeUJpbmRpbmdzKHZpZXdtb2RlbCwgYmluZGluZ3MsIGNoYW5nZXMpIHtcblxuICBcdGJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgXHRcdHZhciB1c2VTZXQgPSBmYWxzZSxcbiAgXHRcdCAgICBpID0gMCxcbiAgXHRcdCAgICBsZW5ndGggPSBjaGFuZ2VzLmxlbmd0aCxcbiAgXHRcdCAgICByZWZpbmVtZW50cyA9IFtdO1xuXG4gIFx0XHR3aGlsZSAoaSA8IGxlbmd0aCkge1xuICBcdFx0XHR2YXIga2V5cGF0aCA9IGNoYW5nZXNbaV07XG5cbiAgXHRcdFx0aWYgKGtleXBhdGggPT09IGJpbmRpbmcua2V5cGF0aCkge1xuICBcdFx0XHRcdHVzZVNldCA9IHRydWU7XG4gIFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoa2V5cGF0aC5zbGljZSgwLCBiaW5kaW5nLmtleXBhdGgubGVuZ3RoKSA9PT0gYmluZGluZy5rZXlwYXRoKSB7XG4gIFx0XHRcdFx0cmVmaW5lbWVudHMucHVzaChrZXlwYXRoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGkrKztcbiAgXHRcdH1cblxuICBcdFx0aWYgKHVzZVNldCkge1xuICBcdFx0XHRiaW5kaW5nLnNldFZhbHVlKHZpZXdtb2RlbC5nZXQoYmluZGluZy5rZXlwYXRoKSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChyZWZpbmVtZW50cy5sZW5ndGgpIHtcbiAgXHRcdFx0YmluZGluZy5yZWZpbmVWYWx1ZShyZWZpbmVtZW50cyk7XG4gIFx0XHR9XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnlBbGxEZXBlbmRhbnRzKHZpZXdtb2RlbCwga2V5cGF0aHMsIGdyb3VwTmFtZSkge1xuICBcdHZhciBxdWV1ZSA9IFtdO1xuXG4gIFx0YWRkS2V5cGF0aHMoa2V5cGF0aHMpO1xuICBcdHF1ZXVlLmZvckVhY2goZGlzcGF0Y2gpO1xuXG4gIFx0ZnVuY3Rpb24gYWRkS2V5cGF0aHMoa2V5cGF0aHMpIHtcbiAgXHRcdGtleXBhdGhzLmZvckVhY2goYWRkS2V5cGF0aCk7XG4gIFx0XHRrZXlwYXRocy5mb3JFYWNoKGNhc2NhZGUpO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIGFkZEtleXBhdGgoa2V5cGF0aCkge1xuICBcdFx0dmFyIGRlcHMgPSBmaW5kRGVwZW5kYW50cyh2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwTmFtZSk7XG5cbiAgXHRcdGlmIChkZXBzKSB7XG4gIFx0XHRcdHF1ZXVlLnB1c2goe1xuICBcdFx0XHRcdGtleXBhdGg6IGtleXBhdGgsXG4gIFx0XHRcdFx0ZGVwczogZGVwc1xuICBcdFx0XHR9KTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiBjYXNjYWRlKGtleXBhdGgpIHtcbiAgXHRcdHZhciBjaGlsZERlcHM7XG5cbiAgXHRcdGlmIChjaGlsZERlcHMgPSB2aWV3bW9kZWwuZGVwc01hcFtncm91cE5hbWVdW2tleXBhdGguc3RyXSkge1xuICBcdFx0XHRhZGRLZXlwYXRocyhjaGlsZERlcHMpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGZ1bmN0aW9uIGRpc3BhdGNoKHNldCkge1xuICBcdFx0dmFyIHZhbHVlID0gdmlld21vZGVsLmdldChzZXQua2V5cGF0aCk7XG4gIFx0XHRzZXQuZGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gIFx0XHRcdHJldHVybiBkLnNldFZhbHVlKHZhbHVlKTtcbiAgXHRcdH0pO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmREZXBlbmRhbnRzKHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXBOYW1lKSB7XG4gIFx0dmFyIGdyb3VwID0gdmlld21vZGVsLmRlcHNbZ3JvdXBOYW1lXTtcbiAgXHRyZXR1cm4gZ3JvdXAgPyBncm91cFtrZXlwYXRoLnN0cl0gOiBudWxsO1xuICB9XG5cbiAgdmFyIGNhcHR1cmUgPSBWaWV3bW9kZWwkY2FwdHVyZTtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkY2FwdHVyZSgpIHtcbiAgXHR0aGlzLmNhcHR1cmVHcm91cHMucHVzaChbXSk7XG4gIH1cblxuICB2YXIgY2xlYXJDYWNoZSA9IFZpZXdtb2RlbCRjbGVhckNhY2hlO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRjbGVhckNhY2hlKGtleXBhdGgsIGtlZXBFeGlzdGluZ1dyYXBwZXIpIHtcbiAgXHR2YXIgY2FjaGVNYXAsIHdyYXBwZXI7XG5cbiAgXHRpZiAoIWtlZXBFeGlzdGluZ1dyYXBwZXIpIHtcbiAgXHRcdC8vIElzIHRoZXJlIGEgd3JhcHBlZCBwcm9wZXJ0eSBhdCB0aGlzIGtleXBhdGg/XG4gIFx0XHRpZiAod3JhcHBlciA9IHRoaXMud3JhcHBlZFtrZXlwYXRoXSkge1xuICBcdFx0XHQvLyBEaWQgd2UgdW53cmFwIGl0P1xuICBcdFx0XHRpZiAod3JhcHBlci50ZWFyZG93bigpICE9PSBmYWxzZSkge1xuICBcdFx0XHRcdC8vIElzIHRoaXMgcmlnaHQ/XG4gIFx0XHRcdFx0Ly8gV2hhdCdzIHRoZSBtZWFuaW5nIG9mIHJldHVybmluZyBmYWxzZSBmcm9tIHRlYXJkb3duP1xuICBcdFx0XHRcdC8vIENvdWxkIHRoZXJlIGJlIGEgR0MgcmFtaWZpY2F0aW9uIGlmIHRoaXMgaXMgYSBcInJlYWxcIiByYWN0aXZlLnRlYXJkb3duKCk/XG4gIFx0XHRcdFx0dGhpcy53cmFwcGVkW2tleXBhdGhdID0gbnVsbDtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHRoaXMuY2FjaGVba2V5cGF0aF0gPSB1bmRlZmluZWQ7XG5cbiAgXHRpZiAoY2FjaGVNYXAgPSB0aGlzLmNhY2hlTWFwW2tleXBhdGhdKSB7XG4gIFx0XHR3aGlsZSAoY2FjaGVNYXAubGVuZ3RoKSB7XG4gIFx0XHRcdHRoaXMuY2xlYXJDYWNoZShjYWNoZU1hcC5wb3AoKSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIFVucmVzb2x2ZWREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKGNvbXB1dGF0aW9uLCByZWYpIHtcbiAgXHR0aGlzLmNvbXB1dGF0aW9uID0gY29tcHV0YXRpb247XG4gIFx0dGhpcy52aWV3bW9kZWwgPSBjb21wdXRhdGlvbi52aWV3bW9kZWw7XG4gIFx0dGhpcy5yZWYgPSByZWY7XG5cbiAgXHQvLyBUT0RPIHRoaXMgc2VlbXMgbGlrZSBhIHJlZCBmbGFnIVxuICBcdHRoaXMucm9vdCA9IHRoaXMudmlld21vZGVsLnJhY3RpdmU7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IHRoaXMucm9vdC5jb21wb25lbnQgJiYgdGhpcy5yb290LmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcbiAgfTtcblxuICBVbnJlc29sdmVkRGVwZW5kZW5jeS5wcm90b3R5cGUgPSB7XG4gIFx0cmVzb2x2ZTogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHRoaXMuY29tcHV0YXRpb24uc29mdERlcHMucHVzaChrZXlwYXRoKTtcbiAgXHRcdHRoaXMuY29tcHV0YXRpb24udW5yZXNvbHZlZERlcHNba2V5cGF0aC5zdHJdID0gbnVsbDtcbiAgXHRcdHRoaXMudmlld21vZGVsLnJlZ2lzdGVyKGtleXBhdGgsIHRoaXMuY29tcHV0YXRpb24sIFwiY29tcHV0ZWRcIik7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBDb21wdXRhdGlvbl9VbnJlc29sdmVkRGVwZW5kZW5jeSA9IFVucmVzb2x2ZWREZXBlbmRlbmN5O1xuXG4gIHZhciBDb21wdXRhdGlvbiA9IGZ1bmN0aW9uIChrZXksIHNpZ25hdHVyZSkge1xuICBcdHRoaXMua2V5ID0ga2V5O1xuXG4gIFx0dGhpcy5nZXR0ZXIgPSBzaWduYXR1cmUuZ2V0dGVyO1xuICBcdHRoaXMuc2V0dGVyID0gc2lnbmF0dXJlLnNldHRlcjtcblxuICBcdHRoaXMuaGFyZERlcHMgPSBzaWduYXR1cmUuZGVwcyB8fCBbXTtcbiAgXHR0aGlzLnNvZnREZXBzID0gW107XG4gIFx0dGhpcy51bnJlc29sdmVkRGVwcyA9IHt9O1xuXG4gIFx0dGhpcy5kZXBWYWx1ZXMgPSB7fTtcblxuICBcdHRoaXMuX2RpcnR5ID0gdGhpcy5fZmlyc3RSdW4gPSB0cnVlO1xuICB9O1xuXG4gIENvbXB1dGF0aW9uLnByb3RvdHlwZSA9IHtcbiAgXHRjb25zdHJ1Y3RvcjogQ29tcHV0YXRpb24sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAodmlld21vZGVsKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgaW5pdGlhbDtcblxuICBcdFx0dGhpcy52aWV3bW9kZWwgPSB2aWV3bW9kZWw7XG4gIFx0XHR0aGlzLmJ5cGFzcyA9IHRydWU7XG5cbiAgXHRcdGluaXRpYWwgPSB2aWV3bW9kZWwuZ2V0KHRoaXMua2V5KTtcbiAgXHRcdHZpZXdtb2RlbC5jbGVhckNhY2hlKHRoaXMua2V5LnN0cik7XG5cbiAgXHRcdHRoaXMuYnlwYXNzID0gZmFsc2U7XG5cbiAgXHRcdGlmICh0aGlzLnNldHRlciAmJiBpbml0aWFsICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy5zZXQoaW5pdGlhbCk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLmhhcmREZXBzKSB7XG4gIFx0XHRcdHRoaXMuaGFyZERlcHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICBcdFx0XHRcdHJldHVybiB2aWV3bW9kZWwucmVnaXN0ZXIoZCwgX3RoaXMsIFwiY29tcHV0ZWRcIik7XG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRpbnZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9kaXJ0eSA9IHRydWU7XG4gIFx0fSxcblxuICBcdGdldDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIG5ld0RlcHMsXG4gIFx0XHQgICAgZGVwZW5kZW5jaWVzQ2hhbmdlZCxcbiAgXHRcdCAgICBkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCA9IGZhbHNlO1xuXG4gIFx0XHRpZiAodGhpcy5nZXR0aW5nKSB7XG4gIFx0XHRcdC8vIHByZXZlbnQgZG91YmxlLWNvbXB1dGF0aW9uIChlLmcuIGNhdXNlZCBieSBhcnJheSBtdXRhdGlvbiBpbnNpZGUgY29tcHV0YXRpb24pXG4gIFx0XHRcdHZhciBtc2cgPSBcIlRoZSBcIiArIHRoaXMua2V5LnN0ciArIFwiIGNvbXB1dGF0aW9uIGluZGlyZWN0bHkgY2FsbGVkIGl0c2VsZi4gVGhpcyBwcm9iYWJseSBpbmRpY2F0ZXMgYSBidWcgaW4gdGhlIGNvbXB1dGF0aW9uLiBJdCBpcyBjb21tb25seSBjYXVzZWQgYnkgYGFycmF5LnNvcnQoLi4uKWAgLSBpZiB0aGF0J3MgdGhlIGNhc2UsIGNsb25lIHRoZSBhcnJheSBmaXJzdCB3aXRoIGBhcnJheS5zbGljZSgpLnNvcnQoLi4uKWBcIjtcbiAgXHRcdFx0d2Fybk9uY2UobXNnKTtcbiAgXHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZ2V0dGluZyA9IHRydWU7XG5cbiAgXHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuICBcdFx0XHQvLyBkZXRlcm1pbmUgd2hldGhlciB0aGUgaW5wdXRzIGhhdmUgY2hhbmdlZCwgaW4gY2FzZSB0aGlzIGRlcGVuZHMgb25cbiAgXHRcdFx0Ly8gb3RoZXIgY29tcHV0ZWQgdmFsdWVzXG4gIFx0XHRcdGlmICh0aGlzLl9maXJzdFJ1biB8fCAhdGhpcy5oYXJkRGVwcy5sZW5ndGggJiYgIXRoaXMuc29mdERlcHMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0ZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQgPSB0cnVlO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFt0aGlzLmhhcmREZXBzLCB0aGlzLnNvZnREZXBzXS5mb3JFYWNoKGZ1bmN0aW9uIChkZXBzKSB7XG4gIFx0XHRcdFx0XHR2YXIga2V5cGF0aCwgdmFsdWUsIGk7XG5cbiAgXHRcdFx0XHRcdGlmIChkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCkge1xuICBcdFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdGkgPSBkZXBzLmxlbmd0aDtcbiAgXHRcdFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRcdFx0a2V5cGF0aCA9IGRlcHNbaV07XG4gIFx0XHRcdFx0XHRcdHZhbHVlID0gX3RoaXMudmlld21vZGVsLmdldChrZXlwYXRoKTtcblxuICBcdFx0XHRcdFx0XHRpZiAoIWlzRXF1YWwodmFsdWUsIF90aGlzLmRlcFZhbHVlc1trZXlwYXRoLnN0cl0pKSB7XG4gIFx0XHRcdFx0XHRcdFx0X3RoaXMuZGVwVmFsdWVzW2tleXBhdGguc3RyXSA9IHZhbHVlO1xuICBcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3lWYWx1ZXNDaGFuZ2VkID0gdHJ1ZTtcblxuICBcdFx0XHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH0pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGRlcGVuZGVuY3lWYWx1ZXNDaGFuZ2VkKSB7XG4gIFx0XHRcdFx0dGhpcy52aWV3bW9kZWwuY2FwdHVyZSgpO1xuXG4gIFx0XHRcdFx0dHJ5IHtcbiAgXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLmdldHRlcigpO1xuICBcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuICBcdFx0XHRcdFx0d2FybklmRGVidWcoXCJGYWlsZWQgdG8gY29tcHV0ZSBcXFwiJXNcXFwiXCIsIHRoaXMua2V5LnN0cik7XG4gIFx0XHRcdFx0XHRsb2dJZkRlYnVnKGVyci5zdGFjayB8fCBlcnIpO1xuXG4gIFx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdm9pZCAwO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdG5ld0RlcHMgPSB0aGlzLnZpZXdtb2RlbC5yZWxlYXNlKCk7XG4gIFx0XHRcdFx0ZGVwZW5kZW5jaWVzQ2hhbmdlZCA9IHRoaXMudXBkYXRlRGVwZW5kZW5jaWVzKG5ld0RlcHMpO1xuXG4gIFx0XHRcdFx0aWYgKGRlcGVuZGVuY2llc0NoYW5nZWQpIHtcbiAgXHRcdFx0XHRcdFt0aGlzLmhhcmREZXBzLCB0aGlzLnNvZnREZXBzXS5mb3JFYWNoKGZ1bmN0aW9uIChkZXBzKSB7XG4gIFx0XHRcdFx0XHRcdGRlcHMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRcdFx0XHRcdF90aGlzLmRlcFZhbHVlc1trZXlwYXRoLnN0cl0gPSBfdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZ2V0dGluZyA9IHRoaXMuX2ZpcnN0UnVuID0gZmFsc2U7XG4gIFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcbiAgXHR9LFxuXG4gIFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdGlmICh0aGlzLnNldHRpbmcpIHtcbiAgXHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghdGhpcy5zZXR0ZXIpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ29tcHV0ZWQgcHJvcGVydGllcyB3aXRob3V0IHNldHRlcnMgYXJlIHJlYWQtb25seS4gKFRoaXMgbWF5IGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJhY3RpdmUhKVwiKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5zZXR0ZXIodmFsdWUpO1xuICBcdH0sXG5cbiAgXHR1cGRhdGVEZXBlbmRlbmNpZXM6IGZ1bmN0aW9uIChuZXdEZXBzKSB7XG4gIFx0XHR2YXIgaSwgb2xkRGVwcywga2V5cGF0aCwgZGVwZW5kZW5jaWVzQ2hhbmdlZCwgdW5yZXNvbHZlZDtcblxuICBcdFx0b2xkRGVwcyA9IHRoaXMuc29mdERlcHM7XG5cbiAgXHRcdC8vIHJlbW92ZSBkZXBlbmRlbmNpZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHVzZWRcbiAgXHRcdGkgPSBvbGREZXBzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0a2V5cGF0aCA9IG9sZERlcHNbaV07XG5cbiAgXHRcdFx0aWYgKG5ld0RlcHMuaW5kZXhPZihrZXlwYXRoKSA9PT0gLTEpIHtcbiAgXHRcdFx0XHRkZXBlbmRlbmNpZXNDaGFuZ2VkID0gdHJ1ZTtcbiAgXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC51bnJlZ2lzdGVyKGtleXBhdGgsIHRoaXMsIFwiY29tcHV0ZWRcIik7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gY3JlYXRlIHJlZmVyZW5jZXMgZm9yIGFueSBuZXcgZGVwZW5kZW5jaWVzXG4gIFx0XHRpID0gbmV3RGVwcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGtleXBhdGggPSBuZXdEZXBzW2ldO1xuXG4gIFx0XHRcdGlmIChvbGREZXBzLmluZGV4T2Yoa2V5cGF0aCkgPT09IC0xICYmICghdGhpcy5oYXJkRGVwcyB8fCB0aGlzLmhhcmREZXBzLmluZGV4T2Yoa2V5cGF0aCkgPT09IC0xKSkge1xuICBcdFx0XHRcdGRlcGVuZGVuY2llc0NoYW5nZWQgPSB0cnVlO1xuXG4gIFx0XHRcdFx0Ly8gaWYgdGhpcyBrZXlwYXRoIGlzIGN1cnJlbnRseSB1bnJlc29sdmVkLCB3ZSBuZWVkIHRvIG1hcmtcbiAgXHRcdFx0XHQvLyBpdCBhcyBzdWNoLiBUT0RPIHRoaXMgaXMgYSBiaXQgbXVkZHkuLi5cbiAgXHRcdFx0XHRpZiAoaXNVbnJlc29sdmVkKHRoaXMudmlld21vZGVsLCBrZXlwYXRoKSAmJiAhdGhpcy51bnJlc29sdmVkRGVwc1trZXlwYXRoLnN0cl0pIHtcbiAgXHRcdFx0XHRcdHVucmVzb2x2ZWQgPSBuZXcgQ29tcHV0YXRpb25fVW5yZXNvbHZlZERlcGVuZGVuY3kodGhpcywga2V5cGF0aC5zdHIpO1xuICBcdFx0XHRcdFx0bmV3RGVwcy5zcGxpY2UoaSwgMSk7XG5cbiAgXHRcdFx0XHRcdHRoaXMudW5yZXNvbHZlZERlcHNba2V5cGF0aC5zdHJdID0gdW5yZXNvbHZlZDtcbiAgXHRcdFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFVucmVzb2x2ZWQodW5yZXNvbHZlZCk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdHRoaXMudmlld21vZGVsLnJlZ2lzdGVyKGtleXBhdGgsIHRoaXMsIFwiY29tcHV0ZWRcIik7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChkZXBlbmRlbmNpZXNDaGFuZ2VkKSB7XG4gIFx0XHRcdHRoaXMuc29mdERlcHMgPSBuZXdEZXBzLnNsaWNlKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBkZXBlbmRlbmNpZXNDaGFuZ2VkO1xuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiBpc1VucmVzb2x2ZWQodmlld21vZGVsLCBrZXlwYXRoKSB7XG4gIFx0dmFyIGtleSA9IGtleXBhdGguZmlyc3RLZXk7XG5cbiAgXHRyZXR1cm4gIShrZXkgaW4gdmlld21vZGVsLmRhdGEpICYmICEoa2V5IGluIHZpZXdtb2RlbC5jb21wdXRhdGlvbnMpICYmICEoa2V5IGluIHZpZXdtb2RlbC5tYXBwaW5ncyk7XG4gIH1cblxuICB2YXIgQ29tcHV0YXRpb25fQ29tcHV0YXRpb24gPSBDb21wdXRhdGlvbjtcblxuICB2YXIgY29tcHV0ZSA9IFZpZXdtb2RlbCRjb21wdXRlO1xuICBmdW5jdGlvbiBWaWV3bW9kZWwkY29tcHV0ZShrZXksIHNpZ25hdHVyZSkge1xuICBcdHZhciBjb21wdXRhdGlvbiA9IG5ldyBDb21wdXRhdGlvbl9Db21wdXRhdGlvbihrZXksIHNpZ25hdHVyZSk7XG5cbiAgXHRpZiAodGhpcy5yZWFkeSkge1xuICBcdFx0Y29tcHV0YXRpb24uaW5pdCh0aGlzKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5jb21wdXRhdGlvbnNba2V5LnN0cl0gPSBjb21wdXRhdGlvbjtcbiAgfVxuXG4gIHZhciBGQUlMRURfTE9PS1VQID0geyBGQUlMRURfTE9PS1VQOiB0cnVlIH07XG5cbiAgdmFyIHZpZXdtb2RlbF9wcm90b3R5cGVfZ2V0ID0gVmlld21vZGVsJGdldDtcblxuICB2YXIgdmlld21vZGVsX3Byb3RvdHlwZV9nZXRfX2VtcHR5ID0ge307XG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRnZXQoa2V5cGF0aCwgb3B0aW9ucykge1xuICBcdHZhciBjYWNoZSA9IHRoaXMuY2FjaGUsXG4gIFx0ICAgIHZhbHVlLFxuICBcdCAgICBjb21wdXRhdGlvbixcbiAgXHQgICAgd3JhcHBlZCxcbiAgXHQgICAgY2FwdHVyZUdyb3VwLFxuICBcdCAgICBrZXlwYXRoU3RyID0ga2V5cGF0aC5zdHIsXG4gIFx0ICAgIGtleTtcblxuICBcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHZpZXdtb2RlbF9wcm90b3R5cGVfZ2V0X19lbXB0eTtcblxuICBcdC8vIGNhcHR1cmUgdGhlIGtleXBhdGgsIGlmIHdlJ3JlIGluc2lkZSBhIGNvbXB1dGF0aW9uXG4gIFx0aWYgKG9wdGlvbnMuY2FwdHVyZSAmJiAoY2FwdHVyZUdyb3VwID0gbGFzdEl0ZW0odGhpcy5jYXB0dXJlR3JvdXBzKSkpIHtcbiAgXHRcdGlmICghIH5jYXB0dXJlR3JvdXAuaW5kZXhPZihrZXlwYXRoKSkge1xuICBcdFx0XHRjYXB0dXJlR3JvdXAucHVzaChrZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoaGFzT3duLmNhbGwodGhpcy5tYXBwaW5ncywga2V5cGF0aC5maXJzdEtleSkpIHtcbiAgXHRcdHJldHVybiB0aGlzLm1hcHBpbmdzW2tleXBhdGguZmlyc3RLZXldLmdldChrZXlwYXRoLCBvcHRpb25zKTtcbiAgXHR9XG5cbiAgXHRpZiAoa2V5cGF0aC5pc1NwZWNpYWwpIHtcbiAgXHRcdHJldHVybiBrZXlwYXRoLnZhbHVlO1xuICBcdH1cblxuICBcdGlmIChjYWNoZVtrZXlwYXRoU3RyXSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgXHRcdC8vIElzIHRoaXMgYSBjb21wdXRlZCBwcm9wZXJ0eT9cbiAgXHRcdGlmICgoY29tcHV0YXRpb24gPSB0aGlzLmNvbXB1dGF0aW9uc1trZXlwYXRoU3RyXSkgJiYgIWNvbXB1dGF0aW9uLmJ5cGFzcykge1xuICBcdFx0XHR2YWx1ZSA9IGNvbXB1dGF0aW9uLmdldCgpO1xuICBcdFx0XHR0aGlzLmFkYXB0KGtleXBhdGhTdHIsIHZhbHVlKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gSXMgdGhpcyBhIHdyYXBwZWQgcHJvcGVydHk/XG4gIFx0XHRlbHNlIGlmICh3cmFwcGVkID0gdGhpcy53cmFwcGVkW2tleXBhdGhTdHJdKSB7XG4gIFx0XHRcdHZhbHVlID0gd3JhcHBlZC52YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gSXMgaXQgdGhlIHJvb3Q/XG4gIFx0XHRlbHNlIGlmIChrZXlwYXRoLmlzUm9vdCkge1xuICBcdFx0XHR0aGlzLmFkYXB0KFwiXCIsIHRoaXMuZGF0YSk7XG4gIFx0XHRcdHZhbHVlID0gdGhpcy5kYXRhO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBObz8gVGhlbiB3ZSBuZWVkIHRvIHJldHJpZXZlIHRoZSB2YWx1ZSBvbmUga2V5IGF0IGEgdGltZVxuICBcdFx0ZWxzZSB7XG4gIFx0XHRcdHZhbHVlID0gcmV0cmlldmUodGhpcywga2V5cGF0aCk7XG4gIFx0XHR9XG5cbiAgXHRcdGNhY2hlW2tleXBhdGhTdHJdID0gdmFsdWU7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHZhbHVlID0gY2FjaGVba2V5cGF0aFN0cl07XG4gIFx0fVxuXG4gIFx0aWYgKCFvcHRpb25zLm5vVW53cmFwICYmICh3cmFwcGVkID0gdGhpcy53cmFwcGVkW2tleXBhdGhTdHJdKSkge1xuICBcdFx0dmFsdWUgPSB3cmFwcGVkLmdldCgpO1xuICBcdH1cblxuICBcdGlmIChrZXlwYXRoLmlzUm9vdCAmJiBvcHRpb25zLmZ1bGxSb290R2V0KSB7XG4gIFx0XHRmb3IgKGtleSBpbiB0aGlzLm1hcHBpbmdzKSB7XG4gIFx0XHRcdHZhbHVlW2tleV0gPSB0aGlzLm1hcHBpbmdzW2tleV0uZ2V0VmFsdWUoKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdmFsdWUgPT09IEZBSUxFRF9MT09LVVAgPyB2b2lkIDAgOiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldHJpZXZlKHZpZXdtb2RlbCwga2V5cGF0aCkge1xuXG4gIFx0dmFyIHBhcmVudFZhbHVlLCBjYWNoZU1hcCwgdmFsdWUsIHdyYXBwZWQ7XG5cbiAgXHRwYXJlbnRWYWx1ZSA9IHZpZXdtb2RlbC5nZXQoa2V5cGF0aC5wYXJlbnQpO1xuXG4gIFx0aWYgKHdyYXBwZWQgPSB2aWV3bW9kZWwud3JhcHBlZFtrZXlwYXRoLnBhcmVudC5zdHJdKSB7XG4gIFx0XHRwYXJlbnRWYWx1ZSA9IHdyYXBwZWQuZ2V0KCk7XG4gIFx0fVxuXG4gIFx0aWYgKHBhcmVudFZhbHVlID09PSBudWxsIHx8IHBhcmVudFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHQvLyB1cGRhdGUgY2FjaGUgbWFwXG4gIFx0aWYgKCEoY2FjaGVNYXAgPSB2aWV3bW9kZWwuY2FjaGVNYXBba2V5cGF0aC5wYXJlbnQuc3RyXSkpIHtcbiAgXHRcdHZpZXdtb2RlbC5jYWNoZU1hcFtrZXlwYXRoLnBhcmVudC5zdHJdID0gW2tleXBhdGguc3RyXTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0aWYgKGNhY2hlTWFwLmluZGV4T2Yoa2V5cGF0aC5zdHIpID09PSAtMSkge1xuICBcdFx0XHRjYWNoZU1hcC5wdXNoKGtleXBhdGguc3RyKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBJZiB0aGlzIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3QsIHdlIHJldHVybiBhIHNlbnRpbmVsIHZhbHVlXG4gIFx0Ly8gc28gdGhhdCB3ZSBrbm93IHRvIHF1ZXJ5IHBhcmVudCBzY29wZSAoaWYgc3VjaCB0aGVyZSBiZSlcbiAgXHRpZiAodHlwZW9mIHBhcmVudFZhbHVlID09PSBcIm9iamVjdFwiICYmICEoa2V5cGF0aC5sYXN0S2V5IGluIHBhcmVudFZhbHVlKSkge1xuICBcdFx0cmV0dXJuIHZpZXdtb2RlbC5jYWNoZVtrZXlwYXRoLnN0cl0gPSBGQUlMRURfTE9PS1VQO1xuICBcdH1cblxuICBcdHZhbHVlID0gcGFyZW50VmFsdWVba2V5cGF0aC5sYXN0S2V5XTtcblxuICBcdC8vIERvIHdlIGhhdmUgYW4gYWRhcHRvciBmb3IgdGhpcyB2YWx1ZT9cbiAgXHR2aWV3bW9kZWwuYWRhcHQoa2V5cGF0aC5zdHIsIHZhbHVlLCBmYWxzZSk7XG5cbiAgXHQvLyBVcGRhdGUgY2FjaGVcbiAgXHR2aWV3bW9kZWwuY2FjaGVba2V5cGF0aC5zdHJdID0gdmFsdWU7XG4gIFx0cmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgdmFyIHZpZXdtb2RlbF9wcm90b3R5cGVfaW5pdCA9IFZpZXdtb2RlbCRpbml0O1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRpbml0KCkge1xuICBcdHZhciBrZXk7XG5cbiAgXHRmb3IgKGtleSBpbiB0aGlzLmNvbXB1dGF0aW9ucykge1xuICBcdFx0dGhpcy5jb21wdXRhdGlvbnNba2V5XS5pbml0KHRoaXMpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfbWFwID0gVmlld21vZGVsJG1hcDtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkbWFwKGtleSwgb3B0aW9ucykge1xuICBcdHZhciBtYXBwaW5nID0gdGhpcy5tYXBwaW5nc1trZXkuc3RyXSA9IG5ldyBNYXBwaW5nKGtleSwgb3B0aW9ucyk7XG4gIFx0bWFwcGluZy5pbml0Vmlld21vZGVsKHRoaXMpO1xuICBcdHJldHVybiBtYXBwaW5nO1xuICB9XG5cbiAgdmFyIE1hcHBpbmcgPSBmdW5jdGlvbiAobG9jYWxLZXksIG9wdGlvbnMpIHtcbiAgXHR0aGlzLmxvY2FsS2V5ID0gbG9jYWxLZXk7XG4gIFx0dGhpcy5rZXlwYXRoID0gb3B0aW9ucy5rZXlwYXRoO1xuICBcdHRoaXMub3JpZ2luID0gb3B0aW9ucy5vcmlnaW47XG5cbiAgXHR0aGlzLmRlcHMgPSBbXTtcbiAgXHR0aGlzLnVucmVzb2x2ZWQgPSBbXTtcblxuICBcdHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcbiAgfTtcblxuICBNYXBwaW5nLnByb3RvdHlwZSA9IHtcbiAgXHRmb3JjZVJlc29sdXRpb246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIFRPRE8gd2FybiwgYXMgcGVyICMxNjkyP1xuICBcdFx0dGhpcy5rZXlwYXRoID0gdGhpcy5sb2NhbEtleTtcbiAgXHRcdHRoaXMuc2V0dXAoKTtcbiAgXHR9LFxuXG4gIFx0Z2V0OiBmdW5jdGlvbiAoa2V5cGF0aCwgb3B0aW9ucykge1xuICBcdFx0aWYgKCF0aGlzLnJlc29sdmVkKSB7XG4gIFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcy5vcmlnaW4uZ2V0KHRoaXMubWFwKGtleXBhdGgpLCBvcHRpb25zKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5rZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcy5vcmlnaW4uZ2V0KHRoaXMua2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdGluaXRWaWV3bW9kZWw6IGZ1bmN0aW9uICh2aWV3bW9kZWwpIHtcbiAgXHRcdHRoaXMubG9jYWwgPSB2aWV3bW9kZWw7XG4gIFx0XHR0aGlzLnNldHVwKCk7XG4gIFx0fSxcblxuICBcdG1hcDogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdGlmICh0eXBlb2YgdGhpcy5rZXlwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMubG9jYWxLZXk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4ga2V5cGF0aC5yZXBsYWNlKHRoaXMubG9jYWxLZXksIHRoaXMua2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdHJlZ2lzdGVyOiBmdW5jdGlvbiAoa2V5cGF0aCwgZGVwZW5kYW50LCBncm91cCkge1xuICBcdFx0dGhpcy5kZXBzLnB1c2goeyBrZXlwYXRoOiBrZXlwYXRoLCBkZXA6IGRlcGVuZGFudCwgZ3JvdXA6IGdyb3VwIH0pO1xuXG4gIFx0XHRpZiAodGhpcy5yZXNvbHZlZCkge1xuICBcdFx0XHR0aGlzLm9yaWdpbi5yZWdpc3Rlcih0aGlzLm1hcChrZXlwYXRoKSwgZGVwZW5kYW50LCBncm91cCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlc29sdmU6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRpZiAodGhpcy5rZXlwYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy51bmJpbmQodHJ1ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0XHR0aGlzLnNldHVwKCk7XG4gIFx0fSxcblxuICBcdHNldDogZnVuY3Rpb24gKGtleXBhdGgsIHZhbHVlKSB7XG4gIFx0XHRpZiAoIXRoaXMucmVzb2x2ZWQpIHtcbiAgXHRcdFx0dGhpcy5mb3JjZVJlc29sdXRpb24oKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5vcmlnaW4uc2V0KHRoaXMubWFwKGtleXBhdGgpLCB2YWx1ZSk7XG4gIFx0fSxcblxuICBcdHNldHVwOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHRpZiAodGhpcy5rZXlwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnJlc29sdmVkID0gdHJ1ZTtcblxuICBcdFx0Ly8gYWNjdW11bGF0ZWQgZGVwZW5kYW50cyBjYW4gbm93IGJlIHJlZ2lzdGVyZWRcbiAgXHRcdGlmICh0aGlzLmRlcHMubGVuZ3RoKSB7XG4gIFx0XHRcdHRoaXMuZGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gIFx0XHRcdFx0dmFyIGtleXBhdGggPSBfdGhpcy5tYXAoZC5rZXlwYXRoKTtcbiAgXHRcdFx0XHRfdGhpcy5vcmlnaW4ucmVnaXN0ZXIoa2V5cGF0aCwgZC5kZXAsIGQuZ3JvdXApO1xuXG4gIFx0XHRcdFx0Ly8gVE9ETyB0aGlzIGlzIGEgYml0IG9mIGEgcmVkIGZsYWcuLi4gYWxsIGRlcHMgc2hvdWxkIGJlIHRoZSBzYW1lP1xuICBcdFx0XHRcdGlmIChkLmRlcC5zZXRWYWx1ZSkge1xuICBcdFx0XHRcdFx0ZC5kZXAuc2V0VmFsdWUoX3RoaXMub3JpZ2luLmdldChrZXlwYXRoKSk7XG4gIFx0XHRcdFx0fSBlbHNlIGlmIChkLmRlcC5pbnZhbGlkYXRlKSB7XG4gIFx0XHRcdFx0XHRkLmRlcC5pbnZhbGlkYXRlKCk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQuIFBsZWFzZSByYWlzZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzIC0gdGhhbmtzIVwiKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdHRoaXMub3JpZ2luLm1hcmsodGhpcy5rZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0c2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0aWYgKCF0aGlzLmtleXBhdGgpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTWFwcGluZyBkb2VzIG5vdCBoYXZlIGtleXBhdGgsIGNhbm5vdCBzZXQgdmFsdWUuIFBsZWFzZSByYWlzZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzIC0gdGhhbmtzIVwiKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5vcmlnaW4uc2V0KHRoaXMua2V5cGF0aCwgdmFsdWUpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uIChrZWVwTG9jYWwpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdGlmICgha2VlcExvY2FsKSB7XG4gIFx0XHRcdGRlbGV0ZSB0aGlzLmxvY2FsLm1hcHBpbmdzW3RoaXMubG9jYWxLZXldO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXRoaXMucmVzb2x2ZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmRlcHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICBcdFx0XHRfdGhpcy5vcmlnaW4udW5yZWdpc3RlcihfdGhpcy5tYXAoZC5rZXlwYXRoKSwgZC5kZXAsIGQuZ3JvdXApO1xuICBcdFx0fSk7XG5cbiAgXHRcdGlmICh0aGlzLnRyYWNrZXIpIHtcbiAgXHRcdFx0dGhpcy5vcmlnaW4udW5yZWdpc3Rlcih0aGlzLmtleXBhdGgsIHRoaXMudHJhY2tlcik7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVucmVnaXN0ZXI6IGZ1bmN0aW9uIChrZXlwYXRoLCBkZXBlbmRhbnQsIGdyb3VwKSB7XG4gIFx0XHR2YXIgZGVwcywgaTtcblxuICBcdFx0aWYgKCF0aGlzLnJlc29sdmVkKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0ZGVwcyA9IHRoaXMuZGVwcztcbiAgXHRcdGkgPSBkZXBzLmxlbmd0aDtcblxuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRpZiAoZGVwc1tpXS5kZXAgPT09IGRlcGVuZGFudCkge1xuICBcdFx0XHRcdGRlcHMuc3BsaWNlKGksIDEpO1xuICBcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHR0aGlzLm9yaWdpbi51bnJlZ2lzdGVyKHRoaXMubWFwKGtleXBhdGgpLCBkZXBlbmRhbnQsIGdyb3VwKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIG1hcmsgPSBWaWV3bW9kZWwkbWFyaztcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkbWFyayhrZXlwYXRoLCBvcHRpb25zKSB7XG4gIFx0dmFyIGNvbXB1dGF0aW9uLFxuICBcdCAgICBrZXlwYXRoU3RyID0ga2V5cGF0aC5zdHI7XG5cbiAgXHQvLyBpbXBsaWNpdCBjaGFuZ2VzIChpLmUuIGBmb28ubGVuZ3RoYCBvbiBgcmFjdGl2ZS5wdXNoKCdmb28nLDQyKWApXG4gIFx0Ly8gc2hvdWxkIG5vdCBiZSBwaWNrZWQgdXAgYnkgcGF0dGVybiBvYnNlcnZlcnNcbiAgXHRpZiAob3B0aW9ucykge1xuICBcdFx0aWYgKG9wdGlvbnMuaW1wbGljaXQpIHtcbiAgXHRcdFx0dGhpcy5pbXBsaWNpdENoYW5nZXNba2V5cGF0aFN0cl0gPSB0cnVlO1xuICBcdFx0fVxuICBcdFx0aWYgKG9wdGlvbnMubm9DYXNjYWRlKSB7XG4gIFx0XHRcdHRoaXMubm9DYXNjYWRlW2tleXBhdGhTdHJdID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoY29tcHV0YXRpb24gPSB0aGlzLmNvbXB1dGF0aW9uc1trZXlwYXRoU3RyXSkge1xuICBcdFx0Y29tcHV0YXRpb24uaW52YWxpZGF0ZSgpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmNoYW5nZXMuaW5kZXhPZihrZXlwYXRoKSA9PT0gLTEpIHtcbiAgXHRcdHRoaXMuY2hhbmdlcy5wdXNoKGtleXBhdGgpO1xuICBcdH1cblxuICBcdC8vIHBhc3Mgb24ga2VlcEV4aXN0aW5nV3JhcHBlciwgaWYgd2UgY2FuXG4gIFx0dmFyIGtlZXBFeGlzdGluZ1dyYXBwZXIgPSBvcHRpb25zID8gb3B0aW9ucy5rZWVwRXhpc3RpbmdXcmFwcGVyIDogZmFsc2U7XG5cbiAgXHR0aGlzLmNsZWFyQ2FjaGUoa2V5cGF0aFN0ciwga2VlcEV4aXN0aW5nV3JhcHBlcik7XG5cbiAgXHRpZiAodGhpcy5yZWFkeSkge1xuICBcdFx0dGhpcy5vbmNoYW5nZSgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBtYXBPbGRUb05ld0luZGV4ID0gZnVuY3Rpb24gKG9sZEFycmF5LCBuZXdBcnJheSkge1xuICBcdHZhciB1c2VkSW5kaWNlcywgZmlyc3RVbnVzZWRJbmRleCwgbmV3SW5kaWNlcywgY2hhbmdlZDtcblxuICBcdHVzZWRJbmRpY2VzID0ge307XG4gIFx0Zmlyc3RVbnVzZWRJbmRleCA9IDA7XG5cbiAgXHRuZXdJbmRpY2VzID0gb2xkQXJyYXkubWFwKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gIFx0XHR2YXIgaW5kZXgsIHN0YXJ0LCBsZW47XG5cbiAgXHRcdHN0YXJ0ID0gZmlyc3RVbnVzZWRJbmRleDtcbiAgXHRcdGxlbiA9IG5ld0FycmF5Lmxlbmd0aDtcblxuICBcdFx0ZG8ge1xuICBcdFx0XHRpbmRleCA9IG5ld0FycmF5LmluZGV4T2YoaXRlbSwgc3RhcnQpO1xuXG4gIFx0XHRcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcbiAgXHRcdFx0XHRyZXR1cm4gLTE7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRzdGFydCA9IGluZGV4ICsgMTtcbiAgXHRcdH0gd2hpbGUgKHVzZWRJbmRpY2VzW2luZGV4XSAmJiBzdGFydCA8IGxlbik7XG5cbiAgXHRcdC8vIGtlZXAgdHJhY2sgb2YgdGhlIGZpcnN0IHVudXNlZCBpbmRleCwgc28gd2UgZG9uJ3Qgc2VhcmNoXG4gIFx0XHQvLyB0aGUgd2hvbGUgb2YgbmV3QXJyYXkgZm9yIGVhY2ggaXRlbSBpbiBvbGRBcnJheSB1bm5lY2Vzc2FyaWx5XG4gIFx0XHRpZiAoaW5kZXggPT09IGZpcnN0VW51c2VkSW5kZXgpIHtcbiAgXHRcdFx0Zmlyc3RVbnVzZWRJbmRleCArPSAxO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoaW5kZXggIT09IGkpIHtcbiAgXHRcdFx0Y2hhbmdlZCA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdHVzZWRJbmRpY2VzW2luZGV4XSA9IHRydWU7XG4gIFx0XHRyZXR1cm4gaW5kZXg7XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gbmV3SW5kaWNlcztcbiAgfTtcblxuICB2YXIgbWVyZ2UgPSBWaWV3bW9kZWwkbWVyZ2U7XG5cbiAgdmFyIGNvbXBhcmF0b3JzID0ge307XG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRtZXJnZShrZXlwYXRoLCBjdXJyZW50QXJyYXksIGFycmF5LCBvcHRpb25zKSB7XG4gIFx0dmFyIG9sZEFycmF5LCBuZXdBcnJheSwgY29tcGFyYXRvciwgbmV3SW5kaWNlcztcblxuICBcdHRoaXMubWFyayhrZXlwYXRoKTtcblxuICBcdGlmIChvcHRpb25zICYmIG9wdGlvbnMuY29tcGFyZSkge1xuXG4gIFx0XHRjb21wYXJhdG9yID0gZ2V0Q29tcGFyYXRvckZ1bmN0aW9uKG9wdGlvbnMuY29tcGFyZSk7XG5cbiAgXHRcdHRyeSB7XG4gIFx0XHRcdG9sZEFycmF5ID0gY3VycmVudEFycmF5Lm1hcChjb21wYXJhdG9yKTtcbiAgXHRcdFx0bmV3QXJyYXkgPSBhcnJheS5tYXAoY29tcGFyYXRvcik7XG4gIFx0XHR9IGNhdGNoIChlcnIpIHtcbiAgXHRcdFx0Ly8gZmFsbGJhY2sgdG8gYW4gaWRlbnRpdHkgY2hlY2sgLSB3b3JzdCBjYXNlIHNjZW5hcmlvIHdlIGhhdmVcbiAgXHRcdFx0Ly8gdG8gZG8gbW9yZSBET00gbWFuaXB1bGF0aW9uIHRoYW4gd2UgdGhvdWdodC4uLlxuICBcdFx0XHR3YXJuSWZEZWJ1ZyhcIm1lcmdlKCk6IFxcXCIlc1xcXCIgY29tcGFyaXNvbiBmYWlsZWQuIEZhbGxpbmcgYmFjayB0byBpZGVudGl0eSBjaGVja2luZ1wiLCBrZXlwYXRoKTtcblxuICBcdFx0XHRvbGRBcnJheSA9IGN1cnJlbnRBcnJheTtcbiAgXHRcdFx0bmV3QXJyYXkgPSBhcnJheTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0b2xkQXJyYXkgPSBjdXJyZW50QXJyYXk7XG4gIFx0XHRuZXdBcnJheSA9IGFycmF5O1xuICBcdH1cblxuICBcdC8vIGZpbmQgbmV3IGluZGljZXMgZm9yIG1lbWJlcnMgb2Ygb2xkQXJyYXlcbiAgXHRuZXdJbmRpY2VzID0gbWFwT2xkVG9OZXdJbmRleChvbGRBcnJheSwgbmV3QXJyYXkpO1xuXG4gIFx0dGhpcy5zbWFydFVwZGF0ZShrZXlwYXRoLCBhcnJheSwgbmV3SW5kaWNlcywgY3VycmVudEFycmF5Lmxlbmd0aCAhPT0gYXJyYXkubGVuZ3RoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeShpdGVtKSB7XG4gIFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KGl0ZW0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q29tcGFyYXRvckZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcbiAgXHQvLyBJZiBgY29tcGFyZWAgaXMgYHRydWVgLCB3ZSB1c2UgSlNPTi5zdHJpbmdpZnkgdG8gY29tcGFyZVxuICBcdC8vIG9iamVjdHMgdGhhdCBhcmUgdGhlIHNhbWUgc2hhcGUsIGJ1dCBub24taWRlbnRpY2FsIC0gaS5lLlxuICBcdC8vIHsgZm9vOiAnYmFyJyB9ICE9PSB7IGZvbzogJ2JhcicgfVxuICBcdGlmIChjb21wYXJhdG9yID09PSB0cnVlKSB7XG4gIFx0XHRyZXR1cm4gc3RyaW5naWZ5O1xuICBcdH1cblxuICBcdGlmICh0eXBlb2YgY29tcGFyYXRvciA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0aWYgKCFjb21wYXJhdG9yc1tjb21wYXJhdG9yXSkge1xuICBcdFx0XHRjb21wYXJhdG9yc1tjb21wYXJhdG9yXSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGl0ZW1bY29tcGFyYXRvcl07XG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBjb21wYXJhdG9yc1tjb21wYXJhdG9yXTtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZW9mIGNvbXBhcmF0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0cmV0dXJuIGNvbXBhcmF0b3I7XG4gIFx0fVxuXG4gIFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIGBjb21wYXJlYCBvcHRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uLCBvciBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gaWRlbnRpZnlpbmcgZmllbGQgKG9yIGB0cnVlYCB0byB1c2UgSlNPTi5zdHJpbmdpZnkpXCIpO1xuICB9XG5cbiAgdmFyIHJlZ2lzdGVyID0gVmlld21vZGVsJHJlZ2lzdGVyO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRyZWdpc3RlcihrZXlwYXRoLCBkZXBlbmRhbnQpIHtcbiAgXHR2YXIgZ3JvdXAgPSBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IFwiZGVmYXVsdFwiIDogYXJndW1lbnRzWzJdO1xuXG4gIFx0dmFyIG1hcHBpbmcsIGRlcHNCeUtleXBhdGgsIGRlcHM7XG5cbiAgXHRpZiAoZGVwZW5kYW50LmlzU3RhdGljKSB7XG4gIFx0XHRyZXR1cm47IC8vIFRPRE8gd2Ugc2hvdWxkIG5ldmVyIGdldCBoZXJlIGlmIGEgZGVwZW5kYW50IGlzIHN0YXRpYy4uLlxuICBcdH1cblxuICBcdGlmIChtYXBwaW5nID0gdGhpcy5tYXBwaW5nc1trZXlwYXRoLmZpcnN0S2V5XSkge1xuICBcdFx0bWFwcGluZy5yZWdpc3RlcihrZXlwYXRoLCBkZXBlbmRhbnQsIGdyb3VwKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0ZGVwc0J5S2V5cGF0aCA9IHRoaXMuZGVwc1tncm91cF0gfHwgKHRoaXMuZGVwc1tncm91cF0gPSB7fSk7XG4gIFx0XHRkZXBzID0gZGVwc0J5S2V5cGF0aFtrZXlwYXRoLnN0cl0gfHwgKGRlcHNCeUtleXBhdGhba2V5cGF0aC5zdHJdID0gW10pO1xuXG4gIFx0XHRkZXBzLnB1c2goZGVwZW5kYW50KTtcblxuICBcdFx0aWYgKCF0aGlzLmRlcHNNYXBbZ3JvdXBdKSB7XG4gIFx0XHRcdHRoaXMuZGVwc01hcFtncm91cF0gPSB7fTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFrZXlwYXRoLmlzUm9vdCkge1xuICBcdFx0XHRyZWdpc3Rlcl9fdXBkYXRlRGVwZW5kYW50c01hcCh0aGlzLCBrZXlwYXRoLCBncm91cCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJfX3VwZGF0ZURlcGVuZGFudHNNYXAodmlld21vZGVsLCBrZXlwYXRoLCBncm91cCkge1xuICBcdHZhciBtYXAsIHBhcmVudCwga2V5cGF0aFN0cjtcblxuICBcdC8vIHVwZGF0ZSBkZXBlbmRhbnRzIG1hcFxuICBcdHdoaWxlICgha2V5cGF0aC5pc1Jvb3QpIHtcbiAgXHRcdG1hcCA9IHZpZXdtb2RlbC5kZXBzTWFwW2dyb3VwXTtcbiAgXHRcdHBhcmVudCA9IG1hcFtrZXlwYXRoLnBhcmVudC5zdHJdIHx8IChtYXBba2V5cGF0aC5wYXJlbnQuc3RyXSA9IFtdKTtcblxuICBcdFx0a2V5cGF0aFN0ciA9IGtleXBhdGguc3RyO1xuXG4gIFx0XHQvLyBUT0RPIGZpbmQgYW4gYWx0ZXJuYXRpdmUgdG8gdGhpcyBuYXN0eSBhcHByb2FjaFxuICBcdFx0aWYgKHBhcmVudFtcIl9cIiArIGtleXBhdGhTdHJdID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cGFyZW50W1wiX1wiICsga2V5cGF0aFN0cl0gPSAwO1xuICBcdFx0XHRwYXJlbnQucHVzaChrZXlwYXRoKTtcbiAgXHRcdH1cblxuICBcdFx0cGFyZW50W1wiX1wiICsga2V5cGF0aFN0cl0gKz0gMTtcbiAgXHRcdGtleXBhdGggPSBrZXlwYXRoLnBhcmVudDtcbiAgXHR9XG4gIH1cblxuICB2YXIgcmVsZWFzZSA9IFZpZXdtb2RlbCRyZWxlYXNlO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRyZWxlYXNlKCkge1xuICBcdHJldHVybiB0aGlzLmNhcHR1cmVHcm91cHMucG9wKCk7XG4gIH1cblxuICB2YXIgcmVzZXQgPSBWaWV3bW9kZWwkcmVzZXQ7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJHJlc2V0KGRhdGEpIHtcbiAgXHR0aGlzLmRhdGEgPSBkYXRhO1xuICBcdHRoaXMuY2xlYXJDYWNoZShcIlwiKTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfc2V0ID0gVmlld21vZGVsJHNldDtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkc2V0KGtleXBhdGgsIHZhbHVlKSB7XG4gIFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzJdO1xuXG4gIFx0dmFyIG1hcHBpbmcsIGNvbXB1dGF0aW9uLCB3cmFwcGVyLCBrZWVwRXhpc3RpbmdXcmFwcGVyO1xuXG4gIFx0Ly8gdW5sZXNzIGRhdGEgaXMgYmVpbmcgc2V0IGZvciBkYXRhIHRyYWNraW5nIHB1cnBvc2VzXG4gIFx0aWYgKCFvcHRpb25zLm5vTWFwcGluZykge1xuICBcdFx0Ly8gSWYgdGhpcyBkYXRhIGJlbG9uZ3MgdG8gYSBkaWZmZXJlbnQgdmlld21vZGVsLFxuICBcdFx0Ly8gcGFzcyB0aGUgY2hhbmdlIGFsb25nXG4gIFx0XHRpZiAobWFwcGluZyA9IHRoaXMubWFwcGluZ3Nba2V5cGF0aC5maXJzdEtleV0pIHtcbiAgXHRcdFx0cmV0dXJuIG1hcHBpbmcuc2V0KGtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRjb21wdXRhdGlvbiA9IHRoaXMuY29tcHV0YXRpb25zW2tleXBhdGguc3RyXTtcbiAgXHRpZiAoY29tcHV0YXRpb24pIHtcbiAgXHRcdGlmIChjb21wdXRhdGlvbi5zZXR0aW5nKSB7XG4gIFx0XHRcdC8vIGxldCB0aGUgb3RoZXIgY29tcHV0YXRpb24gc2V0KCkgaGFuZGxlIHRoaW5ncy4uLlxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0XHRjb21wdXRhdGlvbi5zZXQodmFsdWUpO1xuICBcdFx0dmFsdWUgPSBjb21wdXRhdGlvbi5nZXQoKTtcbiAgXHR9XG5cbiAgXHRpZiAoaXNFcXVhbCh0aGlzLmNhY2hlW2tleXBhdGguc3RyXSwgdmFsdWUpKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0d3JhcHBlciA9IHRoaXMud3JhcHBlZFtrZXlwYXRoLnN0cl07XG5cbiAgXHQvLyBJZiB3ZSBoYXZlIGEgd3JhcHBlciB3aXRoIGEgYHJlc2V0KClgIG1ldGhvZCwgd2UgdHJ5IGFuZCB1c2UgaXQuIElmIHRoZVxuICBcdC8vIGByZXNldCgpYCBtZXRob2QgcmV0dXJucyBmYWxzZSwgdGhlIHdyYXBwZXIgc2hvdWxkIGJlIHRvcm4gZG93biwgYW5kXG4gIFx0Ly8gKG1vc3QgbGlrZWx5KSBhIG5ldyBvbmUgc2hvdWxkIGJlIGNyZWF0ZWQgbGF0ZXJcbiAgXHRpZiAod3JhcHBlciAmJiB3cmFwcGVyLnJlc2V0KSB7XG4gIFx0XHRrZWVwRXhpc3RpbmdXcmFwcGVyID0gd3JhcHBlci5yZXNldCh2YWx1ZSkgIT09IGZhbHNlO1xuXG4gIFx0XHRpZiAoa2VlcEV4aXN0aW5nV3JhcHBlcikge1xuICBcdFx0XHR2YWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKCFjb21wdXRhdGlvbiAmJiAha2VlcEV4aXN0aW5nV3JhcHBlcikge1xuICBcdFx0cmVzb2x2ZVNldCh0aGlzLCBrZXlwYXRoLCB2YWx1ZSk7XG4gIFx0fVxuXG4gIFx0aWYgKCFvcHRpb25zLnNpbGVudCkge1xuICBcdFx0dGhpcy5tYXJrKGtleXBhdGgpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBXZSdyZSBzZXR0aW5nIGEgcGFyZW50IG9mIHRoZSBvcmlnaW5hbCB0YXJnZXQga2V5cGF0aCAoaS5lLlxuICBcdFx0Ly8gY3JlYXRpbmcgYSBmcmVzaCBicmFuY2gpIC0gd2UgbmVlZCB0byBjbGVhciB0aGUgY2FjaGUsIGJ1dFxuICBcdFx0Ly8gbm90IG1hcmsgaXQgYXMgYSBjaGFuZ2VcbiAgXHRcdHRoaXMuY2xlYXJDYWNoZShrZXlwYXRoLnN0cik7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVNldCh2aWV3bW9kZWwsIGtleXBhdGgsIHZhbHVlKSB7XG4gIFx0dmFyIHdyYXBwZXIsIHBhcmVudFZhbHVlLCB3cmFwcGVyU2V0LCB2YWx1ZVNldDtcblxuICBcdHdyYXBwZXJTZXQgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAod3JhcHBlci5zZXQpIHtcbiAgXHRcdFx0d3JhcHBlci5zZXQoa2V5cGF0aC5sYXN0S2V5LCB2YWx1ZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRwYXJlbnRWYWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG4gIFx0XHRcdHZhbHVlU2V0KCk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdHZhbHVlU2V0ID0gZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCFwYXJlbnRWYWx1ZSkge1xuICBcdFx0XHRwYXJlbnRWYWx1ZSA9IGNyZWF0ZUJyYW5jaChrZXlwYXRoLmxhc3RLZXkpO1xuICBcdFx0XHR2aWV3bW9kZWwuc2V0KGtleXBhdGgucGFyZW50LCBwYXJlbnRWYWx1ZSwgeyBzaWxlbnQ6IHRydWUgfSk7XG4gIFx0XHR9XG4gIFx0XHRwYXJlbnRWYWx1ZVtrZXlwYXRoLmxhc3RLZXldID0gdmFsdWU7XG4gIFx0fTtcblxuICBcdHdyYXBwZXIgPSB2aWV3bW9kZWwud3JhcHBlZFtrZXlwYXRoLnBhcmVudC5zdHJdO1xuXG4gIFx0aWYgKHdyYXBwZXIpIHtcbiAgXHRcdHdyYXBwZXJTZXQoKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cGFyZW50VmFsdWUgPSB2aWV3bW9kZWwuZ2V0KGtleXBhdGgucGFyZW50KTtcblxuICBcdFx0Ly8gbWF5IGhhdmUgYmVlbiB3cmFwcGVkIHZpYSB0aGUgYWJvdmUgLmdldCgpXG4gIFx0XHQvLyBjYWxsIG9uIHZpZXdtb2RlbCBpZiB0aGlzIGlzIGZpcnN0IGFjY2VzcyB2aWEgLnNldCgpIVxuICBcdFx0aWYgKHdyYXBwZXIgPSB2aWV3bW9kZWwud3JhcHBlZFtrZXlwYXRoLnBhcmVudC5zdHJdKSB7XG4gIFx0XHRcdHdyYXBwZXJTZXQoKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHZhbHVlU2V0KCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIHNtYXJ0VXBkYXRlID0gVmlld21vZGVsJHNtYXJ0VXBkYXRlO1xuXG4gIHZhciBpbXBsaWNpdE9wdGlvbiA9IHsgaW1wbGljaXQ6IHRydWUgfSxcbiAgICAgIG5vQ2FzY2FkZU9wdGlvbiA9IHsgbm9DYXNjYWRlOiB0cnVlIH07XG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRzbWFydFVwZGF0ZShrZXlwYXRoLCBhcnJheSwgbmV3SW5kaWNlcykge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgZGVwZW5kYW50cywgb2xkTGVuZ3RoLCBpO1xuXG4gIFx0b2xkTGVuZ3RoID0gbmV3SW5kaWNlcy5sZW5ndGg7XG5cbiAgXHQvLyBJbmRpY2VzIHRoYXQgYXJlIGJlaW5nIHJlbW92ZWQgc2hvdWxkIGJlIG1hcmtlZCBhcyBkaXJ0eVxuICBcdG5ld0luZGljZXMuZm9yRWFjaChmdW5jdGlvbiAobmV3SW5kZXgsIG9sZEluZGV4KSB7XG4gIFx0XHRpZiAobmV3SW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdF90aGlzLm1hcmsoa2V5cGF0aC5qb2luKG9sZEluZGV4KSwgbm9DYXNjYWRlT3B0aW9uKTtcbiAgXHRcdH1cbiAgXHR9KTtcblxuICBcdC8vIFVwZGF0ZSB0aGUgbW9kZWxcbiAgXHQvLyBUT0RPIGFsbG93IGV4aXN0aW5nIGFycmF5IHRvIGJlIHVwZGF0ZWQgaW4gcGxhY2UsIHJhdGhlciB0aGFuIHJlcGxhY2VkP1xuICBcdHRoaXMuc2V0KGtleXBhdGgsIGFycmF5LCB7IHNpbGVudDogdHJ1ZSB9KTtcblxuICBcdGlmIChkZXBlbmRhbnRzID0gdGhpcy5kZXBzW1wiZGVmYXVsdFwiXVtrZXlwYXRoLnN0cl0pIHtcbiAgXHRcdGRlcGVuZGFudHMuZmlsdGVyKGNhblNodWZmbGUpLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgXHRcdFx0cmV0dXJuIGQuc2h1ZmZsZShuZXdJbmRpY2VzLCBhcnJheSk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRpZiAob2xkTGVuZ3RoICE9PSBhcnJheS5sZW5ndGgpIHtcbiAgXHRcdHRoaXMubWFyayhrZXlwYXRoLmpvaW4oXCJsZW5ndGhcIiksIGltcGxpY2l0T3B0aW9uKTtcblxuICBcdFx0Zm9yIChpID0gbmV3SW5kaWNlcy50b3VjaGVkRnJvbTsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRcdHRoaXMubWFyayhrZXlwYXRoLmpvaW4oaSkpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBkb24ndCBhbGxvdyByZW1vdmVkIGluZGV4ZXMgYmV5b25kIGVuZCBvZiBuZXcgYXJyYXkgdG8gdHJpZ2dlciByZWNvbXB1dGF0aW9uc1xuICBcdFx0Ly8gVE9ETyBpcyB0aGlzIHN0aWxsIG5lY2Vzc2FyeSwgbm93IHRoYXQgY29tcHV0YXRpb25zIGFyZSBsYXp5P1xuICBcdFx0Zm9yIChpID0gYXJyYXkubGVuZ3RoOyBpIDwgb2xkTGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdFx0dGhpcy5tYXJrKGtleXBhdGguam9pbihpKSwgbm9DYXNjYWRlT3B0aW9uKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBjYW5TaHVmZmxlKGRlcGVuZGFudCkge1xuICBcdHJldHVybiB0eXBlb2YgZGVwZW5kYW50LnNodWZmbGUgPT09IFwiZnVuY3Rpb25cIjtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfdGVhcmRvd24gPSBWaWV3bW9kZWwkdGVhcmRvd247XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJHRlYXJkb3duKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgdW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeTtcblxuICBcdC8vIENsZWFyIGVudGlyZSBjYWNoZSAtIHRoaXMgaGFzIHRoZSBkZXNpcmVkIHNpZGUtZWZmZWN0XG4gIFx0Ly8gb2YgdW53cmFwcGluZyBhZGFwdGVkIHZhbHVlcyAoZS5nLiBhcnJheXMpXG4gIFx0T2JqZWN0LmtleXModGhpcy5jYWNoZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0cmV0dXJuIF90aGlzLmNsZWFyQ2FjaGUoa2V5cGF0aCk7XG4gIFx0fSk7XG5cbiAgXHQvLyBUZWFyZG93biBhbnkgZmFpbGVkIGxvb2t1cHMgLSB3ZSBkb24ndCBuZWVkIHRoZW0gdG8gcmVzb2x2ZSBhbnkgbW9yZVxuICBcdHdoaWxlICh1bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5ID0gdGhpcy51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXMucG9wKCkpIHtcbiAgXHRcdHVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kudGVhcmRvd24oKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdW5yZWdpc3RlciA9IFZpZXdtb2RlbCR1bnJlZ2lzdGVyO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCR1bnJlZ2lzdGVyKGtleXBhdGgsIGRlcGVuZGFudCkge1xuICBcdHZhciBncm91cCA9IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gXCJkZWZhdWx0XCIgOiBhcmd1bWVudHNbMl07XG5cbiAgXHR2YXIgbWFwcGluZywgZGVwcywgaW5kZXg7XG5cbiAgXHRpZiAoZGVwZW5kYW50LmlzU3RhdGljKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKG1hcHBpbmcgPSB0aGlzLm1hcHBpbmdzW2tleXBhdGguZmlyc3RLZXldKSB7XG4gIFx0XHRyZXR1cm4gbWFwcGluZy51bnJlZ2lzdGVyKGtleXBhdGgsIGRlcGVuZGFudCwgZ3JvdXApO1xuICBcdH1cblxuICBcdGRlcHMgPSB0aGlzLmRlcHNbZ3JvdXBdW2tleXBhdGguc3RyXTtcbiAgXHRpbmRleCA9IGRlcHMuaW5kZXhPZihkZXBlbmRhbnQpO1xuXG4gIFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIHJlbW92ZSBhIGRlcGVuZGFudCB0aGF0IHdhcyBubyBsb25nZXIgcmVnaXN0ZXJlZCEgVGhpcyBzaG91bGQgbm90IGhhcHBlbi4gSWYgeW91IGFyZSBzZWVpbmcgdGhpcyBidWcgaW4gZGV2ZWxvcG1lbnQgcGxlYXNlIHJhaXNlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9SYWN0aXZlSlMvUmFjdGl2ZS9pc3N1ZXMgLSB0aGFua3NcIik7XG4gIFx0fVxuXG4gIFx0ZGVwcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gIFx0aWYgKGtleXBhdGguaXNSb290KSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0dW5yZWdpc3Rlcl9fdXBkYXRlRGVwZW5kYW50c01hcCh0aGlzLCBrZXlwYXRoLCBncm91cCk7XG4gIH1cblxuICBmdW5jdGlvbiB1bnJlZ2lzdGVyX191cGRhdGVEZXBlbmRhbnRzTWFwKHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXApIHtcbiAgXHR2YXIgbWFwLCBwYXJlbnQ7XG5cbiAgXHQvLyB1cGRhdGUgZGVwZW5kYW50cyBtYXBcbiAgXHR3aGlsZSAoIWtleXBhdGguaXNSb290KSB7XG4gIFx0XHRtYXAgPSB2aWV3bW9kZWwuZGVwc01hcFtncm91cF07XG4gIFx0XHRwYXJlbnQgPSBtYXBba2V5cGF0aC5wYXJlbnQuc3RyXTtcblxuICBcdFx0cGFyZW50W1wiX1wiICsga2V5cGF0aC5zdHJdIC09IDE7XG5cbiAgXHRcdGlmICghcGFyZW50W1wiX1wiICsga2V5cGF0aC5zdHJdKSB7XG4gIFx0XHRcdC8vIHJlbW92ZSBmcm9tIHBhcmVudCBkZXBzIG1hcFxuICBcdFx0XHRyZW1vdmVGcm9tQXJyYXkocGFyZW50LCBrZXlwYXRoKTtcbiAgXHRcdFx0cGFyZW50W1wiX1wiICsga2V5cGF0aC5zdHJdID0gdW5kZWZpbmVkO1xuICBcdFx0fVxuXG4gIFx0XHRrZXlwYXRoID0ga2V5cGF0aC5wYXJlbnQ7XG4gIFx0fVxuICB9XG5cbiAgdmFyIFZpZXdtb2RlbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dmFyIGFkYXB0ID0gb3B0aW9ucy5hZGFwdDtcbiAgXHR2YXIgZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgXHR2YXIgcmFjdGl2ZSA9IG9wdGlvbnMucmFjdGl2ZTtcbiAgXHR2YXIgY29tcHV0ZWQgPSBvcHRpb25zLmNvbXB1dGVkO1xuICBcdHZhciBtYXBwaW5ncyA9IG9wdGlvbnMubWFwcGluZ3M7XG4gIFx0dmFyIGtleTtcbiAgXHR2YXIgbWFwcGluZztcblxuICBcdC8vIFRPRE8gaXMgaXQgcG9zc2libGUgdG8gcmVtb3ZlIHRoaXMgcmVmZXJlbmNlP1xuICBcdHRoaXMucmFjdGl2ZSA9IHJhY3RpdmU7XG5cbiAgXHR0aGlzLmFkYXB0b3JzID0gYWRhcHQ7XG4gIFx0dGhpcy5vbmNoYW5nZSA9IG9wdGlvbnMub25jaGFuZ2U7XG5cbiAgXHR0aGlzLmNhY2hlID0ge307IC8vIHdlIG5lZWQgdG8gYmUgYWJsZSB0byB1c2UgaGFzT3duUHJvcGVydHksIHNvIGNhbid0IGluaGVyaXQgZnJvbSBudWxsXG4gIFx0dGhpcy5jYWNoZU1hcCA9IGNyZWF0ZShudWxsKTtcblxuICBcdHRoaXMuZGVwcyA9IHtcbiAgXHRcdGNvbXB1dGVkOiBjcmVhdGUobnVsbCksXG4gIFx0XHRcImRlZmF1bHRcIjogY3JlYXRlKG51bGwpXG4gIFx0fTtcbiAgXHR0aGlzLmRlcHNNYXAgPSB7XG4gIFx0XHRjb21wdXRlZDogY3JlYXRlKG51bGwpLFxuICBcdFx0XCJkZWZhdWx0XCI6IGNyZWF0ZShudWxsKVxuICBcdH07XG5cbiAgXHR0aGlzLnBhdHRlcm5PYnNlcnZlcnMgPSBbXTtcblxuICBcdHRoaXMuc3BlY2lhbHMgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHR0aGlzLndyYXBwZWQgPSBjcmVhdGUobnVsbCk7XG4gIFx0dGhpcy5jb21wdXRhdGlvbnMgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHR0aGlzLmNhcHR1cmVHcm91cHMgPSBbXTtcbiAgXHR0aGlzLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llcyA9IFtdO1xuXG4gIFx0dGhpcy5jaGFuZ2VzID0gW107XG4gIFx0dGhpcy5pbXBsaWNpdENoYW5nZXMgPSB7fTtcbiAgXHR0aGlzLm5vQ2FzY2FkZSA9IHt9O1xuXG4gIFx0dGhpcy5kYXRhID0gZGF0YTtcblxuICBcdC8vIHNldCB1cCBleHBsaWNpdCBtYXBwaW5nc1xuICBcdHRoaXMubWFwcGluZ3MgPSBjcmVhdGUobnVsbCk7XG4gIFx0Zm9yIChrZXkgaW4gbWFwcGluZ3MpIHtcbiAgXHRcdHRoaXMubWFwKGdldEtleXBhdGgoa2V5KSwgbWFwcGluZ3Nba2V5XSk7XG4gIFx0fVxuXG4gIFx0aWYgKGRhdGEpIHtcbiAgXHRcdC8vIGlmIGRhdGEgZXhpc3RzIGxvY2FsbHksIGJ1dCBpcyBtaXNzaW5nIG9uIHRoZSBwYXJlbnQsXG4gIFx0XHQvLyB3ZSB0cmFuc2ZlciBvd25lcnNoaXAgdG8gdGhlIHBhcmVudFxuICBcdFx0Zm9yIChrZXkgaW4gZGF0YSkge1xuICBcdFx0XHRpZiAoKG1hcHBpbmcgPSB0aGlzLm1hcHBpbmdzW2tleV0pICYmIG1hcHBpbmcuZ2V0VmFsdWUoKSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0bWFwcGluZy5zZXRWYWx1ZShkYXRhW2tleV0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Zm9yIChrZXkgaW4gY29tcHV0ZWQpIHtcbiAgXHRcdGlmIChtYXBwaW5ncyAmJiBrZXkgaW4gbWFwcGluZ3MpIHtcbiAgXHRcdFx0ZmF0YWwoXCJDYW5ub3QgbWFwIHRvIGEgY29tcHV0ZWQgcHJvcGVydHkgKCclcycpXCIsIGtleSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuY29tcHV0ZShnZXRLZXlwYXRoKGtleSksIGNvbXB1dGVkW2tleV0pO1xuICBcdH1cblxuICBcdHRoaXMucmVhZHkgPSB0cnVlO1xuICB9O1xuXG4gIFZpZXdtb2RlbC5wcm90b3R5cGUgPSB7XG4gIFx0YWRhcHQ6IHByb3RvdHlwZV9hZGFwdCxcbiAgXHRhcHBseUNoYW5nZXM6IGFwcGx5Q2hhbmdlcyxcbiAgXHRjYXB0dXJlOiBjYXB0dXJlLFxuICBcdGNsZWFyQ2FjaGU6IGNsZWFyQ2FjaGUsXG4gIFx0Y29tcHV0ZTogY29tcHV0ZSxcbiAgXHRnZXQ6IHZpZXdtb2RlbF9wcm90b3R5cGVfZ2V0LFxuICBcdGluaXQ6IHZpZXdtb2RlbF9wcm90b3R5cGVfaW5pdCxcbiAgXHRtYXA6IHByb3RvdHlwZV9tYXAsXG4gIFx0bWFyazogbWFyayxcbiAgXHRtZXJnZTogbWVyZ2UsXG4gIFx0cmVnaXN0ZXI6IHJlZ2lzdGVyLFxuICBcdHJlbGVhc2U6IHJlbGVhc2UsXG4gIFx0cmVzZXQ6IHJlc2V0LFxuICBcdHNldDogcHJvdG90eXBlX3NldCxcbiAgXHRzbWFydFVwZGF0ZTogc21hcnRVcGRhdGUsXG4gIFx0dGVhcmRvd246IHByb3RvdHlwZV90ZWFyZG93bixcbiAgXHR1bnJlZ2lzdGVyOiB1bnJlZ2lzdGVyXG4gIH07XG5cbiAgdmFyIHZpZXdtb2RlbF9WaWV3bW9kZWwgPSBWaWV3bW9kZWw7XG5cbiAgZnVuY3Rpb24gSG9va1F1ZXVlKGV2ZW50KSB7XG4gIFx0dGhpcy5ob29rID0gbmV3IGhvb2tzX0hvb2soZXZlbnQpO1xuICBcdHRoaXMuaW5Qcm9jZXNzID0ge307XG4gIFx0dGhpcy5xdWV1ZSA9IHt9O1xuICB9XG5cbiAgSG9va1F1ZXVlLnByb3RvdHlwZSA9IHtcblxuICBcdGNvbnN0cnVjdG9yOiBIb29rUXVldWUsXG5cbiAgXHRiZWdpbjogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdHRoaXMuaW5Qcm9jZXNzW3JhY3RpdmUuX2d1aWRdID0gdHJ1ZTtcbiAgXHR9LFxuXG4gIFx0ZW5kOiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuXG4gIFx0XHR2YXIgcGFyZW50ID0gcmFjdGl2ZS5wYXJlbnQ7XG5cbiAgXHRcdC8vIElmIHRoaXMgaXMgKmlzbid0KiBhIGNoaWxkIG9mIGEgY29tcG9uZW50IHRoYXQncyBpbiBwcm9jZXNzLFxuICBcdFx0Ly8gaXQgc2hvdWxkIGNhbGwgbWV0aG9kcyBvciBmaXJlIGF0IHRoaXMgcG9pbnRcbiAgXHRcdGlmICghcGFyZW50IHx8ICF0aGlzLmluUHJvY2Vzc1twYXJlbnQuX2d1aWRdKSB7XG4gIFx0XHRcdGZpcmUodGhpcywgcmFjdGl2ZSk7XG4gIFx0XHR9XG4gIFx0XHQvLyBlbHNld2lzZSwgaGFuZG9mZiB0byBwYXJlbnQgdG8gZmlyZSB3aGVuIHJlYWR5XG4gIFx0XHRlbHNlIHtcbiAgXHRcdFx0Z2V0Q2hpbGRRdWV1ZSh0aGlzLnF1ZXVlLCBwYXJlbnQpLnB1c2gocmFjdGl2ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdGRlbGV0ZSB0aGlzLmluUHJvY2Vzc1tyYWN0aXZlLl9ndWlkXTtcbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0Q2hpbGRRdWV1ZShxdWV1ZSwgcmFjdGl2ZSkge1xuICBcdHJldHVybiBxdWV1ZVtyYWN0aXZlLl9ndWlkXSB8fCAocXVldWVbcmFjdGl2ZS5fZ3VpZF0gPSBbXSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlKGhvb2tRdWV1ZSwgcmFjdGl2ZSkge1xuXG4gIFx0dmFyIGNoaWxkUXVldWUgPSBnZXRDaGlsZFF1ZXVlKGhvb2tRdWV1ZS5xdWV1ZSwgcmFjdGl2ZSk7XG5cbiAgXHRob29rUXVldWUuaG9vay5maXJlKHJhY3RpdmUpO1xuXG4gIFx0Ly8gcXVldWUgaXMgXCJsaXZlXCIgYmVjYXVzZSBjb21wb25lbnRzIGNhbiBlbmQgdXAgYmVpbmdcbiAgXHQvLyBhZGRlZCB3aGlsZSBob29rcyBmaXJlIG9uIHBhcmVudHMgdGhhdCBtb2RpZnkgZGF0YSB2YWx1ZXMuXG4gIFx0d2hpbGUgKGNoaWxkUXVldWUubGVuZ3RoKSB7XG4gIFx0XHRmaXJlKGhvb2tRdWV1ZSwgY2hpbGRRdWV1ZS5zaGlmdCgpKTtcbiAgXHR9XG5cbiAgXHRkZWxldGUgaG9va1F1ZXVlLnF1ZXVlW3JhY3RpdmUuX2d1aWRdO1xuICB9XG5cbiAgdmFyIGhvb2tzX0hvb2tRdWV1ZSA9IEhvb2tRdWV1ZTtcblxuICB2YXIgaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXMgPSBnZXRDb21wdXRhdGlvblNpZ25hdHVyZXM7XG5cbiAgdmFyIGhlbHBlcnNfZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzX19wYXR0ZXJuID0gL1xcJFxceyhbXlxcfV0rKVxcfS9nO1xuICBmdW5jdGlvbiBnZXRDb21wdXRhdGlvblNpZ25hdHVyZXMocmFjdGl2ZSwgY29tcHV0ZWQpIHtcbiAgXHR2YXIgc2lnbmF0dXJlcyA9IHt9LFxuICBcdCAgICBrZXk7XG5cbiAgXHRmb3IgKGtleSBpbiBjb21wdXRlZCkge1xuICBcdFx0c2lnbmF0dXJlc1trZXldID0gZ2V0Q29tcHV0YXRpb25TaWduYXR1cmUocmFjdGl2ZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc2lnbmF0dXJlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbXB1dGF0aW9uU2lnbmF0dXJlKHJhY3RpdmUsIGtleSwgc2lnbmF0dXJlKSB7XG4gIFx0dmFyIGdldHRlciwgc2V0dGVyO1xuXG4gIFx0aWYgKHR5cGVvZiBzaWduYXR1cmUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0Z2V0dGVyID0gaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXNfX2JpbmQoc2lnbmF0dXJlLCByYWN0aXZlKTtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZW9mIHNpZ25hdHVyZSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0Z2V0dGVyID0gY3JlYXRlRnVuY3Rpb25Gcm9tU3RyaW5nKHJhY3RpdmUsIHNpZ25hdHVyZSk7XG4gIFx0fVxuXG4gIFx0aWYgKHR5cGVvZiBzaWduYXR1cmUgPT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdGlmICh0eXBlb2Ygc2lnbmF0dXJlLmdldCA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRnZXR0ZXIgPSBjcmVhdGVGdW5jdGlvbkZyb21TdHJpbmcocmFjdGl2ZSwgc2lnbmF0dXJlLmdldCk7XG4gIFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBzaWduYXR1cmUuZ2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0Z2V0dGVyID0gaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXNfX2JpbmQoc2lnbmF0dXJlLmdldCwgcmFjdGl2ZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRmYXRhbChcImAlc2AgY29tcHV0YXRpb24gbXVzdCBoYXZlIGEgYGdldCgpYCBtZXRob2RcIiwga2V5KTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHR5cGVvZiBzaWduYXR1cmUuc2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0c2V0dGVyID0gaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXNfX2JpbmQoc2lnbmF0dXJlLnNldCwgcmFjdGl2ZSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHsgZ2V0dGVyOiBnZXR0ZXIsIHNldHRlcjogc2V0dGVyIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkZyb21TdHJpbmcocmFjdGl2ZSwgc3RyKSB7XG4gIFx0dmFyIGZ1bmN0aW9uQm9keSwgaGFzVGhpcywgZm47XG5cbiAgXHRmdW5jdGlvbkJvZHkgPSBcInJldHVybiAoXCIgKyBzdHIucmVwbGFjZShoZWxwZXJzX2dldENvbXB1dGF0aW9uU2lnbmF0dXJlc19fcGF0dGVybiwgZnVuY3Rpb24gKG1hdGNoLCBrZXlwYXRoKSB7XG4gIFx0XHRoYXNUaGlzID0gdHJ1ZTtcbiAgXHRcdHJldHVybiBcIl9fcmFjdGl2ZS5nZXQoXFxcIlwiICsga2V5cGF0aCArIFwiXFxcIilcIjtcbiAgXHR9KSArIFwiKTtcIjtcblxuICBcdGlmIChoYXNUaGlzKSB7XG4gIFx0XHRmdW5jdGlvbkJvZHkgPSBcInZhciBfX3JhY3RpdmUgPSB0aGlzOyBcIiArIGZ1bmN0aW9uQm9keTtcbiAgXHR9XG5cbiAgXHRmbiA9IG5ldyBGdW5jdGlvbihmdW5jdGlvbkJvZHkpO1xuICBcdHJldHVybiBoYXNUaGlzID8gZm4uYmluZChyYWN0aXZlKSA6IGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXNfX2JpbmQoZm4sIGNvbnRleHQpIHtcbiAgXHRyZXR1cm4gL3RoaXMvLnRlc3QoZm4udG9TdHJpbmcoKSkgPyBmbi5iaW5kKGNvbnRleHQpIDogZm47XG4gIH1cblxuICB2YXIgY29uc3RydWN0SG9vayA9IG5ldyBob29rc19Ib29rKFwiY29uc3RydWN0XCIpO1xuICB2YXIgY29uZmlnSG9vayA9IG5ldyBob29rc19Ib29rKFwiY29uZmlnXCIpO1xuICB2YXIgaW5pdEhvb2sgPSBuZXcgaG9va3NfSG9va1F1ZXVlKFwiaW5pdFwiKTtcbiAgdmFyIGluaXRpYWxpc2VfX3VpZCA9IDA7XG5cbiAgdmFyIGluaXRpYWxpc2VfX3JlZ2lzdHJ5TmFtZXMgPSBbXCJhZGFwdG9yc1wiLCBcImNvbXBvbmVudHNcIiwgXCJkZWNvcmF0b3JzXCIsIFwiZWFzaW5nXCIsIFwiZXZlbnRzXCIsIFwiaW50ZXJwb2xhdG9yc1wiLCBcInBhcnRpYWxzXCIsIFwidHJhbnNpdGlvbnNcIl07XG5cbiAgdmFyIGluaXRpYWxpc2UgPSBpbml0aWFsaXNlUmFjdGl2ZUluc3RhbmNlO1xuXG4gIGZ1bmN0aW9uIGluaXRpYWxpc2VSYWN0aXZlSW5zdGFuY2UocmFjdGl2ZSkge1xuICBcdHZhciB1c2VyT3B0aW9ucyA9IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG4gIFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzJdO1xuXG4gIFx0dmFyIGVsLCB2aWV3bW9kZWw7XG5cbiAgXHRpZiAoX1JhY3RpdmUuREVCVUcpIHtcbiAgXHRcdHdlbGNvbWUoKTtcbiAgXHR9XG5cbiAgXHRpbml0aWFsaXNlUHJvcGVydGllcyhyYWN0aXZlLCBvcHRpb25zKTtcblxuICBcdC8vIFRPRE8gcmVtb3ZlIHRoaXMsIGV2ZW50dWFsbHlcbiAgXHRkZWZpbmVQcm9wZXJ0eShyYWN0aXZlLCBcImRhdGFcIiwgeyBnZXQ6IGRlcHJlY2F0ZVJhY3RpdmVEYXRhIH0pO1xuXG4gIFx0Ly8gVE9ETyBkb24ndCBhbGxvdyBgb25jb25zdHJ1Y3RgIHdpdGggYG5ldyBSYWN0aXZlKClgLCB0aGVyZSdzIG5vIG5lZWQgZm9yIGl0XG4gIFx0Y29uc3RydWN0SG9vay5maXJlKHJhY3RpdmUsIHVzZXJPcHRpb25zKTtcblxuICBcdC8vIEFkZCByZWdpc3RyaWVzXG4gIFx0aW5pdGlhbGlzZV9fcmVnaXN0cnlOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0XHRyYWN0aXZlW25hbWVdID0gdXRpbHNfb2JqZWN0X19leHRlbmQoY3JlYXRlKHJhY3RpdmUuY29uc3RydWN0b3JbbmFtZV0gfHwgbnVsbCksIHVzZXJPcHRpb25zW25hbWVdKTtcbiAgXHR9KTtcblxuICBcdC8vIENyZWF0ZSBhIHZpZXdtb2RlbFxuICBcdHZpZXdtb2RlbCA9IG5ldyB2aWV3bW9kZWxfVmlld21vZGVsKHtcbiAgXHRcdGFkYXB0OiBnZXRBZGFwdG9ycyhyYWN0aXZlLCByYWN0aXZlLmFkYXB0LCB1c2VyT3B0aW9ucyksXG4gIFx0XHRkYXRhOiBjdXN0b21fZGF0YS5pbml0KHJhY3RpdmUuY29uc3RydWN0b3IsIHJhY3RpdmUsIHVzZXJPcHRpb25zKSxcbiAgXHRcdGNvbXB1dGVkOiBoZWxwZXJzX2dldENvbXB1dGF0aW9uU2lnbmF0dXJlcyhyYWN0aXZlLCB1dGlsc19vYmplY3RfX2V4dGVuZChjcmVhdGUocmFjdGl2ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcHV0ZWQpLCB1c2VyT3B0aW9ucy5jb21wdXRlZCkpLFxuICBcdFx0bWFwcGluZ3M6IG9wdGlvbnMubWFwcGluZ3MsXG4gIFx0XHRyYWN0aXZlOiByYWN0aXZlLFxuICBcdFx0b25jaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIGdsb2JhbF9ydW5sb29wLmFkZFJhY3RpdmUocmFjdGl2ZSk7XG4gIFx0XHR9XG4gIFx0fSk7XG5cbiAgXHRyYWN0aXZlLnZpZXdtb2RlbCA9IHZpZXdtb2RlbDtcblxuICBcdC8vIFRoaXMgY2FuJ3QgaGFwcGVuIGVhcmxpZXIsIGJlY2F1c2UgY29tcHV0ZWQgcHJvcGVydGllcyBtYXkgY2FsbCBgcmFjdGl2ZS5nZXQoKWAsIGV0Y1xuICBcdHZpZXdtb2RlbC5pbml0KCk7XG5cbiAgXHQvLyBpbml0IGNvbmZpZyBmcm9tIFBhcmVudCBhbmQgb3B0aW9uc1xuICBcdGNvbmZpZ19jb25maWcuaW5pdChyYWN0aXZlLmNvbnN0cnVjdG9yLCByYWN0aXZlLCB1c2VyT3B0aW9ucyk7XG5cbiAgXHRjb25maWdIb29rLmZpcmUocmFjdGl2ZSk7XG4gIFx0aW5pdEhvb2suYmVnaW4ocmFjdGl2ZSk7XG5cbiAgXHQvLyAvLyBJZiB0aGlzIGlzIGEgY29tcG9uZW50IHdpdGggYSBmdW5jdGlvbiBgZGF0YWAgcHJvcGVydHksIGNhbGwgdGhlIGZ1bmN0aW9uXG4gIFx0Ly8gLy8gd2l0aCBgcmFjdGl2ZWAgYXMgY29udGV4dCAodW5sZXNzIHRoZSBjaGlsZCB3YXMgYWxzbyBhIGZ1bmN0aW9uKVxuICBcdC8vIGlmICggdHlwZW9mIHJhY3RpdmUuY29uc3RydWN0b3IucHJvdG90eXBlLmRhdGEgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHVzZXJPcHRpb25zLmRhdGEgIT09ICdmdW5jdGlvbicgKSB7XG4gIFx0Ly8gXHR2aWV3bW9kZWwucmVzZXQoIHJhY3RpdmUuY29uc3RydWN0b3IucHJvdG90eXBlLmRhdGEuY2FsbCggcmFjdGl2ZSApIHx8IGZhdGFsKCAnYGRhdGFgIGZ1bmN0aW9ucyBtdXN0IHJldHVybiBhIGRhdGEgb2JqZWN0JyApICk7XG4gIFx0Ly8gfVxuXG4gIFx0Ly8gUmVuZGVyIHZpcnR1YWwgRE9NXG4gIFx0aWYgKHJhY3RpdmUudGVtcGxhdGUpIHtcbiAgXHRcdHZhciBjc3NJZHMgPSB1bmRlZmluZWQ7XG5cbiAgXHRcdGlmIChvcHRpb25zLmNzc0lkcyB8fCByYWN0aXZlLmNzc0lkKSB7XG4gIFx0XHRcdGNzc0lkcyA9IG9wdGlvbnMuY3NzSWRzID8gb3B0aW9ucy5jc3NJZHMuc2xpY2UoKSA6IFtdO1xuXG4gIFx0XHRcdGlmIChyYWN0aXZlLmNzc0lkKSB7XG4gIFx0XHRcdFx0Y3NzSWRzLnB1c2gocmFjdGl2ZS5jc3NJZCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmFjdGl2ZS5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0dGVtcGxhdGU6IHJhY3RpdmUudGVtcGxhdGUsXG4gIFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG4gIFx0XHRcdG93bmVyOiByYWN0aXZlLCAvLyBzYXZlcyBkb2luZyBgaWYgKCB0aGlzLnBhcmVudCApIHsgLyouLi4qLyB9YCBsYXRlciBvblxuICBcdFx0XHRjc3NJZHM6IGNzc0lkc1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0aW5pdEhvb2suZW5kKHJhY3RpdmUpO1xuXG4gIFx0Ly8gcmVuZGVyIGF1dG9tYXRpY2FsbHkgKCBpZiBgZWxgIGlzIHNwZWNpZmllZCApXG4gIFx0aWYgKGVsID0gZ2V0RWxlbWVudChyYWN0aXZlLmVsKSkge1xuICBcdFx0dmFyIHByb21pc2UgPSByYWN0aXZlLnJlbmRlcihlbCwgcmFjdGl2ZS5hcHBlbmQpO1xuXG4gIFx0XHRpZiAoX1JhY3RpdmUuREVCVUdfUFJPTUlTRVMpIHtcbiAgXHRcdFx0cHJvbWlzZVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgXHRcdFx0XHR3YXJuT25jZUlmRGVidWcoXCJQcm9taXNlIGRlYnVnZ2luZyBpcyBlbmFibGVkLCB0byBoZWxwIHNvbHZlIGVycm9ycyB0aGF0IGhhcHBlbiBhc3luY2hyb25vdXNseS4gU29tZSBicm93c2VycyB3aWxsIGxvZyB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb25zLCBpbiB3aGljaCBjYXNlIHlvdSBjYW4gc2FmZWx5IGRpc2FibGUgcHJvbWlzZSBkZWJ1Z2dpbmc6XFxuICBSYWN0aXZlLkRFQlVHX1BST01JU0VTID0gZmFsc2U7XCIpO1xuICBcdFx0XHRcdHdhcm5JZkRlYnVnKFwiQW4gZXJyb3IgaGFwcGVuZWQgZHVyaW5nIHJlbmRlcmluZ1wiLCB7IHJhY3RpdmU6IHJhY3RpdmUgfSk7XG4gIFx0XHRcdFx0ZXJyLnN0YWNrICYmIGxvZ0lmRGVidWcoZXJyLnN0YWNrKTtcblxuICBcdFx0XHRcdHRocm93IGVycjtcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QWRhcHRvcnMocmFjdGl2ZSwgcHJvdG9BZGFwdCwgdXNlck9wdGlvbnMpIHtcbiAgXHR2YXIgYWRhcHQsIG1hZ2ljLCBtb2RpZnlBcnJheXM7XG5cbiAgXHRwcm90b0FkYXB0ID0gcHJvdG9BZGFwdC5tYXAobG9va3VwKTtcbiAgXHRhZGFwdCA9IGVuc3VyZUFycmF5KHVzZXJPcHRpb25zLmFkYXB0KS5tYXAobG9va3VwKTtcblxuICBcdGFkYXB0ID0gaW5pdGlhbGlzZV9fY29tYmluZShwcm90b0FkYXB0LCBhZGFwdCk7XG5cbiAgXHRtYWdpYyA9IFwibWFnaWNcIiBpbiB1c2VyT3B0aW9ucyA/IHVzZXJPcHRpb25zLm1hZ2ljIDogcmFjdGl2ZS5tYWdpYztcbiAgXHRtb2RpZnlBcnJheXMgPSBcIm1vZGlmeUFycmF5c1wiIGluIHVzZXJPcHRpb25zID8gdXNlck9wdGlvbnMubW9kaWZ5QXJyYXlzIDogcmFjdGl2ZS5tb2RpZnlBcnJheXM7XG5cbiAgXHRpZiAobWFnaWMpIHtcbiAgXHRcdGlmICghZW52aXJvbm1lbnRfX21hZ2ljKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkdldHRlcnMgYW5kIHNldHRlcnMgKG1hZ2ljIG1vZGUpIGFyZSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG1vZGlmeUFycmF5cykge1xuICBcdFx0XHRhZGFwdC5wdXNoKG1hZ2ljQXJyYXkpO1xuICBcdFx0fVxuXG4gIFx0XHRhZGFwdC5wdXNoKGFkYXB0b3JzX21hZ2ljKTtcbiAgXHR9XG5cbiAgXHRpZiAobW9kaWZ5QXJyYXlzKSB7XG4gIFx0XHRhZGFwdC5wdXNoKGFycmF5X2luZGV4KTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gYWRhcHQ7XG5cbiAgXHRmdW5jdGlvbiBsb29rdXAoYWRhcHRvcikge1xuICBcdFx0aWYgKHR5cGVvZiBhZGFwdG9yID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdGFkYXB0b3IgPSBmaW5kSW5WaWV3SGllcmFyY2h5KFwiYWRhcHRvcnNcIiwgcmFjdGl2ZSwgYWRhcHRvcik7XG5cbiAgXHRcdFx0aWYgKCFhZGFwdG9yKSB7XG4gIFx0XHRcdFx0ZmF0YWwobWlzc2luZ1BsdWdpbihhZGFwdG9yLCBcImFkYXB0b3JcIikpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBhZGFwdG9yO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpc2VfX2NvbWJpbmUoYSwgYikge1xuICBcdHZhciBjID0gYS5zbGljZSgpLFxuICBcdCAgICBpID0gYi5sZW5ndGg7XG5cbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpZiAoISB+Yy5pbmRleE9mKGJbaV0pKSB7XG4gIFx0XHRcdGMucHVzaChiW2ldKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gYztcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpc2VQcm9wZXJ0aWVzKHJhY3RpdmUsIG9wdGlvbnMpIHtcbiAgXHQvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpZGVudGlmaWVyLCBmb3IgcGxhY2VzIHdoZXJlIHlvdSdkIHVzZSBhIHdlYWsgbWFwIGlmIGl0XG4gIFx0Ly8gZXhpc3RlZFxuICBcdHJhY3RpdmUuX2d1aWQgPSBcInItXCIgKyBpbml0aWFsaXNlX191aWQrKztcblxuICBcdC8vIGV2ZW50c1xuICBcdHJhY3RpdmUuX3N1YnMgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHQvLyBzdG9yYWdlIGZvciBpdGVtIGNvbmZpZ3VyYXRpb24gZnJvbSBpbnN0YW50aWF0aW9uIHRvIHJlc2V0LFxuICBcdC8vIGxpa2UgZHluYW1pYyBmdW5jdGlvbnMgb3Igb3JpZ2luYWwgdmFsdWVzXG4gIFx0cmFjdGl2ZS5fY29uZmlnID0ge307XG5cbiAgXHQvLyB0d28td2F5IGJpbmRpbmdzXG4gIFx0cmFjdGl2ZS5fdHdvd2F5QmluZGluZ3MgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHQvLyBhbmltYXRpb25zIChzbyB3ZSBjYW4gc3RvcCBhbnkgaW4gcHJvZ3Jlc3MgYXQgdGVhcmRvd24pXG4gIFx0cmFjdGl2ZS5fYW5pbWF0aW9ucyA9IFtdO1xuXG4gIFx0Ly8gbm9kZXMgcmVnaXN0cnlcbiAgXHRyYWN0aXZlLm5vZGVzID0ge307XG5cbiAgXHQvLyBsaXZlIHF1ZXJpZXNcbiAgXHRyYWN0aXZlLl9saXZlUXVlcmllcyA9IFtdO1xuICBcdHJhY3RpdmUuX2xpdmVDb21wb25lbnRRdWVyaWVzID0gW107XG5cbiAgXHQvLyBib3VuZCBkYXRhIGZ1bmN0aW9uc1xuICBcdHJhY3RpdmUuX2JvdW5kRnVuY3Rpb25zID0gW107XG5cbiAgXHQvLyBvYnNlcnZlcnNcbiAgXHRyYWN0aXZlLl9vYnNlcnZlcnMgPSBbXTtcblxuICBcdC8vIHByb3BlcnRpZXMgc3BlY2lmaWMgdG8gaW5saW5lIGNvbXBvbmVudHNcbiAgXHRpZiAob3B0aW9ucy5jb21wb25lbnQpIHtcbiAgXHRcdHJhY3RpdmUucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIFx0XHRyYWN0aXZlLmNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyIHx8IG51bGw7XG4gIFx0XHRyYWN0aXZlLnJvb3QgPSByYWN0aXZlLnBhcmVudC5yb290O1xuXG4gIFx0XHRyYWN0aXZlLmNvbXBvbmVudCA9IG9wdGlvbnMuY29tcG9uZW50O1xuICBcdFx0b3B0aW9ucy5jb21wb25lbnQuaW5zdGFuY2UgPSByYWN0aXZlO1xuXG4gIFx0XHQvLyBmb3IgaGFja2FiaWxpdHksIHRoaXMgY291bGQgYmUgYW4gb3BlbiBvcHRpb25cbiAgXHRcdC8vIGZvciBhbnkgcmFjdGl2ZSBpbnN0YW5jZSwgYnV0IGZvciBub3csIGp1c3RcbiAgXHRcdC8vIGZvciBjb21wb25lbnRzIGFuZCBqdXN0IGZvciByYWN0aXZlLi4uXG4gIFx0XHRyYWN0aXZlLl9pbmxpbmVQYXJ0aWFscyA9IG9wdGlvbnMuaW5saW5lUGFydGlhbHM7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJhY3RpdmUucm9vdCA9IHJhY3RpdmU7XG4gIFx0XHRyYWN0aXZlLnBhcmVudCA9IHJhY3RpdmUuY29udGFpbmVyID0gbnVsbDtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBkZXByZWNhdGVSYWN0aXZlRGF0YSgpIHtcbiAgXHR0aHJvdyBuZXcgRXJyb3IoXCJVc2luZyBgcmFjdGl2ZS5kYXRhYCBpcyBubyBsb25nZXIgc3VwcG9ydGVkIC0geW91IG11c3QgdXNlIHRoZSBgcmFjdGl2ZS5nZXQoKWAgQVBJIGluc3RlYWRcIik7XG4gIH1cblxuICBmdW5jdGlvbiBDb21wbGV4UGFyYW1ldGVyKGNvbXBvbmVudCwgdGVtcGxhdGUsIGNhbGxiYWNrKSB7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgXHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuICBcdFx0cm9vdDogY29tcG9uZW50LnJvb3QsXG4gIFx0XHRvd25lcjogdGhpc1xuICBcdH0pO1xuXG4gIFx0dGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIHZhciBpbml0aWFsaXNlX0NvbXBsZXhQYXJhbWV0ZXIgPSBDb21wbGV4UGFyYW1ldGVyO1xuXG4gIENvbXBsZXhQYXJhbWV0ZXIucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLmRpcnR5KSB7XG4gIFx0XHRcdHRoaXMuZGlydHkgPSB0cnVlO1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRWaWV3KHRoaXMpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuY2FsbGJhY2sodGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpKTtcbiAgXHRcdHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgQ29tcG9uZW50LCBhdHRyaWJ1dGVzLCB5aWVsZFRlbXBsYXRlLCBwYXJ0aWFscykge1xuICBcdHZhciBpbnN0YW5jZSxcbiAgXHQgICAgcGFyZW50RnJhZ21lbnQsXG4gIFx0ICAgIHJhY3RpdmUsXG4gIFx0ICAgIGZyYWdtZW50LFxuICBcdCAgICBjb250YWluZXIsXG4gIFx0ICAgIGlubGluZVBhcnRpYWxzID0ge30sXG4gIFx0ICAgIGRhdGEgPSB7fSxcbiAgXHQgICAgbWFwcGluZ3MgPSB7fSxcbiAgXHQgICAgcmVhZHksXG4gIFx0ICAgIHJlc29sdmVycyA9IFtdO1xuXG4gIFx0cGFyZW50RnJhZ21lbnQgPSBjb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG4gIFx0cmFjdGl2ZSA9IGNvbXBvbmVudC5yb290O1xuXG4gIFx0cGFydGlhbHMgPSBwYXJ0aWFscyB8fCB7fTtcbiAgXHR1dGlsc19vYmplY3RfX2V4dGVuZChpbmxpbmVQYXJ0aWFscywgcGFydGlhbHMpO1xuXG4gIFx0Ly8gTWFrZSBjb250ZW50cyBhdmFpbGFibGUgYXMgYSB7ez5jb250ZW50fX0gcGFydGlhbFxuICBcdHBhcnRpYWxzLmNvbnRlbnQgPSB5aWVsZFRlbXBsYXRlIHx8IFtdO1xuXG4gIFx0Ly8gc2V0IGEgZGVmYXVsdCBwYXJ0aWFsIGZvciB5aWVsZHMgd2l0aCBubyBuYW1lXG4gIFx0aW5saW5lUGFydGlhbHNbXCJcIl0gPSBwYXJ0aWFscy5jb250ZW50O1xuXG4gIFx0aWYgKENvbXBvbmVudC5kZWZhdWx0cy5lbCkge1xuICBcdFx0d2FybklmRGVidWcoXCJUaGUgPCVzLz4gY29tcG9uZW50IGhhcyBhIGRlZmF1bHQgYGVsYCBwcm9wZXJ0eTsgaXQgaGFzIGJlZW4gZGlzcmVnYXJkZWRcIiwgY29tcG9uZW50Lm5hbWUpO1xuICBcdH1cblxuICBcdC8vIGZpbmQgY29udGFpbmVyXG4gIFx0ZnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudDtcbiAgXHR3aGlsZSAoZnJhZ21lbnQpIHtcbiAgXHRcdGlmIChmcmFnbWVudC5vd25lci50eXBlID09PSBZSUVMREVSKSB7XG4gIFx0XHRcdGNvbnRhaW5lciA9IGZyYWdtZW50Lm93bmVyLmNvbnRhaW5lcjtcbiAgXHRcdFx0YnJlYWs7XG4gIFx0XHR9XG5cbiAgXHRcdGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50O1xuICBcdH1cblxuICBcdC8vIGVhY2ggYXR0cmlidXRlIHJlcHJlc2VudHMgZWl0aGVyIGEpIGRhdGEgb3IgYikgYSBtYXBwaW5nXG4gIFx0aWYgKGF0dHJpYnV0ZXMpIHtcbiAgXHRcdE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBcdFx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1trZXldLFxuICBcdFx0XHQgICAgcGFyc2VkLFxuICBcdFx0XHQgICAgcmVzb2x2ZXI7XG5cbiAgXHRcdFx0aWYgKHR5cGVvZiBhdHRyaWJ1dGUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0XHQvLyBpdCdzIHN0YXRpYyBkYXRhXG4gIFx0XHRcdFx0cGFyc2VkID0gcGFyc2VKU09OKGF0dHJpYnV0ZSk7XG4gIFx0XHRcdFx0ZGF0YVtrZXldID0gcGFyc2VkID8gcGFyc2VkLnZhbHVlIDogYXR0cmlidXRlO1xuICBcdFx0XHR9IGVsc2UgaWYgKGF0dHJpYnV0ZSA9PT0gMCkge1xuICBcdFx0XHRcdC8vIGl0IGhhZCBubyAnPScsIHNvIHdlJ2xsIGNhbGwgaXQgdHJ1ZVxuICBcdFx0XHRcdGRhdGFba2V5XSA9IHRydWU7XG4gIFx0XHRcdH0gZWxzZSBpZiAoaXNBcnJheShhdHRyaWJ1dGUpKSB7XG4gIFx0XHRcdFx0Ly8gdGhpcyByZXByZXNlbnRzIGR5bmFtaWMgZGF0YVxuICBcdFx0XHRcdGlmIChpc1NpbmdsZUludGVycG9sYXRvcihhdHRyaWJ1dGUpKSB7XG4gIFx0XHRcdFx0XHRtYXBwaW5nc1trZXldID0ge1xuICBcdFx0XHRcdFx0XHRvcmlnaW46IGNvbXBvbmVudC5yb290LnZpZXdtb2RlbCxcbiAgXHRcdFx0XHRcdFx0a2V5cGF0aDogdW5kZWZpbmVkXG4gIFx0XHRcdFx0XHR9O1xuXG4gIFx0XHRcdFx0XHRyZXNvbHZlciA9IGNyZWF0ZVJlc29sdmVyKGNvbXBvbmVudCwgYXR0cmlidXRlWzBdLCBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRcdFx0XHRpZiAoa2V5cGF0aC5pc1NwZWNpYWwpIHtcbiAgXHRcdFx0XHRcdFx0XHRpZiAocmVhZHkpIHtcbiAgXHRcdFx0XHRcdFx0XHRcdGluc3RhbmNlLnNldChrZXksIGtleXBhdGgudmFsdWUpOyAvLyBUT0RPIHVzZSB2aWV3bW9kZWw/XG4gIFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHRcdGRhdGFba2V5XSA9IGtleXBhdGgudmFsdWU7XG5cbiAgXHRcdFx0XHRcdFx0XHRcdC8vIFRPRE8gZXJyci4uLi4gd291bGQgYmUgYmV0dGVyIGlmIHdlIGRpZG4ndCBoYXZlIHRvIGRvIHRoaXNcbiAgXHRcdFx0XHRcdFx0XHRcdGRlbGV0ZSBtYXBwaW5nc1trZXldO1xuICBcdFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHRpZiAocmVhZHkpIHtcbiAgXHRcdFx0XHRcdFx0XHRcdGluc3RhbmNlLnZpZXdtb2RlbC5tYXBwaW5nc1trZXldLnJlc29sdmUoa2V5cGF0aCk7XG4gIFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHRcdC8vIHJlc29sdmVkIGltbWVkaWF0ZWx5XG4gIFx0XHRcdFx0XHRcdFx0XHRtYXBwaW5nc1trZXldLmtleXBhdGggPSBrZXlwYXRoO1xuICBcdFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdHJlc29sdmVyID0gbmV3IGluaXRpYWxpc2VfQ29tcGxleFBhcmFtZXRlcihjb21wb25lbnQsIGF0dHJpYnV0ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHRcdFx0XHRcdGlmIChyZWFkeSkge1xuICBcdFx0XHRcdFx0XHRcdGluc3RhbmNlLnNldChrZXksIHZhbHVlKTsgLy8gVE9ETyB1c2Ugdmlld21vZGVsP1xuICBcdFx0XHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0XHRcdGRhdGFba2V5XSA9IHZhbHVlO1xuICBcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRyZXNvbHZlcnMucHVzaChyZXNvbHZlcik7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZXJtIHd1dFwiKTtcbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0aW5zdGFuY2UgPSBjcmVhdGUoQ29tcG9uZW50LnByb3RvdHlwZSk7XG5cbiAgXHRpbml0aWFsaXNlKGluc3RhbmNlLCB7XG4gIFx0XHRlbDogbnVsbCxcbiAgXHRcdGFwcGVuZDogdHJ1ZSxcbiAgXHRcdGRhdGE6IGRhdGEsXG4gIFx0XHRwYXJ0aWFsczogcGFydGlhbHMsXG4gIFx0XHRtYWdpYzogcmFjdGl2ZS5tYWdpYyB8fCBDb21wb25lbnQuZGVmYXVsdHMubWFnaWMsXG4gIFx0XHRtb2RpZnlBcnJheXM6IHJhY3RpdmUubW9kaWZ5QXJyYXlzLFxuICBcdFx0Ly8gbmVlZCB0byBpbmhlcml0IHJ1bnRpbWUgcGFyZW50IGFkYXB0b3JzXG4gIFx0XHRhZGFwdDogcmFjdGl2ZS5hZGFwdFxuICBcdH0sIHtcbiAgXHRcdHBhcmVudDogcmFjdGl2ZSxcbiAgXHRcdGNvbXBvbmVudDogY29tcG9uZW50LFxuICBcdFx0Y29udGFpbmVyOiBjb250YWluZXIsXG4gIFx0XHRtYXBwaW5nczogbWFwcGluZ3MsXG4gIFx0XHRpbmxpbmVQYXJ0aWFsczogaW5saW5lUGFydGlhbHMsXG4gIFx0XHRjc3NJZHM6IHBhcmVudEZyYWdtZW50LmNzc0lkc1xuICBcdH0pO1xuXG4gIFx0cmVhZHkgPSB0cnVlO1xuICBcdGNvbXBvbmVudC5yZXNvbHZlcnMgPSByZXNvbHZlcnM7XG5cbiAgXHRyZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlUmVzb2x2ZXIoY29tcG9uZW50LCB0ZW1wbGF0ZSwgY2FsbGJhY2spIHtcbiAgXHR2YXIgcmVzb2x2ZXI7XG5cbiAgXHRpZiAodGVtcGxhdGUucikge1xuICBcdFx0cmVzb2x2ZXIgPSBSZXNvbHZlcnNfY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIoY29tcG9uZW50LCB0ZW1wbGF0ZS5yLCBjYWxsYmFjayk7XG4gIFx0fSBlbHNlIGlmICh0ZW1wbGF0ZS54KSB7XG4gIFx0XHRyZXNvbHZlciA9IG5ldyBSZXNvbHZlcnNfRXhwcmVzc2lvblJlc29sdmVyKGNvbXBvbmVudCwgY29tcG9uZW50LnBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZS54LCBjYWxsYmFjayk7XG4gIFx0fSBlbHNlIGlmICh0ZW1wbGF0ZS5yeCkge1xuICBcdFx0cmVzb2x2ZXIgPSBuZXcgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcihjb21wb25lbnQsIHRlbXBsYXRlLnJ4LCBjYWxsYmFjayk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJlc29sdmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTaW5nbGVJbnRlcnBvbGF0b3IodGVtcGxhdGUpIHtcbiAgXHRyZXR1cm4gdGVtcGxhdGUubGVuZ3RoID09PSAxICYmIHRlbXBsYXRlWzBdLnQgPT09IElOVEVSUE9MQVRPUjtcbiAgfVxuXG4gIC8vIFRPRE8gaG93IHNob3VsZCBldmVudCBhcmd1bWVudHMgYmUgaGFuZGxlZD8gZS5nLlxuICAvLyA8d2lkZ2V0IG9uLWZvbz0nYmFyOjEsMiwzJy8+XG4gIC8vIFRoZSBldmVudCAnYmFyJyB3aWxsIGJlIGZpcmVkIG9uIHRoZSBwYXJlbnQgaW5zdGFuY2VcbiAgLy8gd2hlbiAnZm9vJyBmaXJlcyBvbiB0aGUgY2hpbGQsIGJ1dCB0aGUgMSwyLDMgYXJndW1lbnRzXG4gIC8vIHdpbGwgYmUgbG9zdFxuXG4gIHZhciBpbml0aWFsaXNlX3Byb3BhZ2F0ZUV2ZW50cyA9IHByb3BhZ2F0ZUV2ZW50cztcblxuICBmdW5jdGlvbiBwcm9wYWdhdGVFdmVudHMoY29tcG9uZW50LCBldmVudHNEZXNjcmlwdG9yKSB7XG4gIFx0dmFyIGV2ZW50TmFtZTtcblxuICBcdGZvciAoZXZlbnROYW1lIGluIGV2ZW50c0Rlc2NyaXB0b3IpIHtcbiAgXHRcdGlmIChldmVudHNEZXNjcmlwdG9yLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgXHRcdFx0cHJvcGFnYXRlRXZlbnQoY29tcG9uZW50Lmluc3RhbmNlLCBjb21wb25lbnQucm9vdCwgZXZlbnROYW1lLCBldmVudHNEZXNjcmlwdG9yW2V2ZW50TmFtZV0pO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb3BhZ2F0ZUV2ZW50KGNoaWxkSW5zdGFuY2UsIHBhcmVudEluc3RhbmNlLCBldmVudE5hbWUsIHByb3h5RXZlbnROYW1lKSB7XG4gIFx0aWYgKHR5cGVvZiBwcm94eUV2ZW50TmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0ZmF0YWwoXCJDb21wb25lbnRzIGN1cnJlbnRseSBvbmx5IHN1cHBvcnQgc2ltcGxlIGV2ZW50cyAtIHlvdSBjYW5ub3QgaW5jbHVkZSBhcmd1bWVudHMuIFNvcnJ5IVwiKTtcbiAgXHR9XG5cbiAgXHRjaGlsZEluc3RhbmNlLm9uKGV2ZW50TmFtZSwgZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGV2ZW50LCBhcmdzO1xuXG4gIFx0XHQvLyBzZW1pLXdlYWsgdGVzdCwgYnV0IHdoYXQgZWxzZT8gdGFnIHRoZSBldmVudCBvYmogLl9pc0V2ZW50ID9cbiAgXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1swXSAmJiBhcmd1bWVudHNbMF0ubm9kZSkge1xuICBcdFx0XHRldmVudCA9IEFycmF5LnByb3RvdHlwZS5zaGlmdC5jYWxsKGFyZ3VtZW50cyk7XG4gIFx0XHR9XG5cbiAgXHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIFx0XHRzaGFyZWRfZmlyZUV2ZW50KHBhcmVudEluc3RhbmNlLCBwcm94eUV2ZW50TmFtZSwgeyBldmVudDogZXZlbnQsIGFyZ3M6IGFyZ3MgfSk7XG5cbiAgXHRcdC8vIGNhbmNlbCBidWJibGluZ1xuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH0pO1xuICB9XG5cbiAgdmFyIGluaXRpYWxpc2VfdXBkYXRlTGl2ZVF1ZXJpZXMgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gIFx0dmFyIGFuY2VzdG9yLCBxdWVyeTtcblxuICBcdC8vIElmIHRoZXJlJ3MgYSBsaXZlIHF1ZXJ5IGZvciB0aGlzIGNvbXBvbmVudCB0eXBlLCBhZGQgaXRcbiAgXHRhbmNlc3RvciA9IGNvbXBvbmVudC5yb290O1xuICBcdHdoaWxlIChhbmNlc3Rvcikge1xuICBcdFx0aWYgKHF1ZXJ5ID0gYW5jZXN0b3IuX2xpdmVDb21wb25lbnRRdWVyaWVzW1wiX1wiICsgY29tcG9uZW50Lm5hbWVdKSB7XG4gIFx0XHRcdHF1ZXJ5LnB1c2goY29tcG9uZW50Lmluc3RhbmNlKTtcbiAgXHRcdH1cblxuICBcdFx0YW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2luaXQgPSBDb21wb25lbnQkaW5pdDtcbiAgZnVuY3Rpb24gQ29tcG9uZW50JGluaXQob3B0aW9ucywgQ29tcG9uZW50KSB7XG4gIFx0dmFyIHBhcmVudEZyYWdtZW50LCByb290O1xuXG4gIFx0aWYgKCFDb21wb25lbnQpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkNvbXBvbmVudCBcXFwiXCIgKyB0aGlzLm5hbWUgKyBcIlxcXCIgbm90IGZvdW5kXCIpO1xuICBcdH1cblxuICBcdHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG4gIFx0cm9vdCA9IHBhcmVudEZyYWdtZW50LnJvb3Q7XG5cbiAgXHR0aGlzLnJvb3QgPSByb290O1xuICBcdHRoaXMudHlwZSA9IENPTVBPTkVOVDtcbiAgXHR0aGlzLm5hbWUgPSBvcHRpb25zLnRlbXBsYXRlLmU7XG4gIFx0dGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG4gIFx0dGhpcy5pbmRleFJlZkJpbmRpbmdzID0ge307XG4gIFx0dGhpcy55aWVsZGVycyA9IHt9O1xuICBcdHRoaXMucmVzb2x2ZXJzID0gW107XG5cbiAgXHRjcmVhdGVJbnN0YW5jZSh0aGlzLCBDb21wb25lbnQsIG9wdGlvbnMudGVtcGxhdGUuYSwgb3B0aW9ucy50ZW1wbGF0ZS5mLCBvcHRpb25zLnRlbXBsYXRlLnApO1xuICBcdGluaXRpYWxpc2VfcHJvcGFnYXRlRXZlbnRzKHRoaXMsIG9wdGlvbnMudGVtcGxhdGUudik7XG5cbiAgXHQvLyBpbnRybywgb3V0cm8gYW5kIGRlY29yYXRvciBkaXJlY3RpdmVzIGhhdmUgbm8gZWZmZWN0XG4gIFx0aWYgKG9wdGlvbnMudGVtcGxhdGUudDAgfHwgb3B0aW9ucy50ZW1wbGF0ZS50MSB8fCBvcHRpb25zLnRlbXBsYXRlLnQyIHx8IG9wdGlvbnMudGVtcGxhdGUubykge1xuICBcdFx0d2FybklmRGVidWcoXCJUaGUgXFxcImludHJvXFxcIiwgXFxcIm91dHJvXFxcIiBhbmQgXFxcImRlY29yYXRvclxcXCIgZGlyZWN0aXZlcyBoYXZlIG5vIGVmZmVjdCBvbiBjb21wb25lbnRzXCIsIHsgcmFjdGl2ZTogdGhpcy5pbnN0YW5jZSB9KTtcbiAgXHR9XG5cbiAgXHRpbml0aWFsaXNlX3VwZGF0ZUxpdmVRdWVyaWVzKHRoaXMpO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfcmViaW5kID0gQ29tcG9uZW50JHJlYmluZDtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkcmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHR2YXIgcXVlcnk7XG5cbiAgXHR0aGlzLnJlc29sdmVycy5mb3JFYWNoKHJlYmluZCk7XG5cbiAgXHRmb3IgKHZhciBrIGluIHRoaXMueWllbGRlcnMpIHtcbiAgXHRcdGlmICh0aGlzLnlpZWxkZXJzW2tdWzBdKSB7XG4gIFx0XHRcdHJlYmluZCh0aGlzLnlpZWxkZXJzW2tdWzBdKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAocXVlcnkgPSB0aGlzLnJvb3QuX2xpdmVDb21wb25lbnRRdWVyaWVzW1wiX1wiICsgdGhpcy5uYW1lXSkge1xuICBcdFx0cXVlcnkuX21ha2VEaXJ0eSgpO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIHJlYmluZCh4KSB7XG4gIFx0XHR4LnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9yZW5kZXIgPSBDb21wb25lbnQkcmVuZGVyO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCRyZW5kZXIoKSB7XG4gIFx0dmFyIGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZTtcblxuICBcdGluc3RhbmNlLnJlbmRlcih0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKSk7XG5cbiAgXHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgXHRyZXR1cm4gaW5zdGFuY2UuZnJhZ21lbnQuZGV0YWNoKCk7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV90b1N0cmluZyA9IENvbXBvbmVudCR0b1N0cmluZztcblxuICBmdW5jdGlvbiBDb21wb25lbnQkdG9TdHJpbmcoKSB7XG4gIFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX3VuYmluZCA9IENvbXBvbmVudCR1bmJpbmQ7XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfdW5iaW5kX190ZWFyZG93bkhvb2sgPSBuZXcgaG9va3NfSG9vayhcInRlYXJkb3duXCIpO1xuICBmdW5jdGlvbiBDb21wb25lbnQkdW5iaW5kKCkge1xuICBcdHZhciBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2U7XG5cbiAgXHR0aGlzLnJlc29sdmVycy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG5cbiAgXHRyZW1vdmVGcm9tTGl2ZUNvbXBvbmVudFF1ZXJpZXModGhpcyk7XG5cbiAgXHRpbnN0YW5jZS5fb2JzZXJ2ZXJzLmZvckVhY2goY2FuY2VsKTtcblxuICBcdC8vIHRlYXJkb3duIHRoZSBpbnN0YW5jZVxuICBcdGluc3RhbmNlLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdGluc3RhbmNlLnZpZXdtb2RlbC50ZWFyZG93bigpO1xuXG4gIFx0aWYgKGluc3RhbmNlLmZyYWdtZW50LnJlbmRlcmVkICYmIGluc3RhbmNlLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXykge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KGluc3RhbmNlLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgaW5zdGFuY2UpO1xuICBcdH1cblxuICBcdENvbXBvbmVudF9wcm90b3R5cGVfdW5iaW5kX190ZWFyZG93bkhvb2suZmlyZShpbnN0YW5jZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVGcm9tTGl2ZUNvbXBvbmVudFF1ZXJpZXMoY29tcG9uZW50KSB7XG4gIFx0dmFyIGluc3RhbmNlLCBxdWVyeTtcblxuICBcdGluc3RhbmNlID0gY29tcG9uZW50LnJvb3Q7XG5cbiAgXHRkbyB7XG4gIFx0XHRpZiAocXVlcnkgPSBpbnN0YW5jZS5fbGl2ZUNvbXBvbmVudFF1ZXJpZXNbXCJfXCIgKyBjb21wb25lbnQubmFtZV0pIHtcbiAgXHRcdFx0cXVlcnkuX3JlbW92ZShjb21wb25lbnQpO1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKGluc3RhbmNlID0gaW5zdGFuY2UucGFyZW50KTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX3VucmVuZGVyID0gQ29tcG9uZW50JHVucmVuZGVyO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCR1bnJlbmRlcihzaG91bGREZXN0cm95KSB7XG4gIFx0dGhpcy5zaG91bGREZXN0cm95ID0gc2hvdWxkRGVzdHJveTtcbiAgXHR0aGlzLmluc3RhbmNlLnVucmVuZGVyKCk7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMsIENvbnN0cnVjdG9yKSB7XG4gIFx0dGhpcy5pbml0KG9wdGlvbnMsIENvbnN0cnVjdG9yKTtcbiAgfTtcblxuICBDb21wb25lbnQucHJvdG90eXBlID0ge1xuICBcdGRldGFjaDogQ29tcG9uZW50X3Byb3RvdHlwZV9kZXRhY2gsXG4gIFx0ZmluZDogQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kLFxuICBcdGZpbmRBbGw6IENvbXBvbmVudF9wcm90b3R5cGVfZmluZEFsbCxcbiAgXHRmaW5kQWxsQ29tcG9uZW50czogQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyxcbiAgXHRmaW5kQ29tcG9uZW50OiBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmRDb21wb25lbnQsXG4gIFx0ZmluZE5leHROb2RlOiBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmROZXh0Tm9kZSxcbiAgXHRmaXJzdE5vZGU6IENvbXBvbmVudF9wcm90b3R5cGVfZmlyc3ROb2RlLFxuICBcdGluaXQ6IENvbXBvbmVudF9wcm90b3R5cGVfaW5pdCxcbiAgXHRyZWJpbmQ6IENvbXBvbmVudF9wcm90b3R5cGVfcmViaW5kLFxuICBcdHJlbmRlcjogQ29tcG9uZW50X3Byb3RvdHlwZV9yZW5kZXIsXG4gIFx0dG9TdHJpbmc6IENvbXBvbmVudF9wcm90b3R5cGVfdG9TdHJpbmcsXG4gIFx0dW5iaW5kOiBDb21wb25lbnRfcHJvdG90eXBlX3VuYmluZCxcbiAgXHR1bnJlbmRlcjogQ29tcG9uZW50X3Byb3RvdHlwZV91bnJlbmRlclxuICB9O1xuXG4gIHZhciBfQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuXG4gIHZhciBDb21tZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLnR5cGUgPSBDT01NRU5UO1xuICBcdHRoaXMudmFsdWUgPSBvcHRpb25zLnRlbXBsYXRlLmM7XG4gIH07XG5cbiAgQ29tbWVudC5wcm90b3R5cGUgPSB7XG4gIFx0ZGV0YWNoOiBzaGFyZWRfZGV0YWNoLFxuXG4gIFx0Zmlyc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5ub2RlKSB7XG4gIFx0XHRcdHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGhpcy52YWx1ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzLm5vZGU7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gXCI8IS0tXCIgKyB0aGlzLnZhbHVlICsgXCItLT5cIjtcbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRpZiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0XHR0aGlzLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgaXRlbXNfQ29tbWVudCA9IENvbW1lbnQ7XG5cbiAgdmFyIFlpZWxkZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHZhciBjb250YWluZXIsIGNvbXBvbmVudDtcblxuICBcdHRoaXMudHlwZSA9IFlJRUxERVI7XG5cbiAgXHR0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lciA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQucm9vdDtcbiAgXHR0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudCA9IGNvbnRhaW5lci5jb21wb25lbnQ7XG5cbiAgXHR0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgXHR0aGlzLmNvbnRhaW5lckZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXG4gIFx0dmFyIG5hbWUgPSB0aGlzLm5hbWUgPSBvcHRpb25zLnRlbXBsYXRlLm4gfHwgXCJcIjtcblxuICBcdHZhciB0ZW1wbGF0ZSA9IGNvbnRhaW5lci5faW5saW5lUGFydGlhbHNbbmFtZV07XG5cbiAgXHRpZiAoIXRlbXBsYXRlKSB7XG4gIFx0XHR3YXJuSWZEZWJ1ZyhcIkNvdWxkIG5vdCBmaW5kIHRlbXBsYXRlIGZvciBwYXJ0aWFsIFxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIiwgeyByYWN0aXZlOiBvcHRpb25zLnJvb3QgfSk7XG4gIFx0XHR0ZW1wbGF0ZSA9IFtdO1xuICBcdH1cblxuICBcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRvd25lcjogdGhpcyxcbiAgXHRcdHJvb3Q6IGNvbnRhaW5lci5wYXJlbnQsXG4gIFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gIFx0XHRwRWxlbWVudDogdGhpcy5jb250YWluZXJGcmFnbWVudC5wRWxlbWVudFxuICBcdH0pO1xuXG4gIFx0Ly8gZXZlbiB0aG91Z2ggb25seSBvbmUgeWllbGRlciBpcyBhbGxvd2VkLCB3ZSBuZWVkIHRvIGhhdmUgYW4gYXJyYXkgb2YgdGhlbVxuICBcdC8vIGFzIGl0J3MgcG9zc2libGUgdG8gY2F1c2UgYSB5aWVsZGVyIHRvIGJlIGNyZWF0ZWQgYmVmb3JlIHRoZSBsYXN0IG9uZVxuICBcdC8vIHdhcyBkZXN0cm95ZWQgaW4gdGhlIHNhbWUgdHVybiBvZiB0aGUgcnVubG9vcFxuICBcdGlmICghaXNBcnJheShjb21wb25lbnQueWllbGRlcnNbbmFtZV0pKSB7XG4gIFx0XHRjb21wb25lbnQueWllbGRlcnNbbmFtZV0gPSBbdGhpc107XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGNvbXBvbmVudC55aWVsZGVyc1tuYW1lXS5wdXNoKHRoaXMpO1xuICBcdH1cblxuICBcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoY29tcG9uZW50LnlpZWxkZXJzW25hbWVdLmxlbmd0aCA+IDEpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQSBjb21wb25lbnQgdGVtcGxhdGUgY2FuIG9ubHkgaGF2ZSBvbmUge3t5aWVsZFwiICsgKG5hbWUgPyBcIiBcIiArIG5hbWUgOiBcIlwiKSArIFwifX0gZGVjbGFyYXRpb24gYXQgYSB0aW1lXCIpO1xuICBcdFx0fVxuICBcdH0pO1xuICB9O1xuXG4gIFlpZWxkZXIucHJvdG90eXBlID0ge1xuICBcdGRldGFjaDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZGV0YWNoKCk7XG4gIFx0fSxcblxuICBcdGZpbmQ6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZChzZWxlY3Rvcik7XG4gIFx0fSxcblxuICBcdGZpbmRBbGw6IGZ1bmN0aW9uIChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9LFxuXG4gIFx0ZmluZENvbXBvbmVudDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KHNlbGVjdG9yKTtcbiAgXHR9LFxuXG4gIFx0ZmluZEFsbENvbXBvbmVudHM6IGZ1bmN0aW9uIChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fSxcblxuICBcdGZpbmROZXh0Tm9kZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyRnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRmaXJzdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmdldFZhbHVlKG9wdGlvbnMpO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LnJlbmRlcigpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlcihzaG91bGREZXN0cm95KTtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLmNvbXBvbmVudC55aWVsZGVyc1t0aGlzLm5hbWVdLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC50b1N0cmluZygpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgaXRlbXNfWWllbGRlciA9IFlpZWxkZXI7XG5cbiAgdmFyIERvY3R5cGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMuZGVjbGFyYXRpb24gPSBvcHRpb25zLnRlbXBsYXRlLmE7XG4gIH07XG5cbiAgRG9jdHlwZS5wcm90b3R5cGUgPSB7XG4gIFx0aW5pdDogbm9vcCxcbiAgXHRyZW5kZXI6IG5vb3AsXG4gIFx0dW5yZW5kZXI6IG5vb3AsXG4gIFx0dGVhcmRvd246IG5vb3AsXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBcIjwhRE9DVFlQRVwiICsgdGhpcy5kZWNsYXJhdGlvbiArIFwiPlwiO1xuICBcdH1cbiAgfTtcblxuICB2YXIgaXRlbXNfRG9jdHlwZSA9IERvY3R5cGU7XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9pbml0ID0gRnJhZ21lbnQkaW5pdDtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRpbml0KG9wdGlvbnMpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dGhpcy5vd25lciA9IG9wdGlvbnMub3duZXI7IC8vIFRoZSBpdGVtIHRoYXQgb3ducyB0aGlzIGZyYWdtZW50IC0gYW4gZWxlbWVudCwgc2VjdGlvbiwgcGFydGlhbCwgb3IgYXR0cmlidXRlXG4gIFx0dGhpcy5wYXJlbnQgPSB0aGlzLm93bmVyLnBhcmVudEZyYWdtZW50O1xuXG4gIFx0Ly8gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAgXHR0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3Q7XG4gIFx0dGhpcy5wRWxlbWVudCA9IG9wdGlvbnMucEVsZW1lbnQ7XG4gIFx0dGhpcy5jb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0O1xuICBcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuICBcdHRoaXMua2V5ID0gb3B0aW9ucy5rZXk7XG4gIFx0dGhpcy5yZWdpc3RlcmVkSW5kZXhSZWZzID0gW107XG5cbiAgXHQvLyBlbmNhcHN1bGF0ZWQgc3R5bGVzIHNob3VsZCBiZSBpbmhlcml0ZWQgdW50aWwgdGhleSBnZXQgYXBwbGllZCBieSBhbiBlbGVtZW50XG4gIFx0dGhpcy5jc3NJZHMgPSBcImNzc0lkc1wiIGluIG9wdGlvbnMgPyBvcHRpb25zLmNzc0lkcyA6IHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuY3NzSWRzIDogbnVsbDtcblxuICBcdHRoaXMuaXRlbXMgPSBvcHRpb25zLnRlbXBsYXRlLm1hcChmdW5jdGlvbiAodGVtcGxhdGUsIGkpIHtcbiAgXHRcdHJldHVybiBjcmVhdGVJdGVtKHtcbiAgXHRcdFx0cGFyZW50RnJhZ21lbnQ6IF90aGlzLFxuICBcdFx0XHRwRWxlbWVudDogb3B0aW9ucy5wRWxlbWVudCxcbiAgXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuICBcdFx0XHRpbmRleDogaVxuICBcdFx0fSk7XG4gIFx0fSk7XG5cbiAgXHR0aGlzLnZhbHVlID0gdGhpcy5hcmdzTGlzdCA9IG51bGw7XG4gIFx0dGhpcy5kaXJ0eUFyZ3MgPSB0aGlzLmRpcnR5VmFsdWUgPSB0cnVlO1xuXG4gIFx0dGhpcy5ib3VuZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJdGVtKG9wdGlvbnMpIHtcbiAgXHRpZiAodHlwZW9mIG9wdGlvbnMudGVtcGxhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHJldHVybiBuZXcgaXRlbXNfVGV4dChvcHRpb25zKTtcbiAgXHR9XG5cbiAgXHRzd2l0Y2ggKG9wdGlvbnMudGVtcGxhdGUudCkge1xuICBcdFx0Y2FzZSBZSUVMREVSOlxuICBcdFx0XHRyZXR1cm4gbmV3IGl0ZW1zX1lpZWxkZXIob3B0aW9ucyk7XG4gIFx0XHRjYXNlIElOVEVSUE9MQVRPUjpcbiAgXHRcdFx0cmV0dXJuIG5ldyBpdGVtc19JbnRlcnBvbGF0b3Iob3B0aW9ucyk7XG4gIFx0XHRjYXNlIFNFQ1RJT046XG4gIFx0XHRcdHJldHVybiBuZXcgX1NlY3Rpb24ob3B0aW9ucyk7XG4gIFx0XHRjYXNlIFRSSVBMRTpcbiAgXHRcdFx0cmV0dXJuIG5ldyBfVHJpcGxlKG9wdGlvbnMpO1xuICBcdFx0Y2FzZSBFTEVNRU5UOlxuICBcdFx0XHR2YXIgY29uc3RydWN0b3IgPSB1bmRlZmluZWQ7XG4gIFx0XHRcdGlmIChjb25zdHJ1Y3RvciA9IENvbXBvbmVudF9nZXRDb21wb25lbnQob3B0aW9ucy5wYXJlbnRGcmFnbWVudC5yb290LCBvcHRpb25zLnRlbXBsYXRlLmUpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIG5ldyBfQ29tcG9uZW50KG9wdGlvbnMsIGNvbnN0cnVjdG9yKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRyZXR1cm4gbmV3IF9FbGVtZW50KG9wdGlvbnMpO1xuICBcdFx0Y2FzZSBQQVJUSUFMOlxuICBcdFx0XHRyZXR1cm4gbmV3IF9QYXJ0aWFsKG9wdGlvbnMpO1xuICBcdFx0Y2FzZSBDT01NRU5UOlxuICBcdFx0XHRyZXR1cm4gbmV3IGl0ZW1zX0NvbW1lbnQob3B0aW9ucyk7XG4gIFx0XHRjYXNlIERPQ1RZUEU6XG4gIFx0XHRcdHJldHVybiBuZXcgaXRlbXNfRG9jdHlwZShvcHRpb25zKTtcblxuICBcdFx0ZGVmYXVsdDpcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiU29tZXRoaW5nIHZlcnkgc3RyYW5nZSBoYXBwZW5lZC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3Vlcy4gVGhhbmtzIVwiKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX3JlYmluZCA9IEZyYWdtZW50JHJlYmluZDtcbiAgZnVuY3Rpb24gRnJhZ21lbnQkcmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcblxuICBcdC8vIGFzc2lnbiBuZXcgY29udGV4dCBrZXlwYXRoIGlmIG5lZWRlZFxuICBcdGlmICghdGhpcy5vd25lciB8fCB0aGlzLm93bmVyLmhhc0NvbnRleHQpIHtcbiAgXHRcdGFzc2lnbk5ld0tleXBhdGgodGhpcywgXCJjb250ZXh0XCIsIG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH1cblxuICBcdHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0aWYgKGl0ZW0ucmViaW5kKSB7XG4gIFx0XHRcdGl0ZW0ucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0fVxuICBcdH0pO1xuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9yZW5kZXIgPSBGcmFnbWVudCRyZW5kZXI7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkcmVuZGVyKCkge1xuICBcdHZhciByZXN1bHQ7XG5cbiAgXHRpZiAodGhpcy5pdGVtcy5sZW5ndGggPT09IDEpIHtcbiAgXHRcdHJlc3VsdCA9IHRoaXMuaXRlbXNbMF0ucmVuZGVyKCk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJlc3VsdCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICBcdFx0dGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHRcdHJlc3VsdC5hcHBlbmRDaGlsZChpdGVtLnJlbmRlcigpKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICBcdHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX3RvU3RyaW5nID0gRnJhZ21lbnQkdG9TdHJpbmc7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkdG9TdHJpbmcoZXNjYXBlKSB7XG4gIFx0aWYgKCF0aGlzLml0ZW1zKSB7XG4gIFx0XHRyZXR1cm4gXCJcIjtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5pdGVtcy5tYXAoZXNjYXBlID8gdG9Fc2NhcGVkU3RyaW5nIDogRnJhZ21lbnRfcHJvdG90eXBlX3RvU3RyaW5nX190b1N0cmluZykuam9pbihcIlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEZyYWdtZW50X3Byb3RvdHlwZV90b1N0cmluZ19fdG9TdHJpbmcoaXRlbSkge1xuICBcdHJldHVybiBpdGVtLnRvU3RyaW5nKCk7XG4gIH1cblxuICBmdW5jdGlvbiB0b0VzY2FwZWRTdHJpbmcoaXRlbSkge1xuICBcdHJldHVybiBpdGVtLnRvU3RyaW5nKHRydWUpO1xuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV91bmJpbmQgPSBGcmFnbWVudCR1bmJpbmQ7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkdW5iaW5kKCkge1xuICBcdGlmICghdGhpcy5ib3VuZCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHRoaXMuaXRlbXMuZm9yRWFjaCh1bmJpbmRJdGVtKTtcbiAgXHR0aGlzLmJvdW5kID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiB1bmJpbmRJdGVtKGl0ZW0pIHtcbiAgXHRpZiAoaXRlbS51bmJpbmQpIHtcbiAgXHRcdGl0ZW0udW5iaW5kKCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV91bnJlbmRlciA9IEZyYWdtZW50JHVucmVuZGVyO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JHVucmVuZGVyKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRpZiAoIXRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byB1bnJlbmRlciBhIGZyYWdtZW50IHRoYXQgd2FzIG5vdCByZW5kZXJlZFwiKTtcbiAgXHR9XG5cbiAgXHR0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgXHRcdHJldHVybiBpLnVucmVuZGVyKHNob3VsZERlc3Ryb3kpO1xuICBcdH0pO1xuICBcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBGcmFnbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy5pbml0KG9wdGlvbnMpO1xuICB9O1xuXG4gIEZyYWdtZW50LnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IHByb3RvdHlwZV9idWJibGUsXG4gIFx0ZGV0YWNoOiBGcmFnbWVudF9wcm90b3R5cGVfZGV0YWNoLFxuICBcdGZpbmQ6IEZyYWdtZW50X3Byb3RvdHlwZV9maW5kLFxuICBcdGZpbmRBbGw6IEZyYWdtZW50X3Byb3RvdHlwZV9maW5kQWxsLFxuICBcdGZpbmRBbGxDb21wb25lbnRzOiBGcmFnbWVudF9wcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMsXG4gIFx0ZmluZENvbXBvbmVudDogRnJhZ21lbnRfcHJvdG90eXBlX2ZpbmRDb21wb25lbnQsXG4gIFx0ZmluZE5leHROb2RlOiBwcm90b3R5cGVfZmluZE5leHROb2RlLFxuICBcdGZpcnN0Tm9kZTogcHJvdG90eXBlX2ZpcnN0Tm9kZSxcbiAgXHRnZXRBcmdzTGlzdDogZ2V0QXJnc0xpc3QsXG4gIFx0Z2V0Tm9kZTogZ2V0Tm9kZSxcbiAgXHRnZXRWYWx1ZTogcHJvdG90eXBlX2dldFZhbHVlLFxuICBcdGluaXQ6IEZyYWdtZW50X3Byb3RvdHlwZV9pbml0LFxuICBcdHJlYmluZDogRnJhZ21lbnRfcHJvdG90eXBlX3JlYmluZCxcbiAgXHRyZWdpc3RlckluZGV4UmVmOiBmdW5jdGlvbiAoaWR4KSB7XG4gIFx0XHR2YXIgaWR4cyA9IHRoaXMucmVnaXN0ZXJlZEluZGV4UmVmcztcbiAgXHRcdGlmIChpZHhzLmluZGV4T2YoaWR4KSA9PT0gLTEpIHtcbiAgXHRcdFx0aWR4cy5wdXNoKGlkeCk7XG4gIFx0XHR9XG4gIFx0fSxcbiAgXHRyZW5kZXI6IEZyYWdtZW50X3Byb3RvdHlwZV9yZW5kZXIsXG4gIFx0dG9TdHJpbmc6IEZyYWdtZW50X3Byb3RvdHlwZV90b1N0cmluZyxcbiAgXHR1bmJpbmQ6IEZyYWdtZW50X3Byb3RvdHlwZV91bmJpbmQsXG4gIFx0dW5yZWdpc3RlckluZGV4UmVmOiBmdW5jdGlvbiAoaWR4KSB7XG4gIFx0XHR2YXIgaWR4cyA9IHRoaXMucmVnaXN0ZXJlZEluZGV4UmVmcztcbiAgXHRcdGlkeHMuc3BsaWNlKGlkeHMuaW5kZXhPZihpZHgpLCAxKTtcbiAgXHR9LFxuICBcdHVucmVuZGVyOiBGcmFnbWVudF9wcm90b3R5cGVfdW5yZW5kZXJcbiAgfTtcblxuICB2YXIgdmlydHVhbGRvbV9GcmFnbWVudCA9IEZyYWdtZW50O1xuXG4gIHZhciBwcm90b3R5cGVfcmVzZXQgPSBSYWN0aXZlJHJlc2V0O1xuICB2YXIgc2hvdWxkUmVyZW5kZXIgPSBbXCJ0ZW1wbGF0ZVwiLCBcInBhcnRpYWxzXCIsIFwiY29tcG9uZW50c1wiLCBcImRlY29yYXRvcnNcIiwgXCJldmVudHNcIl0sXG4gICAgICByZXNldEhvb2sgPSBuZXcgaG9va3NfSG9vayhcInJlc2V0XCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJHJlc2V0KGRhdGEpIHtcbiAgXHR2YXIgcHJvbWlzZSwgd3JhcHBlciwgY2hhbmdlcywgaSwgcmVyZW5kZXI7XG5cbiAgXHRkYXRhID0gZGF0YSB8fCB7fTtcblxuICBcdGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc2V0IG1ldGhvZCB0YWtlcyBlaXRoZXIgbm8gYXJndW1lbnRzLCBvciBhbiBvYmplY3QgY29udGFpbmluZyBuZXcgZGF0YVwiKTtcbiAgXHR9XG5cbiAgXHQvLyBJZiB0aGUgcm9vdCBvYmplY3QgaXMgd3JhcHBlZCwgdHJ5IGFuZCB1c2UgdGhlIHdyYXBwZXIncyByZXNldCB2YWx1ZVxuICBcdGlmICgod3JhcHBlciA9IHRoaXMudmlld21vZGVsLndyYXBwZWRbXCJcIl0pICYmIHdyYXBwZXIucmVzZXQpIHtcbiAgXHRcdGlmICh3cmFwcGVyLnJlc2V0KGRhdGEpID09PSBmYWxzZSkge1xuICBcdFx0XHQvLyByZXNldCB3YXMgcmVqZWN0ZWQsIHdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgb2JqZWN0XG4gIFx0XHRcdHRoaXMudmlld21vZGVsLnJlc2V0KGRhdGEpO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHR0aGlzLnZpZXdtb2RlbC5yZXNldChkYXRhKTtcbiAgXHR9XG5cbiAgXHQvLyByZXNldCBjb25maWcgaXRlbXMgYW5kIHRyYWNrIGlmIG5lZWQgdG8gcmVyZW5kZXJcbiAgXHRjaGFuZ2VzID0gY29uZmlnX2NvbmZpZy5yZXNldCh0aGlzKTtcblxuICBcdGkgPSBjaGFuZ2VzLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpZiAoc2hvdWxkUmVyZW5kZXIuaW5kZXhPZihjaGFuZ2VzW2ldKSA+IC0xKSB7XG4gIFx0XHRcdHJlcmVuZGVyID0gdHJ1ZTtcbiAgXHRcdFx0YnJlYWs7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHJlcmVuZGVyKSB7XG4gIFx0XHR2YXIgY29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG4gIFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKHJvb3RLZXlwYXRoKTtcblxuICBcdFx0Ly8gSXMgdGhpcyBpcyBhIGNvbXBvbmVudCwgd2UgbmVlZCB0byBzZXQgdGhlIGBzaG91bGREZXN0cm95YFxuICBcdFx0Ly8gZmxhZywgb3RoZXJ3aXNlIGl0IHdpbGwgYXNzdW1lIGJ5IGRlZmF1bHQgdGhhdCBhIHBhcmVudCBub2RlXG4gIFx0XHQvLyB3aWxsIGJlIGRldGFjaGVkLCBhbmQgdGhlcmVmb3JlIGl0IGRvZXNuJ3QgbmVlZCB0byBib3RoZXJcbiAgXHRcdC8vIGRldGFjaGluZyBpdHMgb3duIG5vZGVzXG4gIFx0XHRpZiAoY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQpIHtcbiAgXHRcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSB0cnVlO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnVucmVuZGVyKCk7XG5cbiAgXHRcdGlmIChjb21wb25lbnQpIHtcbiAgXHRcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSBmYWxzZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gSWYgdGhlIHRlbXBsYXRlIGNoYW5nZWQsIHdlIG5lZWQgdG8gZGVzdHJveSB0aGUgcGFyYWxsZWwgRE9NXG4gIFx0XHQvLyBUT0RPIGlmIHdlJ3JlIGhlcmUsIHByZXN1bWFibHkgaXQgZGlkP1xuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnQudGVtcGxhdGUgIT09IHRoaXMudGVtcGxhdGUpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblxuICBcdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLFxuICBcdFx0XHRcdHJvb3Q6IHRoaXMsXG4gIFx0XHRcdFx0b3duZXI6IHRoaXNcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdHByb21pc2UgPSB0aGlzLnJlbmRlcih0aGlzLmVsLCB0aGlzLmFuY2hvcik7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKTtcbiAgXHRcdHRoaXMudmlld21vZGVsLm1hcmsocm9vdEtleXBhdGgpO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIFx0fVxuXG4gIFx0cmVzZXRIb29rLmZpcmUodGhpcywgZGF0YSk7XG5cbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHZhciByZXNldFBhcnRpYWwgPSBmdW5jdGlvbiAobmFtZSwgcGFydGlhbCkge1xuICBcdHZhciBwcm9taXNlLFxuICBcdCAgICBjb2xsZWN0aW9uID0gW107XG5cbiAgXHRmdW5jdGlvbiBjb2xsZWN0KHNvdXJjZSwgZGVzdCwgcmFjdGl2ZSkge1xuICBcdFx0Ly8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCBhbmQgaXQgaGFzIGl0cyBvd24gcGFydGlhbCwgYmFpbFxuICBcdFx0aWYgKHJhY3RpdmUgJiYgcmFjdGl2ZS5wYXJ0aWFsc1tuYW1lXSkgcmV0dXJuO1xuXG4gIFx0XHRzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0XHQvLyBxdWV1ZSB0byByZXJlbmRlciBpZiB0aGUgaXRlbSBpcyBhIHBhcnRpYWwgYW5kIHRoZSBjdXJyZW50IG5hbWUgbWF0Y2hlc1xuICBcdFx0XHRpZiAoaXRlbS50eXBlID09PSBQQVJUSUFMICYmIGl0ZW0uZ2V0UGFydGlhbE5hbWUoKSA9PT0gbmFtZSkge1xuICBcdFx0XHRcdGRlc3QucHVzaChpdGVtKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIGlmIGl0IGhhcyBhIGZyYWdtZW50LCBwcm9jZXNzIGl0cyBpdGVtc1xuICBcdFx0XHRpZiAoaXRlbS5mcmFnbWVudCkge1xuICBcdFx0XHRcdGNvbGxlY3QoaXRlbS5mcmFnbWVudC5pdGVtcywgZGVzdCwgcmFjdGl2ZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBvciBpZiBpdCBoYXMgZnJhZ21lbnRzXG4gIFx0XHRcdGlmIChpc0FycmF5KGl0ZW0uZnJhZ21lbnRzKSkge1xuICBcdFx0XHRcdGNvbGxlY3QoaXRlbS5mcmFnbWVudHMsIGRlc3QsIHJhY3RpdmUpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gb3IgaWYgaXQgaXMgaXRzZWxmIGEgZnJhZ21lbnQsIHByb2Nlc3MgaXRzIGl0ZW1zXG4gIFx0XHRcdGVsc2UgaWYgKGlzQXJyYXkoaXRlbS5pdGVtcykpIHtcbiAgXHRcdFx0XHRjb2xsZWN0KGl0ZW0uaXRlbXMsIGRlc3QsIHJhY3RpdmUpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gb3IgaWYgaXQgaXMgYSBjb21wb25lbnQsIHN0ZXAgaW4gYW5kIHByb2Nlc3MgaXRzIGl0ZW1zXG4gIFx0XHRcdGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gQ09NUE9ORU5UICYmIGl0ZW0uaW5zdGFuY2UpIHtcbiAgXHRcdFx0XHRjb2xsZWN0KGl0ZW0uaW5zdGFuY2UuZnJhZ21lbnQuaXRlbXMsIGRlc3QsIGl0ZW0uaW5zdGFuY2UpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gaWYgdGhlIGl0ZW0gaXMgYW4gZWxlbWVudCwgcHJvY2VzcyBpdHMgYXR0cmlidXRlcyB0b29cbiAgXHRcdFx0aWYgKGl0ZW0udHlwZSA9PT0gRUxFTUVOVCkge1xuICBcdFx0XHRcdGlmIChpc0FycmF5KGl0ZW0uYXR0cmlidXRlcykpIHtcbiAgXHRcdFx0XHRcdGNvbGxlY3QoaXRlbS5hdHRyaWJ1dGVzLCBkZXN0LCByYWN0aXZlKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAoaXNBcnJheShpdGVtLmNvbmRpdGlvbmFsQXR0cmlidXRlcykpIHtcbiAgXHRcdFx0XHRcdGNvbGxlY3QoaXRlbS5jb25kaXRpb25hbEF0dHJpYnV0ZXMsIGRlc3QsIHJhY3RpdmUpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0Y29sbGVjdCh0aGlzLmZyYWdtZW50Lml0ZW1zLCBjb2xsZWN0aW9uKTtcbiAgXHR0aGlzLnBhcnRpYWxzW25hbWVdID0gcGFydGlhbDtcblxuICBcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKTtcblxuICBcdGNvbGxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0aXRlbS52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgXHRcdGl0ZW0uc2V0VmFsdWUobmFtZSk7XG4gIFx0fSk7XG5cbiAgXHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcblxuICBcdHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIC8vIFRPRE8gc2hvdWxkIHJlc2V0VGVtcGxhdGUgYmUgYXN5bmNocm9ub3VzPyBpLmUuIHNob3VsZCBpdCBiZSBhIGNhc2VcbiAgLy8gb2Ygb3V0cm8sIHVwZGF0ZSB0ZW1wbGF0ZSwgaW50cm8/IEkgcmVja29uIHByb2JhYmx5IG5vdCwgc2luY2UgdGhhdFxuICAvLyBjb3VsZCBiZSBhY2hpZXZlZCB3aXRoIHVucmVuZGVyLXJlc2V0VGVtcGxhdGUtcmVuZGVyLiBBbHNvLCBpdCBzaG91bGRcbiAgLy8gY29uY2VwdHVhbGx5IGJlIHNpbWlsYXIgdG8gcmVzZXRQYXJ0aWFsLCB3aGljaCBjb3VsZG4ndCBiZSBhc3luY1xuXG4gIHZhciByZXNldFRlbXBsYXRlID0gUmFjdGl2ZSRyZXNldFRlbXBsYXRlO1xuICBmdW5jdGlvbiBSYWN0aXZlJHJlc2V0VGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgXHR2YXIgdHJhbnNpdGlvbnNFbmFibGVkLCBjb21wb25lbnQ7XG5cbiAgXHR0ZW1wbGF0ZV90ZW1wbGF0ZS5pbml0KG51bGwsIHRoaXMsIHsgdGVtcGxhdGU6IHRlbXBsYXRlIH0pO1xuXG4gIFx0dHJhbnNpdGlvbnNFbmFibGVkID0gdGhpcy50cmFuc2l0aW9uc0VuYWJsZWQ7XG4gIFx0dGhpcy50cmFuc2l0aW9uc0VuYWJsZWQgPSBmYWxzZTtcblxuICBcdC8vIElzIHRoaXMgaXMgYSBjb21wb25lbnQsIHdlIG5lZWQgdG8gc2V0IHRoZSBgc2hvdWxkRGVzdHJveWBcbiAgXHQvLyBmbGFnLCBvdGhlcndpc2UgaXQgd2lsbCBhc3N1bWUgYnkgZGVmYXVsdCB0aGF0IGEgcGFyZW50IG5vZGVcbiAgXHQvLyB3aWxsIGJlIGRldGFjaGVkLCBhbmQgdGhlcmVmb3JlIGl0IGRvZXNuJ3QgbmVlZCB0byBib3RoZXJcbiAgXHQvLyBkZXRhY2hpbmcgaXRzIG93biBub2Rlc1xuICBcdGlmIChjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudCkge1xuICBcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSB0cnVlO1xuICBcdH1cblxuICBcdHRoaXMudW5yZW5kZXIoKTtcblxuICBcdGlmIChjb21wb25lbnQpIHtcbiAgXHRcdGNvbXBvbmVudC5zaG91bGREZXN0cm95ID0gZmFsc2U7XG4gIFx0fVxuXG4gIFx0Ly8gcmVtb3ZlIGV4aXN0aW5nIGZyYWdtZW50IGFuZCBjcmVhdGUgbmV3IG9uZVxuICBcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLFxuICBcdFx0cm9vdDogdGhpcyxcbiAgXHRcdG93bmVyOiB0aGlzXG4gIFx0fSk7XG5cbiAgXHR0aGlzLnJlbmRlcih0aGlzLmVsLCB0aGlzLmFuY2hvcik7XG5cbiAgXHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IHRyYW5zaXRpb25zRW5hYmxlZDtcbiAgfVxuXG4gIHZhciByZXZlcnNlID0gbWFrZUFycmF5TWV0aG9kKFwicmV2ZXJzZVwiKTtcblxuICB2YXIgUmFjdGl2ZV9wcm90b3R5cGVfc2V0ID0gUmFjdGl2ZSRzZXQ7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRzZXQoa2V5cGF0aCwgdmFsdWUpIHtcbiAgXHR2YXIgbWFwLCBwcm9taXNlO1xuXG4gIFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpO1xuXG4gIFx0Ly8gU2V0IG11bHRpcGxlIGtleXBhdGhzIGluIG9uZSBnb1xuICBcdGlmIChpc09iamVjdChrZXlwYXRoKSkge1xuICBcdFx0bWFwID0ga2V5cGF0aDtcblxuICBcdFx0Zm9yIChrZXlwYXRoIGluIG1hcCkge1xuICBcdFx0XHRpZiAobWFwLmhhc093blByb3BlcnR5KGtleXBhdGgpKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSBtYXBba2V5cGF0aF07XG4gIFx0XHRcdFx0c2V0KHRoaXMsIGtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIFNldCBhIHNpbmdsZSBrZXlwYXRoXG4gIFx0ZWxzZSB7XG4gIFx0XHRzZXQodGhpcywga2V5cGF0aCwgdmFsdWUpO1xuICBcdH1cblxuICBcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBzZXQocmFjdGl2ZSwga2V5cGF0aCwgdmFsdWUpIHtcbiAgXHRrZXlwYXRoID0gZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpO1xuXG4gIFx0aWYgKGtleXBhdGguaXNQYXR0ZXJuKSB7XG4gIFx0XHRnZXRNYXRjaGluZ0tleXBhdGhzKHJhY3RpdmUsIGtleXBhdGgpLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwuc2V0KGtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdH0pO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5zZXQoa2V5cGF0aCwgdmFsdWUpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBzaGlmdCA9IG1ha2VBcnJheU1ldGhvZChcInNoaWZ0XCIpO1xuXG4gIHZhciBwcm90b3R5cGVfc29ydCA9IG1ha2VBcnJheU1ldGhvZChcInNvcnRcIik7XG5cbiAgdmFyIHNwbGljZSA9IG1ha2VBcnJheU1ldGhvZChcInNwbGljZVwiKTtcblxuICB2YXIgc3VidHJhY3QgPSBSYWN0aXZlJHN1YnRyYWN0O1xuICBmdW5jdGlvbiBSYWN0aXZlJHN1YnRyYWN0KGtleXBhdGgsIGQpIHtcbiAgXHRyZXR1cm4gc2hhcmVkX2FkZCh0aGlzLCBrZXlwYXRoLCBkID09PSB1bmRlZmluZWQgPyAtMSA6IC1kKTtcbiAgfVxuXG4gIC8vIFRlYXJkb3duLiBUaGlzIGdvZXMgdGhyb3VnaCB0aGUgcm9vdCBmcmFnbWVudCBhbmQgYWxsIGl0cyBjaGlsZHJlbiwgcmVtb3Zpbmcgb2JzZXJ2ZXJzXG4gIC8vIGFuZCBnZW5lcmFsbHkgY2xlYW5pbmcgdXAgYWZ0ZXIgaXRzZWxmXG5cbiAgdmFyIFJhY3RpdmVfcHJvdG90eXBlX3RlYXJkb3duID0gUmFjdGl2ZSR0ZWFyZG93bjtcblxuICB2YXIgUmFjdGl2ZV9wcm90b3R5cGVfdGVhcmRvd25fX3RlYXJkb3duSG9vayA9IG5ldyBob29rc19Ib29rKFwidGVhcmRvd25cIik7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkdGVhcmRvd24oKSB7XG4gIFx0dmFyIHByb21pc2U7XG5cbiAgXHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdHRoaXMudmlld21vZGVsLnRlYXJkb3duKCk7XG5cbiAgXHR0aGlzLl9vYnNlcnZlcnMuZm9yRWFjaChjYW5jZWwpO1xuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQucmVuZGVyZWQgJiYgdGhpcy5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18pIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgdGhpcyk7XG4gIFx0fVxuXG4gIFx0dGhpcy5zaG91bGREZXN0cm95ID0gdHJ1ZTtcbiAgXHRwcm9taXNlID0gdGhpcy5mcmFnbWVudC5yZW5kZXJlZCA/IHRoaXMudW5yZW5kZXIoKSA6IHV0aWxzX1Byb21pc2UucmVzb2x2ZSgpO1xuXG4gIFx0UmFjdGl2ZV9wcm90b3R5cGVfdGVhcmRvd25fX3RlYXJkb3duSG9vay5maXJlKHRoaXMpO1xuXG4gIFx0dGhpcy5fYm91bmRGdW5jdGlvbnMuZm9yRWFjaChkZWxldGVGdW5jdGlvbkNvcHkpO1xuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVGdW5jdGlvbkNvcHkoYm91bmQpIHtcbiAgXHRkZWxldGUgYm91bmQuZm5bYm91bmQucHJvcF07XG4gIH1cblxuICB2YXIgdG9nZ2xlID0gUmFjdGl2ZSR0b2dnbGU7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkdG9nZ2xlKGtleXBhdGgpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0aWYgKHR5cGVvZiBrZXlwYXRoICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGJhZEFyZ3VtZW50cyk7XG4gIFx0fVxuXG4gIFx0dmFyIGNoYW5nZXMgPSB1bmRlZmluZWQ7XG5cbiAgXHRpZiAoL1xcKi8udGVzdChrZXlwYXRoKSkge1xuICBcdFx0Y2hhbmdlcyA9IHt9O1xuXG4gIFx0XHRnZXRNYXRjaGluZ0tleXBhdGhzKHRoaXMsIGdldEtleXBhdGgobm9ybWFsaXNlKGtleXBhdGgpKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRjaGFuZ2VzW2tleXBhdGguc3RyXSA9ICFfdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdFx0fSk7XG5cbiAgXHRcdHJldHVybiB0aGlzLnNldChjaGFuZ2VzKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5zZXQoa2V5cGF0aCwgIXRoaXMuZ2V0KGtleXBhdGgpKTtcbiAgfVxuXG4gIHZhciB0b0hUTUwgPSBSYWN0aXZlJHRvSFRNTDtcblxuICBmdW5jdGlvbiBSYWN0aXZlJHRvSFRNTCgpIHtcbiAgXHRyZXR1cm4gdGhpcy5mcmFnbWVudC50b1N0cmluZyh0cnVlKTtcbiAgfVxuXG4gIHZhciBSYWN0aXZlX3Byb3RvdHlwZV91bnJlbmRlciA9IFJhY3RpdmUkdW5yZW5kZXI7XG4gIHZhciB1bnJlbmRlckhvb2sgPSBuZXcgaG9va3NfSG9vayhcInVucmVuZGVyXCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJHVucmVuZGVyKCkge1xuICBcdHZhciBwcm9taXNlLCBzaG91bGREZXN0cm95O1xuXG4gIFx0aWYgKCF0aGlzLmZyYWdtZW50LnJlbmRlcmVkKSB7XG4gIFx0XHR3YXJuSWZEZWJ1ZyhcInJhY3RpdmUudW5yZW5kZXIoKSB3YXMgY2FsbGVkIG9uIGEgUmFjdGl2ZSBpbnN0YW5jZSB0aGF0IHdhcyBub3QgcmVuZGVyZWRcIik7XG4gIFx0XHRyZXR1cm4gdXRpbHNfUHJvbWlzZS5yZXNvbHZlKCk7XG4gIFx0fVxuXG4gIFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpO1xuXG4gIFx0Ly8gSWYgdGhpcyBpcyBhIGNvbXBvbmVudCwgYW5kIHRoZSBjb21wb25lbnQgaXNuJ3QgbWFya2VkIGZvciBkZXN0cnVjdGlvbixcbiAgXHQvLyBkb24ndCBkZXRhY2ggbm9kZXMgZnJvbSB0aGUgRE9NIHVubmVjZXNzYXJpbHlcbiAgXHRzaG91bGREZXN0cm95ID0gIXRoaXMuY29tcG9uZW50IHx8IHRoaXMuY29tcG9uZW50LnNob3VsZERlc3Ryb3kgfHwgdGhpcy5zaG91bGREZXN0cm95O1xuXG4gIFx0Ly8gQ2FuY2VsIGFueSBhbmltYXRpb25zIGluIHByb2dyZXNzXG4gIFx0d2hpbGUgKHRoaXMuX2FuaW1hdGlvbnNbMF0pIHtcbiAgXHRcdHRoaXMuX2FuaW1hdGlvbnNbMF0uc3RvcCgpOyAvLyBpdCB3aWxsIHJlbW92ZSBpdHNlbGYgZnJvbSB0aGUgaW5kZXhcbiAgXHR9XG5cbiAgXHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKHNob3VsZERlc3Ryb3kpO1xuXG4gIFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCB0aGlzKTtcblxuICBcdHVucmVuZGVySG9vay5maXJlKHRoaXMpO1xuXG4gIFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB2YXIgdW5zaGlmdCA9IG1ha2VBcnJheU1ldGhvZChcInVuc2hpZnRcIik7XG5cbiAgdmFyIFJhY3RpdmVfcHJvdG90eXBlX3VwZGF0ZSA9IFJhY3RpdmUkdXBkYXRlO1xuICB2YXIgdXBkYXRlSG9vayA9IG5ldyBob29rc19Ib29rKFwidXBkYXRlXCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJHVwZGF0ZShrZXlwYXRoKSB7XG4gIFx0dmFyIHByb21pc2U7XG5cbiAgXHRrZXlwYXRoID0gZ2V0S2V5cGF0aChrZXlwYXRoKSB8fCByb290S2V5cGF0aDtcblxuICBcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKTtcbiAgXHR0aGlzLnZpZXdtb2RlbC5tYXJrKGtleXBhdGgpO1xuICBcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0dXBkYXRlSG9vay5maXJlKHRoaXMsIGtleXBhdGgpO1xuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3VwZGF0ZU1vZGVsID0gUmFjdGl2ZSR1cGRhdGVNb2RlbDtcblxuICBmdW5jdGlvbiBSYWN0aXZlJHVwZGF0ZU1vZGVsKGtleXBhdGgsIGNhc2NhZGUpIHtcbiAgXHR2YXIgdmFsdWVzLCBrZXksIGJpbmRpbmdzO1xuXG4gIFx0aWYgKHR5cGVvZiBrZXlwYXRoID09PSBcInN0cmluZ1wiICYmICFjYXNjYWRlKSB7XG4gIFx0XHRiaW5kaW5ncyA9IHRoaXMuX3R3b3dheUJpbmRpbmdzW2tleXBhdGhdO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRiaW5kaW5ncyA9IFtdO1xuXG4gIFx0XHRmb3IgKGtleSBpbiB0aGlzLl90d293YXlCaW5kaW5ncykge1xuICBcdFx0XHRpZiAoIWtleXBhdGggfHwgZ2V0S2V5cGF0aChrZXkpLmVxdWFsc09yU3RhcnRzV2l0aChrZXlwYXRoKSkge1xuICBcdFx0XHRcdC8vIFRPRE8gaXMgdGhpcyByaWdodD9cbiAgXHRcdFx0XHRiaW5kaW5ncy5wdXNoLmFwcGx5KGJpbmRpbmdzLCB0aGlzLl90d293YXlCaW5kaW5nc1trZXldKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHZhbHVlcyA9IGNvbnNvbGlkYXRlKHRoaXMsIGJpbmRpbmdzKTtcbiAgXHRyZXR1cm4gdGhpcy5zZXQodmFsdWVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnNvbGlkYXRlKHJhY3RpdmUsIGJpbmRpbmdzKSB7XG4gIFx0dmFyIHZhbHVlcyA9IHt9LFxuICBcdCAgICBjaGVja2JveEdyb3VwcyA9IFtdO1xuXG4gIFx0YmluZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICBcdFx0dmFyIG9sZFZhbHVlLCBuZXdWYWx1ZTtcblxuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gcmFkaW8gbmFtZSBiaW5kaW5nc1xuICBcdFx0aWYgKGIucmFkaW9OYW1lICYmICFiLmVsZW1lbnQubm9kZS5jaGVja2VkKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gY2hlY2tib3ggbmFtZSBiaW5kaW5ncyBjb21lIGluIGdyb3Vwcywgc29cbiAgXHRcdC8vIHdlIHdhbnQgdG8gZ2V0IHRoZSB2YWx1ZSBvbmNlIGF0IG1vc3RcbiAgXHRcdGlmIChiLmNoZWNrYm94TmFtZSkge1xuICBcdFx0XHRpZiAoIWNoZWNrYm94R3JvdXBzW2Iua2V5cGF0aC5zdHJdICYmICFiLmNoYW5nZWQoKSkge1xuICBcdFx0XHRcdGNoZWNrYm94R3JvdXBzLnB1c2goYi5rZXlwYXRoKTtcbiAgXHRcdFx0XHRjaGVja2JveEdyb3Vwc1tiLmtleXBhdGguc3RyXSA9IGI7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdG9sZFZhbHVlID0gYi5hdHRyaWJ1dGUudmFsdWU7XG4gIFx0XHRuZXdWYWx1ZSA9IGIuZ2V0VmFsdWUoKTtcblxuICBcdFx0aWYgKGFycmF5Q29udGVudHNNYXRjaChvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFpc0VxdWFsKG9sZFZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgXHRcdFx0dmFsdWVzW2Iua2V5cGF0aC5zdHJdID0gbmV3VmFsdWU7XG4gIFx0XHR9XG4gIFx0fSk7XG5cbiAgXHQvLyBIYW5kbGUgZ3JvdXBzIG9mIGA8aW5wdXQgdHlwZT0nY2hlY2tib3gnIG5hbWU9J3t7Zm9vfX0nIC4uLj5gXG4gIFx0aWYgKGNoZWNrYm94R3JvdXBzLmxlbmd0aCkge1xuICBcdFx0Y2hlY2tib3hHcm91cHMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHR2YXIgYmluZGluZywgb2xkVmFsdWUsIG5ld1ZhbHVlO1xuXG4gIFx0XHRcdGJpbmRpbmcgPSBjaGVja2JveEdyb3Vwc1trZXlwYXRoLnN0cl07IC8vIG9uZSB0byByZXByZXNlbnQgdGhlIGVudGlyZSBncm91cFxuICBcdFx0XHRvbGRWYWx1ZSA9IGJpbmRpbmcuYXR0cmlidXRlLnZhbHVlO1xuICBcdFx0XHRuZXdWYWx1ZSA9IGJpbmRpbmcuZ2V0VmFsdWUoKTtcblxuICBcdFx0XHRpZiAoIWFycmF5Q29udGVudHNNYXRjaChvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gIFx0XHRcdFx0dmFsdWVzW2tleXBhdGguc3RyXSA9IG5ld1ZhbHVlO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZSA9IHtcbiAgXHRhZGQ6IHByb3RvdHlwZV9hZGQsXG4gIFx0YW5pbWF0ZTogcHJvdG90eXBlX2FuaW1hdGUsXG4gIFx0ZGV0YWNoOiBwcm90b3R5cGVfZGV0YWNoLFxuICBcdGZpbmQ6IHByb3RvdHlwZV9maW5kLFxuICBcdGZpbmRBbGw6IHByb3RvdHlwZV9maW5kQWxsLFxuICBcdGZpbmRBbGxDb21wb25lbnRzOiBwcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMsXG4gIFx0ZmluZENvbXBvbmVudDogcHJvdG90eXBlX2ZpbmRDb21wb25lbnQsXG4gIFx0ZmluZENvbnRhaW5lcjogZmluZENvbnRhaW5lcixcbiAgXHRmaW5kUGFyZW50OiBmaW5kUGFyZW50LFxuICBcdGZpcmU6IHByb3RvdHlwZV9maXJlLFxuICBcdGdldDogcHJvdG90eXBlX2dldCxcbiAgXHRpbnNlcnQ6IGluc2VydCxcbiAgXHRtZXJnZTogcHJvdG90eXBlX21lcmdlLFxuICBcdG9ic2VydmU6IG9ic2VydmUsXG4gIFx0b2JzZXJ2ZU9uY2U6IG9ic2VydmVPbmNlLFxuICBcdG9mZjogb2ZmLFxuICBcdG9uOiBvbixcbiAgXHRvbmNlOiBvbmNlLFxuICBcdHBvcDogcG9wLFxuICBcdHB1c2g6IHB1c2gsXG4gIFx0cmVuZGVyOiBwcm90b3R5cGVfcmVuZGVyLFxuICBcdHJlc2V0OiBwcm90b3R5cGVfcmVzZXQsXG4gIFx0cmVzZXRQYXJ0aWFsOiByZXNldFBhcnRpYWwsXG4gIFx0cmVzZXRUZW1wbGF0ZTogcmVzZXRUZW1wbGF0ZSxcbiAgXHRyZXZlcnNlOiByZXZlcnNlLFxuICBcdHNldDogUmFjdGl2ZV9wcm90b3R5cGVfc2V0LFxuICBcdHNoaWZ0OiBzaGlmdCxcbiAgXHRzb3J0OiBwcm90b3R5cGVfc29ydCxcbiAgXHRzcGxpY2U6IHNwbGljZSxcbiAgXHRzdWJ0cmFjdDogc3VidHJhY3QsXG4gIFx0dGVhcmRvd246IFJhY3RpdmVfcHJvdG90eXBlX3RlYXJkb3duLFxuICBcdHRvZ2dsZTogdG9nZ2xlLFxuICBcdHRvSFRNTDogdG9IVE1MLFxuICBcdHRvSHRtbDogdG9IVE1MLFxuICBcdHVucmVuZGVyOiBSYWN0aXZlX3Byb3RvdHlwZV91bnJlbmRlcixcbiAgXHR1bnNoaWZ0OiB1bnNoaWZ0LFxuICBcdHVwZGF0ZTogUmFjdGl2ZV9wcm90b3R5cGVfdXBkYXRlLFxuICBcdHVwZGF0ZU1vZGVsOiBwcm90b3R5cGVfdXBkYXRlTW9kZWxcbiAgfTtcblxuICB2YXIgd3JhcE1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2QsIHN1cGVyTWV0aG9kLCBmb3JjZSkge1xuXG4gIFx0aWYgKGZvcmNlIHx8IG5lZWRzU3VwZXIobWV0aG9kLCBzdXBlck1ldGhvZCkpIHtcblxuICBcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuICBcdFx0XHR2YXIgaGFzU3VwZXIgPSAoXCJfc3VwZXJcIiBpbiB0aGlzKSxcbiAgXHRcdFx0ICAgIF9zdXBlciA9IHRoaXMuX3N1cGVyLFxuICBcdFx0XHQgICAgcmVzdWx0O1xuXG4gIFx0XHRcdHRoaXMuX3N1cGVyID0gc3VwZXJNZXRob2Q7XG5cbiAgXHRcdFx0cmVzdWx0ID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgXHRcdFx0aWYgKGhhc1N1cGVyKSB7XG4gIFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfc3VwZXI7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdFx0fTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmV0dXJuIG1ldGhvZDtcbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gbmVlZHNTdXBlcihtZXRob2QsIHN1cGVyTWV0aG9kKSB7XG4gIFx0cmV0dXJuIHR5cGVvZiBzdXBlck1ldGhvZCA9PT0gXCJmdW5jdGlvblwiICYmIC9fc3VwZXIvLnRlc3QobWV0aG9kKTtcbiAgfVxuXG4gIHZhciB1bndyYXBFeHRlbmRlZCA9IHVud3JhcDtcblxuICBmdW5jdGlvbiB1bndyYXAoQ2hpbGQpIHtcbiAgXHR2YXIgb3B0aW9ucyA9IHt9O1xuXG4gIFx0d2hpbGUgKENoaWxkKSB7XG4gIFx0XHRhZGRSZWdpc3RyaWVzKENoaWxkLCBvcHRpb25zKTtcbiAgXHRcdGFkZE90aGVyT3B0aW9ucyhDaGlsZCwgb3B0aW9ucyk7XG5cbiAgXHRcdGlmIChDaGlsZC5fUGFyZW50ICE9PSBfUmFjdGl2ZSkge1xuICBcdFx0XHRDaGlsZCA9IENoaWxkLl9QYXJlbnQ7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRDaGlsZCA9IGZhbHNlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBvcHRpb25zO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkUmVnaXN0cmllcyhDaGlsZCwgb3B0aW9ucykge1xuICBcdGNvbmZpZ19yZWdpc3RyaWVzLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgXHRcdGFkZFJlZ2lzdHJ5KHIudXNlRGVmYXVsdHMgPyBDaGlsZC5wcm90b3R5cGUgOiBDaGlsZCwgb3B0aW9ucywgci5uYW1lKTtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFJlZ2lzdHJ5KHRhcmdldCwgb3B0aW9ucywgbmFtZSkge1xuICBcdHZhciByZWdpc3RyeSxcbiAgXHQgICAga2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldFtuYW1lXSk7XG5cbiAgXHRpZiAoIWtleXMubGVuZ3RoKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKCEocmVnaXN0cnkgPSBvcHRpb25zW25hbWVdKSkge1xuICBcdFx0cmVnaXN0cnkgPSBvcHRpb25zW25hbWVdID0ge307XG4gIFx0fVxuXG4gIFx0a2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICBcdFx0cmV0dXJuICEoa2V5IGluIHJlZ2lzdHJ5KTtcbiAgXHR9KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdHJldHVybiByZWdpc3RyeVtrZXldID0gdGFyZ2V0W25hbWVdW2tleV07XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRPdGhlck9wdGlvbnMoQ2hpbGQsIG9wdGlvbnMpIHtcbiAgXHRPYmplY3Qua2V5cyhDaGlsZC5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBcdFx0aWYgKGtleSA9PT0gXCJjb21wdXRlZFwiKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dmFyIHZhbHVlID0gQ2hpbGQucHJvdG90eXBlW2tleV07XG5cbiAgXHRcdGlmICghKGtleSBpbiBvcHRpb25zKSkge1xuICBcdFx0XHRvcHRpb25zW2tleV0gPSB2YWx1ZS5fbWV0aG9kID8gdmFsdWUuX21ldGhvZCA6IHZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBpcyBpdCBhIHdyYXBwZWQgZnVuY3Rpb24/XG4gIFx0XHRlbHNlIGlmICh0eXBlb2Ygb3B0aW9uc1trZXldID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiYgb3B0aW9uc1trZXldLl9tZXRob2QpIHtcblxuICBcdFx0XHR2YXIgcmVzdWx0ID0gdW5kZWZpbmVkLFxuICBcdFx0XHQgICAgbmVlZHNTdXBlciA9IHZhbHVlLl9tZXRob2Q7XG5cbiAgXHRcdFx0aWYgKG5lZWRzU3VwZXIpIHtcbiAgXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLl9tZXRob2Q7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyByZXdyYXAgYm91bmQgZGlyZWN0bHkgdG8gcGFyZW50IGZuXG4gIFx0XHRcdHJlc3VsdCA9IHdyYXBNZXRob2Qob3B0aW9uc1trZXldLl9tZXRob2QsIHZhbHVlKTtcblxuICBcdFx0XHRpZiAobmVlZHNTdXBlcikge1xuICBcdFx0XHRcdHJlc3VsdC5fbWV0aG9kID0gcmVzdWx0O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0b3B0aW9uc1trZXldID0gcmVzdWx0O1xuICBcdFx0fVxuICBcdH0pO1xuICB9XG5cbiAgdmFyIF9leHRlbmQgPSBfZXh0ZW5kX19leHRlbmQ7XG5cbiAgZnVuY3Rpb24gX2V4dGVuZF9fZXh0ZW5kKCkge1xuICBcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBvcHRpb25zID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRvcHRpb25zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICBcdH1cblxuICBcdGlmICghb3B0aW9ucy5sZW5ndGgpIHtcbiAgXHRcdHJldHVybiBleHRlbmRPbmUodGhpcyk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiBvcHRpb25zLnJlZHVjZShleHRlbmRPbmUsIHRoaXMpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZE9uZShQYXJlbnQpIHtcbiAgXHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgXHR2YXIgQ2hpbGQsIHByb3RvO1xuXG4gIFx0Ly8gaWYgd2UncmUgZXh0ZW5kaW5nIHdpdGggYW5vdGhlciBSYWN0aXZlIGluc3RhbmNlLi4uXG4gIFx0Ly9cbiAgXHQvLyAgIHZhciBIdW1hbiA9IFJhY3RpdmUuZXh0ZW5kKC4uLiksIFNwaWRlciA9IFJhY3RpdmUuZXh0ZW5kKC4uLik7XG4gIFx0Ly8gICB2YXIgU3BpZGVybWFuID0gSHVtYW4uZXh0ZW5kKCBTcGlkZXIgKTtcbiAgXHQvL1xuICBcdC8vIC4uLmluaGVyaXQgcHJvdG90eXBlIG1ldGhvZHMgYW5kIGRlZmF1bHQgb3B0aW9ucyBhcyB3ZWxsXG4gIFx0aWYgKG9wdGlvbnMucHJvdG90eXBlIGluc3RhbmNlb2YgX1JhY3RpdmUpIHtcbiAgXHRcdG9wdGlvbnMgPSB1bndyYXBFeHRlbmRlZChvcHRpb25zKTtcbiAgXHR9XG5cbiAgXHRDaGlsZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0XHRpZiAoISh0aGlzIGluc3RhbmNlb2YgQ2hpbGQpKSByZXR1cm4gbmV3IENoaWxkKG9wdGlvbnMpO1xuICBcdFx0aW5pdGlhbGlzZSh0aGlzLCBvcHRpb25zKTtcbiAgXHR9O1xuXG4gIFx0cHJvdG8gPSBjcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG4gIFx0cHJvdG8uY29uc3RydWN0b3IgPSBDaGlsZDtcblxuICBcdC8vIFN0YXRpYyBwcm9wZXJ0aWVzXG4gIFx0ZGVmaW5lUHJvcGVydGllcyhDaGlsZCwge1xuICBcdFx0Ly8gYWxpYXMgcHJvdG90eXBlIGFzIGRlZmF1bHRzXG4gIFx0XHRkZWZhdWx0czogeyB2YWx1ZTogcHJvdG8gfSxcblxuICBcdFx0Ly8gZXh0ZW5kYWJsZVxuICBcdFx0ZXh0ZW5kOiB7IHZhbHVlOiBfZXh0ZW5kX19leHRlbmQsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSxcblxuICBcdFx0Ly8gUGFyZW50IC0gZm9yIElFOCwgY2FuJ3QgdXNlIE9iamVjdC5nZXRQcm90b3R5cGVPZlxuICBcdFx0X1BhcmVudDogeyB2YWx1ZTogUGFyZW50IH1cbiAgXHR9KTtcblxuICBcdC8vIGV4dGVuZCBjb25maWd1cmF0aW9uXG4gIFx0Y29uZmlnX2NvbmZpZy5leHRlbmQoUGFyZW50LCBwcm90bywgb3B0aW9ucyk7XG5cbiAgXHRjdXN0b21fZGF0YS5leHRlbmQoUGFyZW50LCBwcm90bywgb3B0aW9ucyk7XG5cbiAgXHRpZiAob3B0aW9ucy5jb21wdXRlZCkge1xuICBcdFx0cHJvdG8uY29tcHV0ZWQgPSB1dGlsc19vYmplY3RfX2V4dGVuZChjcmVhdGUoUGFyZW50LnByb3RvdHlwZS5jb21wdXRlZCksIG9wdGlvbnMuY29tcHV0ZWQpO1xuICBcdH1cblxuICBcdENoaWxkLnByb3RvdHlwZSA9IHByb3RvO1xuXG4gIFx0cmV0dXJuIENoaWxkO1xuICB9XG5cbiAgdmFyIGdldE5vZGVJbmZvID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgXHR2YXIgaW5mbyA9IHt9LFxuICBcdCAgICBwcml2LFxuICBcdCAgICBpbmRpY2VzO1xuXG4gIFx0aWYgKCFub2RlIHx8ICEocHJpdiA9IG5vZGUuX3JhY3RpdmUpKSB7XG4gIFx0XHRyZXR1cm4gaW5mbztcbiAgXHR9XG5cbiAgXHRpbmZvLnJhY3RpdmUgPSBwcml2LnJvb3Q7XG4gIFx0aW5mby5rZXlwYXRoID0gcHJpdi5rZXlwYXRoLnN0cjtcbiAgXHRpbmZvLmluZGV4ID0ge307XG5cbiAgXHQvLyBmaW5kIGFsbCBpbmRleCByZWZlcmVuY2VzIGFuZCByZXNvbHZlIHRoZW1cbiAgXHRpZiAoaW5kaWNlcyA9IFJlc29sdmVyc19maW5kSW5kZXhSZWZzKHByaXYucHJveHkucGFyZW50RnJhZ21lbnQpKSB7XG4gIFx0XHRpbmZvLmluZGV4ID0gUmVzb2x2ZXJzX2ZpbmRJbmRleFJlZnMucmVzb2x2ZShpbmRpY2VzKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gaW5mbztcbiAgfTtcblxuICB2YXIgUmFjdGl2ZSwgcHJvcGVydGllcztcblxuICAvLyBNYWluIFJhY3RpdmUgcmVxdWlyZWQgb2JqZWN0XG4gIFJhY3RpdmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBSYWN0aXZlKSkgcmV0dXJuIG5ldyBSYWN0aXZlKG9wdGlvbnMpO1xuICBcdGluaXRpYWxpc2UodGhpcywgb3B0aW9ucyk7XG4gIH07XG5cbiAgLy8gUmFjdGl2ZSBwcm9wZXJ0aWVzXG4gIHByb3BlcnRpZXMgPSB7XG5cbiAgXHQvLyBkZWJ1ZyBmbGFnXG4gIFx0REVCVUc6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0cnVlIH0sXG4gIFx0REVCVUdfUFJPTUlTRVM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0cnVlIH0sXG5cbiAgXHQvLyBzdGF0aWMgbWV0aG9kczpcbiAgXHRleHRlbmQ6IHsgdmFsdWU6IF9leHRlbmQgfSxcbiAgXHRnZXROb2RlSW5mbzogeyB2YWx1ZTogZ2V0Tm9kZUluZm8gfSxcbiAgXHRwYXJzZTogeyB2YWx1ZTogX3BhcnNlIH0sXG5cbiAgXHQvLyBOYW1lc3BhY2VkIGNvbnN0cnVjdG9yc1xuICBcdFByb21pc2U6IHsgdmFsdWU6IHV0aWxzX1Byb21pc2UgfSxcblxuICBcdC8vIHN1cHBvcnRcbiAgXHRzdmc6IHsgdmFsdWU6IHN2ZyB9LFxuICBcdG1hZ2ljOiB7IHZhbHVlOiBlbnZpcm9ubWVudF9fbWFnaWMgfSxcblxuICBcdC8vIHZlcnNpb25cbiAgXHRWRVJTSU9OOiB7IHZhbHVlOiBcIjAuNy4zXCIgfSxcblxuICBcdC8vIFBsdWdpbnNcbiAgXHRhZGFwdG9yczogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gIFx0Y29tcG9uZW50czogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gIFx0ZGVjb3JhdG9yczogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gIFx0ZWFzaW5nOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogc3RhdGljX2Vhc2luZyB9LFxuICBcdGV2ZW50czogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gIFx0aW50ZXJwb2xhdG9yczogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHN0YXRpY19pbnRlcnBvbGF0b3JzIH0sXG4gIFx0cGFydGlhbHM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuICBcdHRyYW5zaXRpb25zOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfVxuICB9O1xuXG4gIC8vIFJhY3RpdmUgcHJvcGVydGllc1xuICBkZWZpbmVQcm9wZXJ0aWVzKFJhY3RpdmUsIHByb3BlcnRpZXMpO1xuXG4gIFJhY3RpdmUucHJvdG90eXBlID0gdXRpbHNfb2JqZWN0X19leHRlbmQocHJvdG90eXBlLCBjb25maWdfZGVmYXVsdHMpO1xuXG4gIFJhY3RpdmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmFjdGl2ZTtcblxuICAvLyBhbGlhcyBwcm90b3R5cGUgYXMgZGVmYXVsdHNcbiAgUmFjdGl2ZS5kZWZhdWx0cyA9IFJhY3RpdmUucHJvdG90eXBlO1xuXG4gIC8vIFJhY3RpdmUuanMgbWFrZXMgbGliZXJhbCB1c2Ugb2YgdGhpbmdzIGxpa2UgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuIEluXG4gIC8vIG9sZGVyIGJyb3dzZXJzLCB0aGVzZSBhcmUgbWFkZSBhdmFpbGFibGUgdmlhIGEgc2hpbSAtIGhlcmUsIHdlIGRvIGEgcXVpY2tcbiAgLy8gcHJlLWZsaWdodCBjaGVjayB0byBtYWtlIHN1cmUgdGhhdCBlaXRoZXIgYSkgd2UncmUgbm90IGluIGEgc2hpdCBicm93c2VyLFxuICAvLyBvciBiKSB3ZSdyZSB1c2luZyBhIFJhY3RpdmUtbGVnYWN5LmpzIGJ1aWxkXG4gIHZhciBGVU5DVElPTiA9IFwiZnVuY3Rpb25cIjtcblxuICBpZiAodHlwZW9mIERhdGUubm93ICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS50cmltICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgT2JqZWN0LmtleXMgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLm1hcCAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5maWx0ZXIgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSBGVU5DVElPTikge1xuICBcdHRocm93IG5ldyBFcnJvcihcIkl0IGxvb2tzIGxpa2UgeW91J3JlIGF0dGVtcHRpbmcgdG8gdXNlIFJhY3RpdmUuanMgaW4gYW4gb2xkZXIgYnJvd3Nlci4gWW91J2xsIG5lZWQgdG8gdXNlIG9uZSBvZiB0aGUgJ2xlZ2FjeSBidWlsZHMnIGluIG9yZGVyIHRvIGNvbnRpbnVlIC0gc2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L2xlZ2FjeS1idWlsZHMgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCIpO1xuICB9XG5cbiAgdmFyIF9SYWN0aXZlID0gUmFjdGl2ZTtcblxuICByZXR1cm4gX1JhY3RpdmU7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhY3RpdmUuanMubWFwXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpZGVudGl0eSwgY2FsbGJhY2spIHtcblx0aWYgKCFfLmlzT2JqZWN0KGlkZW50aXR5KSkge1xuXHRcdHJldHVybiBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG5cdFx0XHRjYWxsYmFjayh7IG1lc3NhZ2U6ICdNaXNzaW5nIFxcJ2lkZW50aXR5XFwnJywgc3RhdHVzOiA0MDAgfSk7XG5cdFx0fSk7XG5cdH1cblx0Y2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2UoeyB0eXBlOiAnc2VydmljZScsIGlkZW50aXR5OiBpZGVudGl0eSB9LCBmdW5jdGlvbihjb21iaW5lZF9yZXNwb25zZSkge1xuXHRcdGlmIChjaHJvbWUucnVudGltZS5sYXN0RXJyb3IgfHwgXy5pc0VtcHR5KGNvbWJpbmVkX3Jlc3BvbnNlKSkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKF8uZXh0ZW5kKGNocm9tZS5ydW50aW1lLmxhc3RFcnJvciwgeyBzdGF0dXM6IDUwMCB9KSk7XG5cdFx0fVxuXHRcdGNhbGxiYWNrKGNvbWJpbmVkX3Jlc3BvbnNlWzBdLCBjb21iaW5lZF9yZXNwb25zZVsxXSk7XG5cdH0pO1xufTtcbiIsInZhciBfICAgPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbnZhciBob3N0bmFtZXNfdG9fdXJscyA9IHt9O1xuXG4vLyBUT0RPIEJyb3dzZXJpZnkgZnJlYWtzIG91dCB1bmxlc3MgdGhleSdyZSBleHBsaWNpdGx5IGxpc3RlZCBvdXRcbi8vIENhbid0IHVzZSByZXF1aXJlLWdsb2JpZnkgc2luY2UgdGhpcyBpc24ndCBuZWNlc3NhcmlseSBhIGJyb3dzZXJpZnkgZmlsZVxuLy8gQ2FuJ3QgZG8gYSBsb29wIHRocm91Z2ggYXBpcyBhbmQgY29uc3RydWN0IHRoZSByZXF1aXJlIHNpbmNlIHRoaXMgaXMgdXNlZCBieSBicm93c2VyaWZ5XG5fLmVhY2goW3JlcXVpcmUoJy4uL2ltZ3VyL3VybHMnKSxcbiAgICAgICAgcmVxdWlyZSgnLi4vaW5zdGFncmFtL3VybHMnKSxcbiAgICAgICAgcmVxdWlyZSgnLi4vcmVkZGl0L3VybHMnKSxcbiAgICAgICAgcmVxdWlyZSgnLi4vc291bmRjbG91ZC91cmxzJyksXG4gICAgICAgIHJlcXVpcmUoJy4uL3R3aXR0ZXIvdXJscycpLFxuICAgICAgICByZXF1aXJlKCcuLi95b3V0dWJlL3VybHMnKV0sIGZ1bmN0aW9uKGFwaV91cmxzKSB7XG5cdF8uZWFjaChhcGlfdXJscy5ob3N0bmFtZXNfcGFyc2VkLCBmdW5jdGlvbihob3N0bmFtZV9wYXJzZWQpIHtcblx0XHRob3N0bmFtZXNfdG9fdXJsc1tob3N0bmFtZV9wYXJzZWRdID0gaG9zdG5hbWVzX3RvX3VybHNbaG9zdG5hbWVfcGFyc2VkXSB8fCBbXTtcblx0XHRob3N0bmFtZXNfdG9fdXJsc1tob3N0bmFtZV9wYXJzZWRdLnB1c2goYXBpX3VybHMpO1xuXHR9KTtcbn0pO1xuXG52YXIgdXJscyA9IHt9O1xuXG51cmxzLnBhcnNlID0gZnVuY3Rpb24odXJsX3N0cmluZykge1xuXHRpZiAoXy5pc0VtcHR5KHVybF9zdHJpbmcpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHZhciB1cmxfb2JqZWN0ID0gdXJsLnBhcnNlKHVybF9zdHJpbmcsIHRydWUsIHRydWUpO1xuXHRyZXR1cm4gXy5jaGFpbihob3N0bmFtZXNfdG9fdXJsc1t1cmxfb2JqZWN0Lmhvc3RuYW1lXSlcblx0ICAgICAgICAuaW52b2tlKCdwYXJzZScsIHVybF9vYmplY3QpXG5cdCAgICAgICAgLmNvbXBhY3QoKVxuXHQgICAgICAgIC5maXJzdCgpXG5cdCAgICAgICAgLnZhbHVlKCk7XG59O1xuXG51cmxzLnJlcHJlc2VudCA9IGZ1bmN0aW9uKGlkZW50aXR5LCBjb21tZW50KSB7XG5cdHJldHVybiByZXF1aXJlKCcuLi8nICsgaWRlbnRpdHkuYXBpICsgJy91cmxzJykucmVwcmVzZW50KGlkZW50aXR5LCBjb21tZW50KTtcbn07XG5cbnVybHMucHJpbnQgPSBmdW5jdGlvbihpZGVudGl0eSwgY29tbWVudCkge1xuXHRpZiAoIWlkZW50aXR5KSB7XG5cdFx0cmV0dXJuIGlkZW50aXR5O1xuXHR9XG5cdHJldHVybiAodXJscy5yZXByZXNlbnQoaWRlbnRpdHksIGNvbW1lbnQpIHx8IFtdKVswXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdXJscztcbiIsInZhciBfICAgPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbnZhciB1cmxzID0ge307XG5cbnVybHMuaG9zdG5hbWVzX3BhcnNlZCA9IFsneW91dHViZS5jb20nLCAnd3d3LnlvdXR1YmUuY29tJywgJ20ueW91dHViZS5jb20nLCAneW91dHUuYmUnXTtcblxudXJscy5wYXJzZSA9IGZ1bmN0aW9uKHVybF9vYmopIHtcblx0dmFyIHBhdGhfcGFydHMgPSB1cmxfb2JqLnBhdGhuYW1lLnJlcGxhY2UoL15cXC8vLCAnJykucmVwbGFjZSgvXFwvJC8sICcnKS5zcGxpdCgnLycpIHx8IFtdO1xuXHRzd2l0Y2ggKHVybF9vYmouaG9zdG5hbWUpIHtcblx0XHRjYXNlICd5b3V0dWJlLmNvbSc6XG5cdFx0Y2FzZSAnd3d3LnlvdXR1YmUuY29tJzpcblx0XHRjYXNlICdtLnlvdXR1YmUuY29tJzpcblx0XHRcdHN3aXRjaCAocGF0aF9wYXJ0c1swXSkge1xuXHRcdFx0XHRjYXNlICd3YXRjaCc6XG5cdFx0XHRcdFx0cmV0dXJuICFfLmlzRW1wdHkodXJsX29iai5xdWVyeS52KSAmJiBfLmV4dGVuZCh7IGFwaTogJ3lvdXR1YmUnLCB0eXBlOiAnY29udGVudCcsIGlkOiB1cmxfb2JqLnF1ZXJ5LnYucmVwbGFjZSgvWz8mXS4qLywgJycpIH0sXG5cdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmxfb2JqLnF1ZXJ5LnQgJiYgeyB0aW1lX29mZnNldDogdXJsX29iai5xdWVyeS50IH0pO1xuXHRcdFx0XHRjYXNlICdlbWJlZCc6XG5cdFx0XHRcdGNhc2UgJ3YnOlxuXHRcdFx0XHRcdHJldHVybiAhXy5pc0VtcHR5KHBhdGhfcGFydHNbMV0pICYmIF8uZXh0ZW5kKHsgYXBpOiAneW91dHViZScsIHR5cGU6ICdjb250ZW50JywgaWQ6IHBhdGhfcGFydHNbMV0ucmVwbGFjZSgvWz8mXS4qLywgJycpIH0sXG5cdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsX29iai5xdWVyeS5zdGFydCAmJiB7IHRpbWVfb2Zmc2V0OiB1cmxfb2JqLnF1ZXJ5LnN0YXJ0IH0pO1xuXHRcdFx0XHRjYXNlICdhdHRyaWJ1dGlvbl9saW5rJzpcblx0XHRcdFx0XHRyZXR1cm4gIV8uaXNFbXB0eSh1cmxfb2JqLnF1ZXJ5LnUpICYmIHVybHMucGFyc2UodXJsLnBhcnNlKCdodHRwczovL3lvdXR1YmUuY29tJyArIHVybF9vYmoucXVlcnkudSwgdHJ1ZSwgdHJ1ZSkpO1xuXHRcdFx0XHRjYXNlICdjaGFubmVsJzpcblx0XHRcdFx0XHRyZXR1cm4gIV8uaXNFbXB0eShwYXRoX3BhcnRzWzFdKSAmJiB7IGFwaTogJ3lvdXR1YmUnLCB0eXBlOiAnYWNjb3VudCcsIGlkOiBwYXRoX3BhcnRzWzFdLnJlcGxhY2UoL1s/Jl0uKi8sICcnKSB9O1xuXHRcdFx0XHRjYXNlICd1c2VyJzpcblx0XHRcdFx0XHRyZXR1cm4gIV8uaXNFbXB0eShwYXRoX3BhcnRzWzFdKSAmJiB7IGFwaTogJ3lvdXR1YmUnLCB0eXBlOiAnYWNjb3VudCcsIGlkOiBwYXRoX3BhcnRzWzFdLnJlcGxhY2UoL1s/Jl0uKi8sICcnKSwgYXM6ICdsZWdhY3lfdXNlcm5hbWUnIH07XG5cdFx0XHRcdGNhc2UgJ2MnOlxuXHRcdFx0XHRcdHJldHVybiAhXy5pc0VtcHR5KHBhdGhfcGFydHNbMV0pICYmIHsgYXBpOiAneW91dHViZScsIHR5cGU6ICdhY2NvdW50JywgaWQ6ICdjLycgKyBwYXRoX3BhcnRzWzFdLnJlcGxhY2UoL1s/Jl0uKi8sICcnKSwgYXM6ICdjdXN0b21fdXJsJyB9O1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHJldHVybiAhXy5pc0VtcHR5KHBhdGhfcGFydHNbMF0pICYmXG5cdFx0XHRcdFx0ICAgICAgICFwYXRoX3BhcnRzWzBdLm1hdGNoKC9eKD86YWNjb3VudHxjaGFubmVsc3xkYXNoYm9hcmR8ZmVlZHxsb2dvdXR8cGxheWxpc3R8c2lnbmlufHN1YnNjcmlwdGlvbl8oPzpjZW50ZXJ8bWFuYWdlcil8dHx0ZXN0dHViZXx1cGxvYWR8eXQpJC8pICYmXG5cdFx0XHRcdFx0ICAgICAgIHsgYXBpOiAneW91dHViZScsIHR5cGU6ICdhY2NvdW50JywgaWQ6IHBhdGhfcGFydHNbMF0ucmVwbGFjZSgvWz8mXS4qLywgJycpLCBhczogJ2N1c3RvbV91cmwnIH07XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICd5b3V0dS5iZSc6XG5cdFx0XHRyZXR1cm4gIV8uaXNFbXB0eShwYXRoX3BhcnRzWzBdKSAmJiBfLmV4dGVuZCh7IGFwaTogJ3lvdXR1YmUnLCB0eXBlOiAnY29udGVudCcsIGlkOiBwYXRoX3BhcnRzWzBdLnJlcGxhY2UoL1s/Jl0uKi8sICcnKSB9LFxuXHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsX29iai5xdWVyeS50ICYmIHsgdGltZV9vZmZzZXQ6IHVybF9vYmoucXVlcnkudCB9KTtcblx0fVxufTtcblxudXJscy5yZXByZXNlbnQgPSBmdW5jdGlvbihpZGVudGl0eSwgY29tbWVudCkge1xuXHRzd2l0Y2ggKGlkZW50aXR5LnR5cGUpIHtcblx0XHRjYXNlICdjb250ZW50Jzpcblx0XHRcdHJldHVybiBbJ2h0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9JyArIGlkZW50aXR5LmlkICsgKF8ucmVzdWx0KGNvbW1lbnQsICdpZCcpID8gJyZsYz0nICsgY29tbWVudC5pZCA6ICcnKSxcblx0XHRcdCAgICAgICAgJ2h0dHBzOi8veW91dHUuYmUvJyArIGlkZW50aXR5LmlkICsgKF8ucmVzdWx0KGNvbW1lbnQsICdpZCcpID8gJz9sYz0nICsgY29tbWVudC5pZCA6ICcnKV07XG5cdFx0Y2FzZSAnYWNjb3VudCc6XG5cdFx0XHRzd2l0Y2ggKGlkZW50aXR5LmFzKSB7XG5cdFx0XHRcdGNhc2UgJ2N1c3RvbV91cmwnOlxuXHRcdFx0XHRcdHJldHVybiBbJ2h0dHBzOi8vd3d3LnlvdXR1YmUuY29tLycgKyBpZGVudGl0eS5pZF07XG5cdFx0XHRcdGNhc2UgJ2xlZ2FjeV91c2VybmFtZSc6XG5cdFx0XHRcdFx0cmV0dXJuIFsnaHR0cHM6Ly93d3cueW91dHViZS5jb20vdXNlci8nICsgaWRlbnRpdHkuaWRdO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHJldHVybiBbJ2h0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2NoYW5uZWwvJyArIGlkZW50aXR5LmlkXTtcblx0XHRcdH1cblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1cmxzO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbnZhciB1cmxzID0ge307XG5cbnVybHMuaG9zdG5hbWVzX3BhcnNlZCA9IFsndHdpdHRlci5jb20nLCAnd3d3LnR3aXR0ZXIuY29tJywgJ20udHdpdHRlci5jb20nLCAnbW9iaWxlLnR3aXR0ZXIuY29tJ107XG5cbi8vIEZST006IGh0dHBzOi8vZGV2LnR3aXR0ZXIuY29tL3Jlc3QvcmVmZXJlbmNlL2dldC9oZWxwL2NvbmZpZ3VyYXRpb25cbnVybHMubm9uX3VzZXJuYW1lX3JlZ2V4ID0gL14oPzphYm91dHxhY2NvdW50cz98YWN0aXZpdHl8YWxsfGFubm91bmNlbWVudHN8YW55d2hlcmV8YXBpKD86Xz9ydWxlc3xfdGVybXMpfGFwcHN8YXV0aHxiYWRnZXN8YmxvZ3xidXNpbmVzc3xidXR0b25zfGNvbnRhY3RzfGRldmljZXN8ZGlyZWN0X21lc3NhZ2VzfGRvd25sb2Fkcz98ZWRpdF9hbm5vdW5jZW1lbnRzfGZhcXxmYXZvcml0ZXN8ZmluZF8oPzpzb3VyY2VzfHVzZXJzKXxmb2xsb3coPzplcnN8aW5nKXxmcmllbmQoPzpzfF8/cmVxdWVzdCl8Z29vZGllc3xoYXNodGFnfGhlbHB8aG9tZXxpfGltX2FjY291bnR8aW5ib3h8aW52aXRhdGlvbnN8aW52aXRlfGpvYnN8bGlzdHxsb2coPzppbnxvfG91dCl8bWV8bWVkaWFfc2lnbnVwfG1lbnRpb25zfG1lc3NhZ2VzfG1vY2t2aWV3fG5ld3R3aXR0ZXJ8bm90aWZpY2F0aW9uc3xudWRnZXxvYXV0aHxwaG9lbml4X3NlYXJjaHxwb3NpdGlvbnN8cHJpdmFjeXxwdWJsaWNfdGltZWxpbmV8cmVsYXRlZF90d2VldHN8cmVwbGllc3xyZXR3ZWV0KD86ZWRfb2ZfbWluZXxzfHNfYnlfb3RoZXJzKXxydWxlc3xzYXZlZF9zZWFyY2hlc3xzZWFyY2h8c2VudHxzZXNzaW9uc3xzZXR0aW5nc3xzaGFyZXxzaWduKD86aW58dXApfHNpbWlsYXJfdG98c3RhdGlzdGljc3x0ZXJtc3x0b3N8dHJhbnNsYXRlfHRyZW5kc3x0d2VldGJ1dHRvbnx0d3R0cnx1cGRhdGVfZGlzY292ZXJhYmlsaXR5fHVzZXJzfHdlbGNvbWV8d2hvX3RvX2ZvbGxvd3x3aWRnZXRzfHplbmRlc2tfYXV0aCkkLztcblxudXJscy5wYXJzZSA9IGZ1bmN0aW9uKHVybF9vYmopIHtcblx0dmFyIHBhdGhfcGFydHMgPSB1cmxfb2JqLnBhdGhuYW1lLnJlcGxhY2UoL15cXC8vLCAnJykucmVwbGFjZSgvXFwvJC8sICcnKS5zcGxpdCgnLycpIHx8IFtdO1xuXHRpZiAocGF0aF9wYXJ0c1swXSA9PT0gJ2ludGVudCcpIHtcblx0XHRzd2l0Y2ggKHBhdGhfcGFydHNbMV0pIHtcblx0XHRcdGNhc2UgJ3R3ZWV0Jzpcblx0XHRcdFx0cmV0dXJuICFfLmlzRW1wdHkodXJsX29iai5xdWVyeS5pbl9yZXBseV90bykgJiYgeyBhcGk6ICd0d2l0dGVyJywgdHlwZTogJ2NvbnRlbnQnLCBpZDogdXJsX29iai5xdWVyeS5pbl9yZXBseV90byB9O1xuXHRcdFx0Y2FzZSAnZmF2b3JpdGUnOlxuXHRcdFx0Y2FzZSAncmV0d2VldCc6XG5cdFx0XHRcdHJldHVybiAhXy5pc0VtcHR5KHVybF9vYmoucXVlcnkudHdlZXRfaWQpICYmIHsgYXBpOiAndHdpdHRlcicsIHR5cGU6ICdjb250ZW50JywgaWQ6IHVybF9vYmoucXVlcnkudHdlZXRfaWQgfTtcblx0XHRcdGNhc2UgJ2ZvbGxvdyc6XG5cdFx0XHRjYXNlICd1c2VyJzpcblx0XHRcdFx0cmV0dXJuICFfLmlzRW1wdHkodXJsX29iai5xdWVyeS5zY3JlZW5fbmFtZSkgJiYgeyBhcGk6ICd0d2l0dGVyJywgdHlwZTogJ2FjY291bnQnLCBpZDogdXJsX29iai5xdWVyeS5zY3JlZW5fbmFtZSB9O1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fVxuXHRpZiAocGF0aF9wYXJ0cy5sZW5ndGggPT09IDEgJiYgXy5pc0VtcHR5KHBhdGhfcGFydHNbMF0pICYmICh1cmxfb2JqLmhhc2ggfHwgJycpLmluZGV4T2YoJyMhJykgPT09IDApIHtcblx0XHRwYXRoX3BhcnRzID0gdXJsX29iai5oYXNoLnJlcGxhY2UoL14jIVxcLy8sICcnKS5yZXBsYWNlKC9cXC8kLywgJycpLnNwbGl0KCcvJykgfHwgW107XG5cdH1cblx0aWYgKF8uaXNFbXB0eShwYXRoX3BhcnRzWzBdKSB8fCBwYXRoX3BhcnRzWzBdLm1hdGNoKHVybHMubm9uX3VzZXJuYW1lX3JlZ2V4KSkge1xuXHRcdHJldHVybjtcblx0fVxuXHR2YXIgYWNjb3VudCA9IHsgYXBpOiAndHdpdHRlcicsIHR5cGU6ICdhY2NvdW50JywgaWQ6IHBhdGhfcGFydHNbMF0gfTtcblx0aWYgKF8uaXNFbXB0eShwYXRoX3BhcnRzWzFdKSB8fCAhcGF0aF9wYXJ0c1sxXS5tYXRjaCgvXnN0YXR1cyg/OmVzKT8kLykpIHtcblx0XHRyZXR1cm4gYWNjb3VudDtcblx0fVxuXHRyZXR1cm4gIV8uaXNFbXB0eShwYXRoX3BhcnRzWzJdKSAmJiB7IGFwaTogJ3R3aXR0ZXInLCB0eXBlOiAnY29udGVudCcsIGlkOiBwYXRoX3BhcnRzWzJdLCBhY2NvdW50OiBhY2NvdW50IH07XG59O1xuXG51cmxzLnJlcHJlc2VudCA9IGZ1bmN0aW9uKGlkZW50aXR5KSB7XG5cdHN3aXRjaCAoaWRlbnRpdHkudHlwZSkge1xuXHRcdGNhc2UgJ2NvbnRlbnQnOlxuXHRcdFx0cmV0dXJuIFsnaHR0cHM6Ly90d2l0dGVyLmNvbS8nICsgKF8ucmVzdWx0KGlkZW50aXR5LmFjY291bnQsICdpZCcpIHx8ICdzY3JlZW5fbmFtZScpICsgJy9zdGF0dXMvJyArIGlkZW50aXR5LmlkXTtcblx0XHRjYXNlICdhY2NvdW50Jzpcblx0XHRcdHJldHVybiBbJ2h0dHBzOi8vdHdpdHRlci5jb20vJyArIGlkZW50aXR5LmlkXTtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1cmxzO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbnZhciB1cmxzID0ge307XG5cbnVybHMuaG9zdG5hbWVzX3BhcnNlZCA9IFsnc291bmRjbG91ZC5jb20nLCAnd3d3LnNvdW5kY2xvdWQuY29tJywgJ20uc291bmRjbG91ZC5jb20nXTtcblxudXJscy5ub25fdXNlcm5hbWVfcmVnZXggID0gL14oPzpleHBsb3JlfGdyb3Vwc3xqb2JzfG1lc3NhZ2VzfG1vYmlsZXxub3RpZmljYXRpb25zfHBhZ2VzfHBlb3BsZXxwcm98c2V0dGluZ3N8c3RyZWFtfHRhZ3N8dGVybXMtb2YtdXNlfHVwbG9hZCg/Oi1jbGFzc2ljKT98eW91KSQvO1xudXJscy5ub25fdHJhY2tuYW1lX3JlZ2V4ID0gL14oPzpjb21tZW50c3xncm91cHN8Zm9sbG93KD86ZXJzfGluZyl8bGlrZXN8dHJhY2tzKSQvO1xuXG51cmxzLnBhcnNlID0gZnVuY3Rpb24odXJsX29iaikge1xuXHR2YXIgcGF0aF9wYXJ0cyA9IHVybF9vYmoucGF0aG5hbWUucmVwbGFjZSgvXlxcLy8sICcnKS5yZXBsYWNlKC9cXC8kLywgJycpLnNwbGl0KCcvJykgfHwgW107XG5cdGlmIChfLmlzRW1wdHkocGF0aF9wYXJ0c1swXSkgfHwgcGF0aF9wYXJ0c1swXS5tYXRjaCh1cmxzLm5vbl91c2VybmFtZV9yZWdleCkpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0dmFyIGFjY291bnQgPSB7IGFwaTogJ3NvdW5kY2xvdWQnLCB0eXBlOiAnYWNjb3VudCcsIGlkOiBwYXRoX3BhcnRzWzBdIH07XG5cdGlmIChfLmlzRW1wdHkocGF0aF9wYXJ0c1sxXSkgfHwgcGF0aF9wYXJ0c1sxXS5tYXRjaCh1cmxzLm5vbl90cmFja25hbWVfcmVnZXgpKSB7XG5cdFx0cmV0dXJuIGFjY291bnQ7XG5cdH1cblx0dmFyIGNvbnRlbnQgPSB7IGFwaTogJ3NvdW5kY2xvdWQnLCB0eXBlOiAnY29udGVudCcsIGlkOiBwYXRoX3BhcnRzWzFdLCBhY2NvdW50OiBhY2NvdW50IH07XG5cdGlmIChwYXRoX3BhcnRzWzFdID09PSAnc2V0cycpIHtcblx0XHRpZiAoXy5pc0VtcHR5KHBhdGhfcGFydHNbMl0pKSB7XG5cdFx0XHRyZXR1cm4gYWNjb3VudDtcblx0XHR9XG5cdFx0Xy5leHRlbmQoY29udGVudCwgeyBpZDogcGF0aF9wYXJ0c1syXSwgYXM6ICdwbGF5bGlzdCcgfSk7XG5cdH1cblx0cmV0dXJuIGNvbnRlbnQ7XG59O1xuXG51cmxzLnJlcHJlc2VudCA9IGZ1bmN0aW9uKGlkZW50aXR5LCBjb21tZW50KSB7XG5cdHN3aXRjaCAoaWRlbnRpdHkudHlwZSkge1xuXHRcdGNhc2UgJ2NvbnRlbnQnOlxuXHRcdFx0cmV0dXJuIFsnaHR0cHM6Ly9zb3VuZGNsb3VkLmNvbS8nICsgKF8ucmVzdWx0KGlkZW50aXR5LmFjY291bnQsICdpZCcpIHx8ICdzY3JlZW5fbmFtZScpICsgKGlkZW50aXR5LmFzID09PSAncGxheWxpc3QnID8gJy9zZXRzJyA6ICcnKSArICcvJyArIGlkZW50aXR5LmlkICsgKF8ucmVzdWx0KGNvbW1lbnQsICdpZCcpID8gJy9jb21tZW50cy8nICsgY29tbWVudC5pZCA6ICcnKV07XG5cdFx0Y2FzZSAnYWNjb3VudCc6XG5cdFx0XHRyZXR1cm4gWydodHRwczovL3NvdW5kY2xvdWQuY29tLycgKyBpZGVudGl0eS5pZF07XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdXJscztcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG52YXIgdXJscyA9IHt9O1xuXG51cmxzLmhvc3RuYW1lc19wYXJzZWQgPSBbJ3JlZGRpdC5jb20nLCAnd3d3LnJlZGRpdC5jb20nLCAnbnAucmVkZGl0LmNvbScsICdtLnJlZGRpdC5jb20nLCAncmVkZC5pdCcsICdyZWRkaXRtZWRpYS5jb20nLCAnd3d3LnJlZGRpdG1lZGlhLmNvbSddO1xuXG51cmxzLnBhcnNlID0gZnVuY3Rpb24odXJsX29iaikge1xuXHR2YXIgcGF0aG5hbWUgPSAodXJsX29iai5wYXRobmFtZSB8fCAnJykucmVwbGFjZSgvXFwvJC8sICcnKTtcblx0dmFyIG1hdGNoO1xuXHRpZiAoKG1hdGNoID0gcGF0aG5hbWUubWF0Y2goL15cXC8oPzp1KD86c2VyKT8pXFwvKFteL10rKSg/OlxcL1teL10rKT8kLykpICYmIG1hdGNoWzFdKSB7XG5cdFx0cmV0dXJuIHsgYXBpOiAncmVkZGl0JywgdHlwZTogJ2FjY291bnQnLCBpZDogbWF0Y2hbMV0gfTtcblx0fVxuXHRpZiAoKG1hdGNoID0gcGF0aG5hbWUubWF0Y2goL14oPzpcXC9yXFwvKFteL10rKSk/KD86XFwvY29tbWVudHMpP1xcLyhbXi9dKykoPzpcXC8uKyk/JC8pKSAmJiBtYXRjaFsyXSkge1xuXHRcdGlmIChtYXRjaFsxXSkge1xuXHRcdFx0cmV0dXJuIHsgYXBpOiAncmVkZGl0JywgdHlwZTogJ2NvbnRlbnQnLCBpZDogbWF0Y2hbMl0sIHN1YnJlZGRpdDogbWF0Y2hbMV0gfTtcblx0XHR9XG5cdFx0aWYgKG1hdGNoWzJdID09PSAncicpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cmV0dXJuIHsgYXBpOiAncmVkZGl0JywgdHlwZTogJ2NvbnRlbnQnLCBpZDogbWF0Y2hbMl0gfTtcblx0fVxufTtcblxudXJscy5yZXByZXNlbnQgPSBmdW5jdGlvbihpZGVudGl0eSwgY29tbWVudCkge1xuXHRzd2l0Y2ggKGlkZW50aXR5LnR5cGUpIHtcblx0XHRjYXNlICdjb250ZW50Jzpcblx0XHRcdHJldHVybiBbJ2h0dHBzOi8vd3d3LnJlZGRpdC5jb20nICsgKGlkZW50aXR5LnN1YnJlZGRpdCA/ICcvci8nICsgaWRlbnRpdHkuc3VicmVkZGl0IDogJycpICtcblx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9jb21tZW50cy8nICsgaWRlbnRpdHkuaWQgK1xuXHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXy5yZXN1bHQoY29tbWVudCwgJ2lkJykgPyAnL2NvbW1lbnQvJyArIGNvbW1lbnQuaWQgOiAnJyksICdodHRwczovL3JlZGQuaXQvJyArIGlkZW50aXR5LmlkXTtcblx0XHRjYXNlICdhY2NvdW50Jzpcblx0XHRcdHJldHVybiBbJ2h0dHBzOi8vd3d3LnJlZGRpdC5jb20vdXNlci8nICsgaWRlbnRpdHkuaWRdO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVybHM7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxudmFyIHVybHMgPSB7fTtcblxudXJscy5ob3N0bmFtZXNfcGFyc2VkID0gWydpbnN0YWdyYW0uY29tJywgJ3d3dy5pbnN0YWdyYW0uY29tJywgJ2luc3RhZ3IuYW0nXTtcblxudXJscy5wYXJzZSA9IGZ1bmN0aW9uKHVybF9vYmopIHtcblx0dmFyIHBhdGhfcGFydHMgPSB1cmxfb2JqLnBhdGhuYW1lLnJlcGxhY2UoL15cXC8vLCAnJykucmVwbGFjZSgvXFwvJC8sICcnKS5zcGxpdCgnLycpIHx8IFtdO1xuXHRpZiAocGF0aF9wYXJ0c1swXSA9PT0gJ3AnKSB7XG5cdFx0cmV0dXJuICFfLmlzRW1wdHkocGF0aF9wYXJ0c1sxXSkgJiYgeyBhcGk6ICdpbnN0YWdyYW0nLCB0eXBlOiAnY29udGVudCcsIGlkOiBwYXRoX3BhcnRzWzFdLnJlcGxhY2UoL1s/Jl0uKi8sICcnKS5zdWJzdHIoMCwgMTApIH07XG5cdH1cblx0cmV0dXJuICFfLmlzRW1wdHkocGF0aF9wYXJ0c1swXSkgJiZcblx0ICAgICAgICFwYXRoX3BhcnRzWzBdLm1hdGNoKC9eKD86YWJvdXR8ZGV2ZWxvcGVyfGV4cGxvcmV8bGVnYWx8cHJlc3MpJC8pICYmXG5cdCAgICAgICB7IGFwaTogJ2luc3RhZ3JhbScsIHR5cGU6ICdhY2NvdW50JywgaWQ6IHBhdGhfcGFydHNbMF0ucmVwbGFjZSgvWz8mXS4qLywgJycpIH07XG59O1xuXG51cmxzLnJlcHJlc2VudCA9IGZ1bmN0aW9uKGlkZW50aXR5KSB7XG5cdHN3aXRjaCAoaWRlbnRpdHkudHlwZSkge1xuXHRcdGNhc2UgJ2NvbnRlbnQnOlxuXHRcdFx0cmV0dXJuIFsnaHR0cHM6Ly9pbnN0YWdyYW0uY29tL3AvJyArIGlkZW50aXR5LmlkICsgJy8nLCAnaHR0cHM6Ly9pbnN0YWdyLmFtL3AvJyArIGlkZW50aXR5LmlkICsgJy8nXTtcblx0XHRjYXNlICdhY2NvdW50Jzpcblx0XHRcdHJldHVybiBbJ2h0dHBzOi8vaW5zdGFncmFtLmNvbS8nICsgaWRlbnRpdHkuaWQgKyAnLycsICdodHRwczovL2luc3RhZ3IuYW0vJyArIGlkZW50aXR5LmlkICsgJy8nXTtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1cmxzO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbnZhciB1cmxzID0ge307XG5cbnVybHMuaG9zdG5hbWVzX3BhcnNlZCA9IFsnaW1ndXIuY29tJywgJ3d3dy5pbWd1ci5jb20nLCAnaS5pbWd1ci5jb20nLCAnbS5pbWd1ci5jb20nXTtcblxudXJscy5wYXJzZSA9IGZ1bmN0aW9uKHVybF9vYmopIHtcblx0dmFyIHBhdGhfcGFydHMgPSB1cmxfb2JqLnBhdGhuYW1lLnJlcGxhY2UoL15cXC8vLCAnJykucmVwbGFjZSgvXFwvJC8sICcnKS5zcGxpdCgnLycpIHx8IFtdO1xuXHRzd2l0Y2ggKHBhdGhfcGFydHNbMF0pIHtcblx0XHRjYXNlICdhJzpcblx0XHRcdHJldHVybiAhXy5pc0VtcHR5KHBhdGhfcGFydHNbMV0pICYmIHsgYXBpOiAnaW1ndXInLCB0eXBlOiAnY29udGVudCcsIGlkOiBwYXRoX3BhcnRzWzFdLCBhczogJ2FsYnVtJyB9O1xuXHRcdGNhc2UgJ2dhbGxlcnknOlxuXHRcdFx0cmV0dXJuICFfLmlzRW1wdHkocGF0aF9wYXJ0c1sxXSkgJiYgeyBhcGk6ICdpbWd1cicsIHR5cGU6ICdjb250ZW50JywgaWQ6IHBhdGhfcGFydHNbMV0sIGFzOiAnZ2FsbGVyeScgfTtcblx0XHRjYXNlICd1c2VyJzpcblx0XHRcdHJldHVybiAhXy5pc0VtcHR5KHBhdGhfcGFydHNbMV0pICYmIHsgYXBpOiAnaW1ndXInLCB0eXBlOiAnYWNjb3VudCcsIGlkOiBwYXRoX3BhcnRzWzFdIH07XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiAhXy5pc0VtcHR5KHBhdGhfcGFydHNbMF0pICYmIHsgYXBpOiAnaW1ndXInLCB0eXBlOiAnY29udGVudCcsIGlkOiBwYXRoX3BhcnRzWzBdLnJlcGxhY2UoL1xcLi4rPyQvLCAnJyksIGFzOiAnaW1hZ2UnIH07XG5cdH1cbn07XG5cbnVybHMucmVwcmVzZW50ID0gZnVuY3Rpb24oaWRlbnRpdHksIGNvbW1lbnQpIHtcblx0c3dpdGNoIChpZGVudGl0eS50eXBlKSB7XG5cdFx0Y2FzZSAnY29udGVudCc6XG5cdFx0XHRyZXR1cm4gXy5jb21wYWN0KFtcblx0XHRcdFx0Xy5yZXN1bHQoY29tbWVudCwgJ2lkJykgJiYgKCdodHRwczovL2ltZ3VyLmNvbS9nYWxsZXJ5LycgKyBfLnJlc3VsdChpZGVudGl0eSwgJ2lkJykgKyAnL2NvbW1lbnQvJyArIGNvbW1lbnQuaWQpLFxuXHRcdFx0XHQoaWRlbnRpdHkuYXMgPT09ICdpbWFnZScpICYmICgnaHR0cHM6Ly9pbWd1ci5jb20vJyArIGlkZW50aXR5LmlkKSxcblx0XHRcdFx0KGlkZW50aXR5LmFzID09PSAnaW1hZ2UnKSAmJiAoJ2h0dHBzOi8vaS5pbWd1ci5jb20vJyArIGlkZW50aXR5LmlkKSxcblx0XHRcdFx0KGlkZW50aXR5LmFzID09PSAnYWxidW0nKSAmJiAoJ2h0dHBzOi8vaW1ndXIuY29tL2EvJyArIGlkZW50aXR5LmlkKSxcblx0XHRcdFx0J2h0dHBzOi8vaW1ndXIuY29tL2dhbGxlcnkvJyArIGlkZW50aXR5LmlkXG5cdFx0XHRdKTtcblx0XHRjYXNlICdhY2NvdW50Jzpcblx0XHRcdHJldHVybiBbJ2h0dHBzOi8vaW1ndXIuY29tL3VzZXIvJyArIGlkZW50aXR5LmlkXTtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1cmxzO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiBpc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIWlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnkgY29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgdGhlIHBhcnQgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhcyBub24gQVNDSUkgY2hhcmFjdGVycy4gSS5lLiBpdCBkb3NlbnQgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBpbiBBU0NJSS5cbiAgICAgIHZhciBkb21haW5BcnJheSA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgIHZhciBuZXdPdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9tYWluQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHMgPSBkb21haW5BcnJheVtpXTtcbiAgICAgICAgbmV3T3V0LnB1c2gocy5tYXRjaCgvW15BLVphLXowLTlfLV0vKSA/XG4gICAgICAgICAgICAneG4tLScgKyBwdW55Y29kZS5lbmNvZGUocykgOiBzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBuZXdPdXQuam9pbignLicpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAoaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKGlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICBPYmplY3Qua2V5cyh0aGlzKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICByZXN1bHRba10gPSB0aGlzW2tdO1xuICB9LCB0aGlzKTtcblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIE9iamVjdC5rZXlzKHJlbGF0aXZlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmIChrICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICB9KTtcblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICBPYmplY3Qua2V5cyhyZWxhdGl2ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfSk7XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCFpc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0KSAmJiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8XG4gICAgICBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiAgYXJnID09IG51bGw7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuMy4yIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjMuMicsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYyLjEuNFxuICogaHR0cDovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCAyMDA1LCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uLCBJbmMuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTUtMDQtMjhUMTY6MDFaXG4gKi9cblxuKGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59KHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gU3VwcG9ydDogRmlyZWZveCAxOCtcbi8vIENhbid0IGJlIGluIHN0cmljdCBtb2RlLCBzZXZlcmFsIGxpYnMgaW5jbHVkaW5nIEFTUC5ORVQgdHJhY2Vcbi8vIHRoZSBzdGFjayB2aWEgYXJndW1lbnRzLmNhbGxlci5jYWxsZWUgYW5kIEZpcmVmb3ggZGllcyBpZlxuLy8geW91IHRyeSB0byB0cmFjZSB0aHJvdWdoIFwidXNlIHN0cmljdFwiIGNhbGwgY2hhaW5zLiAoIzEzMzM1KVxuLy9cblxudmFyIGFyciA9IFtdO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxuXG5cbnZhclxuXHQvLyBVc2UgdGhlIGNvcnJlY3QgZG9jdW1lbnQgYWNjb3JkaW5nbHkgd2l0aCB3aW5kb3cgYXJndW1lbnQgKHNhbmRib3gpXG5cdGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LFxuXG5cdHZlcnNpb24gPSBcIjIuMS40XCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXG5cblx0Ly8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG5cdHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbXFxkYS16XSkvZ2ksXG5cblx0Ly8gVXNlZCBieSBqUXVlcnkuY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuXHRmY2FtZWxDYXNlID0gZnVuY3Rpb24oIGFsbCwgbGV0dGVyICkge1xuXHRcdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBTdGFydCB3aXRoIGFuIGVtcHR5IHNlbGVjdG9yXG5cdHNlbGVjdG9yOiBcIlwiLFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblx0XHRyZXR1cm4gbnVtICE9IG51bGwgP1xuXG5cdFx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0XHQoIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF0gKSA6XG5cblx0XHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRcdHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cdFx0cmV0LmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0Ly8gKFlvdSBjYW4gc2VlZCB0aGUgYXJndW1lbnRzIHdpdGggYW4gYXJyYXkgb2YgYXJncywgYnV0IHRoaXMgaXNcblx0Ly8gb25seSB1c2VkIGludGVybmFsbHkuKVxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjaywgYXJncyApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCh0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSkpO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbal0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IobnVsbCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbih0YXJnZXQpICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSkgIT0gbnVsbCApIHtcblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IGpRdWVyeS5pc0FycmF5KGNvcHkpKSApICkge1xuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoe1xuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc0Z1bmN0aW9uOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBqUXVlcnkudHlwZShvYmopID09PSBcImZ1bmN0aW9uXCI7XG5cdH0sXG5cblx0aXNBcnJheTogQXJyYXkuaXNBcnJheSxcblxuXHRpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9LFxuXG5cdGlzTnVtZXJpYzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAobnVsbHx0cnVlfGZhbHNlfFwiXCIpXG5cdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdC8vIGFkZGluZyAxIGNvcnJlY3RzIGxvc3Mgb2YgcHJlY2lzaW9uIGZyb20gcGFyc2VGbG9hdCAoIzE1MTAwKVxuXHRcdHJldHVybiAhalF1ZXJ5LmlzQXJyYXkoIG9iaiApICYmIChvYmogLSBwYXJzZUZsb2F0KCBvYmogKSArIDEpID49IDA7XG5cdH0sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHQvLyBOb3QgcGxhaW4gb2JqZWN0czpcblx0XHQvLyAtIEFueSBvYmplY3Qgb3IgdmFsdWUgd2hvc2UgaW50ZXJuYWwgW1tDbGFzc11dIHByb3BlcnR5IGlzIG5vdCBcIltvYmplY3QgT2JqZWN0XVwiXG5cdFx0Ly8gLSBET00gbm9kZXNcblx0XHQvLyAtIHdpbmRvd1xuXHRcdGlmICggalF1ZXJ5LnR5cGUoIG9iaiApICE9PSBcIm9iamVjdFwiIHx8IG9iai5ub2RlVHlwZSB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmICggb2JqLmNvbnN0cnVjdG9yICYmXG5cdFx0XHRcdCFoYXNPd24uY2FsbCggb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJpc1Byb3RvdHlwZU9mXCIgKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgZnVuY3Rpb24gaGFzbid0IHJldHVybmVkIGFscmVhZHksIHdlJ3JlIGNvbmZpZGVudCB0aGF0XG5cdFx0Ly8gfG9ianwgaXMgYSBwbGFpbiBvYmplY3QsIGNyZWF0ZWQgYnkge30gb3IgY29uc3RydWN0ZWQgd2l0aCBuZXcgT2JqZWN0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgbmFtZTtcblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0dHlwZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdFx0fVxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wLCBpT1M8NiAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKG9iaikgXSB8fCBcIm9iamVjdFwiIDpcblx0XHRcdHR5cGVvZiBvYmo7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUgKSB7XG5cdFx0dmFyIHNjcmlwdCxcblx0XHRcdGluZGlyZWN0ID0gZXZhbDtcblxuXHRcdGNvZGUgPSBqUXVlcnkudHJpbSggY29kZSApO1xuXG5cdFx0aWYgKCBjb2RlICkge1xuXHRcdFx0Ly8gSWYgdGhlIGNvZGUgaW5jbHVkZXMgYSB2YWxpZCwgcHJvbG9ndWUgcG9zaXRpb25cblx0XHRcdC8vIHN0cmljdCBtb2RlIHByYWdtYSwgZXhlY3V0ZSBjb2RlIGJ5IGluamVjdGluZyBhXG5cdFx0XHQvLyBzY3JpcHQgdGFnIGludG8gdGhlIGRvY3VtZW50LlxuXHRcdFx0aWYgKCBjb2RlLmluZGV4T2YoXCJ1c2Ugc3RyaWN0XCIpID09PSAxICkge1xuXHRcdFx0XHRzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuXHRcdFx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdC8vIE90aGVyd2lzZSwgYXZvaWQgdGhlIERPTSBub2RlIGNyZWF0aW9uLCBpbnNlcnRpb25cblx0XHRcdC8vIGFuZCByZW1vdmFsIGJ5IHVzaW5nIGFuIGluZGlyZWN0IGdsb2JhbCBldmFsXG5cdFx0XHRcdGluZGlyZWN0KCBjb2RlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcblx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHQvLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5cdGNhbWVsQ2FzZTogZnVuY3Rpb24oIHN0cmluZyApIHtcblx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcblx0fSxcblxuXHRub2RlTmFtZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdH0sXG5cblx0Ly8gYXJncyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjaywgYXJncyApIHtcblx0XHR2YXIgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGgsXG5cdFx0XHRpc0FycmF5ID0gaXNBcnJheWxpa2UoIG9iaiApO1xuXG5cdFx0aWYgKCBhcmdzICkge1xuXHRcdFx0aWYgKCBpc0FycmF5ICkge1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrLmFwcGx5KCBvYmpbIGkgXSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2suYXBwbHkoIG9ialsgaSBdLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQSBzcGVjaWFsLCBmYXN0LCBjYXNlIGZvciB0aGUgbW9zdCBjb21tb24gdXNlIG9mIGVhY2hcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBpc0FycmF5ICkge1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICk7XG5cblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjFcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheWxpa2UoIE9iamVjdChhcnIpICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGlzQXJyYXkgPSBpc0FycmF5bGlrZSggZWxlbXMgKSxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXkgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuXHQvLyBhcmd1bWVudHMuXG5cdHByb3h5OiBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdFx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRcdGNvbnRleHQgPSBmbjtcblx0XHRcdGZuID0gdG1wO1xuXHRcdH1cblxuXHRcdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdFx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdFx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHRcdH07XG5cblx0XHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0XHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRcdHJldHVybiBwcm94eTtcblx0fSxcblxuXHRub3c6IERhdGUubm93LFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59KTtcblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaChcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3JcIi5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKGksIG5hbWUpIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59KTtcblxuZnVuY3Rpb24gaXNBcnJheWxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiBpT1MgOC4yIChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXG5cdGlmICggdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBvYmoubm9kZVR5cGUgPT09IDEgJiYgbGVuZ3RoICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjIuMC1wcmVcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IDIwMDgsIDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24sIEluYy4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNC0xMi0xNlxuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gR2VuZXJhbC1wdXJwb3NlIGNvbnN0YW50c1xuXHRNQVhfTkVHQVRJVkUgPSAxIDw8IDMxLFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBXaGl0ZXNwYWNlIGNoYXJhY3RlcnMgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zeW50YXgvI2NoYXJhY3RlcnNcblx0Y2hhcmFjdGVyRW5jb2RpbmcgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcXFx4MDAtXFxcXHhhMF0pK1wiLFxuXG5cdC8vIExvb3NlbHkgbW9kZWxlZCBvbiBDU1MgaWRlbnRpZmllciBjaGFyYWN0ZXJzXG5cdC8vIEFuIHVucXVvdGVkIHZhbHVlIHNob3VsZCBiZSBhIENTUyBpZGVudGlmaWVyIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdC8vIFByb3BlciBzeW50YXg6IGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRpZGVudGlmaWVyID0gY2hhcmFjdGVyRW5jb2RpbmcucmVwbGFjZSggXCJ3XCIsIFwidyNcIiApLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cblx0cmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoIFwiPVwiICsgd2hpdGVzcGFjZSArIFwiKihbXlxcXFxdJ1xcXCJdKj8pXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIiwgXCJnXCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGNoYXJhY3RlckVuY29kaW5nLnJlcGxhY2UoIFwid1wiLCBcIncqXCIgKSArIFwiKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXHRyZXNjYXBlID0gLyd8XFxcXC9nLFxuXG5cdC8vIENTUyBlc2NhcGVzIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0ZXNjYXBlZCA6XG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbWF0Y2gsIGVsZW0sIG0sIG5vZGVUeXBlLFxuXHRcdC8vIFFTQSB2YXJzXG5cdFx0aSwgZ3JvdXBzLCBvbGQsIG5pZCwgbmV3Q29udGV4dCwgbmV3U2VsZWN0b3I7XG5cblx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cblx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXHRub2RlVHlwZSA9IGNvbnRleHQubm9kZVR5cGU7XG5cblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHRpZiAoICFzZWVkICYmIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyB3aGVuIHBvc3NpYmxlIChlLmcuLCBub3QgdW5kZXIgRG9jdW1lbnRGcmFnbWVudClcblx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXHRcdFx0Ly8gU3BlZWQtdXA6IFNpenpsZShcIiNJRFwiKVxuXHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApO1xuXHRcdFx0XHRcdC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXG5cdFx0XHRcdFx0Ly8gbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAoalF1ZXJ5ICM2OTYzKVxuXHRcdFx0XHRcdGlmICggZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgSUUsIE9wZXJhLCBhbmQgV2Via2l0IHJldHVybiBpdGVtc1xuXHRcdFx0XHRcdFx0Ly8gYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIENvbnRleHQgaXMgbm90IGEgZG9jdW1lbnRcblx0XHRcdFx0XHRpZiAoIGNvbnRleHQub3duZXJEb2N1bWVudCAmJiAoZWxlbSA9IGNvbnRleHQub3duZXJEb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJiBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gU3BlZWQtdXA6IFNpenpsZShcIlRBR1wiKVxuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXCIuQ0xBU1NcIilcblx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUVNBIHBhdGhcblx0XHRpZiAoIHN1cHBvcnQucXNhICYmICghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cdFx0XHRuaWQgPSBvbGQgPSBleHBhbmRvO1xuXHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cdFx0XHRuZXdTZWxlY3RvciA9IG5vZGVUeXBlICE9PSAxICYmIHNlbGVjdG9yO1xuXG5cdFx0XHQvLyBxU0Egd29ya3Mgc3RyYW5nZWx5IG9uIEVsZW1lbnQtcm9vdGVkIHF1ZXJpZXNcblx0XHRcdC8vIFdlIGNhbiB3b3JrIGFyb3VuZCB0aGlzIGJ5IHNwZWNpZnlpbmcgYW4gZXh0cmEgSUQgb24gdGhlIHJvb3Rcblx0XHRcdC8vIGFuZCB3b3JraW5nIHVwIGZyb20gdGhlcmUgKFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGUgdGVjaG5pcXVlKVxuXHRcdFx0Ly8gSUUgOCBkb2Vzbid0IHdvcmsgb24gb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRpZiAoIG5vZGVUeXBlID09PSAxICYmIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApIHtcblx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cblx0XHRcdFx0aWYgKCAob2xkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoXCJpZFwiKSkgKSB7XG5cdFx0XHRcdFx0bmlkID0gb2xkLnJlcGxhY2UoIHJlc2NhcGUsIFwiXFxcXCQmXCIgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCBuaWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuaWQgPSBcIltpZD0nXCIgKyBuaWQgKyBcIiddIFwiO1xuXG5cdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRncm91cHNbaV0gPSBuaWQgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dDtcblx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbihcIixcIik7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggbmV3U2VsZWN0b3IgKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH0gY2F0Y2gocXNhRXJyb3IpIHtcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRpZiAoICFvbGQgKSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7RnVuY3Rpb24oc3RyaW5nLCBPYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGRpdiBhbmQgZXhwZWN0cyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGRpdiApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZGl2LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZGl2ICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0KCB+Yi5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKSAtXG5cdFx0XHQoIH5hLnNvdXJjZUluZGV4IHx8IE1BWF9ORUdBVElWRSApO1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3Rcblx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXG5cdHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXHRyZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBwYXJlbnQsXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIElmIG5vIGRvY3VtZW50IGFuZCBkb2N1bWVudEVsZW1lbnQgaXMgYXZhaWxhYmxlLCByZXR1cm5cblx0aWYgKCBkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBTZXQgb3VyIGRvY3VtZW50XG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblx0cGFyZW50ID0gZG9jLmRlZmF1bHRWaWV3O1xuXG5cdC8vIFN1cHBvcnQ6IElFPjhcblx0Ly8gSWYgaWZyYW1lIGRvY3VtZW50IGlzIGFzc2lnbmVkIHRvIFwiZG9jdW1lbnRcIiB2YXJpYWJsZSBhbmQgaWYgaWZyYW1lIGhhcyBiZWVuIHJlbG9hZGVkLFxuXHQvLyBJRSB3aWxsIHRocm93IFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIGFjY2Vzc2luZyBcImRvY3VtZW50XCIgdmFyaWFibGUsIHNlZSBqUXVlcnkgIzEzOTM2XG5cdC8vIElFNi04IGRvIG5vdCBzdXBwb3J0IHRoZSBkZWZhdWx0VmlldyBwcm9wZXJ0eSBzbyBwYXJlbnQgd2lsbCBiZSB1bmRlZmluZWRcblx0aWYgKCBwYXJlbnQgJiYgcGFyZW50ICE9PSBwYXJlbnQudG9wICkge1xuXHRcdC8vIElFMTEgZG9lcyBub3QgaGF2ZSBhdHRhY2hFdmVudCwgc28gYWxsIG11c3Qgc3VmZmVyXG5cdFx0aWYgKCBwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHBhcmVudC5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXHRcdH0gZWxzZSBpZiAoIHBhcmVudC5hdHRhY2hFdmVudCApIHtcblx0XHRcdHBhcmVudC5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdFx0fVxuXHR9XG5cblx0LyogU3VwcG9ydCB0ZXN0c1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2MgKTtcblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZGl2LmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZGl2LmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZGl2LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXHRcdHJldHVybiAhZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2MuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZGl2ICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jLmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2MuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbmQgYW5kIGZpbHRlclxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0Ly8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcblx0XHRcdFx0Ly8gbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAjNjk2M1xuXHRcdFx0XHRyZXR1cm4gbSAmJiBtLnBhcmVudE5vZGUgPyBbIG0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdC8vIFN1cHBvcnQ6IElFNi83XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdGRlbGV0ZSBFeHByLmZpbmRbXCJJRFwiXTtcblxuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2MucXVlcnlTZWxlY3RvckFsbCApKSApIHtcblx0XHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0XHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBkaXYgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXGZdJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBkaXYucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC4yKywgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjcrXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBkaXYucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRkaXYucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGRpdiwgXCJkaXZcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGRpdiwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBkb2VzIG5vdCBpbXBsZW1lbnQgaW5jbHVzaXZlIGRlc2NlbmRlbnRcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdGlmICggYSA9PT0gZG9jIHx8IGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHRcdGlmICggYiA9PT0gZG9jIHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2MgPyAtMSA6XG5cdFx0XHRcdGIgPT09IGRvYyA/IDEgOlxuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cdFx0Y3VyID0gYjtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbaV0gPT09IGJwW2ldICkge1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpID9cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuXHRcdFx0YXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdDA7XG5cdH07XG5cblx0cmV0dXJuIGRvYztcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgZGlmZiwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gbm9kZVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBwYXJlbnRbIGV4cGFuZG8gXSB8fCAocGFyZW50WyBleHBhbmRvIF0gPSB7fSk7XG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gb3V0ZXJDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVswXSA9PT0gZGlycnVucyAmJiBjYWNoZVsxXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzJdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHVzZUNhY2hlICYmIChjYWNoZSA9IChlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KSlbIHR5cGUgXSkgJiYgY2FjaGVbMF0gPT09IGRpcnJ1bnMgKSB7XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBjYWNoZVsxXTtcblxuXHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKSBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6IG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJiArK2RpZmYgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQobm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSkpWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBmYWxzZTtcblx0XHR9LFxuXG5cdFx0XCJkaXNhYmxlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGRpciA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBkaXIgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cdFx0XHRcdFx0XHRpZiAoIChvbGRDYWNoZSA9IG91dGVyQ2FjaGVbIGRpciBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlWyBkaXIgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWzBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoZWxlbSA9IHRlbXBbaV0pICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbaV0gXSA9ICEobWF0Y2hlckluWyBwb3N0TWFwW2ldIF0gPSBlbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJlxuXHRcdFx0XHRcdFx0KHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIG91dGVybW9zdCApLFxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgIT09IGRvY3VtZW50ICYmIGNvbnRleHQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBLZWVwIGBpYCBhIHN0cmluZyBpZiB0aGVyZSBhcmUgbm8gZWxlbWVudHMgc28gYG1hdGNoZWRDb3VudGAgd2lsbCBiZSBcIjAwXCIgYmVsb3dcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0fTtcblxuXHRyZXR1cm4gYnlTZXQgP1xuXHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdHN1cGVyTWF0Y2hlcjtcbn1cblxuY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFtpXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoIChzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG5vIHNlZWQgYW5kIG9ubHkgb25lIGdyb3VwXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gVGFrZSBhIHNob3J0Y3V0IGFuZCBzZXQgdGhlIGNvbnRleHQgaWYgdGhlIHJvb3Qgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRzdXBwb3J0LmdldEJ5SWQgJiYgY29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdFx0XHRFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHRyc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdjEgKSB7XG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZGl2MS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSApICYgMTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdGRpdi5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiIDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdGRpdi5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGRpdi5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdHJldHVybiBkaXYuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHZhbDtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0pO1xufVxuXG5yZXR1cm4gU2l6emxlO1xuXG59KSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcbmpRdWVyeS5leHByW1wiOlwiXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xuXG5cblxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cbnZhciByc2luZ2xlVGFnID0gKC9ePChcXHcrKVxccypcXC8/Pig/OjxcXC9cXDE+fCkkLyk7XG5cblxuXG52YXIgcmlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvO1xuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSk7XG5cblx0fVxuXG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9KTtcblxuXHR9XG5cblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyID09PSBcInN0cmluZ1wiICkge1xuXHRcdGlmICggcmlzU2ltcGxlLnRlc3QoIHF1YWxpZmllciApICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xuXHRcdH1cblxuXHRcdHF1YWxpZmllciA9IGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMgKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPj0gMCApICE9PSBub3Q7XG5cdH0pO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0cmV0dXJuIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxID9cblx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW10gOlxuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0XHR9KSk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KSApO1xuXHRcdH1cblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0Ly8gTmVlZGVkIGJlY2F1c2UgJCggc2VsZWN0b3IsIGNvbnRleHQgKSBiZWNvbWVzICQoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlKCByZXQgKSA6IHJldCApO1xuXHRcdHJldC5zZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IgPyB0aGlzLnNlbGVjdG9yICsgXCIgXCIgKyBzZWxlY3RvciA6IHNlbGVjdG9yO1xuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3codGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUpICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0qKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWzBdID09PSBcIjxcIiAmJiBzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJiBzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmIChtYXRjaFsxXSB8fCAhY29udGV4dCkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbMV0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WzBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbMV0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbMV0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbMl0gKTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEJsYWNrYmVycnkgNC42XG5cdFx0XHRcdFx0Ly8gZ0VCSUQgcmV0dXJucyBub2RlcyBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICgjNjk2Mylcblx0XHRcdFx0XHRpZiAoIGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHRcdHRoaXNbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuY29udGV4dCA9IGRvY3VtZW50O1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdGpRdWVyeSApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXMuY29udGV4dCA9IHRoaXNbMF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiByb290alF1ZXJ5LnJlYWR5ICE9PSBcInVuZGVmaW5lZFwiID9cblx0XHRcdFx0cm9vdGpRdWVyeS5yZWFkeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3Iuc2VsZWN0b3IgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuc2VsZWN0b3IgPSBzZWxlY3Rvci5zZWxlY3Rvcjtcblx0XHRcdHRoaXMuY29udGV4dCA9IHNlbGVjdG9yLmNvbnRleHQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdH07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xuXG5cbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdGRpcjogZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1hdGNoZWQ7XG5cdH0sXG5cblx0c2libGluZzogZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRcdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZWQ7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbaV0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0cG9zID0gcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSB8fCB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvcnMsIGNvbnRleHQgfHwgdGhpcy5jb250ZXh0ICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0Zm9yICggY3VyID0gdGhpc1tpXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmIChwb3MgP1xuXHRcdFx0XHRcdHBvcy5pbmRleChjdXIpID4gLTEgOlxuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXG5cdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoY3VyLCBzZWxlY3RvcnMpKSApIHtcblxuXHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWUoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZShcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKHNlbGVjdG9yKVxuXHRcdCk7XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoY3VyID0gY3VyW2Rpcl0pICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuc2libGluZyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnNpYmxpbmcoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50IHx8IGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlKCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSk7XG52YXIgcm5vdHdoaXRlID0gKC9cXFMrL2cpO1xuXG5cblxuLy8gU3RyaW5nIHRvIE9iamVjdCBvcHRpb25zIGZvcm1hdCBjYWNoZVxudmFyIG9wdGlvbnNDYWNoZSA9IHt9O1xuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lcyBhbmQgc3RvcmUgaW4gY2FjaGVcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSBvcHRpb25zQ2FjaGVbIG9wdGlvbnMgXSA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0KCBvcHRpb25zQ2FjaGVbIG9wdGlvbnMgXSB8fCBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gTGFzdCBmaXJlIHZhbHVlIChmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzKVxuXHRcdG1lbW9yeSxcblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cdFx0Ly8gRmlyc3QgY2FsbGJhY2sgdG8gZmlyZSAodXNlZCBpbnRlcm5hbGx5IGJ5IGFkZCBhbmQgZmlyZVdpdGgpXG5cdFx0ZmlyaW5nU3RhcnQsXG5cdFx0Ly8gRW5kIG9mIHRoZSBsb29wIHdoZW4gZmlyaW5nXG5cdFx0ZmlyaW5nTGVuZ3RoLFxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IHJlbW92ZSBpZiBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXgsXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cdFx0Ly8gU3RhY2sgb2YgZmlyZSBjYWxscyBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHN0YWNrID0gIW9wdGlvbnMub25jZSAmJiBbXSxcblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdG1lbW9yeSA9IG9wdGlvbnMubWVtb3J5ICYmIGRhdGE7XG5cdFx0XHRmaXJlZCA9IHRydWU7XG5cdFx0XHRmaXJpbmdJbmRleCA9IGZpcmluZ1N0YXJ0IHx8IDA7XG5cdFx0XHRmaXJpbmdTdGFydCA9IDA7XG5cdFx0XHRmaXJpbmdMZW5ndGggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IGxpc3QgJiYgZmlyaW5nSW5kZXggPCBmaXJpbmdMZW5ndGg7IGZpcmluZ0luZGV4KysgKSB7XG5cdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggZGF0YVsgMCBdLCBkYXRhWyAxIF0gKSA9PT0gZmFsc2UgJiYgb3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTsgLy8gVG8gcHJldmVudCBmdXJ0aGVyIGNhbGxzIHVzaW5nIGFkZFxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0aWYgKCBzdGFjayApIHtcblx0XHRcdFx0XHRpZiAoIHN0YWNrLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGZpcmUoIHN0YWNrLnNoaWZ0KCkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VsZi5kaXNhYmxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHQvLyBGaXJzdCwgd2Ugc2F2ZSB0aGUgY3VycmVudCBsZW5ndGhcblx0XHRcdFx0XHR2YXIgc3RhcnQgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHQoZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHQvLyBEbyB3ZSBuZWVkIHRvIGFkZCB0aGUgY2FsbGJhY2tzIHRvIHRoZVxuXHRcdFx0XHRcdC8vIGN1cnJlbnQgZmlyaW5nIGJhdGNoP1xuXHRcdFx0XHRcdGlmICggZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nTGVuZ3RoID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0Ly8gV2l0aCBtZW1vcnksIGlmIHdlJ3JlIG5vdCBmaXJpbmcgdGhlblxuXHRcdFx0XHRcdC8vIHdlIHNob3VsZCBjYWxsIHJpZ2h0IGF3YXlcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdTdGFydCA9IHN0YXJ0O1xuXHRcdFx0XHRcdFx0ZmlyZSggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdFx0aWYgKCBmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdMZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmaXJpbmdMZW5ndGgtLTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/IGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOiAhISggbGlzdCAmJiBsaXN0Lmxlbmd0aCApO1xuXHRcdFx0fSxcblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHRmaXJpbmdMZW5ndGggPSAwO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBIYXZlIHRoZSBsaXN0IGRvIG5vdGhpbmcgYW55bW9yZVxuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxpc3QgPSBzdGFjayA9IG1lbW9yeSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gSXMgaXQgZGlzYWJsZWQ/XG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cdFx0XHQvLyBMb2NrIHRoZSBsaXN0IGluIGl0cyBjdXJyZW50IHN0YXRlXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c3RhY2sgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdGlmICggIW1lbW9yeSApIHtcblx0XHRcdFx0XHRzZWxmLmRpc2FibGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBJcyBpdCBsb2NrZWQ/XG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIXN0YWNrO1xuXHRcdFx0fSxcblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCBsaXN0ICYmICggIWZpcmVkIHx8IHN0YWNrICkgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRpZiAoIGZpcmluZyApIHtcblx0XHRcdFx0XHRcdHN0YWNrLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZmlyZSggYXJncyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxualF1ZXJ5LmV4dGVuZCh7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBsaXN0ZW5lciBsaXN0LCBmaW5hbCBzdGF0ZVxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCBcInJlamVjdGVkXCIgXSxcblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoXCJtZW1vcnlcIikgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0galF1ZXJ5LmlzRnVuY3Rpb24oIGZuc1sgaSBdICkgJiYgZm5zWyBpIF07XG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkWyBkb25lIHwgZmFpbCB8IHByb2dyZXNzIF0gZm9yIGZvcndhcmRpbmcgYWN0aW9ucyB0byBuZXdEZWZlclxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbMV0gXShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gcHJvbWlzZSA/IG5ld0RlZmVyLnByb21pc2UoKSA6IHRoaXMsIGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9KS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0cHJvbWlzZS5waXBlID0gcHJvbWlzZS50aGVuO1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgMyBdO1xuXG5cdFx0XHQvLyBwcm9taXNlWyBkb25lIHwgZmFpbCB8IHByb2dyZXNzIF0gPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbMV0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdC8vIHN0YXRlID0gWyByZXNvbHZlZCB8IHJlamVjdGVkIF1cblx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXG5cdFx0XHRcdC8vIFsgcmVqZWN0X2xpc3QgfCByZXNvbHZlX2xpc3QgXS5kaXNhYmxlOyBwcm9ncmVzc19saXN0LmxvY2tcblx0XHRcdFx0fSwgdHVwbGVzWyBpIF4gMSBdWyAyIF0uZGlzYWJsZSwgdHVwbGVzWyAyIF1bIDIgXS5sb2NrICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGRlZmVycmVkWyByZXNvbHZlIHwgcmVqZWN0IHwgbm90aWZ5IF1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVswXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVswXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gcHJvbWlzZSA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbMF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9KTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHN1Ym9yZGluYXRlIC8qICwgLi4uLCBzdWJvcmRpbmF0ZU4gKi8gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXHRcdFx0bGVuZ3RoID0gcmVzb2x2ZVZhbHVlcy5sZW5ndGgsXG5cblx0XHRcdC8vIHRoZSBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGxlbmd0aCAhPT0gMSB8fCAoIHN1Ym9yZGluYXRlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBzdWJvcmRpbmF0ZS5wcm9taXNlICkgKSA/IGxlbmd0aCA6IDAsXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWQuIElmIHJlc29sdmVWYWx1ZXMgY29uc2lzdCBvZiBvbmx5IGEgc2luZ2xlIERlZmVycmVkLCBqdXN0IHVzZSB0aGF0LlxuXHRcdFx0ZGVmZXJyZWQgPSByZW1haW5pbmcgPT09IDEgPyBzdWJvcmRpbmF0ZSA6IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBVcGRhdGUgZnVuY3Rpb24gZm9yIGJvdGggcmVzb2x2ZSBhbmQgcHJvZ3Jlc3MgdmFsdWVzXG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGksIGNvbnRleHRzLCB2YWx1ZXMgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0Y29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0dmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZXMgPT09IHByb2dyZXNzVmFsdWVzICkge1xuXHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cblx0XHRcdHByb2dyZXNzVmFsdWVzLCBwcm9ncmVzc0NvbnRleHRzLCByZXNvbHZlQ29udGV4dHM7XG5cblx0XHQvLyBBZGQgbGlzdGVuZXJzIHRvIERlZmVycmVkIHN1Ym9yZGluYXRlczsgdHJlYXQgb3RoZXJzIGFzIHJlc29sdmVkXG5cdFx0aWYgKCBsZW5ndGggPiAxICkge1xuXHRcdFx0cHJvZ3Jlc3NWYWx1ZXMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0cHJvZ3Jlc3NDb250ZXh0cyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlKClcblx0XHRcdFx0XHRcdC5kb25lKCB1cGRhdGVGdW5jKCBpLCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKSApXG5cdFx0XHRcdFx0XHQuZmFpbCggZGVmZXJyZWQucmVqZWN0IClcblx0XHRcdFx0XHRcdC5wcm9ncmVzcyggdXBkYXRlRnVuYyggaSwgcHJvZ3Jlc3NDb250ZXh0cywgcHJvZ3Jlc3NWYWx1ZXMgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC0tcmVtYWluaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UncmUgbm90IHdhaXRpbmcgb24gYW55dGhpbmcsIHJlc29sdmUgdGhlIG1hc3RlclxuXHRcdGlmICggIXJlbWFpbmluZyApIHtcblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuXHR9XG59KTtcblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3Q7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0Ly8gQWRkIHRoZSBjYWxsYmFja1xuXHRqUXVlcnkucmVhZHkucHJvbWlzZSgpLmRvbmUoIGZuICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSG9sZCAob3IgcmVsZWFzZSkgdGhlIHJlYWR5IGV2ZW50XG5cdGhvbGRSZWFkeTogZnVuY3Rpb24oIGhvbGQgKSB7XG5cdFx0aWYgKCBob2xkICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXG5cdFx0Ly8gVHJpZ2dlciBhbnkgYm91bmQgcmVhZHkgZXZlbnRzXG5cdFx0aWYgKCBqUXVlcnkuZm4udHJpZ2dlckhhbmRsZXIgKSB7XG5cdFx0XHRqUXVlcnkoIGRvY3VtZW50ICkudHJpZ2dlckhhbmRsZXIoIFwicmVhZHlcIiApO1xuXHRcdFx0alF1ZXJ5KCBkb2N1bWVudCApLm9mZiggXCJyZWFkeVwiICk7XG5cdFx0fVxuXHR9XG59KTtcblxuLyoqXG4gKiBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuICovXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQsIGZhbHNlICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkLCBmYWxzZSApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxualF1ZXJ5LnJlYWR5LnByb21pc2UgPSBmdW5jdGlvbiggb2JqICkge1xuXHRpZiAoICFyZWFkeUxpc3QgKSB7XG5cblx0XHRyZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxuXHRcdC8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuXHRcdC8vIFdlIG9uY2UgdHJpZWQgdG8gdXNlIHJlYWR5U3RhdGUgXCJpbnRlcmFjdGl2ZVwiIGhlcmUsIGJ1dCBpdCBjYXVzZWQgaXNzdWVzIGxpa2UgdGhlIG9uZVxuXHRcdC8vIGRpc2NvdmVyZWQgYnkgQ2hyaXNTIGhlcmU6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMjgyI2NvbW1lbnQ6MTVcblx0XHRpZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiApIHtcblx0XHRcdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHRcdFx0c2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkLCBmYWxzZSApO1xuXG5cdFx0XHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQsIGZhbHNlICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZWFkeUxpc3QucHJvbWlzZSggb2JqICk7XG59O1xuXG4vLyBLaWNrIG9mZiB0aGUgRE9NIHJlYWR5IGNoZWNrIGV2ZW4gaWYgdGhlIHVzZXIgZG9lcyBub3RcbmpRdWVyeS5yZWFkeS5wcm9taXNlKCk7XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0galF1ZXJ5LmFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIGpRdWVyeS50eXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0alF1ZXJ5LmFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbaV0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKCBlbGVtc1tpXSwga2V5LCByYXcgPyB2YWx1ZSA6IHZhbHVlLmNhbGwoIGVsZW1zW2ldLCBpLCBmbiggZWxlbXNbaV0sIGtleSApICkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2hhaW5hYmxlID9cblx0XHRlbGVtcyA6XG5cblx0XHQvLyBHZXRzXG5cdFx0YnVsayA/XG5cdFx0XHRmbi5jYWxsKCBlbGVtcyApIDpcblx0XHRcdGxlbiA/IGZuKCBlbGVtc1swXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG5cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gb2JqZWN0IGNhbiBoYXZlIGRhdGFcbiAqL1xualF1ZXJ5LmFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHQvKiBqc2hpbnQgLVcwMTggKi9cblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQsXG5cdC8vIE9sZCBXZWJLaXQgZG9lcyBub3QgaGF2ZSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMvZnJlZXplIG1ldGhvZCxcblx0Ly8gcmV0dXJuIG5ldyBlbXB0eSBvYmplY3QgaW5zdGVhZCB3aXRoIG5vIFtbc2V0XV0gYWNjZXNzb3Jcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLmNhY2hlID0ge30sIDAsIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHt9O1xuXHRcdH1cblx0fSk7XG5cblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5EYXRhLmFjY2VwdHMgPSBqUXVlcnkuYWNjZXB0RGF0YTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cdGtleTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0Ly8gQWx3YXlzIHJldHVybiB0aGUga2V5IGZvciBhIGZyb3plbiBvYmplY3QuXG5cdFx0aWYgKCAhRGF0YS5hY2NlcHRzKCBvd25lciApICkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGRlc2NyaXB0b3IgPSB7fSxcblx0XHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZSBrZXlcblx0XHRcdHVubG9jayA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXVubG9jayApIHtcblx0XHRcdHVubG9jayA9IERhdGEudWlkKys7XG5cblx0XHRcdC8vIFNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlLCBub24td3JpdGFibGUgcHJvcGVydHlcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRlc2NyaXB0b3JbIHRoaXMuZXhwYW5kbyBdID0geyB2YWx1ZTogdW5sb2NrIH07XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBvd25lciwgZGVzY3JpcHRvciApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDRcblx0XHRcdC8vIEZhbGxiYWNrIHRvIGEgbGVzcyBzZWN1cmUgZGVmaW5pdGlvblxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdGRlc2NyaXB0b3JbIHRoaXMuZXhwYW5kbyBdID0gdW5sb2NrO1xuXHRcdFx0XHRqUXVlcnkuZXh0ZW5kKCBvd25lciwgZGVzY3JpcHRvciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0aWYgKCAhdGhpcy5jYWNoZVsgdW5sb2NrIF0gKSB7XG5cdFx0XHR0aGlzLmNhY2hlWyB1bmxvY2sgXSA9IHt9O1xuXHRcdH1cblxuXHRcdHJldHVybiB1bmxvY2s7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdC8vIFRoZXJlIG1heSBiZSBhbiB1bmxvY2sgYXNzaWduZWQgdG8gdGhpcyBub2RlLFxuXHRcdFx0Ly8gaWYgdGhlcmUgaXMgbm8gZW50cnkgZm9yIHRoaXMgXCJvd25lclwiLCBjcmVhdGUgb25lIGlubGluZVxuXHRcdFx0Ly8gYW5kIHNldCB0aGUgdW5sb2NrIGFzIHRob3VnaCBhbiBvd25lciBlbnRyeSBoYWQgYWx3YXlzIGV4aXN0ZWRcblx0XHRcdHVubG9jayA9IHRoaXMua2V5KCBvd25lciApLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlWyB1bmxvY2sgXTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Y2FjaGVbIGRhdGEgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRnJlc2ggYXNzaWdubWVudHMgYnkgb2JqZWN0IGFyZSBzaGFsbG93IGNvcGllZFxuXHRcdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblx0XHRcdFx0alF1ZXJ5LmV4dGVuZCggdGhpcy5jYWNoZVsgdW5sb2NrIF0sIGRhdGEgKTtcblx0XHRcdC8vIE90aGVyd2lzZSwgY29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0XHRjYWNoZVsgcHJvcCBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHQvLyBFaXRoZXIgYSB2YWxpZCBjYWNoZSBpcyBmb3VuZCwgb3Igd2lsbCBiZSBjcmVhdGVkLlxuXHRcdC8vIE5ldyBjYWNoZXMgd2lsbCBiZSBjcmVhdGVkIGFuZCB0aGUgdW5sb2NrIHJldHVybmVkLFxuXHRcdC8vIGFsbG93aW5nIGRpcmVjdCBhY2Nlc3MgdG8gdGhlIG5ld2x5IGNyZWF0ZWRcblx0XHQvLyBlbXB0eSBkYXRhIG9iamVjdC4gQSB2YWxpZCBvd25lciBvYmplY3QgbXVzdCBiZSBwcm92aWRlZC5cblx0XHR2YXIgY2FjaGUgPSB0aGlzLmNhY2hlWyB0aGlzLmtleSggb3duZXIgKSBdO1xuXG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdGNhY2hlIDogY2FjaGVbIGtleSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgc3RvcmVkO1xuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCgoa2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIpICYmIHZhbHVlID09PSB1bmRlZmluZWQpICkge1xuXG5cdFx0XHRzdG9yZWQgPSB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXG5cdFx0XHRyZXR1cm4gc3RvcmVkICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRzdG9yZWQgOiB0aGlzLmdldCggb3duZXIsIGpRdWVyeS5jYW1lbENhc2Uoa2V5KSApO1xuXHRcdH1cblxuXHRcdC8vIFsqXVdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSwgbmFtZSwgY2FtZWwsXG5cdFx0XHR1bmxvY2sgPSB0aGlzLmtleSggb3duZXIgKSxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZVsgdW5sb2NrIF07XG5cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5jYWNoZVsgdW5sb2NrIF0gPSB7fTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSgga2V5ICkgKSB7XG5cdFx0XHRcdC8vIElmIFwibmFtZVwiIGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2hlbiBkYXRhIGlzIGluaXRpYWxseSBjcmVhdGVkLCB2aWEgKFwia2V5XCIsIFwidmFsXCIpIHNpZ25hdHVyZSxcblx0XHRcdFx0Ly8ga2V5cyB3aWxsIGJlIGNvbnZlcnRlZCB0byBjYW1lbENhc2UuXG5cdFx0XHRcdC8vIFNpbmNlIHRoZXJlIGlzIG5vIHdheSB0byB0ZWxsIF9ob3dfIGEga2V5IHdhcyBhZGRlZCwgcmVtb3ZlXG5cdFx0XHRcdC8vIGJvdGggcGxhaW4ga2V5IGFuZCBjYW1lbENhc2Uga2V5LiAjMTI3ODZcblx0XHRcdFx0Ly8gVGhpcyB3aWxsIG9ubHkgcGVuYWxpemUgdGhlIGFycmF5IGFyZ3VtZW50IHBhdGguXG5cdFx0XHRcdG5hbWUgPSBrZXkuY29uY2F0KCBrZXkubWFwKCBqUXVlcnkuY2FtZWxDYXNlICkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhbWVsID0galF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICk7XG5cdFx0XHRcdC8vIFRyeSB0aGUgc3RyaW5nIGFzIGEga2V5IGJlZm9yZSBhbnkgbWFuaXB1bGF0aW9uXG5cdFx0XHRcdGlmICgga2V5IGluIGNhY2hlICkge1xuXHRcdFx0XHRcdG5hbWUgPSBbIGtleSwgY2FtZWwgXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRuYW1lID0gY2FtZWw7XG5cdFx0XHRcdFx0bmFtZSA9IG5hbWUgaW4gY2FjaGUgP1xuXHRcdFx0XHRcdFx0WyBuYW1lIF0gOiAoIG5hbWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aSA9IG5hbWUubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsgbmFtZVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0cmV0dXJuICFqUXVlcnkuaXNFbXB0eU9iamVjdChcblx0XHRcdHRoaXMuY2FjaGVbIG93bmVyWyB0aGlzLmV4cGFuZG8gXSBdIHx8IHt9XG5cdFx0KTtcblx0fSxcblx0ZGlzY2FyZDogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdGlmICggb3duZXJbIHRoaXMuZXhwYW5kbyBdICkge1xuXHRcdFx0ZGVsZXRlIHRoaXMuY2FjaGVbIG93bmVyWyB0aGlzLmV4cGFuZG8gXSBdO1xuXHRcdH1cblx0fVxufTtcbnZhciBkYXRhX3ByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YV91c2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC8oW0EtWl0pL2c7XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kMVwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZGF0YSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcImZhbHNlXCIgPyBmYWxzZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJudWxsXCIgPyBudWxsIDpcblx0XHRcdFx0XHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRcdFx0XHRcdCtkYXRhICsgXCJcIiA9PT0gZGF0YSA/ICtkYXRhIDpcblx0XHRcdFx0XHRyYnJhY2UudGVzdCggZGF0YSApID8galF1ZXJ5LnBhcnNlSlNPTiggZGF0YSApIDpcblx0XHRcdFx0XHRkYXRhO1xuXHRcdFx0fSBjYXRjaCggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YV91c2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFfdXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YV9wcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YV91c2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFfdXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhX3ByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YV9wcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhX3ByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YV91c2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YV9wcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFMTErXG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lLnNsaWNlKDUpICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFfcHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFfdXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGEsXG5cdFx0XHRcdGNhbWVsS2V5ID0galF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyB3aXRoIHRoZSBrZXkgYXMtaXNcblx0XHRcdFx0ZGF0YSA9IGRhdGFfdXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gd2l0aCB0aGUga2V5IGNhbWVsaXplZFxuXHRcdFx0XHRkYXRhID0gZGF0YV91c2VyLmdldCggZWxlbSwgY2FtZWxLZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwgY2FtZWxLZXksIHVuZGVmaW5lZCApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gRmlyc3QsIGF0dGVtcHQgdG8gc3RvcmUgYSBjb3B5IG9yIHJlZmVyZW5jZSBvZiBhbnlcblx0XHRcdFx0Ly8gZGF0YSB0aGF0IG1pZ2h0J3ZlIGJlZW4gc3RvcmUgd2l0aCBhIGNhbWVsQ2FzZWQga2V5LlxuXHRcdFx0XHR2YXIgZGF0YSA9IGRhdGFfdXNlci5nZXQoIHRoaXMsIGNhbWVsS2V5ICk7XG5cblx0XHRcdFx0Ly8gRm9yIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGUgaW50ZXJvcCwgd2UgaGF2ZSB0b1xuXHRcdFx0XHQvLyBzdG9yZSBwcm9wZXJ0eSBuYW1lcyB3aXRoIGRhc2hlcyBpbiBhIGNhbWVsQ2FzZSBmb3JtLlxuXHRcdFx0XHQvLyBUaGlzIG1pZ2h0IG5vdCBhcHBseSB0byBhbGwgcHJvcGVydGllcy4uLipcblx0XHRcdFx0ZGF0YV91c2VyLnNldCggdGhpcywgY2FtZWxLZXksIHZhbHVlICk7XG5cblx0XHRcdFx0Ly8gKi4uLiBJbiB0aGUgY2FzZSBvZiBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgX2FjdHVhbGx5X1xuXHRcdFx0XHQvLyBoYXZlIGRhc2hlcywgd2UgbmVlZCB0byBhbHNvIHN0b3JlIGEgY29weSBvZiB0aGF0XG5cdFx0XHRcdC8vIHVuY2hhbmdlZCBwcm9wZXJ0eS5cblx0XHRcdFx0aWYgKCBrZXkuaW5kZXhPZihcIi1cIikgIT09IC0xICYmIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRkYXRhX3VzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFfdXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0pO1xuXHR9XG59KTtcblxuXG5qUXVlcnkuZXh0ZW5kKHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFfcHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBqUXVlcnkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YV9wcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheShkYXRhKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhX3ByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhX3ByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIikuYWRkKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhX3ByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9KVxuXHRcdH0pO1xuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWzBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbMF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9KTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFfcHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0pO1xudmFyIHBudW0gPSAoL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8pLnNvdXJjZTtcblxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG52YXIgaXNIaWRkZW4gPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cdFx0Ly8gaXNIaWRkZW4gbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCIgfHwgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cdH07XG5cbnZhciByY2hlY2thYmxlVHlwZSA9ICgvXig/OmNoZWNrYm94fHJhZGlvKSQvaSk7XG5cblxuXG4oZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBTYWZhcmk8PTUuMVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogU2FmYXJpPD01LjEsIEFuZHJvaWQ8NC4yXG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUU8PTExK1xuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xufSkoKTtcbnZhciBzdHJ1bmRlZmluZWQgPSB0eXBlb2YgdW5kZWZpbmVkO1xuXG5cblxuc3VwcG9ydC5mb2N1c2luQnViYmxlcyA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbnZhclxuXHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51KXxjbGljay8sXG5cdHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KSQvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhX3ByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggIShldmVudHMgPSBlbGVtRGF0YS5ldmVudHMpICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggIShldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBzdHJ1bmRlZmluZWQgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzW3RdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbMV07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbMl0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCh7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKFwiLlwiKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggIShoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fCBzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSwgZmFsc2UgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhX3ByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFfcHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzW3RdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbMV07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbMl0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWzJdICYmIG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHwgc3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGVsZXRlIGVsZW1EYXRhLmhhbmRsZTtcblx0XHRcdGRhdGFfcHJpdi5yZW1vdmUoIGVsZW0sIFwiZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KFwiLlwiKSA6IFtdO1xuXG5cdFx0Y3VyID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZihcIi5cIikgPj0gMCApIHtcblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KFwiLlwiKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKFwiOlwiKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKFwiLlwiKTtcblx0XHRldmVudC5uYW1lc3BhY2VfcmUgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoY3VyID0gZXZlbnRQYXRoW2krK10pICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhX3ByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiYgZGF0YV9wcml2LmdldCggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGpRdWVyeS5hY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoIXNwZWNpYWwuX2RlZmF1bHQgfHwgc3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlKSAmJlxuXHRcdFx0XHRqUXVlcnkuYWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHRldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICk7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblx0XHRcdGhhbmRsZXJzID0gKCBkYXRhX3ByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbMF0gPSBldmVudDtcblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoIChtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdKSAmJiAhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yIDIpIGhhdmUgbmFtZXNwYWNlKHMpXG5cdFx0XHRcdC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuXHRcdFx0XHRpZiAoICFldmVudC5uYW1lc3BhY2VfcmUgfHwgZXZlbnQubmFtZXNwYWNlX3JlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoIChqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30pLmhhbmRsZSB8fCBoYW5kbGVPYmouaGFuZGxlciApXG5cdFx0XHRcdFx0XHRcdC5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZXZlbnQucmVzdWx0ID0gcmV0KSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBtYXRjaGVzLCBzZWwsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKCMxMzE4MClcblx0XHQvLyBBdm9pZCBub24tbGVmdC1jbGljayBidWJibGluZyBpbiBGaXJlZm94ICgjMzg2MSlcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiYgY3VyLm5vZGVUeXBlICYmICghZXZlbnQuYnV0dG9uIHx8IGV2ZW50LnR5cGUgIT09IFwiY2xpY2tcIikgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5kaXNhYmxlZCAhPT0gdHJ1ZSB8fCBldmVudC50eXBlICE9PSBcImNsaWNrXCIgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlcyA9IFtdO1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZXNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPj0gMCA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZXMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCh7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZXMgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKHsgZWxlbTogdGhpcywgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHQvLyBJbmNsdWRlcyBzb21lIGV2ZW50IHByb3BzIHNoYXJlZCBieSBLZXlFdmVudCBhbmQgTW91c2VFdmVudFxuXHRwcm9wczogXCJhbHRLZXkgYnViYmxlcyBjYW5jZWxhYmxlIGN0cmxLZXkgY3VycmVudFRhcmdldCBldmVudFBoYXNlIG1ldGFLZXkgcmVsYXRlZFRhcmdldCBzaGlmdEtleSB0YXJnZXQgdGltZVN0YW1wIHZpZXcgd2hpY2hcIi5zcGxpdChcIiBcIiksXG5cblx0Zml4SG9va3M6IHt9LFxuXG5cdGtleUhvb2tzOiB7XG5cdFx0cHJvcHM6IFwiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZVwiLnNwbGl0KFwiIFwiKSxcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBldmVudCwgb3JpZ2luYWwgKSB7XG5cblx0XHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9IG9yaWdpbmFsLmNoYXJDb2RlICE9IG51bGwgPyBvcmlnaW5hbC5jaGFyQ29kZSA6IG9yaWdpbmFsLmtleUNvZGU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0bW91c2VIb29rczoge1xuXHRcdHByb3BzOiBcImJ1dHRvbiBidXR0b25zIGNsaWVudFggY2xpZW50WSBvZmZzZXRYIG9mZnNldFkgcGFnZVggcGFnZVkgc2NyZWVuWCBzY3JlZW5ZIHRvRWxlbWVudFwiLnNwbGl0KFwiIFwiKSxcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBldmVudCwgb3JpZ2luYWwgKSB7XG5cdFx0XHR2YXIgZXZlbnREb2MsIGRvYywgYm9keSxcblx0XHRcdFx0YnV0dG9uID0gb3JpZ2luYWwuYnV0dG9uO1xuXG5cdFx0XHQvLyBDYWxjdWxhdGUgcGFnZVgvWSBpZiBtaXNzaW5nIGFuZCBjbGllbnRYL1kgYXZhaWxhYmxlXG5cdFx0XHRpZiAoIGV2ZW50LnBhZ2VYID09IG51bGwgJiYgb3JpZ2luYWwuY2xpZW50WCAhPSBudWxsICkge1xuXHRcdFx0XHRldmVudERvYyA9IGV2ZW50LnRhcmdldC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuXHRcdFx0XHRkb2MgPSBldmVudERvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHRcdGJvZHkgPSBldmVudERvYy5ib2R5O1xuXG5cdFx0XHRcdGV2ZW50LnBhZ2VYID0gb3JpZ2luYWwuY2xpZW50WCArICggZG9jICYmIGRvYy5zY3JvbGxMZWZ0IHx8IGJvZHkgJiYgYm9keS5zY3JvbGxMZWZ0IHx8IDAgKSAtICggZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDAgKTtcblx0XHRcdFx0ZXZlbnQucGFnZVkgPSBvcmlnaW5hbC5jbGllbnRZICsgKCBkb2MgJiYgZG9jLnNjcm9sbFRvcCAgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCAgfHwgMCApIC0gKCBkb2MgJiYgZG9jLmNsaWVudFRvcCAgfHwgYm9keSAmJiBib2R5LmNsaWVudFRvcCAgfHwgMCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0XHQvLyBOb3RlOiBidXR0b24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIGRvbid0IHVzZSBpdFxuXHRcdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGV2ZW50LndoaWNoID0gKCBidXR0b24gJiAxID8gMSA6ICggYnV0dG9uICYgMiA/IDMgOiAoIGJ1dHRvbiAmIDQgPyAyIDogMCApICkgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoIGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdICkge1xuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblxuXHRcdC8vIENyZWF0ZSBhIHdyaXRhYmxlIGNvcHkgb2YgdGhlIGV2ZW50IG9iamVjdCBhbmQgbm9ybWFsaXplIHNvbWUgcHJvcGVydGllc1xuXHRcdHZhciBpLCBwcm9wLCBjb3B5LFxuXHRcdFx0dHlwZSA9IGV2ZW50LnR5cGUsXG5cdFx0XHRvcmlnaW5hbEV2ZW50ID0gZXZlbnQsXG5cdFx0XHRmaXhIb29rID0gdGhpcy5maXhIb29rc1sgdHlwZSBdO1xuXG5cdFx0aWYgKCAhZml4SG9vayApIHtcblx0XHRcdHRoaXMuZml4SG9va3NbIHR5cGUgXSA9IGZpeEhvb2sgPVxuXHRcdFx0XHRybW91c2VFdmVudC50ZXN0KCB0eXBlICkgPyB0aGlzLm1vdXNlSG9va3MgOlxuXHRcdFx0XHRya2V5RXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5rZXlIb29rcyA6XG5cdFx0XHRcdHt9O1xuXHRcdH1cblx0XHRjb3B5ID0gZml4SG9vay5wcm9wcyA/IHRoaXMucHJvcHMuY29uY2F0KCBmaXhIb29rLnByb3BzICkgOiB0aGlzLnByb3BzO1xuXG5cdFx0ZXZlbnQgPSBuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cblx0XHRpID0gY29weS5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRwcm9wID0gY29weVsgaSBdO1xuXHRcdFx0ZXZlbnRbIHByb3AgXSA9IG9yaWdpbmFsRXZlbnRbIHByb3AgXTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBDb3Jkb3ZhIDIuNSAoV2ViS2l0KSAoIzEzMjU1KVxuXHRcdC8vIEFsbCBldmVudHMgc2hvdWxkIGhhdmUgYSB0YXJnZXQ7IENvcmRvdmEgZGV2aWNlcmVhZHkgZG9lc24ndFxuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGRvY3VtZW50O1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA2LjArLCBDaHJvbWU8Mjhcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdGlmICggZXZlbnQudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZXZlbnQudGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZpeEhvb2suZmlsdGVyID8gZml4SG9vay5maWx0ZXIoIGV2ZW50LCBvcmlnaW5hbEV2ZW50ICkgOiBldmVudDtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGZvY3VzOiB7XG5cdFx0XHQvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHtcblx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIlxuXHRcdH0sXG5cdFx0Ymx1cjoge1xuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cdFx0XHQvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgJiYgdGhpcy5jbGljayAmJiBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHRoaXMuY2xpY2soKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZXZlbnQudGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCwgYnViYmxlICkge1xuXHRcdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZS5cblx0XHQvLyBGYWtlIG9yaWdpbmFsRXZlbnQgdG8gYXZvaWQgZG9ub3IncyBzdG9wUHJvcGFnYXRpb24sIGJ1dCBpZiB0aGVcblx0XHQvLyBzaW11bGF0ZWQgZXZlbnQgcHJldmVudHMgZGVmYXVsdCB0aGVuIHdlIGRvIHRoZSBzYW1lIG9uIHRoZSBkb25vci5cblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWUsXG5cdFx0XHRcdG9yaWdpbmFsRXZlbnQ6IHt9XG5cdFx0XHR9XG5cdFx0KTtcblx0XHRpZiAoIGJ1YmJsZSApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5jYWxsKCBlbGVtLCBlICk7XG5cdFx0fVxuXHRcdGlmICggZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSwgZmFsc2UgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEodGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgalF1ZXJ5Lm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmIGUucHJldmVudERlZmF1bHQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgZS5zdG9wUHJvcGFnYXRpb24gKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIFN1cHBvcnQ6IENocm9tZSAxNStcbmpRdWVyeS5lYWNoKHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAocmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59KTtcblxuLy8gU3VwcG9ydDogRmlyZWZveCwgQ2hyb21lLCBTYWZhcmlcbi8vIENyZWF0ZSBcImJ1YmJsaW5nXCIgZm9jdXMgYW5kIGJsdXIgZXZlbnRzXG5pZiAoICFzdXBwb3J0LmZvY3VzaW5CdWJibGVzICkge1xuXHRqUXVlcnkuZWFjaCh7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApLCB0cnVlICk7XG5cdFx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhX3ByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YV9wcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YV9wcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhX3ByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YV9wcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAvKklOVEVSTkFMKi8gb25lICkge1xuXHRcdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0XHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9uKCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXHRcdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRcdGZuID0gZGF0YTtcblx0XHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0XHRvcmlnRm4gPSBmbjtcblx0XHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdH07XG5cdFx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHRcdH0pO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgPyBoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOiBoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9KTtcblx0fSxcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9KTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1swXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5cbnZhclxuXHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXFx3Ol0rKVtePl0qKVxcLz4vZ2ksXG5cdHJ0YWdOYW1lID0gLzwoW1xcdzpdKykvLFxuXHRyaHRtbCA9IC88fCYjP1xcdys7Lyxcblx0cm5vSW5uZXJodG1sID0gLzwoPzpzY3JpcHR8c3R5bGV8bGluaykvaSxcblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cnNjcmlwdFR5cGUgPSAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pLFxuXHRyc2NyaXB0VHlwZU1hc2tlZCA9IC9edHJ1ZVxcLyguKikvLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2csXG5cblx0Ly8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcblx0d3JhcE1hcCA9IHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFOVxuXHRcdG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuXG5cdFx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRcdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdFx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHRcdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRcdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxuXHR9O1xuXG4vLyBTdXBwb3J0OiBJRTlcbndyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG4vLyBTdXBwb3J0OiAxLnggY29tcGF0aWJpbGl0eVxuLy8gTWFuaXB1bGF0aW5nIHRhYmxlcyByZXF1aXJlcyBhIHRib2R5XG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0alF1ZXJ5Lm5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApID9cblxuXHRcdGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0Ym9keVwiKVswXSB8fFxuXHRcdFx0ZWxlbS5hcHBlbmRDaGlsZCggZWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiKSApIDpcblx0XHRlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpICE9PSBudWxsKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdHZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoIGVsZW0udHlwZSApO1xuXG5cdGlmICggbWF0Y2ggKSB7XG5cdFx0ZWxlbS50eXBlID0gbWF0Y2hbIDEgXTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZShcInR5cGVcIik7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhX3ByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSwgXCJnbG9iYWxFdmFsXCIsICFyZWZFbGVtZW50cyB8fCBkYXRhX3ByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhX3ByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhX3ByaXYuYWNjZXNzKCBzcmMgKTtcblx0XHRwZGF0YUN1ciA9IGRhdGFfcHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0cGRhdGFDdXIuZXZlbnRzID0ge307XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFfdXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFfdXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhX3VzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXHR2YXIgcmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCA/IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICkgOlxuXHRcdFx0W107XG5cblx0cmV0dXJuIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBqUXVlcnkubm9kZU5hbWUoIGNvbnRleHQsIHRhZyApID9cblx0XHRqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKSA6XG5cdFx0cmV0O1xufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGJ1aWxkRnJhZ21lbnQ6IGZ1bmN0aW9uKCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uICkge1xuXHRcdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgY29udGFpbnMsIGosXG5cdFx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdFx0bm9kZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdFx0aWYgKCBqUXVlcnkudHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0LCBQaGFudG9tSlNcblx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpICk7XG5cblx0XHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGVsZW0ucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICkgKyB3cmFwWyAyIF07XG5cblx0XHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBRdFdlYktpdCwgUGhhbnRvbUpTXG5cdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0XHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0XHRpID0gMDtcblx0XHR3aGlsZSAoIChlbGVtID0gbm9kZXNbIGkrKyBdKSApIHtcblxuXHRcdFx0Ly8gIzQwODcgLSBJZiBvcmlnaW4gYW5kIGRlc3RpbmF0aW9uIGVsZW1lbnRzIGFyZSB0aGUgc2FtZSwgYW5kIHRoaXMgaXNcblx0XHRcdC8vIHRoYXQgZWxlbWVudCwgZG8gbm90IGRvIGFueXRoaW5nXG5cdFx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgIT09IC0xICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Y29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0XHRpZiAoIGNvbnRhaW5zICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHRtcFsgaisrIF0pICkge1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmcmFnbWVudDtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSwga2V5LFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IChlbGVtID0gZWxlbXNbIGkgXSkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRrZXkgPSBlbGVtWyBkYXRhX3ByaXYuZXhwYW5kbyBdO1xuXG5cdFx0XHRcdGlmICgga2V5ICYmIChkYXRhID0gZGF0YV9wcml2LmNhY2hlWyBrZXkgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggZGF0YV9wcml2LmNhY2hlWyBrZXkgXSApIHtcblx0XHRcdFx0XHRcdC8vIERpc2NhcmQgYW55IHJlbWFpbmluZyBgcHJpdmF0ZWAgZGF0YVxuXHRcdFx0XHRcdFx0ZGVsZXRlIGRhdGFfcHJpdi5jYWNoZVsga2V5IF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBEaXNjYXJkIGFueSByZW1haW5pbmcgYHVzZXJgIGRhdGFcblx0XHRcdGRlbGV0ZSBkYXRhX3VzZXIuY2FjaGVbIGVsZW1bIGRhdGFfdXNlci5leHBhbmRvIF0gXTtcblx0XHR9XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IsIGtlZXBEYXRhIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0ZWxlbXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCB0aGlzICkgOiB0aGlzLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggIWtlZXBEYXRhICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSApICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRpZiAoIGtlZXBEYXRhICYmIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKGVsZW0gPSB0aGlzW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0gdmFsdWUucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2goIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1sgMCBdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0dGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGFyZyA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblxuXHRcdFx0aWYgKCBhcmcgKSB7XG5cdFx0XHRcdGFyZy5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEZvcmNlIHJlbW92YWwgaWYgdGhlcmUgd2FzIG5vIG5ldyBjb250ZW50IChlLmcuLCBmcm9tIGVtcHR5IGFyZ3VtZW50cylcblx0XHRyZXR1cm4gYXJnICYmIChhcmcubGVuZ3RoIHx8IGFyZy5ub2RlVHlwZSkgPyB0aGlzIDogdGhpcy5yZW1vdmUoKTtcblx0fSxcblxuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmUoIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0ZG9tTWFuaXA6IGZ1bmN0aW9uKCBhcmdzLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdFx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZXQgPSB0aGlzLFxuXHRcdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdFx0aWYgKCBpc0Z1bmN0aW9uIHx8XG5cdFx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdFx0dmFyIHNlbGYgPSBzZXQuZXEoIGluZGV4ICk7XG5cdFx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLmRvbU1hbmlwKCBhcmdzLCBjYWxsYmFjayApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCBsICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBqUXVlcnkuYnVpbGRGcmFnbWVudCggYXJncywgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCB0aGlzICk7XG5cdFx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZmlyc3QgKSB7XG5cdFx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW0gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0XG5cdFx0XHRcdFx0XHRcdC8vIGpRdWVyeS5tZXJnZSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoIHRoaXNbIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHQhZGF0YV9wcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJiBqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICkgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59KTtcblxualF1ZXJ5LmVhY2goe1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBRdFdlYktpdFxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93c1xuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59KTtcblxuXG52YXIgaWZyYW1lLFxuXHRlbGVtZGlzcGxheSA9IHt9O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBhY3R1YWwgZGlzcGxheSBvZiBhIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5vZGVOYW1lIG9mIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gZG9jIERvY3VtZW50IG9iamVjdFxuICovXG4vLyBDYWxsZWQgb25seSBmcm9tIHdpdGhpbiBkZWZhdWx0RGlzcGxheVxuZnVuY3Rpb24gYWN0dWFsRGlzcGxheSggbmFtZSwgZG9jICkge1xuXHR2YXIgc3R5bGUsXG5cdFx0ZWxlbSA9IGpRdWVyeSggZG9jLmNyZWF0ZUVsZW1lbnQoIG5hbWUgKSApLmFwcGVuZFRvKCBkb2MuYm9keSApLFxuXG5cdFx0Ly8gZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUgbWlnaHQgYmUgcmVsaWFibHkgdXNlZCBvbmx5IG9uIGF0dGFjaGVkIGVsZW1lbnRcblx0XHRkaXNwbGF5ID0gd2luZG93LmdldERlZmF1bHRDb21wdXRlZFN0eWxlICYmICggc3R5bGUgPSB3aW5kb3cuZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUoIGVsZW1bIDAgXSApICkgP1xuXG5cdFx0XHQvLyBVc2Ugb2YgdGhpcyBtZXRob2QgaXMgYSB0ZW1wb3JhcnkgZml4IChtb3JlIGxpa2Ugb3B0aW1pemF0aW9uKSB1bnRpbCBzb21ldGhpbmcgYmV0dGVyIGNvbWVzIGFsb25nLFxuXHRcdFx0Ly8gc2luY2UgaXQgd2FzIHJlbW92ZWQgZnJvbSBzcGVjaWZpY2F0aW9uIGFuZCBzdXBwb3J0ZWQgb25seSBpbiBGRlxuXHRcdFx0c3R5bGUuZGlzcGxheSA6IGpRdWVyeS5jc3MoIGVsZW1bIDAgXSwgXCJkaXNwbGF5XCIgKTtcblxuXHQvLyBXZSBkb24ndCBoYXZlIGFueSBkYXRhIHN0b3JlZCBvbiB0aGUgZWxlbWVudCxcblx0Ly8gc28gdXNlIFwiZGV0YWNoXCIgbWV0aG9kIGFzIGZhc3Qgd2F5IHRvIGdldCByaWQgb2YgdGhlIGVsZW1lbnRcblx0ZWxlbS5kZXRhY2goKTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuLyoqXG4gKiBUcnkgdG8gZGV0ZXJtaW5lIHRoZSBkZWZhdWx0IGRpc3BsYXkgdmFsdWUgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IG5vZGVOYW1lXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHREaXNwbGF5KCBub2RlTmFtZSApIHtcblx0dmFyIGRvYyA9IGRvY3VtZW50LFxuXHRcdGRpc3BsYXkgPSBlbGVtZGlzcGxheVsgbm9kZU5hbWUgXTtcblxuXHRpZiAoICFkaXNwbGF5ICkge1xuXHRcdGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7XG5cblx0XHQvLyBJZiB0aGUgc2ltcGxlIHdheSBmYWlscywgcmVhZCBmcm9tIGluc2lkZSBhbiBpZnJhbWVcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiIHx8ICFkaXNwbGF5ICkge1xuXG5cdFx0XHQvLyBVc2UgdGhlIGFscmVhZHktY3JlYXRlZCBpZnJhbWUgaWYgcG9zc2libGVcblx0XHRcdGlmcmFtZSA9IChpZnJhbWUgfHwgalF1ZXJ5KCBcIjxpZnJhbWUgZnJhbWVib3JkZXI9JzAnIHdpZHRoPScwJyBoZWlnaHQ9JzAnLz5cIiApKS5hcHBlbmRUbyggZG9jLmRvY3VtZW50RWxlbWVudCApO1xuXG5cdFx0XHQvLyBBbHdheXMgd3JpdGUgYSBuZXcgSFRNTCBza2VsZXRvbiBzbyBXZWJraXQgYW5kIEZpcmVmb3ggZG9uJ3QgY2hva2Ugb24gcmV1c2Vcblx0XHRcdGRvYyA9IGlmcmFtZVsgMCBdLmNvbnRlbnREb2N1bWVudDtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUVcblx0XHRcdGRvYy53cml0ZSgpO1xuXHRcdFx0ZG9jLmNsb3NlKCk7XG5cblx0XHRcdGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7XG5cdFx0XHRpZnJhbWUuZGV0YWNoKCk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RvcmUgdGhlIGNvcnJlY3QgZGVmYXVsdCBkaXNwbGF5XG5cdFx0ZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXHR9XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG52YXIgcm1hcmdpbiA9ICgvXm1hcmdpbi8pO1xuXG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHQvLyBTdXBwb3J0OiBJRTw9MTErLCBGaXJlZm94PD0zMCsgKCMxNTA5OCwgIzE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdGlmICggZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3Lm9wZW5lciApIHtcblx0XHRcdHJldHVybiBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSwgbnVsbCApO1xuXHRcdH1cblxuXHRcdHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSwgbnVsbCApO1xuXHR9O1xuXG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBTdXBwb3J0OiBJRTlcblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBvbmx5IG5lZWRlZCBmb3IgLmNzcygnZmlsdGVyJykgKCMxMjUzNylcblx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblx0fVxuXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IGlPUyA8IDZcblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gaU9TIDwgNiAoYXQgbGVhc3QpIHJldHVybnMgcGVyY2VudGFnZSBmb3IgYSBsYXJnZXIgc2V0IG9mIHZhbHVlcywgYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVsc1xuXHRcdC8vIHRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzogaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJtYXJnaW4udGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKHRoaXMuZ2V0ID0gaG9va0ZuKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbihmdW5jdGlvbigpIHtcblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLFxuXHRcdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjA7d2lkdGg6MDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHg7bWFyZ2luLXRvcDoxcHg7XCIgK1xuXHRcdFwicG9zaXRpb246YWJzb2x1dGVcIjtcblx0Y29udGFpbmVyLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVBpeGVsUG9zaXRpb25BbmRCb3hTaXppbmdSZWxpYWJsZSgpIHtcblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI5LCBBbmRyb2lkIDIuM1xuXHRcdFx0Ly8gVmVuZG9yLXByZWZpeCBib3gtc2l6aW5nXG5cdFx0XHRcIi13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O1wiICtcblx0XHRcdFwiYm94LXNpemluZzpib3JkZXItYm94O2Rpc3BsYXk6YmxvY2s7bWFyZ2luLXRvcDoxJTt0b3A6MSU7XCIgK1xuXHRcdFx0XCJib3JkZXI6MXB4O3BhZGRpbmc6MXB4O3dpZHRoOjRweDtwb3NpdGlvbjphYnNvbHV0ZVwiO1xuXHRcdGRpdi5pbm5lckhUTUwgPSBcIlwiO1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiwgbnVsbCApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IGRpdlN0eWxlLndpZHRoID09PSBcIjRweFwiO1xuXG5cdFx0ZG9jRWxlbS5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBub2RlLmpzIGpzZG9tXG5cdC8vIERvbid0IGFzc3VtZSB0aGF0IGdldENvbXB1dGVkU3R5bGUgaXMgYSBwcm9wZXJ0eSBvZiB0aGUgZ2xvYmFsIG9iamVjdFxuXHRpZiAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFRoaXMgdGVzdCBpcyBleGVjdXRlZCBvbmx5IG9uY2UgYnV0IHdlIHN0aWxsIGRvIG1lbW9pemluZ1xuXHRcdFx0XHQvLyBzaW5jZSB3ZSBjYW4gdXNlIHRoZSBib3hTaXppbmdSZWxpYWJsZSBwcmUtY29tcHV0aW5nLlxuXHRcdFx0XHQvLyBObyBuZWVkIHRvIGNoZWNrIGlmIHRoZSB0ZXN0IHdhcyBhbHJlYWR5IHBlcmZvcm1lZCwgdGhvdWdoLlxuXHRcdFx0XHRjb21wdXRlUGl4ZWxQb3NpdGlvbkFuZEJveFNpemluZ1JlbGlhYmxlKCk7XG5cdFx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdFx0fSxcblx0XHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBib3hTaXppbmdSZWxpYWJsZVZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRcdGNvbXB1dGVQaXhlbFBvc2l0aW9uQW5kQm94U2l6aW5nUmVsaWFibGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0XHR9LFxuXHRcdFx0cmVsaWFibGVNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcblx0XHRcdFx0Ly8gQ2hlY2sgaWYgZGl2IHdpdGggZXhwbGljaXQgd2lkdGggYW5kIG5vIG1hcmdpbi1yaWdodCBpbmNvcnJlY3RseVxuXHRcdFx0XHQvLyBnZXRzIGNvbXB1dGVkIG1hcmdpbi1yaWdodCBiYXNlZCBvbiB3aWR0aCBvZiBjb250YWluZXIuICgjMzMzMylcblx0XHRcdFx0Ly8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0XG5cdFx0XHRcdC8vIFRoaXMgc3VwcG9ydCBmdW5jdGlvbiBpcyBvbmx5IGV4ZWN1dGVkIG9uY2Ugc28gbm8gbWVtb2l6aW5nIGlzIG5lZWRlZC5cblx0XHRcdFx0dmFyIHJldCxcblx0XHRcdFx0XHRtYXJnaW5EaXYgPSBkaXYuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIFJlc2V0IENTUzogYm94LXNpemluZzsgZGlzcGxheTsgbWFyZ2luOyBib3JkZXI7IHBhZGRpbmdcblx0XHRcdFx0bWFyZ2luRGl2LnN0eWxlLmNzc1RleHQgPSBkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyOSwgQW5kcm9pZCAyLjNcblx0XHRcdFx0XHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcblx0XHRcdFx0XHRcIi13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDstbW96LWJveC1zaXppbmc6Y29udGVudC1ib3g7XCIgK1xuXHRcdFx0XHRcdFwiYm94LXNpemluZzpjb250ZW50LWJveDtkaXNwbGF5OmJsb2NrO21hcmdpbjowO2JvcmRlcjowO3BhZGRpbmc6MFwiO1xuXHRcdFx0XHRtYXJnaW5EaXYuc3R5bGUubWFyZ2luUmlnaHQgPSBtYXJnaW5EaXYuc3R5bGUud2lkdGggPSBcIjBcIjtcblx0XHRcdFx0ZGl2LnN0eWxlLndpZHRoID0gXCIxcHhcIjtcblx0XHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHRcdFx0cmV0ID0gIXBhcnNlRmxvYXQoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBtYXJnaW5EaXYsIG51bGwgKS5tYXJnaW5SaWdodCApO1xuXG5cdFx0XHRcdGRvY0VsZW0ucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXHRcdFx0XHRkaXYucmVtb3ZlQ2hpbGQoIG1hcmdpbkRpdiApO1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pKCk7XG5cblxuLy8gQSBtZXRob2QgZm9yIHF1aWNrbHkgc3dhcHBpbmcgaW4vb3V0IENTUyBwcm9wZXJ0aWVzIHRvIGdldCBjb3JyZWN0IGNhbGN1bGF0aW9ucy5cbmpRdWVyeS5zd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxudmFyXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGUgZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdHJudW1zcGxpdCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoLiopJFwiLCBcImlcIiApLFxuXHRycmVsTnVtID0gbmV3IFJlZ0V4cCggXCJeKFsrLV0pPShcIiArIHBudW0gKyBcIilcIiwgXCJpXCIgKSxcblxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fSxcblxuXHRjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJPXCIsIFwiTW96XCIsIFwibXNcIiBdO1xuXG4vLyBSZXR1cm4gYSBjc3MgcHJvcGVydHkgbWFwcGVkIHRvIGEgcG90ZW50aWFsbHkgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggc3R5bGUsIG5hbWUgKSB7XG5cblx0Ly8gU2hvcnRjdXQgZm9yIG5hbWVzIHRoYXQgYXJlIG5vdCB2ZW5kb3IgcHJlZml4ZWRcblx0aWYgKCBuYW1lIGluIHN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksXG5cdFx0b3JpZ05hbWUgPSBuYW1lLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBzdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvcmlnTmFtZTtcbn1cblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblx0dmFyIG1hdGNoZXMgPSBybnVtc3BsaXQuZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDEgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDIgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSwgaXNCb3JkZXJCb3gsIHN0eWxlcyApIHtcblx0dmFyIGkgPSBleHRyYSA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApID9cblx0XHQvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIHJpZ2h0IG1lYXN1cmVtZW50LCBhdm9pZCBhdWdtZW50YXRpb25cblx0XHQ0IDpcblx0XHQvLyBPdGhlcndpc2UgaW5pdGlhbGl6ZSBmb3IgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0aWVzXG5cdFx0bmFtZSA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cblx0XHR2YWwgPSAwO1xuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW4sIHNvIGFkZCBpdCBpZiB3ZSB3YW50IGl0XG5cdFx0aWYgKCBleHRyYSA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBleHRyYSArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzQm9yZGVyQm94ICkge1xuXHRcdFx0Ly8gYm9yZGVyLWJveCBpbmNsdWRlcyBwYWRkaW5nLCBzbyByZW1vdmUgaXQgaWYgd2Ugd2FudCBjb250ZW50XG5cdFx0XHRpZiAoIGV4dHJhID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBib3JkZXIgbm9yIG1hcmdpbiwgc28gcmVtb3ZlIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQsIHNvIGFkZCBwYWRkaW5nXG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQgbm9yIHBhZGRpbmcsIHNvIGFkZCBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIG9mZnNldCBwcm9wZXJ0eSwgd2hpY2ggaXMgZXF1aXZhbGVudCB0byB0aGUgYm9yZGVyLWJveCB2YWx1ZVxuXHR2YXIgdmFsdWVJc0JvcmRlckJveCA9IHRydWUsXG5cdFx0dmFsID0gbmFtZSA9PT0gXCJ3aWR0aFwiID8gZWxlbS5vZmZzZXRXaWR0aCA6IGVsZW0ub2Zmc2V0SGVpZ2h0LFxuXHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHQvLyBTb21lIG5vbi1odG1sIGVsZW1lbnRzIHJldHVybiB1bmRlZmluZWQgZm9yIG9mZnNldFdpZHRoLCBzbyBjaGVjayBmb3IgbnVsbC91bmRlZmluZWRcblx0Ly8gc3ZnIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjQ5Mjg1XG5cdC8vIE1hdGhNTCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTQ5MTY2OFxuXHRpZiAoIHZhbCA8PSAwIHx8IHZhbCA9PSBudWxsICkge1xuXHRcdC8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0aWYgKCB2YWwgPCAwIHx8IHZhbCA9PSBudWxsICkge1xuXHRcdFx0dmFsID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIENvbXB1dGVkIHVuaXQgaXMgbm90IHBpeGVscy4gU3RvcCBoZXJlIGFuZCByZXR1cm4uXG5cdFx0aWYgKCBybnVtbm9ucHgudGVzdCh2YWwpICkge1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xuXHRcdC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3ggJiZcblx0XHRcdCggc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVsgbmFtZSBdICk7XG5cblx0XHQvLyBOb3JtYWxpemUgXCJcIiwgYXV0bywgYW5kIHByZXBhcmUgZm9yIGV4dHJhXG5cdFx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblx0fVxuXG5cdC8vIFVzZSB0aGUgYWN0aXZlIGJveC1zaXppbmcgbW9kZWwgdG8gYWRkL3N1YnRyYWN0IGlycmVsZXZhbnQgc3R5bGVzXG5cdHJldHVybiAoIHZhbCArXG5cdFx0YXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0bmFtZSxcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXNcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sIGhpZGRlbixcblx0XHR2YWx1ZXMgPSBbXSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhX3ByaXYuZ2V0KCBlbGVtLCBcIm9sZGRpc3BsYXlcIiApO1xuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXHRcdFx0Ly8gUmVzZXQgdGhlIGlubGluZSBkaXNwbGF5IG9mIHRoaXMgZWxlbWVudCB0byBsZWFybiBpZiBpdCBpc1xuXHRcdFx0Ly8gYmVpbmcgaGlkZGVuIGJ5IGNhc2NhZGVkIHJ1bGVzIG9yIG5vdFxuXHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICYmIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZWxlbWVudHMgd2hpY2ggaGF2ZSBiZWVuIG92ZXJyaWRkZW4gd2l0aCBkaXNwbGF5OiBub25lXG5cdFx0XHQvLyBpbiBhIHN0eWxlc2hlZXQgdG8gd2hhdGV2ZXIgdGhlIGRlZmF1bHQgYnJvd3NlciBzdHlsZSBpc1xuXHRcdFx0Ly8gZm9yIHN1Y2ggYW4gZWxlbWVudFxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW4oIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YV9wcml2LmFjY2VzcyggZWxlbSwgXCJvbGRkaXNwbGF5XCIsIGRlZmF1bHREaXNwbGF5KGVsZW0ubm9kZU5hbWUpICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhpZGRlbiA9IGlzSGlkZGVuKCBlbGVtICk7XG5cblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgfHwgIWhpZGRlbiApIHtcblx0XHRcdFx0ZGF0YV9wcml2LnNldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIsIGhpZGRlbiA/IGRpc3BsYXkgOiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIG1vc3Qgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3Bcblx0Ly8gdG8gYXZvaWQgdGhlIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdGlmICggIXNob3cgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gdmFsdWVzWyBpbmRleCBdIHx8IFwiXCIgOiBcIm5vbmVcIjtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5leHRlbmQoe1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge1xuXHRcdFwiZmxvYXRcIjogXCJjc3NGbG9hdFwiXG5cdH0sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fCAoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBzdHlsZSwgb3JpZ05hbWUgKSApO1xuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAocmV0ID0gcnJlbE51bS5leGVjKCB2YWx1ZSApKSApIHtcblx0XHRcdFx0dmFsdWUgPSAoIHJldFsxXSArIDEgKSAqIHJldFsyXSArIHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKSApO1xuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyLCBhZGQgJ3B4JyB0byB0aGUgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSApIHtcblx0XHRcdFx0dmFsdWUgKz0gXCJweFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKFwic2V0XCIgaW4gaG9va3MpIHx8ICh2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHwgKCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggZWxlbS5zdHlsZSwgb3JpZ05hbWUgKSApO1xuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBqUXVlcnkuaXNOdW1lcmljKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59KTtcblxualF1ZXJ5LmVhY2goWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmIGVsZW0ub2Zmc2V0V2lkdGggPT09IDAgP1xuXHRcdFx0XHRcdGpRdWVyeS5zd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgc3R5bGVzID0gZXh0cmEgJiYgZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBleHRyYSA/XG5cdFx0XHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHQpIDogMFxuXHRcdFx0KTtcblx0XHR9XG5cdH07XG59KTtcblxuLy8gU3VwcG9ydDogQW5kcm9pZCAyLjNcbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5SaWdodCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpblJpZ2h0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuc3dhcCggZWxlbSwgeyBcImRpc3BsYXlcIjogXCJpbmxpbmUtYmxvY2tcIiB9LFxuXHRcdFx0XHRjdXJDU1MsIFsgZWxlbSwgXCJtYXJnaW5SaWdodFwiIF0gKTtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KFwiIFwiKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggIXJtYXJnaW4udGVzdCggcHJlZml4ICkgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbiggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBcInN3aW5nXCI7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmXG5cdFx0XHRcdCghdHdlZW4uZWxlbS5zdHlsZSB8fCB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCkgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0uc3R5bGUgJiYgKCB0d2Vlbi5lbGVtLnN0eWxlWyBqUXVlcnkuY3NzUHJvcHNbIHR3ZWVuLnByb3AgXSBdICE9IG51bGwgfHwgalF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRTlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH1cbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIENvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCB0aW1lcklkLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cmZ4bnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKSxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC8sXG5cdGFuaW1hdGlvblByZWZpbHRlcnMgPSBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblx0dHdlZW5lcnMgPSB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKSxcblx0XHRcdFx0dGFyZ2V0ID0gdHdlZW4uY3VyKCksXG5cdFx0XHRcdHBhcnRzID0gcmZ4bnVtLmV4ZWMoIHZhbHVlICksXG5cdFx0XHRcdHVuaXQgPSBwYXJ0cyAmJiBwYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0XHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0XHRcdHN0YXJ0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICt0YXJnZXQgKSAmJlxuXHRcdFx0XHRcdHJmeG51bS5leGVjKCBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCBwcm9wICkgKSxcblx0XHRcdFx0c2NhbGUgPSAxLFxuXHRcdFx0XHRtYXhJdGVyYXRpb25zID0gMjA7XG5cblx0XHRcdGlmICggc3RhcnQgJiYgc3RhcnRbIDMgXSAhPT0gdW5pdCApIHtcblx0XHRcdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdFx0XHR1bml0ID0gdW5pdCB8fCBzdGFydFsgMyBdO1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHRcdFx0cGFydHMgPSBwYXJ0cyB8fCBbXTtcblxuXHRcdFx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdFx0XHRzdGFydCA9ICt0YXJnZXQgfHwgMTtcblxuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZyouXG5cdFx0XHRcdFx0Ly8gVXNlIHN0cmluZyBmb3IgZG91Ymxpbmcgc28gd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IHNlZSBzY2FsZSBhcyB1bmNoYW5nZWQgYmVsb3dcblx0XHRcdFx0XHRzY2FsZSA9IHNjYWxlIHx8IFwiLjVcIjtcblxuXHRcdFx0XHRcdC8vIEFkanVzdCBhbmQgYXBwbHlcblx0XHRcdFx0XHRzdGFydCA9IHN0YXJ0IC8gc2NhbGU7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCBwcm9wLCBzdGFydCArIHVuaXQgKTtcblxuXHRcdFx0XHQvLyBVcGRhdGUgc2NhbGUsIHRvbGVyYXRpbmcgemVybyBvciBOYU4gZnJvbSB0d2Vlbi5jdXIoKSxcblx0XHRcdFx0Ly8gYnJlYWsgdGhlIGxvb3AgaWYgc2NhbGUgaXMgdW5jaGFuZ2VkIG9yIHBlcmZlY3QsIG9yIGlmIHdlJ3ZlIGp1c3QgaGFkIGVub3VnaFxuXHRcdFx0XHR9IHdoaWxlICggc2NhbGUgIT09IChzY2FsZSA9IHR3ZWVuLmN1cigpIC8gdGFyZ2V0KSAmJiBzY2FsZSAhPT0gMSAmJiAtLW1heEl0ZXJhdGlvbnMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXBkYXRlIHR3ZWVuIHByb3BlcnRpZXNcblx0XHRcdGlmICggcGFydHMgKSB7XG5cdFx0XHRcdHN0YXJ0ID0gdHdlZW4uc3RhcnQgPSArc3RhcnQgfHwgK3RhcmdldCB8fCAwO1xuXHRcdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdFx0Ly8gSWYgYSArPS8tPSB0b2tlbiB3YXMgcHJvdmlkZWQsIHdlJ3JlIGRvaW5nIGEgcmVsYXRpdmUgYW5pbWF0aW9uXG5cdFx0XHRcdHR3ZWVuLmVuZCA9IHBhcnRzWyAxIF0gP1xuXHRcdFx0XHRcdHN0YXJ0ICsgKCBwYXJ0c1sgMSBdICsgMSApICogcGFydHNbIDIgXSA6XG5cdFx0XHRcdFx0K3BhcnRzWyAyIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fTtcblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0pO1xuXHRyZXR1cm4gKCBmeE5vdyA9IGpRdWVyeS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0IDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIHR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIHR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkpICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0LyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgdHdlZW4sIGhvb2tzLCBvbGRmaXJlLCBkaXNwbGF5LCBjaGVja0Rpc3BsYXksXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhX3ByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gSGFuZGxlIHF1ZXVlOiBmYWxzZSBwcm9taXNlc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBIZWlnaHQvd2lkdGggb3ZlcmZsb3cgcGFzc1xuXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcImhlaWdodFwiIGluIHByb3BzIHx8IFwid2lkdGhcIiBpbiBwcm9wcyApICkge1xuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG5vdGhpbmcgc25lYWtzIG91dFxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUU5LTEwIGRvIG5vdFxuXHRcdC8vIGNoYW5nZSB0aGUgb3ZlcmZsb3cgYXR0cmlidXRlIHdoZW4gb3ZlcmZsb3dYIGFuZFxuXHRcdC8vIG92ZXJmbG93WSBhcmUgc2V0IHRvIHRoZSBzYW1lIHZhbHVlXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBTZXQgZGlzcGxheSBwcm9wZXJ0eSB0byBpbmxpbmUtYmxvY2sgZm9yIGhlaWdodC93aWR0aFxuXHRcdC8vIGFuaW1hdGlvbnMgb24gaW5saW5lIGVsZW1lbnRzIHRoYXQgYXJlIGhhdmluZyB3aWR0aC9oZWlnaHQgYW5pbWF0ZWRcblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblxuXHRcdC8vIFRlc3QgZGVmYXVsdCBkaXNwbGF5IGlmIGRpc3BsYXkgaXMgY3VycmVudGx5IFwibm9uZVwiXG5cdFx0Y2hlY2tEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgP1xuXHRcdFx0ZGF0YV9wcml2LmdldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKSB8fCBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheTtcblxuXHRcdGlmICggY2hlY2tEaXNwbGF5ID09PSBcImlubGluZVwiICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIHNob3cvaGlkZSBwYXNzXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMuZXhlYyggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgZGF0YVNob3cgbGVmdCBvdmVyIGZyb20gYSBzdG9wcGVkIGhpZGUgb3Igc2hvdyBhbmQgd2UgYXJlIGdvaW5nIHRvIHByb2NlZWQgd2l0aCBzaG93LCB3ZSBzaG91bGQgcHJldGVuZCB0byBiZSBoaWRkZW5cblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cblx0XHQvLyBBbnkgbm9uLWZ4IHZhbHVlIHN0b3BzIHVzIGZyb20gcmVzdG9yaW5nIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpc3BsYXkgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGFTaG93ID0gZGF0YV9wcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwge30gKTtcblx0XHR9XG5cblx0XHQvLyBTdG9yZSBzdGF0ZSBpZiBpdHMgdG9nZ2xlIC0gZW5hYmxlcyAuc3RvcCgpLnRvZ2dsZSgpIHRvIFwicmV2ZXJzZVwiXG5cdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdH1cblx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdGpRdWVyeSggZWxlbSApLnNob3coKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YW5pbS5kb25lKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5oaWRlKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0YW5pbS5kb25lKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHByb3A7XG5cblx0XHRcdGRhdGFfcHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHR0d2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXG5cdFx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0XHR0d2Vlbi5lbmQgPSB0d2Vlbi5zdGFydDtcblx0XHRcdFx0XHR0d2Vlbi5zdGFydCA9IHByb3AgPT09IFwid2lkdGhcIiB8fCBwcm9wID09PSBcImhlaWdodFwiID8gMSA6IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0Ly8gSWYgdGhpcyBpcyBhIG5vb3AgbGlrZSAuaGlkZSgpLmhpZGUoKSwgcmVzdG9yZSBhbiBvdmVyd3JpdHRlbiBkaXNwbGF5IHZhbHVlXG5cdH0gZWxzZSBpZiAoIChkaXNwbGF5ID09PSBcIm5vbmVcIiA/IGRlZmF1bHREaXNwbGF5KCBlbGVtLm5vZGVOYW1lICkgOiBkaXNwbGF5KSA9PT0gXCJpbmxpbmVcIiApIHtcblx0XHRzdHlsZS5kaXNwbGF5ID0gZGlzcGxheTtcblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gYW5pbWF0aW9uUHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0pLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdKTtcblxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHsgc3BlY2lhbEVhc2luZzoge30gfSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0pLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gYW5pbWF0aW9uUHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0pXG5cdCk7XG5cblx0Ly8gYXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0cmV0dXJuIGFuaW1hdGlvbi5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLnNwbGl0KFwiIFwiKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0dHdlZW5lcnNbIHByb3AgXSA9IHR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHR0d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdGFuaW1hdGlvblByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YW5pbWF0aW9uUHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4Lm9mZiA/IDAgOiB0eXBlb2Ygb3B0LmR1cmF0aW9uID09PSBcIm51bWJlclwiID8gb3B0LmR1cmF0aW9uIDpcblx0XHRvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyA/IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdIDogalF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YV9wcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YV9wcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgKHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUpICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuXHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhX3ByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0pO1xuXHR9XG59KTtcblxualF1ZXJ5LmVhY2goWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59KTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goe1xuXHRzbGlkZURvd246IGdlbkZ4KFwic2hvd1wiKSxcblx0c2xpZGVVcDogZ2VuRngoXCJoaWRlXCIpLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoXCJ0b2dnbGVcIiksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0galF1ZXJ5Lm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXHRcdC8vIENoZWNrcyB0aGUgdGltZXIgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVtb3ZlZFxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGlmICggdGltZXIoKSApIHtcblx0XHRqUXVlcnkuZnguc3RhcnQoKTtcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkudGltZXJzLnBvcCgpO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcblxualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggIXRpbWVySWQgKSB7XG5cdFx0dGltZXJJZCA9IHNldEludGVydmFsKCBqUXVlcnkuZngudGljaywgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGNsZWFySW50ZXJ2YWwoIHRpbWVySWQgKTtcblx0dGltZXJJZCA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9KTtcbn07XG5cblxuKGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IGlPUzw9NS4xLCBBbmRyb2lkPD00LjIrXG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRTw9MTErXG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw9Mi4zXG5cdC8vIE9wdGlvbnMgaW5zaWRlIGRpc2FibGVkIHNlbGVjdHMgYXJlIGluY29ycmVjdGx5IG1hcmtlZCBhcyBkaXNhYmxlZFxuXHRzZWxlY3QuZGlzYWJsZWQgPSB0cnVlO1xuXHRzdXBwb3J0Lm9wdERpc2FibGVkID0gIW9wdC5kaXNhYmxlZDtcblxuXHQvLyBTdXBwb3J0OiBJRTw9MTErXG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0pKCk7XG5cblxudmFyIG5vZGVIb29rLCBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0pO1xuXHR9XG59KTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIGRvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IHN0cnVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgYXR0cmlidXRlcyBhcmUgbG93ZXJjYXNlXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IG5vZGVIb29rICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkpICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgP1xuXHRcdFx0XHR1bmRlZmluZWQgOlxuXHRcdFx0XHRyZXQ7XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSwgcHJvcE5hbWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoIChuYW1lID0gYXR0ck5hbWVzW2krK10pICkge1xuXHRcdFx0XHRwcm9wTmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblxuXHRcdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgZ2V0IHNwZWNpYWwgdHJlYXRtZW50ICgjMTA4NzApXG5cdFx0XHRcdGlmICggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdFx0Ly8gU2V0IGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdG8gZmFsc2Vcblx0XHRcdFx0XHRlbGVtWyBwcm9wTmFtZSBdID0gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZTtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIG5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIG5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0pO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9LFxuXG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcywgbm90eG1sLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bm90eG1sID0gblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApO1xuXG5cdFx0aWYgKCBub3R4bWwgKSB7XG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJldCA6XG5cdFx0XHRcdCggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkpICE9PSBudWxsID9cblx0XHRcdFx0cmV0IDpcblx0XHRcdFx0ZWxlbVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaGFzQXR0cmlidXRlKCBcInRhYmluZGV4XCIgKSB8fCByZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fCBlbGVtLmhyZWYgP1xuXHRcdFx0XHRcdGVsZW0udGFiSW5kZXggOlxuXHRcdFx0XHRcdC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0pO1xuXG5cblxuXG52YXIgcmNsYXNzID0gL1tcXHRcXHJcXG5cXGZdL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0cHJvY2VlZCA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGg7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIHRoaXMuY2xhc3NOYW1lICkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICggcHJvY2VlZCApIHtcblx0XHRcdC8vIFRoZSBkaXNqdW5jdGlvbiBoZXJlIGlzIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgcmVtb3ZlQ2xhc3MpXG5cdFx0XHRjbGFzc2VzID0gKCB2YWx1ZSB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIGVsZW0uY2xhc3NOYW1lID9cblx0XHRcdFx0XHQoIFwiIFwiICsgZWxlbS5jbGFzc05hbWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKSA6XG5cdFx0XHRcdFx0XCIgXCJcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChjbGF6eiA9IGNsYXNzZXNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIG9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IGpRdWVyeS50cmltKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGVsZW0uY2xhc3NOYW1lICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5jbGFzc05hbWUgPSBmaW5hbFZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRwcm9jZWVkID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCB0aGlzLmNsYXNzTmFtZSApICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0aWYgKCBwcm9jZWVkICkge1xuXHRcdFx0Y2xhc3NlcyA9ICggdmFsdWUgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF07XG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBlbGVtLmNsYXNzTmFtZSA/XG5cdFx0XHRcdFx0KCBcIiBcIiArIGVsZW0uY2xhc3NOYW1lICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiICkgOlxuXHRcdFx0XHRcdFwiXCJcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChjbGF6eiA9IGNsYXNzZXNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+PSAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHZhbHVlID8galF1ZXJ5LnRyaW0oIGN1ciApIDogXCJcIjtcblx0XHRcdFx0XHRpZiAoIGVsZW0uY2xhc3NOYW1lICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5jbGFzc05hbWUgPSBmaW5hbFZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoIHZhbHVlLmNhbGwodGhpcywgaSwgdGhpcy5jbGFzc05hbWUsIHN0YXRlVmFsKSwgc3RhdGVWYWwgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdHZhciBjbGFzc05hbWUsXG5cdFx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRcdGNsYXNzTmFtZXMgPSB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdFx0d2hpbGUgKCAoY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0pICkge1xuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBzdHJ1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5jbGFzc05hbWUgKSB7XG5cdFx0XHRcdFx0Ly8gc3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFfcHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCB0aGlzLmNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHR0aGlzLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/IFwiXCIgOiBkYXRhX3ByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCI7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0aWYgKCB0aGlzW2ldLm5vZGVUeXBlID09PSAxICYmIChcIiBcIiArIHRoaXNbaV0uY2xhc3NOYW1lICsgXCIgXCIpLnJlcGxhY2UocmNsYXNzLCBcIiBcIikuaW5kZXhPZiggY2xhc3NOYW1lICkgPj0gMCApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59KTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgaXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWzBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdFx0cmV0LnJlcGxhY2UocnJldHVybiwgXCJcIikgOlxuXHRcdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRcdHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5leHRlbmQoe1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUxMC0xMStcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0alF1ZXJ5LnRyaW0oIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiIHx8IGluZGV4IDwgMCxcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGgsXG5cdFx0XHRcdFx0aSA9IGluZGV4IDwgMCA/XG5cdFx0XHRcdFx0XHRtYXggOlxuXHRcdFx0XHRcdFx0b25lID8gaW5kZXggOiAwO1xuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gSUU2LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0KCBzdXBwb3J0Lm9wdERpc2FibGVkID8gIW9wdGlvbi5kaXNhYmxlZCA6IG9wdGlvbi5nZXRBdHRyaWJ1dGUoIFwiZGlzYWJsZWRcIiApID09PSBudWxsICkgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHwgIWpRdWVyeS5ub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIChvcHRpb24uc2VsZWN0ZWQgPSBqUXVlcnkuaW5BcnJheSggb3B0aW9uLnZhbHVlLCB2YWx1ZXMgKSA+PSAwKSApIHtcblx0XHRcdFx0XHRcdG9wdGlvblNldCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeShlbGVtKS52YWwoKSwgdmFsdWUgKSA+PSAwICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG5qUXVlcnkuZWFjaCggKFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IGxvYWQgcmVzaXplIHNjcm9sbCB1bmxvYWQgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yIGNvbnRleHRtZW51XCIpLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fSxcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOiB0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fVxufSk7XG5cblxudmFyIG5vbmNlID0galF1ZXJ5Lm5vdygpO1xuXG52YXIgcnF1ZXJ5ID0gKC9cXD8vKTtcblxuXG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG4vLyBXb3JrYXJvdW5kIGZhaWx1cmUgdG8gc3RyaW5nLWNhc3QgbnVsbCBpbnB1dFxualF1ZXJ5LnBhcnNlSlNPTiA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSArIFwiXCIgKTtcbn07XG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWwsIHRtcDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFOVxuXHR0cnkge1xuXHRcdHRtcCA9IG5ldyBET01QYXJzZXIoKTtcblx0XHR4bWwgPSB0bXAucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRydHMgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cdHJ1cmwgPSAvXihbXFx3ListXSs6KSg/OlxcL1xcLyg/OlteXFwvPyNdKkB8KShbXlxcLz8jOl0qKSg/OjooXFxkKyl8KXwpLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIERvY3VtZW50IGxvY2F0aW9uXG5cdGFqYXhMb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxuXG5cdC8vIFNlZ21lbnQgbG9jYXRpb24gaW50byBwYXJ0c1xuXHRhamF4TG9jUGFydHMgPSBydXJsLmV4ZWMoIGFqYXhMb2NhdGlvbi50b0xvd2VyQ2FzZSgpICkgfHwgW107XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoIChkYXRhVHlwZSA9IGRhdGFUeXBlc1tpKytdKSApIHtcblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVswXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdChzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10pLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJiAhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8IChkZWVwID0ge30pICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIik7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbMF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzWyBcInRocm93c1wiIF0gKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4geyBzdGF0ZTogXCJwYXJzZXJlcnJvclwiLCBlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnQgfTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoe1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGFqYXhMb2NhdGlvbixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGFqYXhMb2NQYXJ0c1sgMSBdICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAveG1sLyxcblx0XHRcdGh0bWw6IC9odG1sLyxcblx0XHRcdGpzb246IC9qc29uL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBqUXVlcnkucGFyc2VKU09OLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cdFx0XHQvLyBDcm9zcy1kb21haW4gZGV0ZWN0aW9uIHZhcnNcblx0XHRcdHBhcnRzLFxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJiAoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cdFx0XHQvLyBUaGUganFYSFIgc3RhdGVcblx0XHRcdHN0YXRlID0gMCxcblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGUgPT09IDIgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHR2YXIgbG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0aWYgKCAhc3RhdGUgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIGxuYW1lIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCAhc3RhdGUgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggc3RhdGUgPCAyICkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICkuY29tcGxldGUgPSBjb21wbGV0ZURlZmVycmVkLmFkZDtcblx0XHRqcVhIUi5zdWNjZXNzID0ganFYSFIuZG9uZTtcblx0XHRqcVhIUi5lcnJvciA9IGpxWEhSLmZhaWw7XG5cblx0XHQvLyBSZW1vdmUgaGFzaCBjaGFyYWN0ZXIgKCM3NTMxOiBhbmQgc3RyaW5nIHByb21vdGlvbilcblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBhamF4TG9jYXRpb24gKSArIFwiXCIgKS5yZXBsYWNlKCByaGFzaCwgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBhamF4TG9jUGFydHNbIDEgXSArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9IGpRdWVyeS50cmltKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gd2UgaGF2ZSBhIHByb3RvY29sOmhvc3Q6cG9ydCBtaXNtYXRjaFxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0cGFydHMgPSBydXJsLmV4ZWMoIHMudXJsLnRvTG93ZXJDYXNlKCkgKTtcblx0XHRcdHMuY3Jvc3NEb21haW4gPSAhISggcGFydHMgJiZcblx0XHRcdFx0KCBwYXJ0c1sgMSBdICE9PSBhamF4TG9jUGFydHNbIDEgXSB8fCBwYXJ0c1sgMiBdICE9PSBhamF4TG9jUGFydHNbIDIgXSB8fFxuXHRcdFx0XHRcdCggcGFydHNbIDMgXSB8fCAoIHBhcnRzWyAxIF0gPT09IFwiaHR0cDpcIiA/IFwiODBcIiA6IFwiNDQzXCIgKSApICE9PVxuXHRcdFx0XHRcdFx0KCBhamF4TG9jUGFydHNbIDMgXSB8fCAoIGFqYXhMb2NQYXJ0c1sgMSBdID09PSBcImh0dHA6XCIgPyBcIjgwXCIgOiBcIjQ0M1wiICkgKSApXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKFwiYWpheFN0YXJ0XCIpO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdGNhY2hlVVJMID0gcy51cmw7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gKCBzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhICk7XG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGFudGktY2FjaGUgaW4gdXJsIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0cy51cmwgPSBydHMudGVzdCggY2FjaGVVUkwgKSA/XG5cblx0XHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgJ18nIHBhcmFtZXRlciwgc2V0IGl0cyB2YWx1ZVxuXHRcdFx0XHRcdGNhY2hlVVJMLnJlcGxhY2UoIHJ0cywgXCIkMV89XCIgKyBub25jZSsrICkgOlxuXG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFkZCBvbmUgdG8gdGhlIGVuZFxuXHRcdFx0XHRcdGNhY2hlVVJMICsgKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArIG5vbmNlKys7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbMF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbMF0gXSArICggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmICggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgc3RhdGUgPT09IDIgKSApIHtcblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRmb3IgKCBpIGluIHsgc3VjY2VzczogMSwgZXJyb3I6IDEsIGNvbXBsZXRlOiAxIH0gKSB7XG5cdFx0XHRqcVhIUlsgaSBdKCBzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoXCJ0aW1lb3V0XCIpO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0c3RhdGUgPSAxO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHQvLyBQcm9wYWdhdGUgZXhjZXB0aW9uIGFzIGVycm9yIGlmIG5vdCBkb25lXG5cdFx0XHRcdGlmICggc3RhdGUgPCAyICkge1xuXHRcdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHRcdC8vIFNpbXBseSByZXRocm93IG90aGVyd2lzZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBDYWxsZWQgb25jZVxuXHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0ZSBpcyBcImRvbmVcIiBub3dcblx0XHRcdHN0YXRlID0gMjtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcIkxhc3QtTW9kaWZpZWRcIik7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcImV0YWdcIik7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKFwiYWpheFN0b3BcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9KTtcblx0fTtcbn0pO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCh7XG5cdFx0dXJsOiB1cmwsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcInRocm93c1wiOiB0cnVlXG5cdH0pO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sLmNhbGwodGhpcywgaSkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0pLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwodGhpcywgaSkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaXNGdW5jdGlvbiA/IGh0bWwuY2FsbCh0aGlzLCBpKSA6IGh0bWwgKTtcblx0XHR9KTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnBhcmVudCgpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiYm9keVwiICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHRcdH1cblx0XHR9KS5lbmQoKTtcblx0fVxufSk7XG5cblxualF1ZXJ5LmV4cHIuZmlsdGVycy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0Ly8gU3VwcG9ydDogT3BlcmEgPD0gMTIuMTJcblx0Ly8gT3BlcmEgcmVwb3J0cyBvZmZzZXRXaWR0aHMgYW5kIG9mZnNldEhlaWdodHMgbGVzcyB0aGFuIHplcm8gb24gc29tZSBlbGVtZW50c1xuXHRyZXR1cm4gZWxlbS5vZmZzZXRXaWR0aCA8PSAwICYmIGVsZW0ub2Zmc2V0SGVpZ2h0IDw9IDA7XG59O1xualF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIuZmlsdGVycy5oaWRkZW4oIGVsZW0gKTtcbn07XG5cblxuXG5cbnZhciByMjAgPSAvJTIwL2csXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIG9iaiApICkge1xuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiA/IGkgOiBcIlwiICkgKyBcIl1cIiwgdiwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgcmV0dXJuIGl0cyB2YWx1ZVxuXHRcdFx0dmFsdWUgPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSA/IHZhbHVlKCkgOiAoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlICk7XG5cdFx0fTtcblxuXHQvLyBTZXQgdHJhZGl0aW9uYWwgdG8gdHJ1ZSBmb3IgalF1ZXJ5IDw9IDEuMy4yIGJlaGF2aW9yLlxuXHRpZiAoIHRyYWRpdGlvbmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0dHJhZGl0aW9uYWwgPSBqUXVlcnkuYWpheFNldHRpbmdzICYmIGpRdWVyeS5hamF4U2V0dGluZ3MudHJhZGl0aW9uYWw7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSk7XG5cblx0fSBlbHNlIHtcblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICkucmVwbGFjZSggcjIwLCBcIitcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9KVxuXHRcdC5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0pXG5cdFx0Lm1hcChmdW5jdGlvbiggaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0cmV0dXJuIHZhbCA9PSBudWxsID9cblx0XHRcdFx0bnVsbCA6XG5cdFx0XHRcdGpRdWVyeS5pc0FycmF5KCB2YWwgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0eyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0pLmdldCgpO1xuXHR9XG59KTtcblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCggZSApIHt9XG59O1xuXG52YXIgeGhySWQgPSAwLFxuXHR4aHJDYWxsYmFja3MgPSB7fSxcblx0eGhyU3VjY2Vzc1N0YXR1cyA9IHtcblx0XHQvLyBmaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblx0XHQvLyBTdXBwb3J0OiBJRTlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuLy8gU3VwcG9ydDogSUU5XG4vLyBPcGVuIHJlcXVlc3RzIG11c3QgYmUgbWFudWFsbHkgYWJvcnRlZCBvbiB1bmxvYWQgKCM1MjgwKVxuLy8gU2VlIGh0dHBzOi8vc3VwcG9ydC5taWNyb3NvZnQuY29tL2tiLzI4NTY3NDYgZm9yIG1vcmUgaW5mb1xuaWYgKCB3aW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdHdpbmRvdy5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCBmdW5jdGlvbigpIHtcblx0XHRmb3IgKCB2YXIga2V5IGluIHhockNhbGxiYWNrcyApIHtcblx0XHRcdHhockNhbGxiYWNrc1sga2V5IF0oKTtcblx0XHR9XG5cdH0pO1xufVxuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpLFxuXHRcdFx0XHRcdGlkID0gKyt4aHJJZDtcblxuXHRcdFx0XHR4aHIub3Blbiggb3B0aW9ucy50eXBlLCBvcHRpb25zLnVybCwgb3B0aW9ucy5hc3luYywgb3B0aW9ucy51c2VybmFtZSwgb3B0aW9ucy5wYXNzd29yZCApO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgeGhyQ2FsbGJhY2tzWyBpZCBdO1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IHhoci5vbmxvYWQgPSB4aHIub25lcnJvciA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFOVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gQWNjZXNzaW5nIGJpbmFyeS1kYXRhIHJlc3BvbnNlVGV4dCB0aHJvd3MgYW4gZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyAoIzExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgPT09IFwic3RyaW5nXCIgPyB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRleHQ6IHhoci5yZXNwb25zZVRleHRcblx0XHRcdFx0XHRcdFx0XHRcdH0gOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHR4aHIub25lcnJvciA9IGNhbGxiYWNrKFwiZXJyb3JcIik7XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IHhockNhbGxiYWNrc1sgaWQgXSA9IGNhbGxiYWNrKFwiYWJvcnRcIik7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59KTtcblxuXG5cblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoe1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC8oPzpqYXZhfGVjbWEpc2NyaXB0L1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoXCI8c2NyaXB0PlwiKS5wcm9wKHtcblx0XHRcdFx0XHRhc3luYzogdHJ1ZSxcblx0XHRcdFx0XHRjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsXG5cdFx0XHRcdFx0c3JjOiBzLnVybFxuXHRcdFx0XHR9KS5vbihcblx0XHRcdFx0XHRcImxvYWQgZXJyb3JcIixcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCh7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiYgISggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSAmJiByanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0galF1ZXJ5LmlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1tcInNjcmlwdCBqc29uXCJdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gZm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyhmdW5jdGlvbigpIHtcblx0XHRcdC8vIFJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cdFx0XHRcdC8vIG1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gc2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBqUXVlcnkuaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9KTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59KTtcblxuXG5cblxuLy8gZGF0YTogc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCwgZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHR2YXIgcGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICksXG5cdFx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWzFdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGpRdWVyeS5idWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vLyBLZWVwIGEgY29weSBvZiB0aGUgb2xkIGxvYWQgbWV0aG9kXG52YXIgX2xvYWQgPSBqUXVlcnkuZm4ubG9hZDtcblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0aWYgKCB0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiICYmIF9sb2FkICkge1xuXHRcdHJldHVybiBfbG9hZC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdH1cblxuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKFwiIFwiKTtcblxuXHRpZiAoIG9mZiA+PSAwICkge1xuXHRcdHNlbGVjdG9yID0galF1ZXJ5LnRyaW0oIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCh7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gaWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZFxuXHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0pLmRvbmUoZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoXCI8ZGl2PlwiKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHR9KS5jb21wbGV0ZSggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGNhbGxiYWNrLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggWyBcImFqYXhTdGFydFwiLCBcImFqYXhTdG9wXCIsIFwiYWpheENvbXBsZXRlXCIsIFwiYWpheEVycm9yXCIsIFwiYWpheFN1Y2Nlc3NcIiwgXCJhamF4U2VuZFwiIF0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0pO1xuXG5cblxuXG5qUXVlcnkuZXhwci5maWx0ZXJzLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcChqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0pLmxlbmd0aDtcbn07XG5cblxuXG5cbnZhciBkb2NFbGVtID0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuLyoqXG4gKiBHZXRzIGEgd2luZG93IGZyb20gYW4gZWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSA/IGVsZW0gOiBlbGVtLm5vZGVUeXBlID09PSA5ICYmIGVsZW0uZGVmYXVsdFZpZXc7XG59XG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZihcImF1dG9cIikgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBjdXJPZmZzZXQgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciBkb2NFbGVtLCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0Ym94ID0geyB0b3A6IDAsIGxlZnQ6IDAgfSxcblx0XHRcdGRvYyA9IGVsZW0gJiYgZWxlbS5vd25lckRvY3VtZW50O1xuXG5cdFx0aWYgKCAhZG9jICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0Ly8gTWFrZSBzdXJlIGl0J3Mgbm90IGEgZGlzY29ubmVjdGVkIERPTSBub2RlXG5cdFx0aWYgKCAhalF1ZXJ5LmNvbnRhaW5zKCBkb2NFbGVtLCBlbGVtICkgKSB7XG5cdFx0XHRyZXR1cm4gYm94O1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IEJsYWNrQmVycnkgNSwgaU9TIDMgKG9yaWdpbmFsIGlQaG9uZSlcblx0XHQvLyBJZiB3ZSBkb24ndCBoYXZlIGdCQ1IsIGp1c3QgdXNlIDAsMCByYXRoZXIgdGhhbiBlcnJvclxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9PSBzdHJ1bmRlZmluZWQgKSB7XG5cdFx0XHRib3ggPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdH1cblx0XHR3aW4gPSBnZXRXaW5kb3coIGRvYyApO1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IGJveC50b3AgKyB3aW4ucGFnZVlPZmZzZXQgLSBkb2NFbGVtLmNsaWVudFRvcCxcblx0XHRcdGxlZnQ6IGJveC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRMZWZ0XG5cdFx0fTtcblx0fSxcblxuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gRml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHdpbmRvdyAocGFyZW50T2Zmc2V0ID0ge3RvcDowLCBsZWZ0OiAwfSwgYmVjYXVzZSBpdCBpcyBpdHMgb25seSBvZmZzZXQgcGFyZW50XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXHRcdFx0Ly8gQXNzdW1lIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyB0aGVyZSB3aGVuIGNvbXB1dGVkIHBvc2l0aW9uIGlzIGZpeGVkXG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpO1xuXG5cdFx0XHQvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJodG1sXCIgKSApIHtcblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcblx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQgfHwgZG9jRWxlbTtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnQsIFwiaHRtbFwiICkgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY0VsZW07XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cdFx0XHR2YXIgd2luID0gZ2V0V2luZG93KCBlbGVtICk7XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW5kb3cucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luZG93LnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoLCBudWxsICk7XG5cdH07XG59KTtcblxuLy8gU3VwcG9ydDogU2FmYXJpPDcrLCBDaHJvbWU8MzcrXG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yMjkyODBcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59KTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LCBmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0Ly8gQXMgb2YgNS84LzIwMTIgdGhpcyB3aWxsIHlpZWxkIGluY29ycmVjdCByZXN1bHRzIGZvciBNb2JpbGUgU2FmYXJpLCBidXQgdGhlcmVcblx0XHRcdFx0XHQvLyBpc24ndCBhIHdob2xlIGxvdCB3ZSBjYW4gZG8uIFNlZSBwdWxsIHJlcXVlc3QgYXQgdGhpcyBVUkwgZm9yIGRpc2N1c3Npb246XG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC83NjRcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlLCBudWxsICk7XG5cdFx0fTtcblx0fSk7XG59KTtcblxuXG4vLyBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldFxualF1ZXJ5LmZuLnNpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcblxualF1ZXJ5LmZuLmFuZFNlbGYgPSBqUXVlcnkuZm4uYWRkQmFjaztcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9KTtcbn1cblxuXG5cblxudmFyXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggdHlwZW9mIG5vR2xvYmFsID09PSBzdHJ1bmRlZmluZWQgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcblxufSkpO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbnZhciBFWFRFTlNJT05fSUQgPSBjaHJvbWUuaTE4bi5nZXRNZXNzYWdlKCdAQGV4dGVuc2lvbl9pZCcpO1xuXG5fLm1peGluKHtcblx0YW5hbHl0aWNzX2xhYmVsOiBmdW5jdGlvbihpZGVudGl0eSkge1xuXHRcdHJldHVybiBfLmNoYWluKFtpZGVudGl0eS5hcGksIGlkZW50aXR5LnR5cGVdKVxuXHRcdCAgICAgICAgLmNvbXBhY3QoKVxuXHRcdCAgICAgICAgLnVuaW9uKGlkZW50aXR5LmFzICYmIFsnYXMnLCBpZGVudGl0eS5hc10pXG5cdFx0ICAgICAgICAudW5pb24oaWRlbnRpdHlbJ2ZvciddICYmIFsnZm9yJywgXy5hbmFseXRpY3NfbGFiZWwoaWRlbnRpdHlbJ2ZvciddKV0pXG5cdFx0ICAgICAgICAudmFsdWUoKVxuXHRcdCAgICAgICAgLmpvaW4oJyAnKTtcblx0fSxcblx0cHJlZml4OiBmdW5jdGlvbihjbGFzc05hbWUpIHtcblx0XHRyZXR1cm4gRVhURU5TSU9OX0lEICsgJy0nICsgY2xhc3NOYW1lO1xuXHR9LFxuXHRzY3JvbGxiYXJfd2lkdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB3aWR0aDtcblx0XHR2YXIgc2Nyb2xsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0c2Nyb2xsRGl2LnN0eWxlLndpZHRoID0gJzEwMHB4Jztcblx0XHRzY3JvbGxEaXYuc3R5bGUuaGVpZ2h0ID0gJzEwMHB4Jztcblx0XHRzY3JvbGxEaXYuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJztcblx0XHRzY3JvbGxEaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHRcdHNjcm9sbERpdi5zdHlsZS50b3AgPSAnLTk5OTlweCc7XG5cdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JvbGxEaXYpO1xuXHRcdHdpZHRoID0gc2Nyb2xsRGl2Lm9mZnNldFdpZHRoIC0gc2Nyb2xsRGl2LmNsaWVudFdpZHRoO1xuXHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2Nyb2xsRGl2KTtcblx0XHRyZXR1cm4gd2lkdGg7XG5cdH1cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBpLCBjYWxsYmFjaykge1xuXHRpZiAoXy5pc0VtcHR5KGFwaSkpIHtcblx0XHRyZXR1cm4gc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuXHRcdFx0Y2FsbGJhY2soeyBtZXNzYWdlOiAnTWlzc2luZyBcXCdhcGlcXCcnLCBzdGF0dXM6IDQwMCB9KTtcblx0XHR9KTtcblx0fVxuXHRjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSh7IHR5cGU6ICdhdXRoJywgYXBpOiBhcGkgfSwgZnVuY3Rpb24oY29tYmluZWRfcmVzcG9uc2UpIHtcblx0XHRpZiAoY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yIHx8IF8uaXNFbXB0eShjb21iaW5lZF9yZXNwb25zZSkpIHtcblx0XHRcdHJldHVybiBjYWxsYmFjayhfLmV4dGVuZChjaHJvbWUucnVudGltZS5sYXN0RXJyb3IsIHsgc3RhdHVzOiA1MDAgfSkpO1xuXHRcdH1cblx0XHRjYWxsYmFjayhjb21iaW5lZF9yZXNwb25zZVswXSwgY29tYmluZWRfcmVzcG9uc2VbMV0pO1xuXHR9KTtcbn07XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcblx0dmFyIGFyZ3MgPSBfLnRvQXJyYXkoYXJndW1lbnRzKTtcblx0Y2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2UoeyB0eXBlOiAnYW5hbHl0aWNzJywgcmVxdWVzdDogYXJncyB9LCAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpICYmIGZ1bmN0aW9uKCkge1xuXHRcdGlmIChfLmNoYWluKGFyZ3MpLmZpcnN0KDIpLmlzRXF1YWwoWydzZW5kJywgJ2V4Y2VwdGlvbiddKS52YWx1ZSgpKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdnb29nbGUgYW5hbHl0aWNzJywgYXJncyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUuZGVidWcoJ2dvb2dsZSBhbmFseXRpY3MnLCBhcmdzKTtcblx0XHR9XG5cdH0pO1xufTtcbiIsInZhciBfICAgICAgICAgICAgID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIHNoYXJlZF9jb25maWcgPSByZXF1aXJlKCdob3ZlcmNhcmRzc2hhcmVkL2NvbmZpZycpO1xuXG52YXIgY29uZmlnID0ge1xuXHRlbmRwb2ludDogXCJkZXZlbG9wbWVudFwiID09PSAncHJvZHVjdGlvbicgPyAnaHR0cDovL2hvdmVyLmNhcmRzL3YyJyA6ICdodHRwOi8vbG9jYWxob3N0OjUwMDAvdjInLFxuXHRhbmFseXRpY3NfaWQ6ICdVQS02NDI0NjgyMC0zJyxcblx0YXBpczoge1xuXHRcdGltZ3VyOiB7fSxcblx0XHRpbnN0YWdyYW06IHtcblx0XHRcdGNsaWVudF9vbl9hdXRoOiB0cnVlLFxuXHRcdFx0Y2xpZW50X2F1dGhfdXJsOiAnaHR0cHM6Ly9pbnN0YWdyYW0uY29tL29hdXRoL2F1dGhvcml6ZS8/Y2xpZW50X2lkPTQxZTU2MDYxYzFlMzRmYmJiMTZhYjFkMDk1ZGFkNzhiJnJlZGlyZWN0X3VyaT1odHRwczovL0VYVEVOU0lPTl9JRC5jaHJvbWl1bWFwcC5vcmcvY2FsbGJhY2smcmVzcG9uc2VfdHlwZT10b2tlbidcblx0XHR9LFxuXHRcdHJlZGRpdDoge1xuXHRcdFx0a2V5OiAnMGpYcUV1ZFFQcVNMNncnXG5cdFx0fSxcblx0XHRzb3VuZGNsb3VkOiB7XG5cdFx0XHRrZXk6ICc3OGE4MjcyNTRiZDdhNWUzYmJhNjFhYTE4OTIyYmYyZSdcblx0XHR9LFxuXHRcdHR3aXR0ZXI6IHt9LFxuXHRcdHlvdXR1YmU6IHt9XG5cdH1cbn07XG5cbnZhciBhcGlzID0gXy5pbnRlcnNlY3Rpb24oXy5rZXlzKGNvbmZpZy5hcGlzKSwgXy5rZXlzKHNoYXJlZF9jb25maWcuYXBpcykpO1xuXG5jb25maWcuYXBpcyA9IF8uY2hhaW4oY29uZmlnLmFwaXMpXG4gICAgICAgICAgICAgICAucGljayhhcGlzKVxuICAgICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oYXBpX2NvbmZpZywgYXBpKSB7IF8uZGVmYXVsdHMoYXBpX2NvbmZpZywgc2hhcmVkX2NvbmZpZy5hcGlzW2FwaV0pOyB9KVxuICAgICAgICAgICAgICAgLnZhbHVlKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29uZmlnO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdGNvdW50czoge1xuXHRcdGdyaWQ6ICAgMjEsXG5cdFx0bGlzdGVkOiAyMFxuXHR9LFxuXHRhcGlzOiB7XG5cdFx0aW1ndXI6ICAgICAgcmVxdWlyZSgnLi9pbWd1ci9jb25maWcnKSxcblx0XHRpbnN0YWdyYW06ICByZXF1aXJlKCcuL2luc3RhZ3JhbS9jb25maWcnKSxcblx0XHRyZWRkaXQ6ICAgICByZXF1aXJlKCcuL3JlZGRpdC9jb25maWcnKSxcblx0XHRzb3VuZGNsb3VkOiByZXF1aXJlKCcuL3NvdW5kY2xvdWQvY29uZmlnJyksXG5cdFx0dHdpdHRlcjogICAgcmVxdWlyZSgnLi90d2l0dGVyL2NvbmZpZycpLFxuXHRcdHlvdXR1YmU6ICAgIHJlcXVpcmUoJy4veW91dHViZS9jb25maWcnKVxuXHR9XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuXHRcImRpc2N1c3Npb25fYXBpc1wiOiBbXCJ5b3V0dWJlXCIsIFwicmVkZGl0XCIsIFwidHdpdHRlclwiXSxcblx0XCJjb250ZW50LXNlY3VyaXR5LXBvbGljeVwiOiB7XG5cdFx0XCJpbWctc3JjXCI6IFtcImh0dHBzOi8veXQzLmdncGh0LmNvbVwiLCBcImh0dHBzOi8vKi5nb29nbGV1c2VyY29udGVudC5jb21cIl0sXG5cdFx0XCJzY3JpcHQtc3JjXCI6IFtcImh0dHBzOi8vcy55dGltZy5jb21cIl1cblx0fVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuXHRcImNhbl9hdXRoXCI6IHRydWUsXG5cdFwiZGlzY3Vzc2lvbl9hcGlzXCI6IFtcInR3aXR0ZXJcIiwgXCJyZWRkaXRcIl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJkaXNjdXNzaW9uX2FwaXNcIjogW1wic291bmRjbG91ZFwiLCBcInJlZGRpdFwiLCBcInR3aXR0ZXJcIl0sXG5cdFwiY29udGVudC1zZWN1cml0eS1wb2xpY3lcIjoge1xuXHRcdFwiaW1nLXNyY1wiOiBbXCJodHRwczovL2kxLnNuZGNkbi5jb21cIl0sXG5cdFx0XCJmcmFtZS1zcmNcIjogW1wiaHR0cHM6Ly93LnNvdW5kY2xvdWQuY29tXCJdXG5cdH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJkaXNjdXNzaW9uX2FwaXNcIjogW1wicmVkZGl0XCIsIFwidHdpdHRlclwiXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuXHRcImNhbl9hdXRoXCI6IHRydWUsXG5cdFwiZGlzY3Vzc2lvbl9hcGlzXCI6IFtcImluc3RhZ3JhbVwiLCBcInJlZGRpdFwiLCBcInR3aXR0ZXJcIl0sXG5cdFwiY29udGVudC1zZWN1cml0eS1wb2xpY3lcIjoge1xuXHRcdFwiaW1nLXNyY1wiOiBbXCJodHRwczovL3Njb250ZW50LmNkbmluc3RhZ3JhbS5jb21cIl0sXG5cdFx0XCJtZWRpYS1zcmNcIjogW1wiaHR0cHM6Ly9zY29udGVudC5jZG5pbnN0YWdyYW0uY29tXCJdXG5cdH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJkaXNjdXNzaW9uX2FwaXNcIjogW1wiaW1ndXJcIiwgXCJyZWRkaXRcIiwgXCJ0d2l0dGVyXCJdLFxuXHRcImNvbnRlbnQtc2VjdXJpdHktcG9saWN5XCI6IHtcblx0XHRcImltZy1zcmNcIjogW1wiaHR0cDovL2kuaW1ndXIuY29tXCJdLFxuXHRcdFwibWVkaWEtc3JjXCI6IFtcImh0dHA6Ly9pLmltZ3VyLmNvbVwiXVxuXHR9XG59XG4iLCIvLyAgICAgVW5kZXJzY29yZS5qcyAxLjguM1xuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAgICAgKGMpIDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbihmdW5jdGlvbigpIHtcblxuICAvLyBCYXNlbGluZSBzZXR1cFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZXhwb3J0c2Agb24gdGhlIHNlcnZlci5cbiAgdmFyIHJvb3QgPSB0aGlzO1xuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgX2AgdmFyaWFibGUuXG4gIHZhciBwcmV2aW91c1VuZGVyc2NvcmUgPSByb290Ll87XG5cbiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZSwgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxuICB2YXJcbiAgICBwdXNoICAgICAgICAgICAgID0gQXJyYXlQcm90by5wdXNoLFxuICAgIHNsaWNlICAgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgIHRvU3RyaW5nICAgICAgICAgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICBoYXNPd25Qcm9wZXJ0eSAgID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gQWxsICoqRUNNQVNjcmlwdCA1KiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlXG4gIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuICB2YXJcbiAgICBuYXRpdmVJc0FycmF5ICAgICAgPSBBcnJheS5pc0FycmF5LFxuICAgIG5hdGl2ZUtleXMgICAgICAgICA9IE9iamVjdC5rZXlzLFxuICAgIG5hdGl2ZUJpbmQgICAgICAgICA9IEZ1bmNQcm90by5iaW5kLFxuICAgIG5hdGl2ZUNyZWF0ZSAgICAgICA9IE9iamVjdC5jcmVhdGU7XG5cbiAgLy8gTmFrZWQgZnVuY3Rpb24gcmVmZXJlbmNlIGZvciBzdXJyb2dhdGUtcHJvdG90eXBlLXN3YXBwaW5nLlxuICB2YXIgQ3RvciA9IGZ1bmN0aW9uKCl7fTtcblxuICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cbiAgdmFyIF8gPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgXykgcmV0dXJuIG9iajtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgXykpIHJldHVybiBuZXcgXyhvYmopO1xuICAgIHRoaXMuX3dyYXBwZWQgPSBvYmo7XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgYHJlcXVpcmUoKWAgQVBJLiBJZiB3ZSdyZSBpblxuICAvLyB0aGUgYnJvd3NlciwgYWRkIGBfYCBhcyBhIGdsb2JhbCBvYmplY3QuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF87XG4gICAgfVxuICAgIGV4cG9ydHMuXyA9IF87XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5fID0gXztcbiAgfVxuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbi5cbiAgXy5WRVJTSU9OID0gJzEuOC4zJztcblxuICAvLyBJbnRlcm5hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZWZmaWNpZW50IChmb3IgY3VycmVudCBlbmdpbmVzKSB2ZXJzaW9uXG4gIC8vIG9mIHRoZSBwYXNzZWQtaW4gY2FsbGJhY2ssIHRvIGJlIHJlcGVhdGVkbHkgYXBwbGllZCBpbiBvdGhlciBVbmRlcnNjb3JlXG4gIC8vIGZ1bmN0aW9ucy5cbiAgdmFyIG9wdGltaXplQ2IgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHJldHVybiBmdW5jO1xuICAgIHN3aXRjaCAoYXJnQ291bnQgPT0gbnVsbCA/IDMgOiBhcmdDb3VudCkge1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIG90aGVyKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBIG1vc3RseS1pbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBjYWxsYmFja3MgdGhhdCBjYW4gYmUgYXBwbGllZFxuICAvLyB0byBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgdGhlIGRlc2lyZWQgcmVzdWx0IOKAlCBlaXRoZXJcbiAgLy8gaWRlbnRpdHksIGFuIGFyYml0cmFyeSBjYWxsYmFjaywgYSBwcm9wZXJ0eSBtYXRjaGVyLCBvciBhIHByb3BlcnR5IGFjY2Vzc29yLlxuICB2YXIgY2IgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIF8uaWRlbnRpdHk7XG4gICAgaWYgKF8uaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybiBvcHRpbWl6ZUNiKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCk7XG4gICAgaWYgKF8uaXNPYmplY3QodmFsdWUpKSByZXR1cm4gXy5tYXRjaGVyKHZhbHVlKTtcbiAgICByZXR1cm4gXy5wcm9wZXJ0eSh2YWx1ZSk7XG4gIH07XG4gIF8uaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBjYih2YWx1ZSwgY29udGV4dCwgSW5maW5pdHkpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhc3NpZ25lciBmdW5jdGlvbnMuXG4gIHZhciBjcmVhdGVBc3NpZ25lciA9IGZ1bmN0aW9uKGtleXNGdW5jLCB1bmRlZmluZWRPbmx5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoIDwgMiB8fCBvYmogPT0gbnVsbCkgcmV0dXJuIG9iajtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF0sXG4gICAgICAgICAgICBrZXlzID0ga2V5c0Z1bmMoc291cmNlKSxcbiAgICAgICAgICAgIGwgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoIXVuZGVmaW5lZE9ubHkgfHwgb2JqW2tleV0gPT09IHZvaWQgMCkgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIGFub3RoZXIuXG4gIHZhciBiYXNlQ3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KHByb3RvdHlwZSkpIHJldHVybiB7fTtcbiAgICBpZiAobmF0aXZlQ3JlYXRlKSByZXR1cm4gbmF0aXZlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBDdG9yO1xuICAgIEN0b3IucHJvdG90eXBlID0gbnVsbDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBwcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9ialtrZXldO1xuICAgIH07XG4gIH07XG5cbiAgLy8gSGVscGVyIGZvciBjb2xsZWN0aW9uIG1ldGhvZHMgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBjb2xsZWN0aW9uXG4gIC8vIHNob3VsZCBiZSBpdGVyYXRlZCBhcyBhbiBhcnJheSBvciBhcyBhbiBvYmplY3RcbiAgLy8gUmVsYXRlZDogaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGhcbiAgLy8gQXZvaWRzIGEgdmVyeSBuYXN0eSBpT1MgOCBKSVQgYnVnIG9uIEFSTS02NC4gIzIwOTRcbiAgdmFyIE1BWF9BUlJBWV9JTkRFWCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG4gIHZhciBnZXRMZW5ndGggPSBwcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gIHZhciBpc0FycmF5TGlrZSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKGNvbGxlY3Rpb24pO1xuICAgIHJldHVybiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInICYmIGxlbmd0aCA+PSAwICYmIGxlbmd0aCA8PSBNQVhfQVJSQVlfSU5ERVg7XG4gIH07XG5cbiAgLy8gQ29sbGVjdGlvbiBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBUaGUgY29ybmVyc3RvbmUsIGFuIGBlYWNoYCBpbXBsZW1lbnRhdGlvbiwgYWthIGBmb3JFYWNoYC5cbiAgLy8gSGFuZGxlcyByYXcgb2JqZWN0cyBpbiBhZGRpdGlvbiB0byBhcnJheS1saWtlcy4gVHJlYXRzIGFsbFxuICAvLyBzcGFyc2UgYXJyYXktbGlrZXMgYXMgaWYgdGhleSB3ZXJlIGRlbnNlLlxuICBfLmVhY2ggPSBfLmZvckVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgaSwgbGVuZ3RoO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpba2V5c1tpXV0sIGtleXNbaV0sIG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQuXG4gIF8ubWFwID0gXy5jb2xsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICByZXN1bHRzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgcmVzdWx0c1tpbmRleF0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIHJlZHVjaW5nIGZ1bmN0aW9uIGl0ZXJhdGluZyBsZWZ0IG9yIHJpZ2h0LlxuICBmdW5jdGlvbiBjcmVhdGVSZWR1Y2UoZGlyKSB7XG4gICAgLy8gT3B0aW1pemVkIGl0ZXJhdG9yIGZ1bmN0aW9uIGFzIHVzaW5nIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAvLyBpbiB0aGUgbWFpbiBmdW5jdGlvbiB3aWxsIGRlb3B0aW1pemUgdGhlLCBzZWUgIzE5OTEuXG4gICAgZnVuY3Rpb24gaXRlcmF0b3Iob2JqLCBpdGVyYXRlZSwgbWVtbywga2V5cywgaW5kZXgsIGxlbmd0aCkge1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgICBtZW1vID0gaXRlcmF0ZWUobWVtbywgb2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGNvbnRleHQpIHtcbiAgICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgNCk7XG4gICAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBpbml0aWFsIHZhbHVlIGlmIG5vbmUgaXMgcHJvdmlkZWQuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgbWVtbyA9IG9ialtrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleF07XG4gICAgICAgIGluZGV4ICs9IGRpcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gKipSZWR1Y2UqKiBidWlsZHMgdXAgYSBzaW5nbGUgcmVzdWx0IGZyb20gYSBsaXN0IG9mIHZhbHVlcywgYWthIGBpbmplY3RgLFxuICAvLyBvciBgZm9sZGxgLlxuICBfLnJlZHVjZSA9IF8uZm9sZGwgPSBfLmluamVjdCA9IGNyZWF0ZVJlZHVjZSgxKTtcblxuICAvLyBUaGUgcmlnaHQtYXNzb2NpYXRpdmUgdmVyc2lvbiBvZiByZWR1Y2UsIGFsc28ga25vd24gYXMgYGZvbGRyYC5cbiAgXy5yZWR1Y2VSaWdodCA9IF8uZm9sZHIgPSBjcmVhdGVSZWR1Y2UoLTEpO1xuXG4gIC8vIFJldHVybiB0aGUgZmlyc3QgdmFsdWUgd2hpY2ggcGFzc2VzIGEgdHJ1dGggdGVzdC4gQWxpYXNlZCBhcyBgZGV0ZWN0YC5cbiAgXy5maW5kID0gXy5kZXRlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBrZXk7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGtleSA9IF8uZmluZEluZGV4KG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gXy5maW5kS2V5KG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKGtleSAhPT0gdm9pZCAwICYmIGtleSAhPT0gLTEpIHJldHVybiBvYmpba2V5XTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBzZWxlY3RgLlxuICBfLmZpbHRlciA9IF8uc2VsZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgbGlzdCkpIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgZm9yIHdoaWNoIGEgdHJ1dGggdGVzdCBmYWlscy5cbiAgXy5yZWplY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubmVnYXRlKGNiKHByZWRpY2F0ZSkpLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgd2hldGhlciBhbGwgb2YgdGhlIGVsZW1lbnRzIG1hdGNoIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYWxsYC5cbiAgXy5ldmVyeSA9IF8uYWxsID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAoIXByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBvYmplY3QgbWF0Y2hlcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFueWAuXG4gIF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgdGhlIGFycmF5IG9yIG9iamVjdCBjb250YWlucyBhIGdpdmVuIGl0ZW0gKHVzaW5nIGA9PT1gKS5cbiAgLy8gQWxpYXNlZCBhcyBgaW5jbHVkZXNgIGFuZCBgaW5jbHVkZWAuXG4gIF8uY29udGFpbnMgPSBfLmluY2x1ZGVzID0gXy5pbmNsdWRlID0gZnVuY3Rpb24ob2JqLCBpdGVtLCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gICAgaWYgKCFpc0FycmF5TGlrZShvYmopKSBvYmogPSBfLnZhbHVlcyhvYmopO1xuICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ICE9ICdudW1iZXInIHx8IGd1YXJkKSBmcm9tSW5kZXggPSAwO1xuICAgIHJldHVybiBfLmluZGV4T2Yob2JqLCBpdGVtLCBmcm9tSW5kZXgpID49IDA7XG4gIH07XG5cbiAgLy8gSW52b2tlIGEgbWV0aG9kICh3aXRoIGFyZ3VtZW50cykgb24gZXZlcnkgaXRlbSBpbiBhIGNvbGxlY3Rpb24uXG4gIF8uaW52b2tlID0gZnVuY3Rpb24ob2JqLCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgaXNGdW5jID0gXy5pc0Z1bmN0aW9uKG1ldGhvZCk7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNGdW5jID8gbWV0aG9kIDogdmFsdWVbbWV0aG9kXTtcbiAgICAgIHJldHVybiBmdW5jID09IG51bGwgPyBmdW5jIDogZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgbWFwYDogZmV0Y2hpbmcgYSBwcm9wZXJ0eS5cbiAgXy5wbHVjayA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgXy5wcm9wZXJ0eShrZXkpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaWx0ZXJgOiBzZWxlY3Rpbmcgb25seSBvYmplY3RzXG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ud2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5tYXRjaGVyKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmluZGA6IGdldHRpbmcgdGhlIGZpcnN0IG9iamVjdFxuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmZpbmRXaGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maW5kKG9iaiwgXy5tYXRjaGVyKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtYXhpbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1heCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gLUluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSAtSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgPiByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA+IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gLUluZmluaXR5ICYmIHJlc3VsdCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5taW4gPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IEluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSBJbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA8IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkIDwgbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSBJbmZpbml0eSAmJiByZXN1bHQgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFNodWZmbGUgYSBjb2xsZWN0aW9uLCB1c2luZyB0aGUgbW9kZXJuIHZlcnNpb24gb2YgdGhlXG4gIC8vIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXLigJNZYXRlc19zaHVmZmxlKS5cbiAgXy5zaHVmZmxlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHNldCA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBzZXQubGVuZ3RoO1xuICAgIHZhciBzaHVmZmxlZCA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCByYW5kOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcmFuZCA9IF8ucmFuZG9tKDAsIGluZGV4KTtcbiAgICAgIGlmIChyYW5kICE9PSBpbmRleCkgc2h1ZmZsZWRbaW5kZXhdID0gc2h1ZmZsZWRbcmFuZF07XG4gICAgICBzaHVmZmxlZFtyYW5kXSA9IHNldFtpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBzaHVmZmxlZDtcbiAgfTtcblxuICAvLyBTYW1wbGUgKipuKiogcmFuZG9tIHZhbHVlcyBmcm9tIGEgY29sbGVjdGlvbi5cbiAgLy8gSWYgKipuKiogaXMgbm90IHNwZWNpZmllZCwgcmV0dXJucyBhIHNpbmdsZSByYW5kb20gZWxlbWVudC5cbiAgLy8gVGhlIGludGVybmFsIGBndWFyZGAgYXJndW1lbnQgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgbWFwYC5cbiAgXy5zYW1wbGUgPSBmdW5jdGlvbihvYmosIG4sIGd1YXJkKSB7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkge1xuICAgICAgaWYgKCFpc0FycmF5TGlrZShvYmopKSBvYmogPSBfLnZhbHVlcyhvYmopO1xuICAgICAgcmV0dXJuIG9ialtfLnJhbmRvbShvYmoubGVuZ3RoIC0gMSldO1xuICAgIH1cbiAgICByZXR1cm4gXy5zaHVmZmxlKG9iaikuc2xpY2UoMCwgTWF0aC5tYXgoMCwgbikpO1xuICB9O1xuXG4gIC8vIFNvcnQgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiBwcm9kdWNlZCBieSBhbiBpdGVyYXRlZS5cbiAgXy5zb3J0QnkgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgcmV0dXJuIF8ucGx1Y2soXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBjcml0ZXJpYTogaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KVxuICAgICAgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhIDwgYiB8fCBiID09PSB2b2lkIDApIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XG4gICAgfSksICd2YWx1ZScpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHVzZWQgZm9yIGFnZ3JlZ2F0ZSBcImdyb3VwIGJ5XCIgb3BlcmF0aW9ucy5cbiAgdmFyIGdyb3VwID0gZnVuY3Rpb24oYmVoYXZpb3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGtleSA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgb2JqKTtcbiAgICAgICAgYmVoYXZpb3IocmVzdWx0LCB2YWx1ZSwga2V5KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEdyb3VwcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLiBQYXNzIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGVcbiAgLy8gdG8gZ3JvdXAgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjcml0ZXJpb24uXG4gIF8uZ3JvdXBCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldLnB1c2godmFsdWUpOyBlbHNlIHJlc3VsdFtrZXldID0gW3ZhbHVlXTtcbiAgfSk7XG5cbiAgLy8gSW5kZXhlcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLCBzaW1pbGFyIHRvIGBncm91cEJ5YCwgYnV0IGZvclxuICAvLyB3aGVuIHlvdSBrbm93IHRoYXQgeW91ciBpbmRleCB2YWx1ZXMgd2lsbCBiZSB1bmlxdWUuXG4gIF8uaW5kZXhCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH0pO1xuXG4gIC8vIENvdW50cyBpbnN0YW5jZXMgb2YgYW4gb2JqZWN0IHRoYXQgZ3JvdXAgYnkgYSBjZXJ0YWluIGNyaXRlcmlvbi4gUGFzc1xuICAvLyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlIHRvIGNvdW50IGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgLy8gY3JpdGVyaW9uLlxuICBfLmNvdW50QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XSsrOyBlbHNlIHJlc3VsdFtrZXldID0gMTtcbiAgfSk7XG5cbiAgLy8gU2FmZWx5IGNyZWF0ZSBhIHJlYWwsIGxpdmUgYXJyYXkgZnJvbSBhbnl0aGluZyBpdGVyYWJsZS5cbiAgXy50b0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBbXTtcbiAgICBpZiAoXy5pc0FycmF5KG9iaikpIHJldHVybiBzbGljZS5jYWxsKG9iaik7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHJldHVybiBfLm1hcChvYmosIF8uaWRlbnRpdHkpO1xuICAgIHJldHVybiBfLnZhbHVlcyhvYmopO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIG9iamVjdC5cbiAgXy5zaXplID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gMDtcbiAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqKSA/IG9iai5sZW5ndGggOiBfLmtleXMob2JqKS5sZW5ndGg7XG4gIH07XG5cbiAgLy8gU3BsaXQgYSBjb2xsZWN0aW9uIGludG8gdHdvIGFycmF5czogb25lIHdob3NlIGVsZW1lbnRzIGFsbCBzYXRpc2Z5IHRoZSBnaXZlblxuICAvLyBwcmVkaWNhdGUsIGFuZCBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIGRvIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUuXG4gIF8ucGFydGl0aW9uID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBwYXNzID0gW10sIGZhaWwgPSBbXTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHtcbiAgICAgIChwcmVkaWNhdGUodmFsdWUsIGtleSwgb2JqKSA/IHBhc3MgOiBmYWlsKS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW3Bhc3MsIGZhaWxdO1xuICB9O1xuXG4gIC8vIEFycmF5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGZpcnN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgaGVhZGAgYW5kIGB0YWtlYC4gVGhlICoqZ3VhcmQqKiBjaGVja1xuICAvLyBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8uZmlyc3QgPSBfLmhlYWQgPSBfLnRha2UgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbMF07XG4gICAgcmV0dXJuIF8uaW5pdGlhbChhcnJheSwgYXJyYXkubGVuZ3RoIC0gbik7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgbGFzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEVzcGVjaWFsbHkgdXNlZnVsIG9uXG4gIC8vIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIGFsbCB0aGUgdmFsdWVzIGluXG4gIC8vIHRoZSBhcnJheSwgZXhjbHVkaW5nIHRoZSBsYXN0IE4uXG4gIF8uaW5pdGlhbCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSAobiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pKSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGxhc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuICBfLmxhc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIF8ucmVzdChhcnJheSwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gbikpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGZpcnN0IGVudHJ5IG9mIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgdGFpbGAgYW5kIGBkcm9wYC5cbiAgLy8gRXNwZWNpYWxseSB1c2VmdWwgb24gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgYW4gKipuKiogd2lsbCByZXR1cm5cbiAgLy8gdGhlIHJlc3QgTiB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuICBfLnJlc3QgPSBfLnRhaWwgPSBfLmRyb3AgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgbiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pO1xuICB9O1xuXG4gIC8vIFRyaW0gb3V0IGFsbCBmYWxzeSB2YWx1ZXMgZnJvbSBhbiBhcnJheS5cbiAgXy5jb21wYWN0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIF8uaWRlbnRpdHkpO1xuICB9O1xuXG4gIC8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIGEgcmVjdXJzaXZlIGBmbGF0dGVuYCBmdW5jdGlvbi5cbiAgdmFyIGZsYXR0ZW4gPSBmdW5jdGlvbihpbnB1dCwgc2hhbGxvdywgc3RyaWN0LCBzdGFydEluZGV4KSB7XG4gICAgdmFyIG91dHB1dCA9IFtdLCBpZHggPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4IHx8IDAsIGxlbmd0aCA9IGdldExlbmd0aChpbnB1dCk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gaW5wdXRbaV07XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmIChfLmlzQXJyYXkodmFsdWUpIHx8IF8uaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICAvL2ZsYXR0ZW4gY3VycmVudCBsZXZlbCBvZiBhcnJheSBvciBhcmd1bWVudHMgb2JqZWN0XG4gICAgICAgIGlmICghc2hhbGxvdykgdmFsdWUgPSBmbGF0dGVuKHZhbHVlLCBzaGFsbG93LCBzdHJpY3QpO1xuICAgICAgICB2YXIgaiA9IDAsIGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgb3V0cHV0Lmxlbmd0aCArPSBsZW47XG4gICAgICAgIHdoaWxlIChqIDwgbGVuKSB7XG4gICAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlW2orK107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCkge1xuICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgLy8gRmxhdHRlbiBvdXQgYW4gYXJyYXksIGVpdGhlciByZWN1cnNpdmVseSAoYnkgZGVmYXVsdCksIG9yIGp1c3Qgb25lIGxldmVsLlxuICBfLmZsYXR0ZW4gPSBmdW5jdGlvbihhcnJheSwgc2hhbGxvdykge1xuICAgIHJldHVybiBmbGF0dGVuKGFycmF5LCBzaGFsbG93LCBmYWxzZSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgYXJyYXkgdGhhdCBkb2VzIG5vdCBjb250YWluIHRoZSBzcGVjaWZpZWQgdmFsdWUocykuXG4gIF8ud2l0aG91dCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZGlmZmVyZW5jZShhcnJheSwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBoYXMgYWxyZWFkeVxuICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXG4gIC8vIEFsaWFzZWQgYXMgYHVuaXF1ZWAuXG4gIF8udW5pcSA9IF8udW5pcXVlID0gZnVuY3Rpb24oYXJyYXksIGlzU29ydGVkLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmICghXy5pc0Jvb2xlYW4oaXNTb3J0ZWQpKSB7XG4gICAgICBjb250ZXh0ID0gaXRlcmF0ZWU7XG4gICAgICBpdGVyYXRlZSA9IGlzU29ydGVkO1xuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhdGVlICE9IG51bGwpIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldLFxuICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaSwgYXJyYXkpIDogdmFsdWU7XG4gICAgICBpZiAoaXNTb3J0ZWQpIHtcbiAgICAgICAgaWYgKCFpIHx8IHNlZW4gIT09IGNvbXB1dGVkKSByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgIH0gZWxzZSBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKHNlZW4sIGNvbXB1dGVkKSkge1xuICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFfLmNvbnRhaW5zKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHVuaW9uOiBlYWNoIGRpc3RpbmN0IGVsZW1lbnQgZnJvbSBhbGwgb2ZcbiAgLy8gdGhlIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8udW5pb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy51bmlxKGZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGV2ZXJ5IGl0ZW0gc2hhcmVkIGJldHdlZW4gYWxsIHRoZVxuICAvLyBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGFycmF5W2ldO1xuICAgICAgaWYgKF8uY29udGFpbnMocmVzdWx0LCBpdGVtKSkgY29udGludWU7XG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoYXJndW1lbnRzW2pdLCBpdGVtKSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaiA9PT0gYXJnc0xlbmd0aCkgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gVGFrZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9uZSBhcnJheSBhbmQgYSBudW1iZXIgb2Ygb3RoZXIgYXJyYXlzLlxuICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxuICBfLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN0ID0gZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUsIDEpO1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpe1xuICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKHJlc3QsIHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICBfLnppcCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuemlwKGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQ29tcGxlbWVudCBvZiBfLnppcC4gVW56aXAgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgYW5kIGdyb3Vwc1xuICAvLyBlYWNoIGFycmF5J3MgZWxlbWVudHMgb24gc2hhcmVkIGluZGljZXNcbiAgXy51bnppcCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ICYmIF8ubWF4KGFycmF5LCBnZXRMZW5ndGgpLmxlbmd0aCB8fCAwO1xuICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IF8ucGx1Y2soYXJyYXksIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBDb252ZXJ0cyBsaXN0cyBpbnRvIG9iamVjdHMuIFBhc3MgZWl0aGVyIGEgc2luZ2xlIGFycmF5IG9mIGBba2V5LCB2YWx1ZV1gXG4gIC8vIHBhaXJzLCBvciB0d28gcGFyYWxsZWwgYXJyYXlzIG9mIHRoZSBzYW1lIGxlbmd0aCAtLSBvbmUgb2Yga2V5cywgYW5kIG9uZSBvZlxuICAvLyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gIF8ub2JqZWN0ID0gZnVuY3Rpb24obGlzdCwgdmFsdWVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgobGlzdCk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICByZXN1bHRbbGlzdFtpXV0gPSB2YWx1ZXNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGZpbmRJbmRleCBhbmQgZmluZExhc3RJbmRleCBmdW5jdGlvbnNcbiAgZnVuY3Rpb24gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoZGlyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIHZhciBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggb24gYW4gYXJyYXktbGlrZSB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0XG4gIF8uZmluZEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoMSk7XG4gIF8uZmluZExhc3RJbmRleCA9IGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKC0xKTtcblxuICAvLyBVc2UgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoXG4gIC8vIGFuIG9iamVjdCBzaG91bGQgYmUgaW5zZXJ0ZWQgc28gYXMgdG8gbWFpbnRhaW4gb3JkZXIuIFVzZXMgYmluYXJ5IHNlYXJjaC5cbiAgXy5zb3J0ZWRJbmRleCA9IGZ1bmN0aW9uKGFycmF5LCBvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgdmFyIHZhbHVlID0gaXRlcmF0ZWUob2JqKTtcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W21pZF0pIDwgdmFsdWUpIGxvdyA9IG1pZCArIDE7IGVsc2UgaGlnaCA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbiAgfTtcblxuICAvLyBHZW5lcmF0b3IgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBpbmRleE9mIGFuZCBsYXN0SW5kZXhPZiBmdW5jdGlvbnNcbiAgZnVuY3Rpb24gY3JlYXRlSW5kZXhGaW5kZXIoZGlyLCBwcmVkaWNhdGVGaW5kLCBzb3J0ZWRJbmRleCkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgaXRlbSwgaWR4KSB7XG4gICAgICB2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICBpZiAodHlwZW9mIGlkeCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgaSA9IGlkeCA+PSAwID8gaWR4IDogTWF0aC5tYXgoaWR4ICsgbGVuZ3RoLCBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IGlkeCA+PSAwID8gTWF0aC5taW4oaWR4ICsgMSwgbGVuZ3RoKSA6IGlkeCArIGxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc29ydGVkSW5kZXggJiYgaWR4ICYmIGxlbmd0aCkge1xuICAgICAgICBpZHggPSBzb3J0ZWRJbmRleChhcnJheSwgaXRlbSk7XG4gICAgICAgIHJldHVybiBhcnJheVtpZHhdID09PSBpdGVtID8gaWR4IDogLTE7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSAhPT0gaXRlbSkge1xuICAgICAgICBpZHggPSBwcmVkaWNhdGVGaW5kKHNsaWNlLmNhbGwoYXJyYXksIGksIGxlbmd0aCksIF8uaXNOYU4pO1xuICAgICAgICByZXR1cm4gaWR4ID49IDAgPyBpZHggKyBpIDogLTE7XG4gICAgICB9XG4gICAgICBmb3IgKGlkeCA9IGRpciA+IDAgPyBpIDogbGVuZ3RoIC0gMTsgaWR4ID49IDAgJiYgaWR4IDwgbGVuZ3RoOyBpZHggKz0gZGlyKSB7XG4gICAgICAgIGlmIChhcnJheVtpZHhdID09PSBpdGVtKSByZXR1cm4gaWR4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksXG4gIC8vIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxuICAvLyBmb3IgKippc1NvcnRlZCoqIHRvIHVzZSBiaW5hcnkgc2VhcmNoLlxuICBfLmluZGV4T2YgPSBjcmVhdGVJbmRleEZpbmRlcigxLCBfLmZpbmRJbmRleCwgXy5zb3J0ZWRJbmRleCk7XG4gIF8ubGFzdEluZGV4T2YgPSBjcmVhdGVJbmRleEZpbmRlcigtMSwgXy5maW5kTGFzdEluZGV4KTtcblxuICAvLyBHZW5lcmF0ZSBhbiBpbnRlZ2VyIEFycmF5IGNvbnRhaW5pbmcgYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi4gQSBwb3J0IG9mXG4gIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4gIC8vIFt0aGUgUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNyYW5nZSkuXG4gIF8ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChzdG9wID09IG51bGwpIHtcbiAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBzdGVwID0gc3RlcCB8fCAxO1xuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICB2YXIgcmFuZ2UgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKywgc3RhcnQgKz0gc3RlcCkge1xuICAgICAgcmFuZ2VbaWR4XSA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIERldGVybWluZXMgd2hldGhlciB0byBleGVjdXRlIGEgZnVuY3Rpb24gYXMgYSBjb25zdHJ1Y3RvclxuICAvLyBvciBhIG5vcm1hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBhcmd1bWVudHNcbiAgdmFyIGV4ZWN1dGVCb3VuZCA9IGZ1bmN0aW9uKHNvdXJjZUZ1bmMsIGJvdW5kRnVuYywgY29udGV4dCwgY2FsbGluZ0NvbnRleHQsIGFyZ3MpIHtcbiAgICBpZiAoIShjYWxsaW5nQ29udGV4dCBpbnN0YW5jZW9mIGJvdW5kRnVuYykpIHJldHVybiBzb3VyY2VGdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIHZhciBzZWxmID0gYmFzZUNyZWF0ZShzb3VyY2VGdW5jLnByb3RvdHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IHNvdXJjZUZ1bmMuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgaWYgKF8uaXNPYmplY3QocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBmdW5jdGlvbiBib3VuZCB0byBhIGdpdmVuIG9iamVjdCAoYXNzaWduaW5nIGB0aGlzYCwgYW5kIGFyZ3VtZW50cyxcbiAgLy8gb3B0aW9uYWxseSkuIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBGdW5jdGlvbi5iaW5kYCBpZlxuICAvLyBhdmFpbGFibGUuXG4gIF8uYmluZCA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQpIHtcbiAgICBpZiAobmF0aXZlQmluZCAmJiBmdW5jLmJpbmQgPT09IG5hdGl2ZUJpbmQpIHJldHVybiBuYXRpdmVCaW5kLmFwcGx5KGZ1bmMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JpbmQgbXVzdCBiZSBjYWxsZWQgb24gYSBmdW5jdGlvbicpO1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgY29udGV4dCwgdGhpcywgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH07XG5cbiAgLy8gUGFydGlhbGx5IGFwcGx5IGEgZnVuY3Rpb24gYnkgY3JlYXRpbmcgYSB2ZXJzaW9uIHRoYXQgaGFzIGhhZCBzb21lIG9mIGl0c1xuICAvLyBhcmd1bWVudHMgcHJlLWZpbGxlZCwgd2l0aG91dCBjaGFuZ2luZyBpdHMgZHluYW1pYyBgdGhpc2AgY29udGV4dC4gXyBhY3RzXG4gIC8vIGFzIGEgcGxhY2Vob2xkZXIsIGFsbG93aW5nIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMgdG8gYmUgcHJlLWZpbGxlZC5cbiAgXy5wYXJ0aWFsID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciBib3VuZEFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSAwLCBsZW5ndGggPSBib3VuZEFyZ3MubGVuZ3RoO1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYm91bmRBcmdzW2ldID09PSBfID8gYXJndW1lbnRzW3Bvc2l0aW9uKytdIDogYm91bmRBcmdzW2ldO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgYXJndW1lbnRzLmxlbmd0aCkgYXJncy5wdXNoKGFyZ3VtZW50c1twb3NpdGlvbisrXSk7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCB0aGlzLCB0aGlzLCBhcmdzKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBCaW5kIGEgbnVtYmVyIG9mIGFuIG9iamVjdCdzIG1ldGhvZHMgdG8gdGhhdCBvYmplY3QuIFJlbWFpbmluZyBhcmd1bWVudHNcbiAgLy8gYXJlIHRoZSBtZXRob2QgbmFtZXMgdG8gYmUgYm91bmQuIFVzZWZ1bCBmb3IgZW5zdXJpbmcgdGhhdCBhbGwgY2FsbGJhY2tzXG4gIC8vIGRlZmluZWQgb24gYW4gb2JqZWN0IGJlbG9uZyB0byBpdC5cbiAgXy5iaW5kQWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGksIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsIGtleTtcbiAgICBpZiAobGVuZ3RoIDw9IDEpIHRocm93IG5ldyBFcnJvcignYmluZEFsbCBtdXN0IGJlIHBhc3NlZCBmdW5jdGlvbiBuYW1lcycpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gYXJndW1lbnRzW2ldO1xuICAgICAgb2JqW2tleV0gPSBfLmJpbmQob2JqW2tleV0sIG9iaik7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cbiAgXy5tZW1vaXplID0gZnVuY3Rpb24oZnVuYywgaGFzaGVyKSB7XG4gICAgdmFyIG1lbW9pemUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBjYWNoZSA9IG1lbW9pemUuY2FjaGU7XG4gICAgICB2YXIgYWRkcmVzcyA9ICcnICsgKGhhc2hlciA/IGhhc2hlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDoga2V5KTtcbiAgICAgIGlmICghXy5oYXMoY2FjaGUsIGFkZHJlc3MpKSBjYWNoZVthZGRyZXNzXSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBjYWNoZVthZGRyZXNzXTtcbiAgICB9O1xuICAgIG1lbW9pemUuY2FjaGUgPSB7fTtcbiAgICByZXR1cm4gbWVtb2l6ZTtcbiAgfTtcblxuICAvLyBEZWxheXMgYSBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGFuZCB0aGVuIGNhbGxzXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cbiAgXy5kZWxheSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSwgd2FpdCk7XG4gIH07XG5cbiAgLy8gRGVmZXJzIGEgZnVuY3Rpb24sIHNjaGVkdWxpbmcgaXQgdG8gcnVuIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzXG4gIC8vIGNsZWFyZWQuXG4gIF8uZGVmZXIgPSBfLnBhcnRpYWwoXy5kZWxheSwgXywgMSk7XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlXG4gIC8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLiBOb3JtYWxseSwgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsIHJ1blxuICAvLyBhcyBtdWNoIGFzIGl0IGNhbiwgd2l0aG91dCBldmVyIGdvaW5nIG1vcmUgdGhhbiBvbmNlIHBlciBgd2FpdGAgZHVyYXRpb247XG4gIC8vIGJ1dCBpZiB5b3UnZCBsaWtlIHRvIGRpc2FibGUgdGhlIGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlLCBwYXNzXG4gIC8vIGB7bGVhZGluZzogZmFsc2V9YC4gVG8gZGlzYWJsZSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UsIGRpdHRvLlxuICBfLnRocm90dGxlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgIHZhciBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogXy5ub3coKTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vdyA9IF8ubm93KCk7XG4gICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHByZXZpb3VzID0gbm93O1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4gIC8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcbiAgLy8gTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4gIC8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXG4gIF8uZGVib3VuY2UgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsYXN0ID0gXy5ub3coKSAtIHRpbWVzdGFtcDtcblxuICAgICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB0aW1lc3RhbXAgPSBfLm5vdygpO1xuICAgICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxuICAvLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4gIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gXy5wYXJ0aWFsKHdyYXBwZXIsIGZ1bmMpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBuZWdhdGVkIHZlcnNpb24gb2YgdGhlIHBhc3NlZC1pbiBwcmVkaWNhdGUuXG4gIF8ubmVnYXRlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBhIGxpc3Qgb2YgZnVuY3Rpb25zLCBlYWNoXG4gIC8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gIF8uY29tcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBzdGFydCA9IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSA9IHN0YXJ0O1xuICAgICAgdmFyIHJlc3VsdCA9IGFyZ3Nbc3RhcnRdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB3aGlsZSAoaS0tKSByZXN1bHQgPSBhcmdzW2ldLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgb24gYW5kIGFmdGVyIHRoZSBOdGggY2FsbC5cbiAgXy5hZnRlciA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPCAxKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgdXAgdG8gKGJ1dCBub3QgaW5jbHVkaW5nKSB0aGUgTnRoIGNhbGwuXG4gIF8uYmVmb3JlID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICB2YXIgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA+IDApIHtcbiAgICAgICAgbWVtbyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aW1lcyA8PSAxKSBmdW5jID0gbnVsbDtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhdCBtb3N0IG9uZSB0aW1lLCBubyBtYXR0ZXIgaG93XG4gIC8vIG9mdGVuIHlvdSBjYWxsIGl0LiBVc2VmdWwgZm9yIGxhenkgaW5pdGlhbGl6YXRpb24uXG4gIF8ub25jZSA9IF8ucGFydGlhbChfLmJlZm9yZSwgMik7XG5cbiAgLy8gT2JqZWN0IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gS2V5cyBpbiBJRSA8IDkgdGhhdCB3b24ndCBiZSBpdGVyYXRlZCBieSBgZm9yIGtleSBpbiAuLi5gIGFuZCB0aHVzIG1pc3NlZC5cbiAgdmFyIGhhc0VudW1CdWcgPSAhe3RvU3RyaW5nOiBudWxsfS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKTtcbiAgdmFyIG5vbkVudW1lcmFibGVQcm9wcyA9IFsndmFsdWVPZicsICdpc1Byb3RvdHlwZU9mJywgJ3RvU3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAncHJvcGVydHlJc0VudW1lcmFibGUnLCAnaGFzT3duUHJvcGVydHknLCAndG9Mb2NhbGVTdHJpbmcnXTtcblxuICBmdW5jdGlvbiBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cykge1xuICAgIHZhciBub25FbnVtSWR4ID0gbm9uRW51bWVyYWJsZVByb3BzLmxlbmd0aDtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBvYmouY29uc3RydWN0b3I7XG4gICAgdmFyIHByb3RvID0gKF8uaXNGdW5jdGlvbihjb25zdHJ1Y3RvcikgJiYgY29uc3RydWN0b3IucHJvdG90eXBlKSB8fCBPYmpQcm90bztcblxuICAgIC8vIENvbnN0cnVjdG9yIGlzIGEgc3BlY2lhbCBjYXNlLlxuICAgIHZhciBwcm9wID0gJ2NvbnN0cnVjdG9yJztcbiAgICBpZiAoXy5oYXMob2JqLCBwcm9wKSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkga2V5cy5wdXNoKHByb3ApO1xuXG4gICAgd2hpbGUgKG5vbkVudW1JZHgtLSkge1xuICAgICAgcHJvcCA9IG5vbkVudW1lcmFibGVQcm9wc1tub25FbnVtSWR4XTtcbiAgICAgIGlmIChwcm9wIGluIG9iaiAmJiBvYmpbcHJvcF0gIT09IHByb3RvW3Byb3BdICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSB7XG4gICAgICAgIGtleXMucHVzaChwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZXRyaWV2ZSB0aGUgbmFtZXMgb2YgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBPYmplY3Qua2V5c2BcbiAgXy5rZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICBpZiAobmF0aXZlS2V5cykgcmV0dXJuIG5hdGl2ZUtleXMob2JqKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIGFsbCB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LlxuICBfLmFsbEtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICBfLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciB2YWx1ZXMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXSA9IG9ialtrZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIG9iamVjdFxuICAvLyBJbiBjb250cmFzdCB0byBfLm1hcCBpdCByZXR1cm5zIGFuIG9iamVjdFxuICBfLm1hcE9iamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICBfLmtleXMob2JqKSxcbiAgICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHRzID0ge30sXG4gICAgICAgICAgY3VycmVudEtleTtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY3VycmVudEtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgICByZXN1bHRzW2N1cnJlbnRLZXldID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ29udmVydCBhbiBvYmplY3QgaW50byBhIGxpc3Qgb2YgYFtrZXksIHZhbHVlXWAgcGFpcnMuXG4gIF8ucGFpcnMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgcGFpcnMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhaXJzW2ldID0gW2tleXNbaV0sIG9ialtrZXlzW2ldXV07XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbiAgfTtcblxuICAvLyBJbnZlcnQgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiBhbiBvYmplY3QuIFRoZSB2YWx1ZXMgbXVzdCBiZSBzZXJpYWxpemFibGUuXG4gIF8uaW52ZXJ0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFtvYmpba2V5c1tpXV1dID0ga2V5c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBzb3J0ZWQgbGlzdCBvZiB0aGUgZnVuY3Rpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoZSBvYmplY3QuXG4gIC8vIEFsaWFzZWQgYXMgYG1ldGhvZHNgXG4gIF8uZnVuY3Rpb25zID0gXy5tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvYmpba2V5XSkpIG5hbWVzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLnNvcnQoKTtcbiAgfTtcblxuICAvLyBFeHRlbmQgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gcGFzc2VkLWluIG9iamVjdChzKS5cbiAgXy5leHRlbmQgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMpO1xuXG4gIC8vIEFzc2lnbnMgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIG93biBwcm9wZXJ0aWVzIGluIHRoZSBwYXNzZWQtaW4gb2JqZWN0KHMpXG4gIC8vIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduKVxuICBfLmV4dGVuZE93biA9IF8uYXNzaWduID0gY3JlYXRlQXNzaWduZXIoXy5rZXlzKTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBrZXkgb24gYW4gb2JqZWN0IHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kS2V5ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaiksIGtleTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2tleV0sIGtleSwgb2JqKSkgcmV0dXJuIGtleTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9ubHkgY29udGFpbmluZyB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5waWNrID0gZnVuY3Rpb24ob2JqZWN0LCBvaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sIG9iaiA9IG9iamVjdCwgaXRlcmF0ZWUsIGtleXM7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChfLmlzRnVuY3Rpb24ob2l0ZXJhdGVlKSkge1xuICAgICAga2V5cyA9IF8uYWxsS2V5cyhvYmopO1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKG9pdGVyYXRlZSwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMgPSBmbGF0dGVuKGFyZ3VtZW50cywgZmFsc2UsIGZhbHNlLCAxKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqKSB7IHJldHVybiBrZXkgaW4gb2JqOyB9O1xuICAgICAgb2JqID0gT2JqZWN0KG9iaik7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgaWYgKGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iaikpIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCB3aXRob3V0IHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLm9taXQgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihpdGVyYXRlZSkpIHtcbiAgICAgIGl0ZXJhdGVlID0gXy5uZWdhdGUoaXRlcmF0ZWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IF8ubWFwKGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpLCBTdHJpbmcpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJldHVybiAhXy5jb250YWlucyhrZXlzLCBrZXkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF8ucGljayhvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBGaWxsIGluIGEgZ2l2ZW4gb2JqZWN0IHdpdGggZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICBfLmRlZmF1bHRzID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzLCB0cnVlKTtcblxuICAvLyBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGdpdmVuIHByb3RvdHlwZSBvYmplY3QuXG4gIC8vIElmIGFkZGl0aW9uYWwgcHJvcGVydGllcyBhcmUgcHJvdmlkZWQgdGhlbiB0aGV5IHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4gIC8vIGNyZWF0ZWQgb2JqZWN0LlxuICBfLmNyZWF0ZSA9IGZ1bmN0aW9uKHByb3RvdHlwZSwgcHJvcHMpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgIGlmIChwcm9wcykgXy5leHRlbmRPd24ocmVzdWx0LCBwcm9wcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSAoc2hhbGxvdy1jbG9uZWQpIGR1cGxpY2F0ZSBvZiBhbiBvYmplY3QuXG4gIF8uY2xvbmUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF8uZXh0ZW5kKHt9LCBvYmopO1xuICB9O1xuXG4gIC8vIEludm9rZXMgaW50ZXJjZXB0b3Igd2l0aCB0aGUgb2JqLCBhbmQgdGhlbiByZXR1cm5zIG9iai5cbiAgLy8gVGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4sIGluXG4gIC8vIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW4gdGhlIGNoYWluLlxuICBfLnRhcCA9IGZ1bmN0aW9uKG9iaiwgaW50ZXJjZXB0b3IpIHtcbiAgICBpbnRlcmNlcHRvcihvYmopO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2YgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uaXNNYXRjaCA9IGZ1bmN0aW9uKG9iamVjdCwgYXR0cnMpIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhhdHRycyksIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkgcmV0dXJuICFsZW5ndGg7XG4gICAgdmFyIG9iaiA9IE9iamVjdChvYmplY3QpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKGF0dHJzW2tleV0gIT09IG9ialtrZXldIHx8ICEoa2V5IGluIG9iaikpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuICB2YXIgZXEgPSBmdW5jdGlvbihhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xuICAgIC8vIEEgc3RyaWN0IGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYG51bGwgPT0gdW5kZWZpbmVkYC5cbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGEgPT09IGI7XG4gICAgLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXG4gICAgaWYgKGEgaW5zdGFuY2VvZiBfKSBhID0gYS5fd3JhcHBlZDtcbiAgICBpZiAoYiBpbnN0YW5jZW9mIF8pIGIgPSBiLl93cmFwcGVkO1xuICAgIC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXG4gICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSk7XG4gICAgaWYgKGNsYXNzTmFtZSAhPT0gdG9TdHJpbmcuY2FsbChiKSkgcmV0dXJuIGZhbHNlO1xuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCByZWd1bGFyIGV4cHJlc3Npb25zLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICAvLyBSZWdFeHBzIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MgZm9yIGNvbXBhcmlzb24gKE5vdGU6ICcnICsgL2EvaSA9PT0gJy9hL2knKVxuICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZyhcIjVcIilgLlxuICAgICAgICByZXR1cm4gJycgKyBhID09PSAnJyArIGI7XG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuICAgICAgICAvLyBPYmplY3QoTmFOKSBpcyBlcXVpdmFsZW50IHRvIE5hTlxuICAgICAgICBpZiAoK2EgIT09ICthKSByZXR1cm4gK2IgIT09ICtiO1xuICAgICAgICAvLyBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yIG90aGVyIG51bWVyaWMgdmFsdWVzLlxuICAgICAgICByZXR1cm4gK2EgPT09IDAgPyAxIC8gK2EgPT09IDEgLyBiIDogK2EgPT09ICtiO1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgICAgcmV0dXJuICthID09PSArYjtcbiAgICB9XG5cbiAgICB2YXIgYXJlQXJyYXlzID0gY2xhc3NOYW1lID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIGlmICghYXJlQXJyYXlzKSB7XG4gICAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzIG9yIGBBcnJheWBzXG4gICAgICAvLyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuICAgICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvciwgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNGdW5jdGlvbihiQ3RvcikgJiYgYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuXG4gICAgLy8gSW5pdGlhbGl6aW5nIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIC8vIEl0J3MgZG9uZSBoZXJlIHNpbmNlIHdlIG9ubHkgbmVlZCB0aGVtIGZvciBvYmplY3RzIGFuZCBhcnJheXMgY29tcGFyaXNvbi5cbiAgICBhU3RhY2sgPSBhU3RhY2sgfHwgW107XG4gICAgYlN0YWNrID0gYlN0YWNrIHx8IFtdO1xuICAgIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT09IGEpIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PT0gYjtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnB1c2goYSk7XG4gICAgYlN0YWNrLnB1c2goYik7XG5cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICBpZiAoYXJlQXJyYXlzKSB7XG4gICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKCFlcShhW2xlbmd0aF0sIGJbbGVuZ3RoXSwgYVN0YWNrLCBiU3RhY2spKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgICAgdmFyIGtleXMgPSBfLmtleXMoYSksIGtleTtcbiAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMgYmVmb3JlIGNvbXBhcmluZyBkZWVwIGVxdWFsaXR5LlxuICAgICAgaWYgKF8ua2V5cyhiKS5sZW5ndGggIT09IGxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlclxuICAgICAgICBrZXkgPSBrZXlzW2xlbmd0aF07XG4gICAgICAgIGlmICghKF8uaGFzKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIGFTdGFjaywgYlN0YWNrKSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnBvcCgpO1xuICAgIGJTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBQZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHR3byBvYmplY3RzIGFyZSBlcXVhbC5cbiAgXy5pc0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBlcShhLCBiKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIGFycmF5LCBzdHJpbmcsIG9yIG9iamVjdCBlbXB0eT9cbiAgLy8gQW4gXCJlbXB0eVwiIG9iamVjdCBoYXMgbm8gZW51bWVyYWJsZSBvd24tcHJvcGVydGllcy5cbiAgXy5pc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSAmJiAoXy5pc0FycmF5KG9iaikgfHwgXy5pc1N0cmluZyhvYmopIHx8IF8uaXNBcmd1bWVudHMob2JqKSkpIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xuICAgIHJldHVybiBfLmtleXMob2JqKS5sZW5ndGggPT09IDA7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50P1xuICBfLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGFuIGFycmF5P1xuICAvLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgQXJyYXkuaXNBcnJheVxuICBfLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gIH07XG5cbiAgLy8gQWRkIHNvbWUgaXNUeXBlIG1ldGhvZHM6IGlzQXJndW1lbnRzLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXIsIGlzRGF0ZSwgaXNSZWdFeHAsIGlzRXJyb3IuXG4gIF8uZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJywgJ0Vycm9yJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBfWydpcycgKyBuYW1lXSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgJyArIG5hbWUgKyAnXSc7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRGVmaW5lIGEgZmFsbGJhY2sgdmVyc2lvbiBvZiB0aGUgbWV0aG9kIGluIGJyb3dzZXJzIChhaGVtLCBJRSA8IDkpLCB3aGVyZVxuICAvLyB0aGVyZSBpc24ndCBhbnkgaW5zcGVjdGFibGUgXCJBcmd1bWVudHNcIiB0eXBlLlxuICBpZiAoIV8uaXNBcmd1bWVudHMoYXJndW1lbnRzKSkge1xuICAgIF8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmhhcyhvYmosICdjYWxsZWUnKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gT3B0aW1pemUgYGlzRnVuY3Rpb25gIGlmIGFwcHJvcHJpYXRlLiBXb3JrIGFyb3VuZCBzb21lIHR5cGVvZiBidWdzIGluIG9sZCB2OCxcbiAgLy8gSUUgMTEgKCMxNjIxKSwgYW5kIGluIFNhZmFyaSA4ICgjMTkyOSkuXG4gIGlmICh0eXBlb2YgLy4vICE9ICdmdW5jdGlvbicgJiYgdHlwZW9mIEludDhBcnJheSAhPSAnb2JqZWN0Jykge1xuICAgIF8uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJyB8fCBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyP1xuICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIGlzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XG4gIH07XG5cbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gPyAoTmFOIGlzIHRoZSBvbmx5IG51bWJlciB3aGljaCBkb2VzIG5vdCBlcXVhbCBpdHNlbGYpLlxuICBfLmlzTmFOID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBvYmogIT09ICtvYmo7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGJvb2xlYW4/XG4gIF8uaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgZXF1YWwgdG8gbnVsbD9cbiAgXy5pc051bGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgdW5kZWZpbmVkP1xuICBfLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xuICB9O1xuXG4gIC8vIFNob3J0Y3V0IGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gcHJvcGVydHkgZGlyZWN0bHlcbiAgLy8gb24gaXRzZWxmIChpbiBvdGhlciB3b3Jkcywgbm90IG9uIGEgcHJvdG90eXBlKS5cbiAgXy5oYXMgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgfTtcblxuICAvLyBVdGlsaXR5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJ1biBVbmRlcnNjb3JlLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHNcbiAgLy8gcHJldmlvdXMgb3duZXIuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICByb290Ll8gPSBwcmV2aW91c1VuZGVyc2NvcmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gS2VlcCB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gYXJvdW5kIGZvciBkZWZhdWx0IGl0ZXJhdGVlcy5cbiAgXy5pZGVudGl0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8vIFByZWRpY2F0ZS1nZW5lcmF0aW5nIGZ1bmN0aW9ucy4gT2Z0ZW4gdXNlZnVsIG91dHNpZGUgb2YgVW5kZXJzY29yZS5cbiAgXy5jb25zdGFudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH07XG5cbiAgXy5ub29wID0gZnVuY3Rpb24oKXt9O1xuXG4gIF8ucHJvcGVydHkgPSBwcm9wZXJ0eTtcblxuICAvLyBHZW5lcmF0ZXMgYSBmdW5jdGlvbiBmb3IgYSBnaXZlbiBvYmplY3QgdGhhdCByZXR1cm5zIGEgZ2l2ZW4gcHJvcGVydHkuXG4gIF8ucHJvcGVydHlPZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT0gbnVsbCA/IGZ1bmN0aW9uKCl7fSA6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIHByZWRpY2F0ZSBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mXG4gIC8vIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLm1hdGNoZXIgPSBfLm1hdGNoZXMgPSBmdW5jdGlvbihhdHRycykge1xuICAgIGF0dHJzID0gXy5leHRlbmRPd24oe30sIGF0dHJzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5pc01hdGNoKG9iaiwgYXR0cnMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUnVuIGEgZnVuY3Rpb24gKipuKiogdGltZXMuXG4gIF8udGltZXMgPSBmdW5jdGlvbihuLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciBhY2N1bSA9IEFycmF5KE1hdGgubWF4KDAsIG4pKTtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBhY2N1bVtpXSA9IGl0ZXJhdGVlKGkpO1xuICAgIHJldHVybiBhY2N1bTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiBhbmQgbWF4IChpbmNsdXNpdmUpLlxuICBfLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICBtYXggPSBtaW47XG4gICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWluICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgfTtcblxuICAvLyBBIChwb3NzaWJseSBmYXN0ZXIpIHdheSB0byBnZXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGFzIGFuIGludGVnZXIuXG4gIF8ubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9O1xuXG4gICAvLyBMaXN0IG9mIEhUTUwgZW50aXRpZXMgZm9yIGVzY2FwaW5nLlxuICB2YXIgZXNjYXBlTWFwID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjeDI3OycsXG4gICAgJ2AnOiAnJiN4NjA7J1xuICB9O1xuICB2YXIgdW5lc2NhcGVNYXAgPSBfLmludmVydChlc2NhcGVNYXApO1xuXG4gIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgdmFyIGNyZWF0ZUVzY2FwZXIgPSBmdW5jdGlvbihtYXApIHtcbiAgICB2YXIgZXNjYXBlciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWFwW21hdGNoXTtcbiAgICB9O1xuICAgIC8vIFJlZ2V4ZXMgZm9yIGlkZW50aWZ5aW5nIGEga2V5IHRoYXQgbmVlZHMgdG8gYmUgZXNjYXBlZFxuICAgIHZhciBzb3VyY2UgPSAnKD86JyArIF8ua2V5cyhtYXApLmpvaW4oJ3wnKSArICcpJztcbiAgICB2YXIgdGVzdFJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UpO1xuICAgIHZhciByZXBsYWNlUmVnZXhwID0gUmVnRXhwKHNvdXJjZSwgJ2cnKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcgPT0gbnVsbCA/ICcnIDogJycgKyBzdHJpbmc7XG4gICAgICByZXR1cm4gdGVzdFJlZ2V4cC50ZXN0KHN0cmluZykgPyBzdHJpbmcucmVwbGFjZShyZXBsYWNlUmVnZXhwLCBlc2NhcGVyKSA6IHN0cmluZztcbiAgICB9O1xuICB9O1xuICBfLmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIoZXNjYXBlTWFwKTtcbiAgXy51bmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIodW5lc2NhcGVNYXApO1xuXG4gIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgYHByb3BlcnR5YCBpcyBhIGZ1bmN0aW9uIHRoZW4gaW52b2tlIGl0IHdpdGggdGhlXG4gIC8vIGBvYmplY3RgIGFzIGNvbnRleHQ7IG90aGVyd2lzZSwgcmV0dXJuIGl0LlxuICBfLnJlc3VsdCA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIGZhbGxiYWNrKSB7XG4gICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB2b2lkIDAgOiBvYmplY3RbcHJvcGVydHldO1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICB2YWx1ZSA9IGZhbGxiYWNrO1xuICAgIH1cbiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGludGVnZXIgaWQgKHVuaXF1ZSB3aXRoaW4gdGhlIGVudGlyZSBjbGllbnQgc2Vzc2lvbikuXG4gIC8vIFVzZWZ1bCBmb3IgdGVtcG9yYXJ5IERPTSBpZHMuXG4gIHZhciBpZENvdW50ZXIgPSAwO1xuICBfLnVuaXF1ZUlkID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIGlkID0gKytpZENvdW50ZXIgKyAnJztcbiAgICByZXR1cm4gcHJlZml4ID8gcHJlZml4ICsgaWQgOiBpZDtcbiAgfTtcblxuICAvLyBCeSBkZWZhdWx0LCBVbmRlcnNjb3JlIHVzZXMgRVJCLXN0eWxlIHRlbXBsYXRlIGRlbGltaXRlcnMsIGNoYW5nZSB0aGVcbiAgLy8gZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gICAgZXZhbHVhdGUgICAgOiAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgIGludGVycG9sYXRlIDogLzwlPShbXFxzXFxTXSs/KSU+L2csXG4gICAgZXNjYXBlICAgICAgOiAvPCUtKFtcXHNcXFNdKz8pJT4vZ1xuICB9O1xuXG4gIC8vIFdoZW4gY3VzdG9taXppbmcgYHRlbXBsYXRlU2V0dGluZ3NgLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byBkZWZpbmUgYW5cbiAgLy8gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiBvciBlc2NhcGluZyByZWdleCwgd2UgbmVlZCBvbmUgdGhhdCBpc1xuICAvLyBndWFyYW50ZWVkIG5vdCB0byBtYXRjaC5cbiAgdmFyIG5vTWF0Y2ggPSAvKC4pXi87XG5cbiAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcbiAgLy8gc3RyaW5nIGxpdGVyYWwuXG4gIHZhciBlc2NhcGVzID0ge1xuICAgIFwiJ1wiOiAgICAgIFwiJ1wiLFxuICAgICdcXFxcJzogICAgICdcXFxcJyxcbiAgICAnXFxyJzogICAgICdyJyxcbiAgICAnXFxuJzogICAgICduJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgdmFyIGVzY2FwZXIgPSAvXFxcXHwnfFxccnxcXG58XFx1MjAyOHxcXHUyMDI5L2c7XG5cbiAgdmFyIGVzY2FwZUNoYXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTtcbiAgfTtcblxuICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxuICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXG4gIC8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICAvLyBOQjogYG9sZFNldHRpbmdzYCBvbmx5IGV4aXN0cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIF8udGVtcGxhdGUgPSBmdW5jdGlvbih0ZXh0LCBzZXR0aW5ncywgb2xkU2V0dGluZ3MpIHtcbiAgICBpZiAoIXNldHRpbmdzICYmIG9sZFNldHRpbmdzKSBzZXR0aW5ncyA9IG9sZFNldHRpbmdzO1xuICAgIHNldHRpbmdzID0gXy5kZWZhdWx0cyh7fSwgc2V0dGluZ3MsIF8udGVtcGxhdGVTZXR0aW5ncyk7XG5cbiAgICAvLyBDb21iaW5lIGRlbGltaXRlcnMgaW50byBvbmUgcmVndWxhciBleHByZXNzaW9uIHZpYSBhbHRlcm5hdGlvbi5cbiAgICB2YXIgbWF0Y2hlciA9IFJlZ0V4cChbXG4gICAgICAoc2V0dGluZ3MuZXNjYXBlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuZXZhbHVhdGUgfHwgbm9NYXRjaCkuc291cmNlXG4gICAgXS5qb2luKCd8JykgKyAnfCQnLCAnZycpO1xuXG4gICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCBlc2NhcGluZyBzdHJpbmcgbGl0ZXJhbHMgYXBwcm9wcmlhdGVseS5cbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzb3VyY2UgPSBcIl9fcCs9J1wiO1xuICAgIHRleHQucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlLCBpbnRlcnBvbGF0ZSwgZXZhbHVhdGUsIG9mZnNldCkge1xuICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShlc2NhcGVyLCBlc2NhcGVDaGFyKTtcbiAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgZXNjYXBlICsgXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgaW50ZXJwb2xhdGUgKyBcIikpPT1udWxsPycnOl9fdCkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChldmFsdWF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xuICAgICAgfVxuXG4gICAgICAvLyBBZG9iZSBWTXMgbmVlZCB0aGUgbWF0Y2ggcmV0dXJuZWQgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBvZmZlc3QuXG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG4gICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXG4gICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcblxuICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICtcbiAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXG4gICAgICBzb3VyY2UgKyAncmV0dXJuIF9fcDtcXG4nO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsICdfJywgc291cmNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgdmFyIHRlbXBsYXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEsIF8pO1xuICAgIH07XG5cbiAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBzb3VyY2UgYXMgYSBjb252ZW5pZW5jZSBmb3IgcHJlY29tcGlsYXRpb24uXG4gICAgdmFyIGFyZ3VtZW50ID0gc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaic7XG4gICAgdGVtcGxhdGUuc291cmNlID0gJ2Z1bmN0aW9uKCcgKyBhcmd1bWVudCArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH07XG5cbiAgLy8gQWRkIGEgXCJjaGFpblwiIGZ1bmN0aW9uLiBTdGFydCBjaGFpbmluZyBhIHdyYXBwZWQgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8uY2hhaW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfKG9iaik7XG4gICAgaW5zdGFuY2UuX2NoYWluID0gdHJ1ZTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgLy8gT09QXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuICAvLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdFxuICAvLyBjYW4gYmUgdXNlZCBPTy1zdHlsZS4gVGhpcyB3cmFwcGVyIGhvbGRzIGFsdGVyZWQgdmVyc2lvbnMgb2YgYWxsIHRoZVxuICAvLyB1bmRlcnNjb3JlIGZ1bmN0aW9ucy4gV3JhcHBlZCBvYmplY3RzIG1heSBiZSBjaGFpbmVkLlxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb250aW51ZSBjaGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uKGluc3RhbmNlLCBvYmopIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX2NoYWluID8gXyhvYmopLmNoYWluKCkgOiBvYmo7XG4gIH07XG5cbiAgLy8gQWRkIHlvdXIgb3duIGN1c3RvbSBmdW5jdGlvbnMgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm1peGluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXy5lYWNoKF8uZnVuY3Rpb25zKG9iaiksIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gX1tuYW1lXSA9IG9ialtuYW1lXTtcbiAgICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW3RoaXMuX3dyYXBwZWRdO1xuICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiByZXN1bHQodGhpcywgZnVuYy5hcHBseShfLCBhcmdzKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEFkZCBhbGwgb2YgdGhlIFVuZGVyc2NvcmUgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgXy5taXhpbihfKTtcblxuICAvLyBBZGQgYWxsIG11dGF0b3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fd3JhcHBlZDtcbiAgICAgIG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoKG5hbWUgPT09ICdzaGlmdCcgfHwgbmFtZSA9PT0gJ3NwbGljZScpICYmIG9iai5sZW5ndGggPT09IDApIGRlbGV0ZSBvYmpbMF07XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG9iaik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWRkIGFsbCBhY2Nlc3NvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBtZXRob2QuYXBwbHkodGhpcy5fd3JhcHBlZCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRXh0cmFjdHMgdGhlIHJlc3VsdCBmcm9tIGEgd3JhcHBlZCBhbmQgY2hhaW5lZCBvYmplY3QuXG4gIF8ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gUHJvdmlkZSB1bndyYXBwaW5nIHByb3h5IGZvciBzb21lIG1ldGhvZHMgdXNlZCBpbiBlbmdpbmUgb3BlcmF0aW9uc1xuICAvLyBzdWNoIGFzIGFyaXRobWV0aWMgYW5kIEpTT04gc3RyaW5naWZpY2F0aW9uLlxuICBfLnByb3RvdHlwZS52YWx1ZU9mID0gXy5wcm90b3R5cGUudG9KU09OID0gXy5wcm90b3R5cGUudmFsdWU7XG5cbiAgXy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJycgKyB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG4gIC8vIEFNRCByZWdpc3RyYXRpb24gaGFwcGVucyBhdCB0aGUgZW5kIGZvciBjb21wYXRpYmlsaXR5IHdpdGggQU1EIGxvYWRlcnNcbiAgLy8gdGhhdCBtYXkgbm90IGVuZm9yY2UgbmV4dC10dXJuIHNlbWFudGljcyBvbiBtb2R1bGVzLiBFdmVuIHRob3VnaCBnZW5lcmFsXG4gIC8vIHByYWN0aWNlIGZvciBBTUQgcmVnaXN0cmF0aW9uIGlzIHRvIGJlIGFub255bW91cywgdW5kZXJzY29yZSByZWdpc3RlcnNcbiAgLy8gYXMgYSBuYW1lZCBtb2R1bGUgYmVjYXVzZSwgbGlrZSBqUXVlcnksIGl0IGlzIGEgYmFzZSBsaWJyYXJ5IHRoYXQgaXNcbiAgLy8gcG9wdWxhciBlbm91Z2ggdG8gYmUgYnVuZGxlZCBpbiBhIHRoaXJkIHBhcnR5IGxpYiwgYnV0IG5vdCBiZSBwYXJ0IG9mXG4gIC8vIGFuIEFNRCBsb2FkIHJlcXVlc3QuIFRob3NlIGNhc2VzIGNvdWxkIGdlbmVyYXRlIGFuIGVycm9yIHdoZW4gYW5cbiAgLy8gYW5vbnltb3VzIGRlZmluZSgpIGlzIGNhbGxlZCBvdXRzaWRlIG9mIGEgbG9hZGVyIHJlcXVlc3QuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoJ3VuZGVyc2NvcmUnLCBbXSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxufS5jYWxsKHRoaXMpKTtcbiJdfQ==
